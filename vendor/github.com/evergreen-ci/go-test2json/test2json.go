package test2json

import (
	"bytes"
	"encoding/json"
	"fmt"
	"regexp"
	"strings"
	"time"
	"unicode"

	"github.com/pkg/errors"
)

// Constants that correspond to a Test's Status
const (
	Passed  = "pass"
	Failed  = "fail"
	Skipped = "skip"
)

// Test represents the data accumlated from iterating/analysing the test events
// emitted by test2json
type Test struct {
	// Name is the test's name, or an empty string if reporting
	// package level results
	Name string

	// One of "pass", "fail" or "skip"
	Status string

	// FirstLogLine is the index into Log (see TestResults) that corresponds
	// to the first log line printed by this Test
	FirstLogLine int

	// StartTime and EndTime correspond to the start and end time for tests.
	// These values will be set to the same time for benchmark tests
	StartTime time.Time
	EndTime   time.Time
}

// TestKey is the key for the Tests map in TestResults
type TestKey struct {
	Name string
	// Starting at zero, this indicates the nth run of a test with this
	// name
	Iteration int
}

// TestResults are the combined test results and log data from parsing test2json
type TestResults struct {
	// Log is the combined stdout/stderr output, split by line. Lines have all
	// trailing whitespace is removed, and are presented in the same order that
	// they would be printed when running `go test`
	Log []string

	Tests map[TestKey]*Test
}

// ProcessBytes returns processed/merged test data from raw file bytes
func ProcessBytes(data []byte) (*TestResults, error) {
	events, err := unmarshal(data)
	if err != nil {
		return nil, err
	}

	log, tests := processTestEvents(events)

	return &TestResults{
		Log:   log,
		Tests: tests,
	}, nil
}

const (
	benchFailPrefix = "--- FAIL: %s"
	benchSkipPrefix = "--- SKIP: %s"

	actionPass   = "pass"
	actionFail   = "fail"
	actionRun    = "run"
	actionPause  = "pause"
	actionCont   = "cont"
	actionBench  = "bench"
	actionOutput = "output"
	actionSkip   = "skip"

	benchmark = "Benchmark"
)

var (
	testStartRegex = regexp.MustCompile(`^=== RUN\s+.*$`)
)

// Golang's JSON result output ('test2json') is a newline delimited list
// of the following struct, encoded as JSON.

// The following rules APPEAR to hold true of Golang's JSON output:
// 1. Golang offers no field to distinguish between subsequent runs of a test,
// such as when setting -test.count to a number greater than 1. However,
// Golang will not run more than one test of the same name at once, even with a
// call to t.Parallel(). This means that when you observe a "fail" or "pass"
// action with the same test name, you know that the next time you see "run",
// it corresponds to a subsequent iteration.
// 2. Benchmarks do not have a "run" action
// 3. The Output field has trailing newlines, even on Windows
// 4. The file emitted by test2json on Windows uses Unix-style line endings
// 5. Benchmarks do not provide Elapsed, even on fail, except in the package
// level result
// 6. Benchmark output will not match the Test. For example,
// in the benchmark corpus, the output for BenchmarkSomethingSilent-8 is tagged
// with Test name BenchmarkSomethingElse-8
type testEvent struct {
	// Time is the time that the line was processed by by go test. Contrary
	// to the documentation, this string appears to be an RFC3339Nano
	// formatted string
	Time time.Time

	// Action is one of:
	// run    - the test has started running
	// pause  - the test has been paused
	// cont   - the test has continued running
	// pass   - the test passed
	// bench  - the benchmark printed log output but did not fail
	// fail   - the test or benchmark failed
	// output - the test printed output
	// Additionally, the following is generated by go 1.10.3 but is undocumented:
	// skip   - the test was skipped
	Action string

	// Package optionally specifies the go package path of the test being
	// run
	Package string

	// Test specifies the name of the test function being tested. When
	// go test is reporting benchmarks, the value of Test should NOT
	// be trusted, except for "fail", "bench", and "skip" events. Test is
	// empty when test2json is reporting package-level results
	Test string

	// Elapsed is the number of seconds a test took. It is set only when
	// action is pass or fail for non-benchmark tests, and in the
	// package-level pass/fail action
	Elapsed float64

	// Output is the line that gotest captured, including trailing newlines
	// or carriage returns. On Windows, the trailing newlines are
	// Unix-style
	Output string
}

func unmarshal(data []byte) ([]*testEvent, error) {
	lines := bytes.Split(data, []byte("\n"))
	out := make([]*testEvent, 0, len(lines))
	for i := range lines {
		if len(lines[i]) == 0 {
			continue
		}

		t := testEvent{}
		if err := json.Unmarshal(lines[i], &t); err != nil {
			return nil, errors.Wrapf(err, "failed to parse line %d", i+1)
		}

		out = append(out, &t)
	}
	return out, nil
}

func startTimeFromEndTimeAndElapsed(endTime time.Time, elapsedSeconds float64) time.Time {
	elapsedNano := elapsedSeconds * float64(time.Second)
	return endTime.Add(-time.Duration(elapsedNano))
}

func processTestEvents(data []*testEvent) ([]string, map[TestKey]*Test) {
	iteration := map[string]int{}
	testLog := []string{}
	m := map[TestKey]*Test{}

	for _, event := range data {
		key := TestKey{
			Name:      event.Test,
			Iteration: iteration[event.Test],
		}

		if _, ok := m[key]; !ok {
			m[key] = &Test{Name: event.Test}
		}

		switch event.Action {
		case actionRun:
			m[key].StartTime = event.Time

		case actionPass, actionFail, actionSkip:
			m[key].Status = event.Action
			m[key].EndTime = event.Time

			// Benchmark test results do not provide any timing info
			// so we just set start/end to the same time
			if strings.HasPrefix(key.Name, benchmark) {
				m[key].StartTime = event.Time
			} else if m[key].StartTime.IsZero() {
				m[key].StartTime = startTimeFromEndTimeAndElapsed(event.Time, event.Elapsed)
			}
			iteration[event.Test]++

		case actionBench:
			m[key].Status = actionPass
			m[key].StartTime = event.Time
			m[key].EndTime = event.Time
			m[key].FirstLogLine = len(testLog) - 1

		case actionPause, actionCont, actionOutput:
			// test2json does not guarantee that all tests will
			// have a "pass" or "fail" event (ex: panics,
			// benchmarks), so we assign the most recent event's
			// time to the EndTime if the status hasn't been set yet
			if len(m[key].Status) == 0 {
				m[key].EndTime = event.Time
			}

			if event.Action == actionOutput {
				trimmedLine := strings.TrimRightFunc(event.Output, unicode.IsSpace)
				testLog = append(testLog, trimmedLine)
				if shouldTagLineNumber(trimmedLine, event.Package, key.Name) {
					m[key].FirstLogLine = len(testLog) - 1
				}
			}
		}
	}

	for _, test := range m {
		if len(test.Status) == 0 {
			test.Status = Failed
		}
	}

	return testLog, m
}

func shouldTagLineNumber(line, packageName, testName string) bool {
	if testStartRegex.MatchString(line) {
		return true
	}

	// All tests below apply only to benchmarks
	if !strings.HasPrefix(testName, "Benchmark") {
		return false
	}
	if strings.HasPrefix(line, fmt.Sprintf(benchFailPrefix, testName)) {
		return true
	}
	if strings.HasPrefix(line, fmt.Sprintf(benchSkipPrefix, testName)) {
		return true
	}

	return false
}
