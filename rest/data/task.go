package data

import (
	"context"
	"fmt"
	"net/http"

	"github.com/evergreen-ci/evergreen/model"
	serviceModel "github.com/evergreen-ci/evergreen/model"
	"github.com/evergreen-ci/evergreen/model/task"
	"github.com/evergreen-ci/gimlet"
	"github.com/pkg/errors"
)

// FindTasksByBuildId uses the service layer's task type to query the backing database for a
// list of task that matches buildId. It accepts the startTaskId and a limit
// to allow for pagination of the queries. It returns results sorted by taskId.
func FindTasksByBuildId(ctx context.Context, buildId, taskId, status string, limit int, sortDir int) ([]task.Task, error) {
	pipeline := task.TasksByBuildIdPipeline(buildId, taskId, status, limit, sortDir)
	res := []task.Task{}

	err := task.Aggregate(ctx, pipeline, &res)
	if err != nil {
		return []task.Task{}, err
	}

	if taskId != "" {
		found := false
		for _, t := range res {
			if t.Id == taskId {
				found = true
				break
			}
		}
		if !found {
			return []task.Task{}, gimlet.ErrorResponse{
				StatusCode: http.StatusNotFound,
				Message:    fmt.Sprintf("task '%s' not found", taskId),
			}
		}
	}
	return res, nil
}

// FindTasksByProjectAndCommit is a method to find a set of tasks which ran as part of
// certain version in a project. It takes the projectId, commit hash, and a taskId
// for paginating through the results.
func FindTasksByProjectAndCommit(ctx context.Context, opts task.GetTasksByProjectAndCommitOptions) ([]task.Task, error) {
	projectId, err := model.GetIdForProject(opts.Project)
	if err != nil {
		return nil, gimlet.ErrorResponse{
			StatusCode: http.StatusNotFound,
			Message:    errors.Wrapf(err, "project '%s' not found", projectId).Error(),
		}
	}

	opts.Project = projectId
	pipeline := task.TasksByProjectAndCommitPipeline(opts)

	res := []task.Task{}
	err = task.Aggregate(ctx, pipeline, &res)
	if err != nil {
		return []task.Task{}, err
	}
	if len(res) == 0 {
		var message string
		if opts.Status != "" {
			message = fmt.Sprintf("task from project '%s' and commit '%s' with status '%s' "+
				"not found", projectId, opts.CommitHash, opts.Status)
		} else {
			message = fmt.Sprintf("task from project '%s' and commit '%s' not found",
				projectId, opts.CommitHash)
		}
		return []task.Task{}, gimlet.ErrorResponse{
			StatusCode: http.StatusNotFound,
			Message:    message,
		}
	}
	return res, nil
}

func CheckTaskSecret(taskID string, r *http.Request) (*task.Task, int, error) {
	t, code, err := serviceModel.ValidateTask(r.Context(), taskID, true, r)
	return t, code, errors.Wrapf(err, "invalid task '%s'", taskID)
}

func FindTask(ctx context.Context, taskID string) (*task.Task, error) {
	foundTask, err := task.FindOneId(ctx, taskID)
	if err != nil {
		return nil, gimlet.ErrorResponse{
			StatusCode: http.StatusInternalServerError,
			Message:    errors.Wrap(err, "finding task").Error(),
		}
	}
	if foundTask == nil {
		return nil, gimlet.ErrorResponse{
			StatusCode: http.StatusNotFound,
			Message:    fmt.Sprintf("task '%s' not found", taskID),
		}
	}

	return foundTask, nil
}

// FindGeneratedTasksFromID finds info about all tasks that were generated by
// the given generator task.
func FindGeneratedTasksFromID(generatorID string) ([]task.GeneratedTaskInfo, error) {
	taskInfos, err := task.FindGeneratedTasksFromID(generatorID)
	if err != nil {
		return nil, errors.Wrapf(err, "finding tasks generated by task '%s'", generatorID)
	}
	if len(taskInfos) == 0 {
		return nil, gimlet.ErrorResponse{
			Message:    fmt.Sprintf("no tasks generated by task '%s' could be found", generatorID),
			StatusCode: http.StatusNotFound,
		}
	}
	return taskInfos, nil
}
