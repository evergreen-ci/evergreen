package alerts

import (
	"time"

	"github.com/evergreen-ci/evergreen"
	"github.com/evergreen-ci/evergreen/model/alertrecord"
	"github.com/evergreen-ci/evergreen/model/task"
	"github.com/mongodb/grip"
	"github.com/mongodb/grip/message"
	"github.com/mongodb/grip/sometimes"
	"github.com/pkg/errors"
)

/* Task trigger Implementations */

// TaskFailed is a trigger that queues an alert whenever a task fails, regardless of any alerts
// generated by previous runs of the task or other tasks within the version/variant/task type.
type TaskFailed struct{}

func (tf TaskFailed) Id() string        { return alertrecord.TaskFailedId }
func (trig TaskFailed) Display() string { return "any task fails" }

func (trig TaskFailed) ShouldExecute(ctx triggerContext) (bool, error) {
	if ctx.task.Status != evergreen.TaskFailed {
		return false, nil
	}
	return true, nil
}

func (trig TaskFailed) CreateAlertRecord(_ triggerContext) *alertrecord.AlertRecord { return nil }

// FirstFailureInVersion is a trigger that queues an alert whenever a task fails for the first time
// within a version. After one failure has triggered an alert for this event, subsequent failures
// will not trigger additional alerts.
type FirstFailureInVersion struct{}

func (trig FirstFailureInVersion) Id() string      { return alertrecord.FirstVersionFailureId }
func (trig FirstFailureInVersion) Display() string { return "the first task failure occurs" }
func (trig FirstFailureInVersion) CreateAlertRecord(ctx triggerContext) *alertrecord.AlertRecord {
	return newAlertRecord(ctx, alertrecord.FirstVersionFailureId)
}

func (trig FirstFailureInVersion) ShouldExecute(ctx triggerContext) (bool, error) {
	if ctx.task.Status != evergreen.TaskFailed {
		return false, nil
	}
	rec, err := alertrecord.FindOne(alertrecord.ByFirstFailureInVersion(ctx.task.Project, ctx.task.Version))
	if err != nil {
		return false, err
	}
	return rec == nil, nil
}

// FirstFailureInVersion is a trigger that queues an alert whenever a task fails for the first time
// within a variant. After one failure has triggered an alert for this event, subsequent failures
// will not trigger additional alerts.
type FirstFailureInVariant struct{}

func (trig FirstFailureInVariant) Id() string { return alertrecord.FirstVariantFailureId }
func (trig FirstFailureInVariant) Display() string {
	return "the first failure within each variant occurs"
}
func (trig FirstFailureInVariant) CreateAlertRecord(ctx triggerContext) *alertrecord.AlertRecord {
	return newAlertRecord(ctx, alertrecord.FirstVariantFailureId)
}
func (trig FirstFailureInVariant) ShouldExecute(ctx triggerContext) (bool, error) {
	if ctx.task.Status != evergreen.TaskFailed {
		return false, nil
	}
	rec, err := alertrecord.FindOne(alertrecord.ByFirstFailureInVariant(ctx.task.Version, ctx.task.BuildVariant))
	if err != nil {
		return false, nil
	}
	return rec == nil, nil
}

// FirstFailureInVersion is a trigger that queues an alert whenever a task fails for the first time
// for a task of a given name within a version. For example:
// "compile" fails on linux-64;   ShouldExecute returns true
// "compile" fails on windows;    ShouldExecute returns false because one was already sent for compile.
// "unit-tests" fails on windows; ShouldExecute returns true because nothing was sent yet for unit-tests.
// "unit-tests" fails on linux-64; ShouldExecute returns false
type FirstFailureInTaskType struct{}

func (trig FirstFailureInTaskType) Id() string { return alertrecord.FirstTaskTypeFailureId }
func (trig FirstFailureInTaskType) Display() string {
	return "the first failure for each task name occurs"
}
func (trig FirstFailureInTaskType) CreateAlertRecord(ctx triggerContext) *alertrecord.AlertRecord {
	return newAlertRecord(ctx, alertrecord.FirstTaskTypeFailureId)
}
func (trig FirstFailureInTaskType) ShouldExecute(ctx triggerContext) (bool, error) {
	if ctx.task.Status != evergreen.TaskFailed {
		return false, nil
	}
	rec, err := alertrecord.FindOne(alertrecord.ByFirstFailureInTaskType(ctx.task.Version, ctx.task.DisplayName))
	if err != nil {
		return false, nil
	}
	return rec == nil, nil
}

// TaskFailTransition is a trigger that queues an alert iff the following conditions are met:
// 1) A task fails and the previous completion of this task on the same variant was passing or
// the task has never run before
// 2) The most recent alert for this trigger, if existing, was stored when the 'last passing task'
// at the time was older than the 'last passing task' for the newly failed task.
// 3) The previous run was a failure, and there has been Multipler*Batchtime time since
// the previous alert was sent.
type TaskFailTransition struct{}

func (trig TaskFailTransition) Id() string { return alertrecord.TaskFailTransitionId }
func (trig TaskFailTransition) Display() string {
	return "a previously passing task fails"
}
func (trig TaskFailTransition) ShouldExecute(ctx triggerContext) (bool, error) {
	if ctx.task.Status != evergreen.TaskFailed {
		return false, nil
	}
	if ctx.previousCompleted == nil {
		return true, nil
	}

	if ctx.previousCompleted.Status == evergreen.TaskSucceeded {
		// the task transitioned to failure - but we will only trigger an alert if we haven't recorded
		// a sent alert for a transition after the same previously passing task.
		q := alertrecord.ByLastFailureTransition(ctx.task.DisplayName, ctx.task.BuildVariant, ctx.task.Project)
		lastAlerted, err := alertrecord.FindOne(q)
		if err != nil {
			errMessage := getShouldExecuteError(ctx)
			errMessage[message.FieldsMsgName] = "could not find a record for the last alert"
			errMessage["error"] = err.Error()
			grip.Error(errMessage)
			return false, err
		}

		if lastAlerted == nil || (lastAlerted.RevisionOrderNumber < ctx.previousCompleted.RevisionOrderNumber) {
			// Either this alert has never been triggered before, or it was triggered for a
			// transition from failure after an older success than this one - so we need to
			// execute this trigger again.
			errMessage := getShouldExecuteError(ctx)
			errMessage["outcome"] = "sending alert"
			errMessage[message.FieldsMsgName] = "identified transition to failure!"
			grip.Info(errMessage)

			return true, nil
		}
	}
	if ctx.previousCompleted.Status == evergreen.TaskFailed {
		// check if enough time has passed since our last transition alert
		q := alertrecord.ByLastFailureTransition(ctx.task.DisplayName, ctx.task.BuildVariant, ctx.task.Project)
		lastAlerted, err := alertrecord.FindOne(q)

		if err != nil || lastAlerted == nil {
			errMessage := getShouldExecuteError(ctx)
			errMessage[message.FieldsMsgName] = "could not find a record for the last alert"
			errMessage["error"] = err.Error()
			errMessage["lastAlert"] = lastAlerted
			grip.Error(errMessage)
			return false, err
		}

		if lastAlerted.TaskId == "" {
			maybeSend := sometimes.Quarter()
			errMessage := getShouldExecuteError(ctx)
			errMessage[message.FieldsMsgName] = "empty last alert task_id"
			errMessage["lastAlert"] = lastAlerted
			if maybeSend {
				errMessage["outcome"] = "sending alert 25% of the time"
			}
			grip.Warning(errMessage)

			return maybeSend, nil
		}

		return taskFinishedTwoOrMoreDaysAgo(lastAlerted.TaskId)
	}
	return false, nil
}

func getShouldExecuteError(ctx triggerContext) message.Fields {
	m := message.Fields{
		"alert":   "transition to failure",
		"outcome": "no alert",
		"task_id": ctx.task.Id,
		"query": map[string]string{
			"display": ctx.task.DisplayName,
			"variant": ctx.task.BuildVariant,
			"project": ctx.task.Project,
		},
	}

	if ctx.previousCompleted == nil {
		m["previous"] = nil
	} else {
		m["previous"] = map[string]interface{}{
			"id":          ctx.previousCompleted.Id,
			"variant":     ctx.previousCompleted.BuildVariant,
			"project":     ctx.previousCompleted.Project,
			"finish_time": ctx.previousCompleted.FinishTime,
			"status":      ctx.previousCompleted.Status,
		}
	}

	return m
}

func (trig TaskFailTransition) CreateAlertRecord(ctx triggerContext) *alertrecord.AlertRecord {
	rec := newAlertRecord(ctx, alertrecord.TaskFailTransitionId)
	// For pass/fail transition bookkeeping, we store the revision order number of the
	// previous (passing) task, not the currently passing task.
	rec.RevisionOrderNumber = -1
	if ctx.previousCompleted != nil {
		rec.RevisionOrderNumber = ctx.previousCompleted.RevisionOrderNumber
	}
	return rec
}

func taskFinishedTwoOrMoreDaysAgo(taskId string) (bool, error) {
	t, err := task.FindOne(task.ById(taskId))
	if err != nil {
		return false, err
	}
	if t == nil {
		return false, errors.Errorf("task %s not found", taskId)
	}

	return time.Since(t.FinishTime) >= 48*time.Hour, nil
}

type LastRevisionNotFound struct{}

func (lrnf LastRevisionNotFound) Id() string      { return alertrecord.TaskFailedId }
func (lrnf LastRevisionNotFound) Display() string { return "any task fails" }

func (lrnf LastRevisionNotFound) ShouldExecute(ctx triggerContext) (bool, error) {
	if ctx.task.Status != evergreen.TaskFailed {
		return false, nil
	}
	return true, nil
}

func (lrnf LastRevisionNotFound) CreateAlertRecord(ctx triggerContext) *alertrecord.AlertRecord {
	rec := newAlertRecord(ctx, alertrecord.LastRevisionNotFound)
	return rec
}
