package graphql

import (
	"fmt"
	"os"

	"github.com/99designs/gqlgen/codegen/config"
)

func GenerateSecretFields(cfg *config.Config) error {
	var redactedFields []string

	for _, schemaType := range cfg.Schema.Types {
		for _, field := range schemaType.Fields {
			if field.Directives.ForName("redactSecrets") != nil {
				redactedFields = append(redactedFields, field.Name)
			}
		}
	}

	return generateRedactedFieldsFile(redactedFields)
}

func generateRedactedFieldsFile(fields []string) error {
	file, err := os.Create("graphql/redacted_fields_gen.go")
	if err != nil {
		return err
	}
	defer file.Close()

	_, err = file.WriteString(`// Code generated by graphql/redact_secrets_plugin.go DO NOT EDIT.
package graphql
import (
	"reflect"
)

var RedactedFields = []string{

`)
	if err != nil {
		return err
	}

	for _, field := range fields {
		_, err = file.WriteString(fmt.Sprintf("\t\"%s\",\n", field))
		if err != nil {
			return err
		}
	}

	_, err = file.WriteString("}\n")
	if err != nil {
		return err
	}

	_, err = file.WriteString(
		`
func IsFieldRedacted(fieldName string) bool {
	for _, field := range RedactedFields {
		if field == fieldName {
			return true
		}
	}
	return false
}

// RedactFieldsInMap recursively searches for and redacts fields in a map.
// Assumes map structure like map[string]interface{} where interface{} can be another map, a slice, or a basic datatype.
func RedactFieldsInMap(data map[string]interface{}) {
	for key, value := range data {
		// If the current key matches a field that should be redacted, redact it.
		if IsFieldRedacted(key) {
			data[key] = "REDACTED"
			continue
		}

		// If the value is a map, recursively redact fields within it.
		if reflect.TypeOf(value).Kind() == reflect.Map {
			if subMap, ok := value.(map[string]interface{}); ok {
				RedactFieldsInMap(subMap)
			}
		}

		// If the value is a slice, iterate over it and redact fields if elements are maps.
		if reflect.TypeOf(value).Kind() == reflect.Slice {
			sliceVal := reflect.ValueOf(value)
			for i := 0; i < sliceVal.Len(); i++ {
				elem := sliceVal.Index(i).Interface()
				if reflect.TypeOf(elem).Kind() == reflect.Map {
					if elemMap, ok := elem.(map[string]interface{}); ok {
						RedactFieldsInMap(elemMap)
					}
				}
			}
		}
	}
}

`)
	if err != nil {
		return err
	}

	return err
}
