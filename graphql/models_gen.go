// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graphql

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/evergreen-ci/evergreen/apimodels"
	"github.com/evergreen-ci/evergreen/model/host"
	"github.com/evergreen-ci/evergreen/rest/model"
	"github.com/evergreen-ci/evergreen/thirdparty"
)

type AbortInfo struct {
	BuildVariantDisplayName string `json:"buildVariantDisplayName"`
	NewVersion              string `json:"newVersion"`
	PrClosed                bool   `json:"prClosed"`
	TaskDisplayName         string `json:"taskDisplayName"`
	TaskID                  string `json:"taskID"`
	User                    string `json:"user"`
}

type AddFavoriteProjectInput struct {
	ProjectIdentifier string `json:"projectIdentifier"`
}

// Build Baron is a service that can be integrated into a project (see Confluence Wiki for more details).
// This type is returned from the buildBaron query, and contains information about Build Baron configurations and suggested
// tickets from JIRA for a given task on a given execution.
type BuildBaron struct {
	BbTicketCreationDefined bool                         `json:"bbTicketCreationDefined"`
	BuildBaronConfigured    bool                         `json:"buildBaronConfigured"`
	SearchReturnInfo        *thirdparty.SearchReturnInfo `json:"searchReturnInfo,omitempty"`
}

// BuildVariantOptions is an input to the mainlineCommits query.
// It stores values for statuses, tasks, and variants which are used to filter for matching versions.
type BuildVariantOptions struct {
	IncludeBaseTasks *bool    `json:"includeBaseTasks,omitempty"`
	Statuses         []string `json:"statuses,omitempty"`
	Tasks            []string `json:"tasks,omitempty"`
	Variants         []string `json:"variants,omitempty"`
}

// CreateDistroInput is the input to the createDistro mutation.
type CreateDistroInput struct {
	NewDistroID      string `json:"newDistroId"`
	SingleTaskDistro *bool  `json:"singleTaskDistro,omitempty"`
}

type CursorParams struct {
	CursorID      string               `json:"cursorId"`
	Direction     TaskHistoryDirection `json:"direction"`
	IncludeCursor bool                 `json:"includeCursor"`
}

// DeactivateStepbackTaskInput is the input to the deactivateStepbackTask mutation.
type DeactivateStepbackTaskInput struct {
	ProjectID        string `json:"projectId"`
	BuildVariantName string `json:"buildVariantName"`
	TaskName         string `json:"taskName"`
}

// DefaultSectionToRepoInput is the input to the defaultSectionToRepo mutation.
type DefaultSectionToRepoInput struct {
	ProjectID string                 `json:"projectId"`
	Section   ProjectSettingsSection `json:"section"`
}

// DeleteDistroInput is the input to the deleteDistro mutation.
type DeleteDistroInput struct {
	DistroID string `json:"distroId"`
}

// Return type representing whether a distro was deleted.
type DeleteDistroPayload struct {
	DeletedDistroID string `json:"deletedDistroId"`
}

// DeleteGithubAppCredentialsInput is the input to the deleteGithubAppCredentials mutation.
type DeleteGithubAppCredentialsInput struct {
	ProjectID string `json:"projectId"`
}

// DeleteGithubAppCredentialsPayload is returned by the deleteGithubAppCredentials mutation.
type DeleteGithubAppCredentialsPayload struct {
	OldAppID int `json:"oldAppId"`
}

type Dependency struct {
	BuildVariant   string         `json:"buildVariant"`
	MetStatus      MetStatus      `json:"metStatus"`
	Name           string         `json:"name"`
	RequiredStatus RequiredStatus `json:"requiredStatus"`
	TaskID         string         `json:"taskId"`
}

type DisplayTask struct {
	ExecTasks []string `json:"ExecTasks"`
	Name      string   `json:"Name"`
}

type DistroEvent struct {
	After     map[string]any `json:"after,omitempty"`
	Before    map[string]any `json:"before,omitempty"`
	Data      map[string]any `json:"data,omitempty"`
	Timestamp time.Time      `json:"timestamp"`
	User      string         `json:"user"`
}

// DistroEventsInput is the input to the distroEvents query.
type DistroEventsInput struct {
	Before   *time.Time `json:"before,omitempty"`
	DistroID string     `json:"distroId"`
	Limit    *int       `json:"limit,omitempty"`
}

type DistroEventsPayload struct {
	Count           int            `json:"count"`
	EventLogEntries []*DistroEvent `json:"eventLogEntries"`
}

type DistroPermissions struct {
	Admin bool `json:"admin"`
	Edit  bool `json:"edit"`
	View  bool `json:"view"`
}

type DistroPermissionsOptions struct {
	DistroID string `json:"distroId"`
}

// EditSpawnHostInput is the input to the editSpawnHost mutation.
// Its fields determine how a given host will be modified.
type EditSpawnHostInput struct {
	AddedInstanceTags   []*host.Tag             `json:"addedInstanceTags,omitempty"`
	DeletedInstanceTags []*host.Tag             `json:"deletedInstanceTags,omitempty"`
	DisplayName         *string                 `json:"displayName,omitempty"`
	Expiration          *time.Time              `json:"expiration,omitempty"`
	HostID              string                  `json:"hostId"`
	InstanceType        *string                 `json:"instanceType,omitempty"`
	NoExpiration        *bool                   `json:"noExpiration,omitempty"`
	PublicKey           *PublicKeyInput         `json:"publicKey,omitempty"`
	SavePublicKey       *bool                   `json:"savePublicKey,omitempty"`
	ServicePassword     *string                 `json:"servicePassword,omitempty"`
	SleepSchedule       *host.SleepScheduleInfo `json:"sleepSchedule,omitempty"`
	Volume              *string                 `json:"volume,omitempty"`
}

type ExternalLinkForMetadata struct {
	URL         string `json:"url"`
	DisplayName string `json:"displayName"`
}

type GeneratedTaskCountResults struct {
	BuildVariantName *string `json:"buildVariantName,omitempty"`
	TaskName         *string `json:"taskName,omitempty"`
	TaskID           *string `json:"taskId,omitempty"`
	EstimatedTasks   int     `json:"estimatedTasks"`
}

type GroupedBuildVariant struct {
	DisplayName string           `json:"displayName"`
	Tasks       []*model.APITask `json:"tasks,omitempty"`
	Variant     string           `json:"variant"`
}

type GroupedFiles struct {
	Files     []*model.APIFile `json:"files,omitempty"`
	TaskName  *string          `json:"taskName,omitempty"`
	TaskID    string           `json:"taskId"`
	Execution int              `json:"execution"`
}

// GroupedProjects is the return value for the projects & viewableProjectRefs queries.
// It contains an array of projects which are grouped under a groupDisplayName.
type GroupedProjects struct {
	GroupDisplayName string                 `json:"groupDisplayName"`
	Projects         []*model.APIProjectRef `json:"projects"`
	Repo             *model.APIProjectRef   `json:"repo,omitempty"`
}

// HostEvents is the return value for the hostEvents query.
// It contains the event log entries for a given host.
type HostEvents struct {
	Count           int                           `json:"count"`
	EventLogEntries []*model.HostAPIEventLogEntry `json:"eventLogEntries"`
}

type HostEventsInput struct {
	Limit *int `json:"limit,omitempty"`
	Page  *int `json:"page,omitempty"`
	// sort by timestamp
	SortDir    *SortDirection `json:"sortDir,omitempty"`
	EventTypes []string       `json:"eventTypes,omitempty"`
}

// HostsResponse is the return value for the hosts query.
// It contains an array of Hosts matching the filter conditions, as well as some count information.
type HostsResponse struct {
	FilteredHostsCount *int             `json:"filteredHostsCount,omitempty"`
	Hosts              []*model.APIHost `json:"hosts"`
	TotalHostsCount    int              `json:"totalHostsCount"`
}

type ImageEventsPayload struct {
	Count           int                    `json:"count"`
	EventLogEntries []*model.APIImageEvent `json:"eventLogEntries"`
}

type ImageOperatingSystemPayload struct {
	Data          []*model.APIOSInfo `json:"data"`
	FilteredCount int                `json:"filteredCount"`
	TotalCount    int                `json:"totalCount"`
}

type ImagePackagesPayload struct {
	Data          []*model.APIPackage `json:"data"`
	FilteredCount int                 `json:"filteredCount"`
	TotalCount    int                 `json:"totalCount"`
}

type ImageToolchainsPayload struct {
	Data          []*model.APIToolchain `json:"data"`
	FilteredCount int                   `json:"filteredCount"`
	TotalCount    int                   `json:"totalCount"`
}

type MainlineCommitVersion struct {
	RolledUpVersions []*model.APIVersion `json:"rolledUpVersions,omitempty"`
	Version          *model.APIVersion   `json:"version,omitempty"`
}

// MainlineCommits is returned by the mainline commits query.
// It contains information about versions (both unactivated and activated) which is surfaced on the Project Health page.
type MainlineCommits struct {
	NextPageOrderNumber *int                     `json:"nextPageOrderNumber,omitempty"`
	PrevPageOrderNumber *int                     `json:"prevPageOrderNumber,omitempty"`
	Versions            []*MainlineCommitVersion `json:"versions"`
}

// MainlineCommitsOptions is an input to the mainlineCommits query.
// Its fields determine what mainline commits we fetch for a given projectID.
type MainlineCommitsOptions struct {
	Limit             *int     `json:"limit,omitempty"`
	ProjectIdentifier string   `json:"projectIdentifier"`
	Requesters        []string `json:"requesters,omitempty"`
	Revision          *string  `json:"revision,omitempty"`
	ShouldCollapse    *bool    `json:"shouldCollapse,omitempty"`
	SkipOrderNumber   *int     `json:"skipOrderNumber,omitempty"`
}

type Manifest struct {
	ID              string            `json:"id"`
	Branch          string            `json:"branch"`
	IsBase          bool              `json:"isBase"`
	ModuleOverrides map[string]string `json:"moduleOverrides,omitempty"`
	Modules         map[string]any    `json:"modules,omitempty"`
	Project         string            `json:"project"`
	Revision        string            `json:"revision"`
}

// MoveProjectInput is the input to the attachProjectToNewRepo mutation.
// It contains information used to move a project to a a new owner and repo.
type MoveProjectInput struct {
	NewOwner  string `json:"newOwner"`
	NewRepo   string `json:"newRepo"`
	ProjectID string `json:"projectId"`
}

type Mutation struct {
}

// Return type representing whether a distro was created and any validation errors
type NewDistroPayload struct {
	NewDistroID string `json:"newDistroId"`
}

// PatchConfigure is the input to the schedulePatch mutation.
// It contains information about how a user has configured their patch (e.g. name, tasks to run, etc).
type PatchConfigure struct {
	Description         string                `json:"description"`
	Parameters          []*model.APIParameter `json:"parameters,omitempty"`
	PatchTriggerAliases []string              `json:"patchTriggerAliases,omitempty"`
	VariantsTasks       []*VariantTasks       `json:"variantsTasks"`
}

type PatchDuration struct {
	Makespan  *string    `json:"makespan,omitempty"`
	Time      *PatchTime `json:"time,omitempty"`
	TimeTaken *string    `json:"timeTaken,omitempty"`
}

type PatchProject struct {
	Variants []*ProjectBuildVariant `json:"variants"`
}

type PatchTime struct {
	Finished    *string `json:"finished,omitempty"`
	Started     *string `json:"started,omitempty"`
	SubmittedAt string  `json:"submittedAt"`
}

// Patches is the return value of the patches field for the User and Project types.
// It contains an array Patches for either an individual user or a project.
type Patches struct {
	FilteredPatchCount int               `json:"filteredPatchCount"`
	Patches            []*model.APIPatch `json:"patches"`
}

// PatchesInput is the input value to the patches field for the User and Project types.
// Based on the information in PatchesInput, we return a list of Patches for either an individual user or a project.
type PatchesInput struct {
	Limit          int      `json:"limit"`
	OnlyMergeQueue *bool    `json:"onlyMergeQueue,omitempty"`
	IncludeHidden  *bool    `json:"includeHidden,omitempty"`
	Page           int      `json:"page"`
	PatchName      string   `json:"patchName"`
	Statuses       []string `json:"statuses"`
	Requesters     []string `json:"requesters,omitempty"`
}

type Permissions struct {
	CanCreateDistro      bool                `json:"canCreateDistro"`
	CanCreateProject     bool                `json:"canCreateProject"`
	CanEditAdminSettings bool                `json:"canEditAdminSettings"`
	DistroPermissions    *DistroPermissions  `json:"distroPermissions"`
	ProjectPermissions   *ProjectPermissions `json:"projectPermissions"`
	RepoPermissions      *RepoPermissions    `json:"repoPermissions"`
	UserID               string              `json:"userId"`
}

// PodEvents is the return value for the events query.
// It contains the event log entries for a pod.
type PodEvents struct {
	Count           int                          `json:"count"`
	EventLogEntries []*model.PodAPIEventLogEntry `json:"eventLogEntries"`
}

type ProjectBuildVariant struct {
	DisplayName string   `json:"displayName"`
	Name        string   `json:"name"`
	Tasks       []string `json:"tasks"`
}

// ProjectEvents contains project event log entries that concern the history of changes related to project
// settings.
// Although RepoSettings uses RepoRef in practice to have stronger types, this can't be enforced
// or event logs because new fields could always be introduced that don't exist in the old event logs.
type ProjectEvents struct {
	Count           int                      `json:"count"`
	EventLogEntries []*model.APIProjectEvent `json:"eventLogEntries"`
}

type ProjectPermissions struct {
	Edit bool `json:"edit"`
	View bool `json:"view"`
}

type ProjectPermissionsOptions struct {
	ProjectIdentifier string `json:"projectIdentifier"`
}

// PromoteVarsToRepoInput is the input to the promoteVarsToRepo mutation.
type PromoteVarsToRepoInput struct {
	ProjectID string   `json:"projectId"`
	VarNames  []string `json:"varNames"`
}

// PublicKeyInput is an input to the createPublicKey and updatePublicKey mutations.
type PublicKeyInput struct {
	Key  string `json:"key"`
	Name string `json:"name"`
}

type Query struct {
}

type RemoveFavoriteProjectInput struct {
	ProjectIdentifier string `json:"projectIdentifier"`
}

type RepoPermissions struct {
	Edit bool `json:"edit"`
	View bool `json:"view"`
}

type RepoPermissionsOptions struct {
	RepoID string `json:"repoId"`
}

// SaveDistroInput is the input to the saveDistro mutation.
type SaveDistroInput struct {
	Distro *model.APIDistro      `json:"distro"`
	OnSave DistroOnSaveOperation `json:"onSave"`
}

// Return type representing the updated distro and the number of hosts that were updated.
type SaveDistroPayload struct {
	Distro    *model.APIDistro `json:"distro"`
	HostCount int              `json:"hostCount"`
}

// SetLastRevisionInput is the input to the setLastRevision mutation.
// It contains information used to fix the repotracker error of a project.
type SetLastRevisionInput struct {
	ProjectIdentifier string `json:"projectIdentifier"`
	Revision          string `json:"revision"`
}

type SetLastRevisionPayload struct {
	MergeBaseRevision string `json:"mergeBaseRevision"`
}

// SortOrder[] is an input value for version.tasks. It is used to define whether to sort by ASC/DEC for a given sort key.
type SortOrder struct {
	Direction SortDirection    `json:"Direction"`
	Key       TaskSortCategory `json:"Key"`
}

// SpawnHostInput is the input to the spawnHost mutation.
// Its fields determine the properties of the host that will be spawned.
type SpawnHostInput struct {
	DistroID                string                  `json:"distroId"`
	Expiration              *time.Time              `json:"expiration,omitempty"`
	HomeVolumeSize          *int                    `json:"homeVolumeSize,omitempty"`
	IsVirtualWorkStation    bool                    `json:"isVirtualWorkStation"`
	NoExpiration            bool                    `json:"noExpiration"`
	PublicKey               *PublicKeyInput         `json:"publicKey"`
	Region                  string                  `json:"region"`
	SavePublicKey           bool                    `json:"savePublicKey"`
	SetUpScript             *string                 `json:"setUpScript,omitempty"`
	SleepSchedule           *host.SleepScheduleInfo `json:"sleepSchedule,omitempty"`
	SpawnHostsStartedByTask *bool                   `json:"spawnHostsStartedByTask,omitempty"`
	TaskID                  *string                 `json:"taskId,omitempty"`
	UseProjectSetupScript   *bool                   `json:"useProjectSetupScript,omitempty"`
	UserDataScript          *string                 `json:"userDataScript,omitempty"`
	UseTaskConfig           *bool                   `json:"useTaskConfig,omitempty"`
	VolumeID                *string                 `json:"volumeId,omitempty"`
}

// SpawnVolumeInput is the input to the spawnVolume mutation.
// Its fields determine the properties of the volume that will be spawned.
type SpawnVolumeInput struct {
	AvailabilityZone string     `json:"availabilityZone"`
	Expiration       *time.Time `json:"expiration,omitempty"`
	Host             *string    `json:"host,omitempty"`
	NoExpiration     *bool      `json:"noExpiration,omitempty"`
	Size             int        `json:"size"`
	Type             string     `json:"type"`
}

type Subscriber struct {
	EmailSubscriber       *string                         `json:"emailSubscriber,omitempty"`
	GithubCheckSubscriber *model.APIGithubCheckSubscriber `json:"githubCheckSubscriber,omitempty"`
	GithubPRSubscriber    *model.APIGithubPRSubscriber    `json:"githubPRSubscriber,omitempty"`
	JiraCommentSubscriber *string                         `json:"jiraCommentSubscriber,omitempty"`
	JiraIssueSubscriber   *model.APIJIRAIssueSubscriber   `json:"jiraIssueSubscriber,omitempty"`
	SlackSubscriber       *string                         `json:"slackSubscriber,omitempty"`
	WebhookSubscriber     *model.APIWebhookSubscriber     `json:"webhookSubscriber,omitempty"`
}

// TaskFiles is the return value for the taskFiles query.
// Some tasks generate files which are represented by this type.
type TaskFiles struct {
	FileCount    int             `json:"fileCount"`
	GroupedFiles []*GroupedFiles `json:"groupedFiles"`
}

// TaskFilterOptions defines the parameters that are used when fetching tasks from a Version.
type TaskFilterOptions struct {
	BaseStatuses               []string     `json:"baseStatuses,omitempty"`
	IncludeNeverActivatedTasks *bool        `json:"includeNeverActivatedTasks,omitempty"`
	Limit                      *int         `json:"limit,omitempty"`
	Page                       *int         `json:"page,omitempty"`
	Sorts                      []*SortOrder `json:"sorts,omitempty"`
	Statuses                   []string     `json:"statuses,omitempty"`
	TaskName                   *string      `json:"taskName,omitempty"`
	Variant                    *string      `json:"variant,omitempty"`
}

type TaskHistory struct {
	Tasks      []*model.APITask       `json:"tasks"`
	Pagination *TaskHistoryPagination `json:"pagination"`
}

type TaskHistoryOpts struct {
	ProjectIdentifier string        `json:"projectIdentifier"`
	TaskName          string        `json:"taskName"`
	BuildVariant      string        `json:"buildVariant"`
	CursorParams      *CursorParams `json:"cursorParams"`
	Limit             *int          `json:"limit,omitempty"`
	Date              *time.Time    `json:"date,omitempty"`
}

type TaskHistoryPagination struct {
	MostRecentTaskOrder int `json:"mostRecentTaskOrder"`
	OldestTaskOrder     int `json:"oldestTaskOrder"`
}

// TaskLogs is the return value for the task.taskLogs query.
// It contains the logs for a given task on a given execution.
type TaskLogs struct {
	AgentLogs  []*apimodels.LogMessage       `json:"agentLogs"`
	AllLogs    []*apimodels.LogMessage       `json:"allLogs"`
	EventLogs  []*model.TaskAPIEventLogEntry `json:"eventLogs"`
	Execution  int                           `json:"execution"`
	SystemLogs []*apimodels.LogMessage       `json:"systemLogs"`
	TaskID     string                        `json:"taskId"`
	TaskLogs   []*apimodels.LogMessage       `json:"taskLogs"`
}

// TaskOwnerTeam is the return value for the taskOwnerTeam query.
// It is used to identify the team that owns a task. Based on the FWS team assignment.
type TaskOwnerTeam struct {
	AssignmentType string `json:"assignmentType"`
	Messages       string `json:"messages"`
	TeamName       string `json:"teamName"`
	JiraProject    string `json:"jiraProject"`
}

// TaskQueueDistro[] is the return value for the taskQueueDistros query.
// It contains information about how many tasks and hosts are running on on a particular distro.
type TaskQueueDistro struct {
	ID        string `json:"id"`
	HostCount int    `json:"hostCount"`
	TaskCount int    `json:"taskCount"`
}

// TaskTestResult is the return value for the task.Tests resolver.
// It contains the test results for a task. For example, if there is a task to run all unit tests, then the test results
// could be the result of each individual unit test.
type TaskTestResult struct {
	TestResults       []*model.APITest `json:"testResults"`
	TotalTestCount    int              `json:"totalTestCount"`
	FilteredTestCount int              `json:"filteredTestCount"`
}

// TaskTestResultSample is the return value for the taskTestSample query.
// It is used to represent failing test results on the task history pages.
type TaskTestResultSample struct {
	Execution               int      `json:"execution"`
	MatchingFailedTestNames []string `json:"matchingFailedTestNames"`
	TaskID                  string   `json:"taskId"`
	TotalTestCount          int      `json:"totalTestCount"`
}

// TestFilter is an input value for the taskTestSample query.
// It's used to filter for tests with testName and status testStatus.
type TestFilter struct {
	TestName   string `json:"testName"`
	TestStatus string `json:"testStatus"`
}

// TestFilterOptions is an input for the task.Tests query.
// It's used to filter, sort, and paginate test results of a task.
type TestFilterOptions struct {
	TestName            *string            `json:"testName,omitempty"`
	ExcludeDisplayNames *bool              `json:"excludeDisplayNames,omitempty"`
	Statuses            []string           `json:"statuses,omitempty"`
	GroupID             *string            `json:"groupID,omitempty"`
	Sort                []*TestSortOptions `json:"sort,omitempty"`
	Limit               *int               `json:"limit,omitempty"`
	Page                *int               `json:"page,omitempty"`
}

// TestSortOptions is an input for the task.Tests query.
// It's used to define sort criteria for test results of a task.
type TestSortOptions struct {
	SortBy    TestSortCategory `json:"sortBy"`
	Direction SortDirection    `json:"direction"`
}

type UpdateBetaFeaturesInput struct {
	BetaFeatures *model.APIBetaFeatures `json:"betaFeatures"`
}

type UpdateBetaFeaturesPayload struct {
	BetaFeatures *model.APIBetaFeatures `json:"betaFeatures,omitempty"`
}

type UpdateParsleySettingsInput struct {
	ParsleySettings *model.APIParsleySettings `json:"parsleySettings"`
}

type UpdateParsleySettingsPayload struct {
	ParsleySettings *model.APIParsleySettings `json:"parsleySettings,omitempty"`
}

type UpdateSpawnHostStatusInput struct {
	Action        SpawnHostStatusActions `json:"action"`
	HostID        string                 `json:"hostId"`
	ShouldKeepOff *bool                  `json:"shouldKeepOff,omitempty"`
}

// UpdateVolumeInput is the input to the updateVolume mutation.
// Its fields determine how a given volume will be modified.
type UpdateVolumeInput struct {
	Expiration   *time.Time `json:"expiration,omitempty"`
	Name         *string    `json:"name,omitempty"`
	NoExpiration *bool      `json:"noExpiration,omitempty"`
	Size         *int       `json:"size,omitempty"`
	VolumeID     string     `json:"volumeId"`
}

type UpstreamProject struct {
	Owner       string            `json:"owner"`
	Project     string            `json:"project"`
	Repo        string            `json:"repo"`
	ResourceID  string            `json:"resourceID"`
	Revision    string            `json:"revision"`
	Task        *model.APITask    `json:"task,omitempty"`
	TriggerID   string            `json:"triggerID"`
	TriggerType string            `json:"triggerType"`
	Version     *model.APIVersion `json:"version,omitempty"`
}

// UserConfig is returned by the userConfig query.
// It contains configuration information such as the user's api key for the Evergreen CLI and a user's
// preferred UI (legacy vs Spruce).
type UserConfig struct {
	APIKey        string `json:"api_key"`
	APIServerHost string `json:"api_server_host"`
	UIServerHost  string `json:"ui_server_host"`
	User          string `json:"user"`
}

type VariantTasks struct {
	DisplayTasks []*DisplayTask `json:"displayTasks"`
	Tasks        []string       `json:"tasks"`
	Variant      string         `json:"variant"`
}

type VersionTasks struct {
	Count int              `json:"count"`
	Data  []*model.APITask `json:"data"`
}

type VersionTiming struct {
	Makespan  *model.APIDuration `json:"makespan,omitempty"`
	TimeTaken *model.APIDuration `json:"timeTaken,omitempty"`
}

// VolumeHost is the input to the attachVolumeToHost mutation.
// Its fields are used to attach the volume with volumeId to the host with hostId.
type VolumeHost struct {
	VolumeID string `json:"volumeId"`
	HostID   string `json:"hostId"`
}

type Waterfall struct {
	FlattenedVersions []*model.APIVersion  `json:"flattenedVersions"`
	Pagination        *WaterfallPagination `json:"pagination"`
}

type WaterfallOptions struct {
	Date  *time.Time `json:"date,omitempty"`
	Limit *int       `json:"limit,omitempty"`
	// Return versions with an order greater than minOrder. Used for paginating backward.
	MinOrder *int `json:"minOrder,omitempty"`
	// Return versions with an order lower than maxOrder. Used for paginating forward.
	MaxOrder          *int     `json:"maxOrder,omitempty"`
	ProjectIdentifier string   `json:"projectIdentifier"`
	Requesters        []string `json:"requesters,omitempty"`
	Revision          *string  `json:"revision,omitempty"`
	Statuses          []string `json:"statuses,omitempty"`
	Tasks             []string `json:"tasks,omitempty"`
	// Toggle case sensitivity when matching on task names. Note that if false, performance will be slower.
	TaskCaseSensitive *bool    `json:"taskCaseSensitive,omitempty"`
	Variants          []string `json:"variants,omitempty"`
	// Toggle case sensitivity when matching on variant names. Note that if false, performance will be slower.
	VariantCaseSensitive *bool `json:"variantCaseSensitive,omitempty"`
}

type WaterfallPagination struct {
	ActiveVersionIds       []string `json:"activeVersionIds"`
	HasNextPage            bool     `json:"hasNextPage"`
	HasPrevPage            bool     `json:"hasPrevPage"`
	MostRecentVersionOrder int      `json:"mostRecentVersionOrder"`
	NextPageOrder          int      `json:"nextPageOrder"`
	PrevPageOrder          int      `json:"prevPageOrder"`
}

type WaterfallVersion struct {
	InactiveVersions []*model.APIVersion `json:"inactiveVersions,omitempty"`
	Version          *model.APIVersion   `json:"version,omitempty"`
}

type AccessLevel string

const (
	AccessLevelAdmin AccessLevel = "ADMIN"
	AccessLevelEdit  AccessLevel = "EDIT"
	AccessLevelView  AccessLevel = "VIEW"
)

var AllAccessLevel = []AccessLevel{
	AccessLevelAdmin,
	AccessLevelEdit,
	AccessLevelView,
}

func (e AccessLevel) IsValid() bool {
	switch e {
	case AccessLevelAdmin, AccessLevelEdit, AccessLevelView:
		return true
	}
	return false
}

func (e AccessLevel) String() string {
	return string(e)
}

func (e *AccessLevel) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccessLevel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccessLevel", str)
	}
	return nil
}

func (e AccessLevel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AccessLevel) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AccessLevel) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type Arch string

const (
	ArchLinux64Bit    Arch = "LINUX_64_BIT"
	ArchLinuxArm64Bit Arch = "LINUX_ARM_64_BIT"
	ArchLinuxPpc64Bit Arch = "LINUX_PPC_64_BIT"
	ArchLinuxZseries  Arch = "LINUX_ZSERIES"
	ArchOsx64Bit      Arch = "OSX_64_BIT"
	ArchOsxArm64Bit   Arch = "OSX_ARM_64_BIT"
	ArchWindows64Bit  Arch = "WINDOWS_64_BIT"
)

var AllArch = []Arch{
	ArchLinux64Bit,
	ArchLinuxArm64Bit,
	ArchLinuxPpc64Bit,
	ArchLinuxZseries,
	ArchOsx64Bit,
	ArchOsxArm64Bit,
	ArchWindows64Bit,
}

func (e Arch) IsValid() bool {
	switch e {
	case ArchLinux64Bit, ArchLinuxArm64Bit, ArchLinuxPpc64Bit, ArchLinuxZseries, ArchOsx64Bit, ArchOsxArm64Bit, ArchWindows64Bit:
		return true
	}
	return false
}

func (e Arch) String() string {
	return string(e)
}

func (e *Arch) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Arch(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Arch", str)
	}
	return nil
}

func (e Arch) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *Arch) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e Arch) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type BootstrapMethod string

const (
	BootstrapMethodLegacySSH BootstrapMethod = "LEGACY_SSH"
	BootstrapMethodSSH       BootstrapMethod = "SSH"
	BootstrapMethodUserData  BootstrapMethod = "USER_DATA"
)

var AllBootstrapMethod = []BootstrapMethod{
	BootstrapMethodLegacySSH,
	BootstrapMethodSSH,
	BootstrapMethodUserData,
}

func (e BootstrapMethod) IsValid() bool {
	switch e {
	case BootstrapMethodLegacySSH, BootstrapMethodSSH, BootstrapMethodUserData:
		return true
	}
	return false
}

func (e BootstrapMethod) String() string {
	return string(e)
}

func (e *BootstrapMethod) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = BootstrapMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid BootstrapMethod", str)
	}
	return nil
}

func (e BootstrapMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *BootstrapMethod) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e BootstrapMethod) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type CommunicationMethod string

const (
	CommunicationMethodLegacySSH CommunicationMethod = "LEGACY_SSH"
	CommunicationMethodSSH       CommunicationMethod = "SSH"
	CommunicationMethodRPC       CommunicationMethod = "RPC"
)

var AllCommunicationMethod = []CommunicationMethod{
	CommunicationMethodLegacySSH,
	CommunicationMethodSSH,
	CommunicationMethodRPC,
}

func (e CommunicationMethod) IsValid() bool {
	switch e {
	case CommunicationMethodLegacySSH, CommunicationMethodSSH, CommunicationMethodRPC:
		return true
	}
	return false
}

func (e CommunicationMethod) String() string {
	return string(e)
}

func (e *CommunicationMethod) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CommunicationMethod(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CommunicationMethod", str)
	}
	return nil
}

func (e CommunicationMethod) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *CommunicationMethod) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e CommunicationMethod) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type DispatcherVersion string

const (
	DispatcherVersionRevisedWithDependencies DispatcherVersion = "REVISED_WITH_DEPENDENCIES"
)

var AllDispatcherVersion = []DispatcherVersion{
	DispatcherVersionRevisedWithDependencies,
}

func (e DispatcherVersion) IsValid() bool {
	switch e {
	case DispatcherVersionRevisedWithDependencies:
		return true
	}
	return false
}

func (e DispatcherVersion) String() string {
	return string(e)
}

func (e *DispatcherVersion) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DispatcherVersion(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DispatcherVersion", str)
	}
	return nil
}

func (e DispatcherVersion) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DispatcherVersion) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DispatcherVersion) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type DistroOnSaveOperation string

const (
	DistroOnSaveOperationDecommission  DistroOnSaveOperation = "DECOMMISSION"
	DistroOnSaveOperationRestartJasper DistroOnSaveOperation = "RESTART_JASPER"
	DistroOnSaveOperationReprovision   DistroOnSaveOperation = "REPROVISION"
	DistroOnSaveOperationNone          DistroOnSaveOperation = "NONE"
)

var AllDistroOnSaveOperation = []DistroOnSaveOperation{
	DistroOnSaveOperationDecommission,
	DistroOnSaveOperationRestartJasper,
	DistroOnSaveOperationReprovision,
	DistroOnSaveOperationNone,
}

func (e DistroOnSaveOperation) IsValid() bool {
	switch e {
	case DistroOnSaveOperationDecommission, DistroOnSaveOperationRestartJasper, DistroOnSaveOperationReprovision, DistroOnSaveOperationNone:
		return true
	}
	return false
}

func (e DistroOnSaveOperation) String() string {
	return string(e)
}

func (e *DistroOnSaveOperation) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DistroOnSaveOperation(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DistroOnSaveOperation", str)
	}
	return nil
}

func (e DistroOnSaveOperation) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DistroOnSaveOperation) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DistroOnSaveOperation) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type DistroSettingsAccess string

const (
	DistroSettingsAccessAdmin  DistroSettingsAccess = "ADMIN"
	DistroSettingsAccessCreate DistroSettingsAccess = "CREATE"
	DistroSettingsAccessEdit   DistroSettingsAccess = "EDIT"
	DistroSettingsAccessView   DistroSettingsAccess = "VIEW"
)

var AllDistroSettingsAccess = []DistroSettingsAccess{
	DistroSettingsAccessAdmin,
	DistroSettingsAccessCreate,
	DistroSettingsAccessEdit,
	DistroSettingsAccessView,
}

func (e DistroSettingsAccess) IsValid() bool {
	switch e {
	case DistroSettingsAccessAdmin, DistroSettingsAccessCreate, DistroSettingsAccessEdit, DistroSettingsAccessView:
		return true
	}
	return false
}

func (e DistroSettingsAccess) String() string {
	return string(e)
}

func (e *DistroSettingsAccess) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DistroSettingsAccess(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DistroSettingsAccess", str)
	}
	return nil
}

func (e DistroSettingsAccess) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *DistroSettingsAccess) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e DistroSettingsAccess) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type FeedbackRule string

const (
	FeedbackRuleWaitsOverThresh FeedbackRule = "WAITS_OVER_THRESH"
	FeedbackRuleNoFeedback      FeedbackRule = "NO_FEEDBACK"
	FeedbackRuleDefault         FeedbackRule = "DEFAULT"
)

var AllFeedbackRule = []FeedbackRule{
	FeedbackRuleWaitsOverThresh,
	FeedbackRuleNoFeedback,
	FeedbackRuleDefault,
}

func (e FeedbackRule) IsValid() bool {
	switch e {
	case FeedbackRuleWaitsOverThresh, FeedbackRuleNoFeedback, FeedbackRuleDefault:
		return true
	}
	return false
}

func (e FeedbackRule) String() string {
	return string(e)
}

func (e *FeedbackRule) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FeedbackRule(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FeedbackRule", str)
	}
	return nil
}

func (e FeedbackRule) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *FeedbackRule) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e FeedbackRule) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type FinderVersion string

const (
	FinderVersionLegacy    FinderVersion = "LEGACY"
	FinderVersionParallel  FinderVersion = "PARALLEL"
	FinderVersionPipeline  FinderVersion = "PIPELINE"
	FinderVersionAlternate FinderVersion = "ALTERNATE"
)

var AllFinderVersion = []FinderVersion{
	FinderVersionLegacy,
	FinderVersionParallel,
	FinderVersionPipeline,
	FinderVersionAlternate,
}

func (e FinderVersion) IsValid() bool {
	switch e {
	case FinderVersionLegacy, FinderVersionParallel, FinderVersionPipeline, FinderVersionAlternate:
		return true
	}
	return false
}

func (e FinderVersion) String() string {
	return string(e)
}

func (e *FinderVersion) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = FinderVersion(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid FinderVersion", str)
	}
	return nil
}

func (e FinderVersion) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *FinderVersion) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e FinderVersion) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type HostAccessLevel string

const (
	HostAccessLevelEdit HostAccessLevel = "EDIT"
	HostAccessLevelView HostAccessLevel = "VIEW"
)

var AllHostAccessLevel = []HostAccessLevel{
	HostAccessLevelEdit,
	HostAccessLevelView,
}

func (e HostAccessLevel) IsValid() bool {
	switch e {
	case HostAccessLevelEdit, HostAccessLevelView:
		return true
	}
	return false
}

func (e HostAccessLevel) String() string {
	return string(e)
}

func (e *HostAccessLevel) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HostAccessLevel(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HostAccessLevel", str)
	}
	return nil
}

func (e HostAccessLevel) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *HostAccessLevel) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e HostAccessLevel) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type HostAllocatorVersion string

const (
	HostAllocatorVersionUtilization HostAllocatorVersion = "UTILIZATION"
)

var AllHostAllocatorVersion = []HostAllocatorVersion{
	HostAllocatorVersionUtilization,
}

func (e HostAllocatorVersion) IsValid() bool {
	switch e {
	case HostAllocatorVersionUtilization:
		return true
	}
	return false
}

func (e HostAllocatorVersion) String() string {
	return string(e)
}

func (e *HostAllocatorVersion) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HostAllocatorVersion(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HostAllocatorVersion", str)
	}
	return nil
}

func (e HostAllocatorVersion) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *HostAllocatorVersion) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e HostAllocatorVersion) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type HostSortBy string

const (
	HostSortByID          HostSortBy = "ID"
	HostSortByCurrentTask HostSortBy = "CURRENT_TASK"
	HostSortByDistro      HostSortBy = "DISTRO"
	HostSortByElapsed     HostSortBy = "ELAPSED"
	HostSortByIdleTime    HostSortBy = "IDLE_TIME"
	HostSortByOwner       HostSortBy = "OWNER"
	HostSortByStatus      HostSortBy = "STATUS"
	HostSortByUptime      HostSortBy = "UPTIME"
)

var AllHostSortBy = []HostSortBy{
	HostSortByID,
	HostSortByCurrentTask,
	HostSortByDistro,
	HostSortByElapsed,
	HostSortByIdleTime,
	HostSortByOwner,
	HostSortByStatus,
	HostSortByUptime,
}

func (e HostSortBy) IsValid() bool {
	switch e {
	case HostSortByID, HostSortByCurrentTask, HostSortByDistro, HostSortByElapsed, HostSortByIdleTime, HostSortByOwner, HostSortByStatus, HostSortByUptime:
		return true
	}
	return false
}

func (e HostSortBy) String() string {
	return string(e)
}

func (e *HostSortBy) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = HostSortBy(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid HostSortBy", str)
	}
	return nil
}

func (e HostSortBy) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *HostSortBy) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e HostSortBy) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type MetStatus string

const (
	MetStatusUnmet   MetStatus = "UNMET"
	MetStatusMet     MetStatus = "MET"
	MetStatusPending MetStatus = "PENDING"
	MetStatusStarted MetStatus = "STARTED"
)

var AllMetStatus = []MetStatus{
	MetStatusUnmet,
	MetStatusMet,
	MetStatusPending,
	MetStatusStarted,
}

func (e MetStatus) IsValid() bool {
	switch e {
	case MetStatusUnmet, MetStatusMet, MetStatusPending, MetStatusStarted:
		return true
	}
	return false
}

func (e MetStatus) String() string {
	return string(e)
}

func (e *MetStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MetStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MetStatus", str)
	}
	return nil
}

func (e MetStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *MetStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e MetStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type OverallocatedRule string

const (
	OverallocatedRuleTerminate OverallocatedRule = "TERMINATE"
	OverallocatedRuleIgnore    OverallocatedRule = "IGNORE"
	OverallocatedRuleDefault   OverallocatedRule = "DEFAULT"
)

var AllOverallocatedRule = []OverallocatedRule{
	OverallocatedRuleTerminate,
	OverallocatedRuleIgnore,
	OverallocatedRuleDefault,
}

func (e OverallocatedRule) IsValid() bool {
	switch e {
	case OverallocatedRuleTerminate, OverallocatedRuleIgnore, OverallocatedRuleDefault:
		return true
	}
	return false
}

func (e OverallocatedRule) String() string {
	return string(e)
}

func (e *OverallocatedRule) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OverallocatedRule(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OverallocatedRule", str)
	}
	return nil
}

func (e OverallocatedRule) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *OverallocatedRule) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e OverallocatedRule) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type PlannerVersion string

const (
	PlannerVersionTunable PlannerVersion = "TUNABLE"
)

var AllPlannerVersion = []PlannerVersion{
	PlannerVersionTunable,
}

func (e PlannerVersion) IsValid() bool {
	switch e {
	case PlannerVersionTunable:
		return true
	}
	return false
}

func (e PlannerVersion) String() string {
	return string(e)
}

func (e *PlannerVersion) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PlannerVersion(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PlannerVersion", str)
	}
	return nil
}

func (e PlannerVersion) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *PlannerVersion) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e PlannerVersion) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type ProjectPermission string

const (
	ProjectPermissionSettings    ProjectPermission = "SETTINGS"
	ProjectPermissionTasks       ProjectPermission = "TASKS"
	ProjectPermissionAnnotations ProjectPermission = "ANNOTATIONS"
	ProjectPermissionPatches     ProjectPermission = "PATCHES"
	ProjectPermissionLogs        ProjectPermission = "LOGS"
)

var AllProjectPermission = []ProjectPermission{
	ProjectPermissionSettings,
	ProjectPermissionTasks,
	ProjectPermissionAnnotations,
	ProjectPermissionPatches,
	ProjectPermissionLogs,
}

func (e ProjectPermission) IsValid() bool {
	switch e {
	case ProjectPermissionSettings, ProjectPermissionTasks, ProjectPermissionAnnotations, ProjectPermissionPatches, ProjectPermissionLogs:
		return true
	}
	return false
}

func (e ProjectPermission) String() string {
	return string(e)
}

func (e *ProjectPermission) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectPermission(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectPermission", str)
	}
	return nil
}

func (e ProjectPermission) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ProjectPermission) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ProjectPermission) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type ProjectSettingsSection string

const (
	ProjectSettingsSectionGeneral              ProjectSettingsSection = "GENERAL"
	ProjectSettingsSectionAccess               ProjectSettingsSection = "ACCESS"
	ProjectSettingsSectionVariables            ProjectSettingsSection = "VARIABLES"
	ProjectSettingsSectionNotifications        ProjectSettingsSection = "NOTIFICATIONS"
	ProjectSettingsSectionPatchAliases         ProjectSettingsSection = "PATCH_ALIASES"
	ProjectSettingsSectionWorkstation          ProjectSettingsSection = "WORKSTATION"
	ProjectSettingsSectionTriggers             ProjectSettingsSection = "TRIGGERS"
	ProjectSettingsSectionPeriodicBuilds       ProjectSettingsSection = "PERIODIC_BUILDS"
	ProjectSettingsSectionPlugins              ProjectSettingsSection = "PLUGINS"
	ProjectSettingsSectionContainers           ProjectSettingsSection = "CONTAINERS"
	ProjectSettingsSectionViewsAndFilters      ProjectSettingsSection = "VIEWS_AND_FILTERS"
	ProjectSettingsSectionGithubAndCommitQueue ProjectSettingsSection = "GITHUB_AND_COMMIT_QUEUE"
	ProjectSettingsSectionGithubAppSettings    ProjectSettingsSection = "GITHUB_APP_SETTINGS"
	ProjectSettingsSectionGithubPermissions    ProjectSettingsSection = "GITHUB_PERMISSIONS"
)

var AllProjectSettingsSection = []ProjectSettingsSection{
	ProjectSettingsSectionGeneral,
	ProjectSettingsSectionAccess,
	ProjectSettingsSectionVariables,
	ProjectSettingsSectionNotifications,
	ProjectSettingsSectionPatchAliases,
	ProjectSettingsSectionWorkstation,
	ProjectSettingsSectionTriggers,
	ProjectSettingsSectionPeriodicBuilds,
	ProjectSettingsSectionPlugins,
	ProjectSettingsSectionContainers,
	ProjectSettingsSectionViewsAndFilters,
	ProjectSettingsSectionGithubAndCommitQueue,
	ProjectSettingsSectionGithubAppSettings,
	ProjectSettingsSectionGithubPermissions,
}

func (e ProjectSettingsSection) IsValid() bool {
	switch e {
	case ProjectSettingsSectionGeneral, ProjectSettingsSectionAccess, ProjectSettingsSectionVariables, ProjectSettingsSectionNotifications, ProjectSettingsSectionPatchAliases, ProjectSettingsSectionWorkstation, ProjectSettingsSectionTriggers, ProjectSettingsSectionPeriodicBuilds, ProjectSettingsSectionPlugins, ProjectSettingsSectionContainers, ProjectSettingsSectionViewsAndFilters, ProjectSettingsSectionGithubAndCommitQueue, ProjectSettingsSectionGithubAppSettings, ProjectSettingsSectionGithubPermissions:
		return true
	}
	return false
}

func (e ProjectSettingsSection) String() string {
	return string(e)
}

func (e *ProjectSettingsSection) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProjectSettingsSection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProjectSettingsSection", str)
	}
	return nil
}

func (e ProjectSettingsSection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ProjectSettingsSection) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ProjectSettingsSection) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type Provider string

const (
	ProviderDocker      Provider = "DOCKER"
	ProviderEc2Fleet    Provider = "EC2_FLEET"
	ProviderEc2OnDemand Provider = "EC2_ON_DEMAND"
	ProviderStatic      Provider = "STATIC"
)

var AllProvider = []Provider{
	ProviderDocker,
	ProviderEc2Fleet,
	ProviderEc2OnDemand,
	ProviderStatic,
}

func (e Provider) IsValid() bool {
	switch e {
	case ProviderDocker, ProviderEc2Fleet, ProviderEc2OnDemand, ProviderStatic:
		return true
	}
	return false
}

func (e Provider) String() string {
	return string(e)
}

func (e *Provider) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Provider(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Provider", str)
	}
	return nil
}

func (e Provider) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *Provider) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e Provider) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type RequiredStatus string

const (
	RequiredStatusMustFail    RequiredStatus = "MUST_FAIL"
	RequiredStatusMustFinish  RequiredStatus = "MUST_FINISH"
	RequiredStatusMustSucceed RequiredStatus = "MUST_SUCCEED"
)

var AllRequiredStatus = []RequiredStatus{
	RequiredStatusMustFail,
	RequiredStatusMustFinish,
	RequiredStatusMustSucceed,
}

func (e RequiredStatus) IsValid() bool {
	switch e {
	case RequiredStatusMustFail, RequiredStatusMustFinish, RequiredStatusMustSucceed:
		return true
	}
	return false
}

func (e RequiredStatus) String() string {
	return string(e)
}

func (e *RequiredStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RequiredStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RequiredStatus", str)
	}
	return nil
}

func (e RequiredStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *RequiredStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e RequiredStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type RoundingRule string

const (
	RoundingRuleDown    RoundingRule = "DOWN"
	RoundingRuleUp      RoundingRule = "UP"
	RoundingRuleDefault RoundingRule = "DEFAULT"
)

var AllRoundingRule = []RoundingRule{
	RoundingRuleDown,
	RoundingRuleUp,
	RoundingRuleDefault,
}

func (e RoundingRule) IsValid() bool {
	switch e {
	case RoundingRuleDown, RoundingRuleUp, RoundingRuleDefault:
		return true
	}
	return false
}

func (e RoundingRule) String() string {
	return string(e)
}

func (e *RoundingRule) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RoundingRule(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RoundingRule", str)
	}
	return nil
}

func (e RoundingRule) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *RoundingRule) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e RoundingRule) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SortDirection string

const (
	SortDirectionAsc  SortDirection = "ASC"
	SortDirectionDesc SortDirection = "DESC"
)

var AllSortDirection = []SortDirection{
	SortDirectionAsc,
	SortDirectionDesc,
}

func (e SortDirection) IsValid() bool {
	switch e {
	case SortDirectionAsc, SortDirectionDesc:
		return true
	}
	return false
}

func (e SortDirection) String() string {
	return string(e)
}

func (e *SortDirection) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortDirection", str)
	}
	return nil
}

func (e SortDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SortDirection) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SortDirection) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type SpawnHostStatusActions string

const (
	SpawnHostStatusActionsStart     SpawnHostStatusActions = "START"
	SpawnHostStatusActionsStop      SpawnHostStatusActions = "STOP"
	SpawnHostStatusActionsTerminate SpawnHostStatusActions = "TERMINATE"
)

var AllSpawnHostStatusActions = []SpawnHostStatusActions{
	SpawnHostStatusActionsStart,
	SpawnHostStatusActionsStop,
	SpawnHostStatusActionsTerminate,
}

func (e SpawnHostStatusActions) IsValid() bool {
	switch e {
	case SpawnHostStatusActionsStart, SpawnHostStatusActionsStop, SpawnHostStatusActionsTerminate:
		return true
	}
	return false
}

func (e SpawnHostStatusActions) String() string {
	return string(e)
}

func (e *SpawnHostStatusActions) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SpawnHostStatusActions(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SpawnHostStatusActions", str)
	}
	return nil
}

func (e SpawnHostStatusActions) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *SpawnHostStatusActions) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e SpawnHostStatusActions) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type TaskHistoryDirection string

const (
	TaskHistoryDirectionAfter  TaskHistoryDirection = "AFTER"
	TaskHistoryDirectionBefore TaskHistoryDirection = "BEFORE"
)

var AllTaskHistoryDirection = []TaskHistoryDirection{
	TaskHistoryDirectionAfter,
	TaskHistoryDirectionBefore,
}

func (e TaskHistoryDirection) IsValid() bool {
	switch e {
	case TaskHistoryDirectionAfter, TaskHistoryDirectionBefore:
		return true
	}
	return false
}

func (e TaskHistoryDirection) String() string {
	return string(e)
}

func (e *TaskHistoryDirection) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TaskHistoryDirection(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TaskHistoryDirection", str)
	}
	return nil
}

func (e TaskHistoryDirection) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TaskHistoryDirection) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TaskHistoryDirection) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type TaskQueueItemType string

const (
	TaskQueueItemTypeCommit TaskQueueItemType = "COMMIT"
	TaskQueueItemTypePatch  TaskQueueItemType = "PATCH"
)

var AllTaskQueueItemType = []TaskQueueItemType{
	TaskQueueItemTypeCommit,
	TaskQueueItemTypePatch,
}

func (e TaskQueueItemType) IsValid() bool {
	switch e {
	case TaskQueueItemTypeCommit, TaskQueueItemTypePatch:
		return true
	}
	return false
}

func (e TaskQueueItemType) String() string {
	return string(e)
}

func (e *TaskQueueItemType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TaskQueueItemType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TaskQueueItemType", str)
	}
	return nil
}

func (e TaskQueueItemType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TaskQueueItemType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TaskQueueItemType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type TaskSortCategory string

const (
	TaskSortCategoryName       TaskSortCategory = "NAME"
	TaskSortCategoryStatus     TaskSortCategory = "STATUS"
	TaskSortCategoryBaseStatus TaskSortCategory = "BASE_STATUS"
	TaskSortCategoryVariant    TaskSortCategory = "VARIANT"
	TaskSortCategoryDuration   TaskSortCategory = "DURATION"
)

var AllTaskSortCategory = []TaskSortCategory{
	TaskSortCategoryName,
	TaskSortCategoryStatus,
	TaskSortCategoryBaseStatus,
	TaskSortCategoryVariant,
	TaskSortCategoryDuration,
}

func (e TaskSortCategory) IsValid() bool {
	switch e {
	case TaskSortCategoryName, TaskSortCategoryStatus, TaskSortCategoryBaseStatus, TaskSortCategoryVariant, TaskSortCategoryDuration:
		return true
	}
	return false
}

func (e TaskSortCategory) String() string {
	return string(e)
}

func (e *TaskSortCategory) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TaskSortCategory(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TaskSortCategory", str)
	}
	return nil
}

func (e TaskSortCategory) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TaskSortCategory) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TaskSortCategory) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type TestSortCategory string

const (
	TestSortCategoryBaseStatus TestSortCategory = "BASE_STATUS"
	TestSortCategoryStatus     TestSortCategory = "STATUS"
	TestSortCategoryStartTime  TestSortCategory = "START_TIME"
	TestSortCategoryDuration   TestSortCategory = "DURATION"
	TestSortCategoryTestName   TestSortCategory = "TEST_NAME"
)

var AllTestSortCategory = []TestSortCategory{
	TestSortCategoryBaseStatus,
	TestSortCategoryStatus,
	TestSortCategoryStartTime,
	TestSortCategoryDuration,
	TestSortCategoryTestName,
}

func (e TestSortCategory) IsValid() bool {
	switch e {
	case TestSortCategoryBaseStatus, TestSortCategoryStatus, TestSortCategoryStartTime, TestSortCategoryDuration, TestSortCategoryTestName:
		return true
	}
	return false
}

func (e TestSortCategory) String() string {
	return string(e)
}

func (e *TestSortCategory) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TestSortCategory(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TestSortCategory", str)
	}
	return nil
}

func (e TestSortCategory) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TestSortCategory) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TestSortCategory) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
