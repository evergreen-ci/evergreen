// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graphql

import (
	"bytes"
	"context"
	"embed"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/evergreen-ci/evergreen"
	"github.com/evergreen-ci/evergreen/apimodels"
	model1 "github.com/evergreen-ci/evergreen/model"
	"github.com/evergreen-ci/evergreen/model/distro"
	"github.com/evergreen-ci/evergreen/model/event"
	"github.com/evergreen-ci/evergreen/model/host"
	"github.com/evergreen-ci/evergreen/model/task"
	"github.com/evergreen-ci/evergreen/rest/model"
	"github.com/evergreen-ci/evergreen/thirdparty"
	"github.com/evergreen-ci/plank"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	AdminSettings() AdminSettingsResolver
	Annotation() AnnotationResolver
	ContainerPool() ContainerPoolResolver
	Distro() DistroResolver
	Host() HostResolver
	Image() ImageResolver
	IssueLink() IssueLinkResolver
	LogkeeperBuild() LogkeeperBuildResolver
	Mutation() MutationResolver
	Patch() PatchResolver
	Permissions() PermissionsResolver
	Pod() PodResolver
	PodEventLogData() PodEventLogDataResolver
	Project() ProjectResolver
	ProjectSettings() ProjectSettingsResolver
	ProjectVars() ProjectVarsResolver
	Query() QueryResolver
	RepoRef() RepoRefResolver
	RepoSettings() RepoSettingsResolver
	SleepSchedule() SleepScheduleResolver
	SpruceConfig() SpruceConfigResolver
	SubscriberWrapper() SubscriberWrapperResolver
	Task() TaskResolver
	TaskContainerCreationOpts() TaskContainerCreationOptsResolver
	TaskLogs() TaskLogsResolver
	TaskQueueItem() TaskQueueItemResolver
	TicketFields() TicketFieldsResolver
	User() UserResolver
	Version() VersionResolver
	Volume() VolumeResolver
	AdminSettingsInput() AdminSettingsInputResolver
	DistroInput() DistroInputResolver
	HostAllocatorSettingsInput() HostAllocatorSettingsInputResolver
	PlannerSettingsInput() PlannerSettingsInputResolver
	ProjectInput() ProjectInputResolver
	ProjectSettingsInput() ProjectSettingsInputResolver
	RepoRefInput() RepoRefInputResolver
	RepoSettingsInput() RepoSettingsInputResolver
	SleepScheduleInput() SleepScheduleInputResolver
	SubscriberInput() SubscriberInputResolver
}

type DirectiveRoot struct {
	RedactSecrets                func(ctx context.Context, obj any, next graphql.Resolver) (res any, err error)
	RequireAdmin                 func(ctx context.Context, obj any, next graphql.Resolver) (res any, err error)
	RequireDistroAccess          func(ctx context.Context, obj any, next graphql.Resolver, access DistroSettingsAccess) (res any, err error)
	RequireHostAccess            func(ctx context.Context, obj any, next graphql.Resolver, access HostAccessLevel) (res any, err error)
	RequirePatchOwner            func(ctx context.Context, obj any, next graphql.Resolver) (res any, err error)
	RequireProjectAccess         func(ctx context.Context, obj any, next graphql.Resolver, permission ProjectPermission, access AccessLevel) (res any, err error)
	RequireProjectAdmin          func(ctx context.Context, obj any, next graphql.Resolver) (res any, err error)
	RequireProjectSettingsAccess func(ctx context.Context, obj any, next graphql.Resolver) (res any, err error)
}

type ComplexityRoot struct {
	APIConfig struct {
		CorpURL        func(childComplexity int) int
		HttpListenAddr func(childComplexity int) int
		URL            func(childComplexity int) int
	}

	AWSConfig struct {
		MaxVolumeSizePerUser func(childComplexity int) int
		Pod                  func(childComplexity int) int
	}

	AWSPodConfig struct {
		ECS func(childComplexity int) int
	}

	AbortInfo struct {
		BuildVariantDisplayName func(childComplexity int) int
		NewVersion              func(childComplexity int) int
		PrClosed                func(childComplexity int) int
		TaskDisplayName         func(childComplexity int) int
		TaskID                  func(childComplexity int) int
		User                    func(childComplexity int) int
	}

	AdminEvent struct {
		After     func(childComplexity int) int
		Before    func(childComplexity int) int
		Section   func(childComplexity int) int
		Timestamp func(childComplexity int) int
		User      func(childComplexity int) int
	}

	AdminEventsPayload struct {
		Count           func(childComplexity int) int
		EventLogEntries func(childComplexity int) int
	}

	AdminSettings struct {
		Amboy               func(childComplexity int) int
		AmboyDB             func(childComplexity int) int
		Api                 func(childComplexity int) int
		AuthConfig          func(childComplexity int) int
		Banner              func(childComplexity int) int
		BannerTheme         func(childComplexity int) int
		Cedar               func(childComplexity int) int
		DisabledGQLQueries  func(childComplexity int) int
		FWS                 func(childComplexity int) int
		HostInit            func(childComplexity int) int
		Jira                func(childComplexity int) int
		LoggerConfig        func(childComplexity int) int
		Notify              func(childComplexity int) int
		PodLifecycle        func(childComplexity int) int
		RepoTracker         func(childComplexity int) int
		RuntimeEnvironments func(childComplexity int) int
		Scheduler           func(childComplexity int) int
		ServiceFlags        func(childComplexity int) int
		Slack               func(childComplexity int) int
		Splunk              func(childComplexity int) int
		TaskLimits          func(childComplexity int) int
		TestSelection       func(childComplexity int) int
		Triggers            func(childComplexity int) int
		Ui                  func(childComplexity int) int
	}

	AdminTasksToRestartPayload struct {
		TasksToRestart func(childComplexity int) int
	}

	AmboyConfig struct {
		GroupBackgroundCreateFrequencyMinutes func(childComplexity int) int
		GroupDefaultWorkers                   func(childComplexity int) int
		GroupPruneFrequencyMinutes            func(childComplexity int) int
		GroupTTLMinutes                       func(childComplexity int) int
		LocalStorage                          func(childComplexity int) int
		LockTimeoutMinutes                    func(childComplexity int) int
		Name                                  func(childComplexity int) int
		NamedQueues                           func(childComplexity int) int
		PoolSizeLocal                         func(childComplexity int) int
		PoolSizeRemote                        func(childComplexity int) int
		Retry                                 func(childComplexity int) int
		SampleSize                            func(childComplexity int) int
		SingleName                            func(childComplexity int) int
	}

	AmboyDBConfig struct {
		Database func(childComplexity int) int
		URL      func(childComplexity int) int
	}

	AmboyNamedQueueConfig struct {
		LockTimeoutSeconds func(childComplexity int) int
		Name               func(childComplexity int) int
		NumWorkers         func(childComplexity int) int
		Regexp             func(childComplexity int) int
		SampleSize         func(childComplexity int) int
	}

	AmboyRetryConfig struct {
		MaxCapacity                         func(childComplexity int) int
		MaxRetryAttempts                    func(childComplexity int) int
		MaxRetryTimeSeconds                 func(childComplexity int) int
		NumWorkers                          func(childComplexity int) int
		RetryBackoffSeconds                 func(childComplexity int) int
		StaleRetryingMonitorIntervalSeconds func(childComplexity int) int
	}

	Annotation struct {
		CreatedIssues     func(childComplexity int) int
		Id                func(childComplexity int) int
		Issues            func(childComplexity int) int
		MetadataLinks     func(childComplexity int) int
		Note              func(childComplexity int) int
		SuspectedIssues   func(childComplexity int) int
		TaskExecution     func(childComplexity int) int
		TaskId            func(childComplexity int) int
		WebhookConfigured func(childComplexity int) int
	}

	AuthConfig struct {
		AllowServiceUsers       func(childComplexity int) int
		BackgroundReauthMinutes func(childComplexity int) int
		Github                  func(childComplexity int) int
		Kanopy                  func(childComplexity int) int
		Multi                   func(childComplexity int) int
		Naive                   func(childComplexity int) int
		Okta                    func(childComplexity int) int
		PreferredType           func(childComplexity int) int
	}

	AuthUser struct {
		DisplayName func(childComplexity int) int
		Email       func(childComplexity int) int
		Password    func(childComplexity int) int
		Username    func(childComplexity int) int
	}

	BetaFeatures struct {
		SpruceWaterfallEnabled func(childComplexity int) int
	}

	BootstrapSettings struct {
		ClientDir             func(childComplexity int) int
		Communication         func(childComplexity int) int
		Env                   func(childComplexity int) int
		JasperBinaryDir       func(childComplexity int) int
		JasperCredentialsPath func(childComplexity int) int
		Method                func(childComplexity int) int
		PreconditionScripts   func(childComplexity int) int
		ResourceLimits        func(childComplexity int) int
		RootDir               func(childComplexity int) int
		ServiceUser           func(childComplexity int) int
		ShellPath             func(childComplexity int) int
	}

	Build struct {
		ActualMakespan    func(childComplexity int) int
		BuildVariant      func(childComplexity int) int
		Id                func(childComplexity int) int
		PredictedMakespan func(childComplexity int) int
		Status            func(childComplexity int) int
	}

	BuildBaron struct {
		BbTicketCreationDefined func(childComplexity int) int
		BuildBaronConfigured    func(childComplexity int) int
		SearchReturnInfo        func(childComplexity int) int
	}

	BuildBaronSettings struct {
		BFSuggestionFeaturesURL func(childComplexity int) int
		BFSuggestionPassword    func(childComplexity int) int
		BFSuggestionServer      func(childComplexity int) int
		BFSuggestionTimeoutSecs func(childComplexity int) int
		BFSuggestionUsername    func(childComplexity int) int
		TicketCreateIssueType   func(childComplexity int) int
		TicketCreateProject     func(childComplexity int) int
		TicketSearchProjects    func(childComplexity int) int
	}

	BuildVariantTuple struct {
		BuildVariant func(childComplexity int) int
		DisplayName  func(childComplexity int) int
	}

	CedarConfig struct {
		DBName func(childComplexity int) int
		DBURL  func(childComplexity int) int
	}

	ChildPatchAlias struct {
		Alias   func(childComplexity int) int
		PatchID func(childComplexity int) int
	}

	ClientBinary struct {
		Arch        func(childComplexity int) int
		DisplayName func(childComplexity int) int
		OS          func(childComplexity int) int
		URL         func(childComplexity int) int
	}

	ClientConfig struct {
		ClientBinaries func(childComplexity int) int
		LatestRevision func(childComplexity int) int
	}

	CloudProviderConfig struct {
		AWS func(childComplexity int) int
	}

	CommitQueueParams struct {
		Enabled     func(childComplexity int) int
		MergeMethod func(childComplexity int) int
		Message     func(childComplexity int) int
	}

	ContainerPool struct {
		Distro        func(childComplexity int) int
		Id            func(childComplexity int) int
		MaxContainers func(childComplexity int) int
		Port          func(childComplexity int) int
	}

	ContainerPoolsConfig struct {
		Pools func(childComplexity int) int
	}

	ContainerResources struct {
		CPU      func(childComplexity int) int
		MemoryMB func(childComplexity int) int
		Name     func(childComplexity int) int
	}

	DeleteDistroPayload struct {
		DeletedDistroID func(childComplexity int) int
	}

	DeleteGithubAppCredentialsPayload struct {
		OldAppID func(childComplexity int) int
	}

	Dependency struct {
		BuildVariant   func(childComplexity int) int
		MetStatus      func(childComplexity int) int
		Name           func(childComplexity int) int
		RequiredStatus func(childComplexity int) int
		TaskID         func(childComplexity int) int
	}

	DispatcherSettings struct {
		Version func(childComplexity int) int
	}

	Distro struct {
		AdminOnly             func(childComplexity int) int
		Aliases               func(childComplexity int) int
		Arch                  func(childComplexity int) int
		AuthorizedKeysFile    func(childComplexity int) int
		AvailableRegions      func(childComplexity int) int
		BootstrapSettings     func(childComplexity int) int
		ContainerPool         func(childComplexity int) int
		DisableShallowClone   func(childComplexity int) int
		Disabled              func(childComplexity int) int
		DispatcherSettings    func(childComplexity int) int
		ExecUser              func(childComplexity int) int
		Expansions            func(childComplexity int) int
		FinderSettings        func(childComplexity int) int
		HomeVolumeSettings    func(childComplexity int) int
		HostAllocatorSettings func(childComplexity int) int
		IcecreamSettings      func(childComplexity int) int
		ImageID               func(childComplexity int) int
		IsCluster             func(childComplexity int) int
		IsVirtualWorkstation  func(childComplexity int) int
		Mountpoints           func(childComplexity int) int
		Name                  func(childComplexity int) int
		Note                  func(childComplexity int) int
		PlannerSettings       func(childComplexity int) int
		Provider              func(childComplexity int) int
		ProviderAccount       func(childComplexity int) int
		ProviderSettingsList  func(childComplexity int) int
		SSHOptions            func(childComplexity int) int
		Setup                 func(childComplexity int) int
		SetupAsSudo           func(childComplexity int) int
		SingleTaskDistro      func(childComplexity int) int
		User                  func(childComplexity int) int
		UserSpawnAllowed      func(childComplexity int) int
		ValidProjects         func(childComplexity int) int
		WarningNote           func(childComplexity int) int
		WorkDir               func(childComplexity int) int
	}

	DistroEvent struct {
		After     func(childComplexity int) int
		Before    func(childComplexity int) int
		Data      func(childComplexity int) int
		Timestamp func(childComplexity int) int
		User      func(childComplexity int) int
	}

	DistroEventsPayload struct {
		Count           func(childComplexity int) int
		EventLogEntries func(childComplexity int) int
	}

	DistroInfo struct {
		BootstrapMethod      func(childComplexity int) int
		Id                   func(childComplexity int) int
		IsVirtualWorkstation func(childComplexity int) int
		IsWindows            func(childComplexity int) int
		User                 func(childComplexity int) int
		WorkDir              func(childComplexity int) int
	}

	DistroPermissions struct {
		Admin func(childComplexity int) int
		Edit  func(childComplexity int) int
		View  func(childComplexity int) int
	}

	ECSConfig struct {
		MaxCPU      func(childComplexity int) int
		MaxMemoryMB func(childComplexity int) int
	}

	EnvVar struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	Expansion struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	ExternalLink struct {
		DisplayName func(childComplexity int) int
		Requesters  func(childComplexity int) int
		URLTemplate func(childComplexity int) int
	}

	ExternalLinkForMetadata struct {
		DisplayName func(childComplexity int) int
		URL         func(childComplexity int) int
	}

	FWSConfig struct {
		URL func(childComplexity int) int
	}

	FailingCommand struct {
		FailureMetadataTags func(childComplexity int) int
		FullDisplayName     func(childComplexity int) int
	}

	File struct {
		Link       func(childComplexity int) int
		Name       func(childComplexity int) int
		URLParsley func(childComplexity int) int
		Visibility func(childComplexity int) int
	}

	FileDiff struct {
		Additions   func(childComplexity int) int
		Deletions   func(childComplexity int) int
		Description func(childComplexity int) int
		DiffLink    func(childComplexity int) int
		FileName    func(childComplexity int) int
	}

	FinderSettings struct {
		Version func(childComplexity int) int
	}

	GeneralSubscription struct {
		ID             func(childComplexity int) int
		OwnerType      func(childComplexity int) int
		RegexSelectors func(childComplexity int) int
		ResourceType   func(childComplexity int) int
		Selectors      func(childComplexity int) int
		Subscriber     func(childComplexity int) int
		Trigger        func(childComplexity int) int
		TriggerData    func(childComplexity int) int
	}

	GeneratedTaskCountResults struct {
		BuildVariantName func(childComplexity int) int
		EstimatedTasks   func(childComplexity int) int
		TaskID           func(childComplexity int) int
		TaskName         func(childComplexity int) int
	}

	GitHubAuthConfig struct {
		AppId        func(childComplexity int) int
		ClientId     func(childComplexity int) int
		ClientSecret func(childComplexity int) int
		DefaultOwner func(childComplexity int) int
		DefaultRepo  func(childComplexity int) int
		Organization func(childComplexity int) int
		Users        func(childComplexity int) int
	}

	GitHubDynamicTokenPermissionGroup struct {
		Name        func(childComplexity int) int
		Permissions func(childComplexity int) int
	}

	GitTag struct {
		Pusher func(childComplexity int) int
		Tag    func(childComplexity int) int
	}

	GithubAppAuth struct {
		AppID      func(childComplexity int) int
		PrivateKey func(childComplexity int) int
	}

	GithubCheckSubscriber struct {
		Owner func(childComplexity int) int
		Ref   func(childComplexity int) int
		Repo  func(childComplexity int) int
	}

	GithubPRSubscriber struct {
		Owner    func(childComplexity int) int
		PRNumber func(childComplexity int) int
		Ref      func(childComplexity int) int
		Repo     func(childComplexity int) int
	}

	GithubPatch struct {
		Author     func(childComplexity int) int
		BaseOwner  func(childComplexity int) int
		BaseRepo   func(childComplexity int) int
		HeadBranch func(childComplexity int) int
		HeadHash   func(childComplexity int) int
		HeadOwner  func(childComplexity int) int
		HeadRepo   func(childComplexity int) int
		PRNumber   func(childComplexity int) int
	}

	GithubProjectConflicts struct {
		CommitCheckIdentifiers func(childComplexity int) int
		CommitQueueIdentifiers func(childComplexity int) int
		PRTestingIdentifiers   func(childComplexity int) int
	}

	GithubUser struct {
		LastKnownAs func(childComplexity int) int
		UID         func(childComplexity int) int
	}

	GroupedBuildVariant struct {
		DisplayName func(childComplexity int) int
		Tasks       func(childComplexity int) int
		Variant     func(childComplexity int) int
	}

	GroupedFiles struct {
		Execution func(childComplexity int) int
		Files     func(childComplexity int) int
		TaskID    func(childComplexity int) int
		TaskName  func(childComplexity int) int
	}

	GroupedProjects struct {
		GroupDisplayName func(childComplexity int) int
		Projects         func(childComplexity int) int
		Repo             func(childComplexity int) int
	}

	GroupedTaskStatusCount struct {
		DisplayName  func(childComplexity int) int
		StatusCounts func(childComplexity int) int
		Variant      func(childComplexity int) int
	}

	HomeVolumeSettings struct {
		FormatCommand func(childComplexity int) int
	}

	Host struct {
		Ami                   func(childComplexity int) int
		AvailabilityZone      func(childComplexity int) int
		DisplayName           func(childComplexity int) int
		Distro                func(childComplexity int) int
		DistroID              func(childComplexity int) int
		Elapsed               func(childComplexity int) int
		EventTypes            func(childComplexity int) int
		Events                func(childComplexity int, opts HostEventsInput) int
		Expiration            func(childComplexity int) int
		HomeVolume            func(childComplexity int) int
		HomeVolumeID          func(childComplexity int) int
		HostURL               func(childComplexity int) int
		Id                    func(childComplexity int) int
		InstanceTags          func(childComplexity int) int
		InstanceType          func(childComplexity int) int
		LastCommunicationTime func(childComplexity int) int
		NoExpiration          func(childComplexity int) int
		PersistentDNSName     func(childComplexity int) int
		Provider              func(childComplexity int) int
		RunningTask           func(childComplexity int) int
		SleepSchedule         func(childComplexity int) int
		StartedBy             func(childComplexity int) int
		Status                func(childComplexity int) int
		Tag                   func(childComplexity int) int
		TotalIdleTime         func(childComplexity int) int
		Uptime                func(childComplexity int) int
		User                  func(childComplexity int) int
		Volumes               func(childComplexity int) int
	}

	HostAllocatorSettings struct {
		AcceptableHostIdleTime func(childComplexity int) int
		AutoTuneMaximumHosts   func(childComplexity int) int
		FeedbackRule           func(childComplexity int) int
		FutureHostFraction     func(childComplexity int) int
		HostsOverallocatedRule func(childComplexity int) int
		MaximumHosts           func(childComplexity int) int
		MinimumHosts           func(childComplexity int) int
		RoundingRule           func(childComplexity int) int
		Version                func(childComplexity int) int
	}

	HostEventLogData struct {
		AgentBuild         func(childComplexity int) int
		AgentRevision      func(childComplexity int) int
		Duration           func(childComplexity int) int
		Execution          func(childComplexity int) int
		Hostname           func(childComplexity int) int
		JasperRevision     func(childComplexity int) int
		Logs               func(childComplexity int) int
		MonitorOp          func(childComplexity int) int
		NewStatus          func(childComplexity int) int
		OldStatus          func(childComplexity int) int
		ProvisioningMethod func(childComplexity int) int
		Successful         func(childComplexity int) int
		TaskId             func(childComplexity int) int
		TaskPid            func(childComplexity int) int
		TaskStatus         func(childComplexity int) int
		User               func(childComplexity int) int
	}

	HostEventLogEntry struct {
		Data         func(childComplexity int) int
		EventType    func(childComplexity int) int
		ID           func(childComplexity int) int
		ProcessedAt  func(childComplexity int) int
		ResourceId   func(childComplexity int) int
		ResourceType func(childComplexity int) int
		Timestamp    func(childComplexity int) int
	}

	HostEvents struct {
		Count           func(childComplexity int) int
		EventLogEntries func(childComplexity int) int
	}

	HostInitConfig struct {
		CloudStatusBatchSize func(childComplexity int) int
		HostThrottle         func(childComplexity int) int
		MaxTotalDynamicHosts func(childComplexity int) int
		ProvisioningThrottle func(childComplexity int) int
	}

	HostsResponse struct {
		FilteredHostsCount func(childComplexity int) int
		Hosts              func(childComplexity int) int
		TotalHostsCount    func(childComplexity int) int
	}

	IceCreamSettings struct {
		ConfigPath    func(childComplexity int) int
		SchedulerHost func(childComplexity int) int
	}

	Image struct {
		AMI             func(childComplexity int) int
		Distros         func(childComplexity int) int
		Events          func(childComplexity int, limit int, page int) int
		ID              func(childComplexity int) int
		LastDeployed    func(childComplexity int) int
		LatestTask      func(childComplexity int) int
		OperatingSystem func(childComplexity int, opts thirdparty.OSInfoFilterOptions) int
		Packages        func(childComplexity int, opts thirdparty.PackageFilterOptions) int
		Toolchains      func(childComplexity int, opts thirdparty.ToolchainFilterOptions) int
	}

	ImageEvent struct {
		AMIAfter  func(childComplexity int) int
		AMIBefore func(childComplexity int) int
		Entries   func(childComplexity int) int
		Timestamp func(childComplexity int) int
	}

	ImageEventEntry struct {
		Action func(childComplexity int) int
		After  func(childComplexity int) int
		Before func(childComplexity int) int
		Name   func(childComplexity int) int
		Type   func(childComplexity int) int
	}

	ImageEventsPayload struct {
		Count           func(childComplexity int) int
		EventLogEntries func(childComplexity int) int
	}

	ImageOperatingSystemPayload struct {
		Data          func(childComplexity int) int
		FilteredCount func(childComplexity int) int
		TotalCount    func(childComplexity int) int
	}

	ImagePackagesPayload struct {
		Data          func(childComplexity int) int
		FilteredCount func(childComplexity int) int
		TotalCount    func(childComplexity int) int
	}

	ImageToolchainsPayload struct {
		Data          func(childComplexity int) int
		FilteredCount func(childComplexity int) int
		TotalCount    func(childComplexity int) int
	}

	InstanceTag struct {
		CanBeModified func(childComplexity int) int
		Key           func(childComplexity int) int
		Value         func(childComplexity int) int
	}

	IssueLink struct {
		ConfidenceScore func(childComplexity int) int
		IssueKey        func(childComplexity int) int
		JiraTicket      func(childComplexity int) int
		Source          func(childComplexity int) int
		URL             func(childComplexity int) int
	}

	JiraConfig struct {
		Email               func(childComplexity int) int
		Host                func(childComplexity int) int
		PersonalAccessToken func(childComplexity int) int
	}

	JiraIssueSubscriber struct {
		IssueType func(childComplexity int) int
		Project   func(childComplexity int) int
	}

	JiraStatus struct {
		Id   func(childComplexity int) int
		Name func(childComplexity int) int
	}

	JiraTicket struct {
		Fields func(childComplexity int) int
		Key    func(childComplexity int) int
	}

	KanopyAuthConfig struct {
		HeaderName func(childComplexity int) int
		Issuer     func(childComplexity int) int
		KeysetURL  func(childComplexity int) int
	}

	LogBuffering struct {
		Count                func(childComplexity int) int
		DurationSeconds      func(childComplexity int) int
		IncomingBufferFactor func(childComplexity int) int
		UseAsync             func(childComplexity int) int
	}

	LogMessage struct {
		Message   func(childComplexity int) int
		Severity  func(childComplexity int) int
		Timestamp func(childComplexity int) int
		Type      func(childComplexity int) int
		Version   func(childComplexity int) int
	}

	LoggerConfig struct {
		Buffer         func(childComplexity int) int
		DefaultLevel   func(childComplexity int) int
		LogkeeperURL   func(childComplexity int) int
		RedactKeys     func(childComplexity int) int
		ThresholdLevel func(childComplexity int) int
	}

	LogkeeperBuild struct {
		BuildNum      func(childComplexity int) int
		Builder       func(childComplexity int) int
		ID            func(childComplexity int) int
		Task          func(childComplexity int) int
		TaskExecution func(childComplexity int) int
		TaskID        func(childComplexity int) int
		Tests         func(childComplexity int) int
	}

	LogkeeperTest struct {
		BuildID       func(childComplexity int) int
		Command       func(childComplexity int) int
		ID            func(childComplexity int) int
		Name          func(childComplexity int) int
		Phase         func(childComplexity int) int
		TaskExecution func(childComplexity int) int
		TaskID        func(childComplexity int) int
	}

	MainlineCommitVersion struct {
		RolledUpVersions func(childComplexity int) int
		Version          func(childComplexity int) int
	}

	MainlineCommits struct {
		NextPageOrderNumber func(childComplexity int) int
		PrevPageOrderNumber func(childComplexity int) int
		Versions            func(childComplexity int) int
	}

	Manifest struct {
		Branch          func(childComplexity int) int
		ID              func(childComplexity int) int
		IsBase          func(childComplexity int) int
		ModuleOverrides func(childComplexity int) int
		Modules         func(childComplexity int) int
		Project         func(childComplexity int) int
		Revision        func(childComplexity int) int
	}

	MetadataLink struct {
		Source func(childComplexity int) int
		Text   func(childComplexity int) int
		URL    func(childComplexity int) int
	}

	ModuleCodeChange struct {
		BranchName func(childComplexity int) int
		FileDiffs  func(childComplexity int) int
		HTMLLink   func(childComplexity int) int
		RawLink    func(childComplexity int) int
	}

	MultiAuthConfig struct {
		ReadOnly  func(childComplexity int) int
		ReadWrite func(childComplexity int) int
	}

	Mutation struct {
		AbortTask                     func(childComplexity int, taskID string) int
		AddAnnotationIssue            func(childComplexity int, taskID string, execution int, apiIssue model.APIIssueLink, isIssue bool) int
		AddFavoriteProject            func(childComplexity int, opts AddFavoriteProjectInput) int
		AttachProjectToNewRepo        func(childComplexity int, project MoveProjectInput) int
		AttachProjectToRepo           func(childComplexity int, projectID string) int
		AttachVolumeToHost            func(childComplexity int, volumeAndHost VolumeHost) int
		BbCreateTicket                func(childComplexity int, taskID string, execution *int) int
		ClearMySubscriptions          func(childComplexity int) int
		CopyDistro                    func(childComplexity int, opts model.CopyDistroOpts) int
		CopyProject                   func(childComplexity int, project model.CopyProjectOpts, requestS3Creds *bool) int
		CreateDistro                  func(childComplexity int, opts CreateDistroInput) int
		CreateProject                 func(childComplexity int, project model.APIProjectRef, requestS3Creds *bool) int
		CreatePublicKey               func(childComplexity int, publicKeyInput PublicKeyInput) int
		DeactivateStepbackTask        func(childComplexity int, opts DeactivateStepbackTaskInput) int
		DefaultSectionToRepo          func(childComplexity int, opts DefaultSectionToRepoInput) int
		DeleteDistro                  func(childComplexity int, opts DeleteDistroInput) int
		DeleteGithubAppCredentials    func(childComplexity int, opts DeleteGithubAppCredentialsInput) int
		DeleteProject                 func(childComplexity int, projectID string) int
		DeleteSubscriptions           func(childComplexity int, subscriptionIds []string) int
		DetachProjectFromRepo         func(childComplexity int, projectID string) int
		DetachVolumeFromHost          func(childComplexity int, volumeID string) int
		EditAnnotationNote            func(childComplexity int, taskID string, execution int, originalMessage string, newMessage string) int
		EditSpawnHost                 func(childComplexity int, spawnHost *EditSpawnHostInput) int
		ForceRepotrackerRun           func(childComplexity int, projectID string) int
		MigrateVolume                 func(childComplexity int, volumeID string, spawnHostInput *SpawnHostInput) int
		MoveAnnotationIssue           func(childComplexity int, taskID string, execution int, apiIssue model.APIIssueLink, isIssue bool) int
		OverrideTaskDependencies      func(childComplexity int, taskID string) int
		PromoteVarsToRepo             func(childComplexity int, opts PromoteVarsToRepoInput) int
		RemoveAnnotationIssue         func(childComplexity int, taskID string, execution int, apiIssue model.APIIssueLink, isIssue bool) int
		RemoveFavoriteProject         func(childComplexity int, opts RemoveFavoriteProjectInput) int
		RemovePublicKey               func(childComplexity int, keyName string) int
		RemoveVolume                  func(childComplexity int, volumeID string) int
		ReprovisionToNew              func(childComplexity int, hostIds []string) int
		RestartAdminTasks             func(childComplexity int, opts model1.RestartOptions) int
		RestartJasper                 func(childComplexity int, hostIds []string) int
		RestartTask                   func(childComplexity int, taskID string, failedOnly bool) int
		RestartVersions               func(childComplexity int, versionID string, abort bool, versionsToRestart []*model1.VersionToRestart) int
		SaveAdminSettings             func(childComplexity int, adminSettings model.APIAdminSettings) int
		SaveDistro                    func(childComplexity int, opts SaveDistroInput) int
		SaveProjectSettingsForSection func(childComplexity int, projectSettings *model.APIProjectSettings, section ProjectSettingsSection) int
		SaveRepoSettingsForSection    func(childComplexity int, repoSettings *model.APIProjectSettings, section ProjectSettingsSection) int
		SaveSubscription              func(childComplexity int, subscription model.APISubscription) int
		SchedulePatch                 func(childComplexity int, patchID string, configure PatchConfigure) int
		ScheduleTasks                 func(childComplexity int, versionID string, taskIds []string) int
		ScheduleUndispatchedBaseTasks func(childComplexity int, versionID string) int
		SetAnnotationMetadataLinks    func(childComplexity int, taskID string, execution int, metadataLinks []*model.APIMetadataLink) int
		SetLastRevision               func(childComplexity int, opts SetLastRevisionInput) int
		SetPatchVisibility            func(childComplexity int, patchIds []string, hidden bool) int
		SetTaskPriorities             func(childComplexity int, taskPriorities []*TaskPriority) int
		SetTaskPriority               func(childComplexity int, taskID string, priority int) int
		SetVersionPriority            func(childComplexity int, versionID string, priority int) int
		SpawnHost                     func(childComplexity int, spawnHostInput *SpawnHostInput) int
		SpawnVolume                   func(childComplexity int, spawnVolumeInput SpawnVolumeInput) int
		UnscheduleTask                func(childComplexity int, taskID string) int
		UnscheduleVersionTasks        func(childComplexity int, versionID string, abort bool) int
		UpdateBetaFeatures            func(childComplexity int, opts UpdateBetaFeaturesInput) int
		UpdateHostStatus              func(childComplexity int, hostIds []string, status string, notes *string) int
		UpdateParsleySettings         func(childComplexity int, opts UpdateParsleySettingsInput) int
		UpdatePublicKey               func(childComplexity int, targetKeyName string, updateInfo PublicKeyInput) int
		UpdateSpawnHostStatus         func(childComplexity int, updateSpawnHostStatusInput UpdateSpawnHostStatusInput) int
		UpdateUserSettings            func(childComplexity int, userSettings *model.APIUserSettings) int
		UpdateVolume                  func(childComplexity int, updateVolumeInput UpdateVolumeInput) int
	}

	NaiveAuthConfig struct {
		Users func(childComplexity int) int
	}

	NewDistroPayload struct {
		NewDistroID func(childComplexity int) int
	}

	Note struct {
		Message func(childComplexity int) int
		Source  func(childComplexity int) int
	}

	Notifications struct {
		BuildBreak            func(childComplexity int) int
		BuildBreakID          func(childComplexity int) int
		PatchFinish           func(childComplexity int) int
		PatchFinishID         func(childComplexity int) int
		PatchFirstFailure     func(childComplexity int) int
		PatchFirstFailureID   func(childComplexity int) int
		SpawnHostExpiration   func(childComplexity int) int
		SpawnHostExpirationID func(childComplexity int) int
		SpawnHostOutcome      func(childComplexity int) int
		SpawnHostOutcomeID    func(childComplexity int) int
	}

	NotifyConfig struct {
		BufferIntervalSeconds   func(childComplexity int) int
		BufferTargetPerInterval func(childComplexity int) int
		SES                     func(childComplexity int) int
	}

	OSInfo struct {
		Name    func(childComplexity int) int
		Version func(childComplexity int) int
	}

	OktaConfig struct {
		ClientID           func(childComplexity int) int
		ClientSecret       func(childComplexity int) int
		ExpireAfterMinutes func(childComplexity int) int
		Issuer             func(childComplexity int) int
		Scopes             func(childComplexity int) int
		UserGroup          func(childComplexity int) int
	}

	OomTrackerInfo struct {
		Detected func(childComplexity int) int
		Pids     func(childComplexity int) int
	}

	Package struct {
		Manager func(childComplexity int) int
		Name    func(childComplexity int) int
		Version func(childComplexity int) int
	}

	Parameter struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	ParsleyFilter struct {
		CaseSensitive func(childComplexity int) int
		Description   func(childComplexity int) int
		ExactMatch    func(childComplexity int) int
		Expression    func(childComplexity int) int
	}

	ParsleySettings struct {
		JumpToFailingLineEnabled func(childComplexity int) int
		SectionsEnabled          func(childComplexity int) int
	}

	Patch struct {
		Activated           func(childComplexity int) int
		Alias               func(childComplexity int) int
		Author              func(childComplexity int) int
		AuthorDisplayName   func(childComplexity int) int
		BaseTaskStatuses    func(childComplexity int) int
		Builds              func(childComplexity int) int
		ChildPatchAliases   func(childComplexity int) int
		ChildPatches        func(childComplexity int) int
		CreateTime          func(childComplexity int) int
		Description         func(childComplexity int) int
		Duration            func(childComplexity int) int
		GeneratedTaskCounts func(childComplexity int) int
		Githash             func(childComplexity int) int
		GithubPatchData     func(childComplexity int) int
		Hidden              func(childComplexity int) int
		Id                  func(childComplexity int) int
		ModuleCodeChanges   func(childComplexity int) int
		Parameters          func(childComplexity int) int
		PatchNumber         func(childComplexity int) int
		PatchTriggerAliases func(childComplexity int) int
		Project             func(childComplexity int) int
		ProjectId           func(childComplexity int) int
		ProjectIdentifier   func(childComplexity int) int
		ProjectMetadata     func(childComplexity int) int
		Status              func(childComplexity int) int
		TaskCount           func(childComplexity int) int
		TaskStatuses        func(childComplexity int) int
		Tasks               func(childComplexity int) int
		Time                func(childComplexity int) int
		Variants            func(childComplexity int) int
		VariantsTasks       func(childComplexity int) int
		VersionFull         func(childComplexity int) int
	}

	PatchDuration struct {
		Makespan  func(childComplexity int) int
		Time      func(childComplexity int) int
		TimeTaken func(childComplexity int) int
	}

	PatchProject struct {
		Variants func(childComplexity int) int
	}

	PatchTime struct {
		Finished    func(childComplexity int) int
		Started     func(childComplexity int) int
		SubmittedAt func(childComplexity int) int
	}

	PatchTriggerAlias struct {
		Alias                  func(childComplexity int) int
		ChildProjectId         func(childComplexity int) int
		ChildProjectIdentifier func(childComplexity int) int
		DownstreamRevision     func(childComplexity int) int
		ParentAsModule         func(childComplexity int) int
		Status                 func(childComplexity int) int
		TaskSpecifiers         func(childComplexity int) int
		VariantsTasks          func(childComplexity int) int
	}

	Patches struct {
		FilteredPatchCount func(childComplexity int) int
		Patches            func(childComplexity int) int
	}

	PeriodicBuild struct {
		Alias         func(childComplexity int) int
		ConfigFile    func(childComplexity int) int
		Cron          func(childComplexity int) int
		ID            func(childComplexity int) int
		IntervalHours func(childComplexity int) int
		Message       func(childComplexity int) int
		NextRunTime   func(childComplexity int) int
	}

	Permissions struct {
		CanCreateDistro      func(childComplexity int) int
		CanCreateProject     func(childComplexity int) int
		CanEditAdminSettings func(childComplexity int) int
		DistroPermissions    func(childComplexity int, options DistroPermissionsOptions) int
		ProjectPermissions   func(childComplexity int, options ProjectPermissionsOptions) int
		RepoPermissions      func(childComplexity int, options RepoPermissionsOptions) int
		UserID               func(childComplexity int) int
	}

	PlannerSettings struct {
		CommitQueueFactor         func(childComplexity int) int
		ExpectedRuntimeFactor     func(childComplexity int) int
		GenerateTaskFactor        func(childComplexity int) int
		GroupVersions             func(childComplexity int) int
		MainlineTimeInQueueFactor func(childComplexity int) int
		NumDependentsFactor       func(childComplexity int) int
		PatchFactor               func(childComplexity int) int
		PatchTimeInQueueFactor    func(childComplexity int) int
		TargetTime                func(childComplexity int) int
		Version                   func(childComplexity int) int
	}

	Pod struct {
		Events                    func(childComplexity int, limit *int, page *int) int
		ID                        func(childComplexity int) int
		Status                    func(childComplexity int) int
		Task                      func(childComplexity int) int
		TaskContainerCreationOpts func(childComplexity int) int
		Type                      func(childComplexity int) int
	}

	PodEventLogData struct {
		NewStatus     func(childComplexity int) int
		OldStatus     func(childComplexity int) int
		Reason        func(childComplexity int) int
		Task          func(childComplexity int) int
		TaskExecution func(childComplexity int) int
		TaskID        func(childComplexity int) int
		TaskStatus    func(childComplexity int) int
	}

	PodEventLogEntry struct {
		Data         func(childComplexity int) int
		EventType    func(childComplexity int) int
		ID           func(childComplexity int) int
		ProcessedAt  func(childComplexity int) int
		ResourceId   func(childComplexity int) int
		ResourceType func(childComplexity int) int
		Timestamp    func(childComplexity int) int
	}

	PodEvents struct {
		Count           func(childComplexity int) int
		EventLogEntries func(childComplexity int) int
	}

	PodLifecycleConfig struct {
		MaxParallelPodRequests      func(childComplexity int) int
		MaxPodDefinitionCleanupRate func(childComplexity int) int
		MaxSecretCleanupRate        func(childComplexity int) int
	}

	PreconditionScript struct {
		Path   func(childComplexity int) int
		Script func(childComplexity int) int
	}

	Project struct {
		Admins                             func(childComplexity int) int
		Banner                             func(childComplexity int) int
		BatchTime                          func(childComplexity int) int
		Branch                             func(childComplexity int) int
		BuildBaronSettings                 func(childComplexity int) int
		CommitQueue                        func(childComplexity int) int
		ContainerSizeDefinitions           func(childComplexity int) int
		DeactivatePrevious                 func(childComplexity int) int
		DisabledStatsCache                 func(childComplexity int) int
		DispatchingDisabled                func(childComplexity int) int
		DisplayName                        func(childComplexity int) int
		Enabled                            func(childComplexity int) int
		ExternalLinks                      func(childComplexity int) int
		GitHubDynamicTokenPermissionGroups func(childComplexity int) int
		GitHubPermissionGroupByRequester   func(childComplexity int) int
		GitTagAuthorizedTeams              func(childComplexity int) int
		GitTagAuthorizedUsers              func(childComplexity int) int
		GitTagVersionsEnabled              func(childComplexity int) int
		GithubChecksEnabled                func(childComplexity int) int
		GithubMQTriggerAliases             func(childComplexity int) int
		GithubPRTriggerAliases             func(childComplexity int) int
		GithubTriggerAliases               func(childComplexity int) int
		Hidden                             func(childComplexity int) int
		Id                                 func(childComplexity int) int
		Identifier                         func(childComplexity int) int
		IsFavorite                         func(childComplexity int) int
		ManualPRTestingEnabled             func(childComplexity int) int
		NotifyOnBuildFailure               func(childComplexity int) int
		OldestAllowedMergeBase             func(childComplexity int) int
		Owner                              func(childComplexity int) int
		PRTestingEnabled                   func(childComplexity int) int
		ParsleyFilters                     func(childComplexity int) int
		PatchTriggerAliases                func(childComplexity int) int
		Patches                            func(childComplexity int, patchesInput PatchesInput) int
		PatchingDisabled                   func(childComplexity int) int
		PerfEnabled                        func(childComplexity int) int
		PeriodicBuilds                     func(childComplexity int) int
		ProjectHealthView                  func(childComplexity int) int
		RemotePath                         func(childComplexity int) int
		Repo                               func(childComplexity int) int
		RepoRefId                          func(childComplexity int) int
		RepotrackerDisabled                func(childComplexity int) int
		RepotrackerError                   func(childComplexity int) int
		Restricted                         func(childComplexity int) int
		SpawnHostScriptPath                func(childComplexity int) int
		StepbackBisect                     func(childComplexity int) int
		StepbackDisabled                   func(childComplexity int) int
		TaskAnnotationSettings             func(childComplexity int) int
		TracksPushEvents                   func(childComplexity int) int
		Triggers                           func(childComplexity int) int
		VersionControlEnabled              func(childComplexity int) int
		WorkstationConfig                  func(childComplexity int) int
	}

	ProjectAlias struct {
		Alias       func(childComplexity int) int
		Description func(childComplexity int) int
		GitTag      func(childComplexity int) int
		ID          func(childComplexity int) int
		Parameters  func(childComplexity int) int
		RemotePath  func(childComplexity int) int
		Task        func(childComplexity int) int
		TaskTags    func(childComplexity int) int
		Variant     func(childComplexity int) int
		VariantTags func(childComplexity int) int
	}

	ProjectBanner struct {
		Text  func(childComplexity int) int
		Theme func(childComplexity int) int
	}

	ProjectBuildVariant struct {
		DisplayName func(childComplexity int) int
		Name        func(childComplexity int) int
		Tasks       func(childComplexity int) int
	}

	ProjectEventLogEntry struct {
		After     func(childComplexity int) int
		Before    func(childComplexity int) int
		Timestamp func(childComplexity int) int
		User      func(childComplexity int) int
	}

	ProjectEventSettings struct {
		Aliases               func(childComplexity int) int
		GithubAppAuth         func(childComplexity int) int
		GithubWebhooksEnabled func(childComplexity int) int
		ProjectRef            func(childComplexity int) int
		Subscriptions         func(childComplexity int) int
		Vars                  func(childComplexity int) int
	}

	ProjectEvents struct {
		Count           func(childComplexity int) int
		EventLogEntries func(childComplexity int) int
	}

	ProjectPermissions struct {
		Edit func(childComplexity int) int
		View func(childComplexity int) int
	}

	ProjectSettings struct {
		Aliases               func(childComplexity int) int
		GithubAppAuth         func(childComplexity int) int
		GithubWebhooksEnabled func(childComplexity int) int
		ProjectRef            func(childComplexity int) int
		Subscriptions         func(childComplexity int) int
		Vars                  func(childComplexity int) int
	}

	ProjectTasksPair struct {
		AllowedBVs   func(childComplexity int) int
		AllowedTasks func(childComplexity int) int
		ProjectID    func(childComplexity int) int
	}

	ProjectVars struct {
		AdminOnlyVars func(childComplexity int) int
		PrivateVars   func(childComplexity int) int
		Vars          func(childComplexity int) int
	}

	PublicKey struct {
		Key  func(childComplexity int) int
		Name func(childComplexity int) int
	}

	Query struct {
		AWSRegions               func(childComplexity int) int
		AdminEvents              func(childComplexity int, opts AdminEventsInput) int
		AdminSettings            func(childComplexity int) int
		AdminTasksToRestart      func(childComplexity int, opts model1.RestartOptions) int
		BbGetCreatedTickets      func(childComplexity int, taskID string) int
		BuildBaron               func(childComplexity int, taskID string, execution int) int
		BuildVariantsForTaskName func(childComplexity int, projectIdentifier string, taskName string) int
		ClientConfig             func(childComplexity int) int
		Distro                   func(childComplexity int, distroID string) int
		DistroEvents             func(childComplexity int, opts DistroEventsInput) int
		DistroTaskQueue          func(childComplexity int, distroID string) int
		Distros                  func(childComplexity int, onlySpawnable bool) int
		GithubProjectConflicts   func(childComplexity int, projectID string) int
		HasVersion               func(childComplexity int, patchID string) int
		Host                     func(childComplexity int, hostID string) int
		HostEvents               func(childComplexity int, hostID string, hostTag *string, limit *int, page *int) int
		Hosts                    func(childComplexity int, hostID *string, distroID *string, currentTaskID *string, statuses []string, startedBy *string, sortBy *HostSortBy, sortDir *SortDirection, page *int, limit *int) int
		Image                    func(childComplexity int, imageID string) int
		Images                   func(childComplexity int) int
		InstanceTypes            func(childComplexity int) int
		IsRepo                   func(childComplexity int, projectOrRepoID string) int
		LogkeeperBuildMetadata   func(childComplexity int, buildID string) int
		MainlineCommits          func(childComplexity int, options MainlineCommitsOptions, buildVariantOptions *BuildVariantOptions) int
		MyHosts                  func(childComplexity int) int
		MyPublicKeys             func(childComplexity int) int
		MyVolumes                func(childComplexity int) int
		Patch                    func(childComplexity int, patchID string) int
		Pod                      func(childComplexity int, podID string) int
		Project                  func(childComplexity int, projectIdentifier string) int
		ProjectEvents            func(childComplexity int, projectIdentifier string, limit *int, before *time.Time) int
		ProjectSettings          func(childComplexity int, projectIdentifier string) int
		Projects                 func(childComplexity int) int
		RepoEvents               func(childComplexity int, repoID string, limit *int, before *time.Time) int
		RepoSettings             func(childComplexity int, repoID string) int
		SpruceConfig             func(childComplexity int) int
		SubnetAvailabilityZones  func(childComplexity int) int
		Task                     func(childComplexity int, taskID string, execution *int) int
		TaskAllExecutions        func(childComplexity int, taskID string) int
		TaskHistory              func(childComplexity int, options TaskHistoryOpts) int
		TaskNamesForBuildVariant func(childComplexity int, projectIdentifier string, buildVariant string) int
		TaskQueueDistros         func(childComplexity int) int
		TaskTestSample           func(childComplexity int, versionID string, taskIds []string, filters []*TestFilter) int
		User                     func(childComplexity int, userID *string) int
		UserConfig               func(childComplexity int) int
		Version                  func(childComplexity int, versionID string) int
		ViewableProjectRefs      func(childComplexity int) int
		Waterfall                func(childComplexity int, options WaterfallOptions) int
	}

	RepoCommitQueueParams struct {
		Enabled     func(childComplexity int) int
		MergeMethod func(childComplexity int) int
		Message     func(childComplexity int) int
	}

	RepoPermissions struct {
		Edit func(childComplexity int) int
		View func(childComplexity int) int
	}

	RepoRef struct {
		Admins                             func(childComplexity int) int
		BatchTime                          func(childComplexity int) int
		BuildBaronSettings                 func(childComplexity int) int
		CommitQueue                        func(childComplexity int) int
		ContainerSizeDefinitions           func(childComplexity int) int
		DeactivatePrevious                 func(childComplexity int) int
		DisabledStatsCache                 func(childComplexity int) int
		DispatchingDisabled                func(childComplexity int) int
		DisplayName                        func(childComplexity int) int
		Enabled                            func(childComplexity int) int
		ExternalLinks                      func(childComplexity int) int
		GitHubDynamicTokenPermissionGroups func(childComplexity int) int
		GitHubPermissionGroupByRequester   func(childComplexity int) int
		GitTagAuthorizedTeams              func(childComplexity int) int
		GitTagAuthorizedUsers              func(childComplexity int) int
		GitTagVersionsEnabled              func(childComplexity int) int
		GithubChecksEnabled                func(childComplexity int) int
		GithubMQTriggerAliases             func(childComplexity int) int
		GithubPRTriggerAliases             func(childComplexity int) int
		GithubTriggerAliases               func(childComplexity int) int
		Id                                 func(childComplexity int) int
		ManualPRTestingEnabled             func(childComplexity int) int
		NotifyOnBuildFailure               func(childComplexity int) int
		OldestAllowedMergeBase             func(childComplexity int) int
		Owner                              func(childComplexity int) int
		PRTestingEnabled                   func(childComplexity int) int
		ParsleyFilters                     func(childComplexity int) int
		PatchTriggerAliases                func(childComplexity int) int
		PatchingDisabled                   func(childComplexity int) int
		PerfEnabled                        func(childComplexity int) int
		PeriodicBuilds                     func(childComplexity int) int
		RemotePath                         func(childComplexity int) int
		Repo                               func(childComplexity int) int
		RepotrackerDisabled                func(childComplexity int) int
		Restricted                         func(childComplexity int) int
		SpawnHostScriptPath                func(childComplexity int) int
		StepbackBisect                     func(childComplexity int) int
		StepbackDisabled                   func(childComplexity int) int
		TaskAnnotationSettings             func(childComplexity int) int
		TracksPushEvents                   func(childComplexity int) int
		Triggers                           func(childComplexity int) int
		VersionControlEnabled              func(childComplexity int) int
		WorkstationConfig                  func(childComplexity int) int
	}

	RepoSettings struct {
		Aliases               func(childComplexity int) int
		GithubAppAuth         func(childComplexity int) int
		GithubWebhooksEnabled func(childComplexity int) int
		ProjectRef            func(childComplexity int) int
		Subscriptions         func(childComplexity int) int
		Vars                  func(childComplexity int) int
	}

	RepoWorkstationConfig struct {
		GitClone      func(childComplexity int) int
		SetupCommands func(childComplexity int) int
	}

	RepotrackerConfig struct {
		MaxConcurrentRequests      func(childComplexity int) int
		MaxRepoRevisionsToSearch   func(childComplexity int) int
		NumNewRepoRevisionsToFetch func(childComplexity int) int
	}

	RepotrackerError struct {
		Exists            func(childComplexity int) int
		InvalidRevision   func(childComplexity int) int
		MergeBaseRevision func(childComplexity int) int
	}

	ResourceLimits struct {
		LockedMemoryKB  func(childComplexity int) int
		NumFiles        func(childComplexity int) int
		NumProcesses    func(childComplexity int) int
		NumTasks        func(childComplexity int) int
		VirtualMemoryKB func(childComplexity int) int
	}

	RestartAdminTasksPayload struct {
		NumRestartedTasks func(childComplexity int) int
	}

	RuntimeEnvironmentConfig struct {
		APIKey  func(childComplexity int) int
		BaseURL func(childComplexity int) int
	}

	SESConfig struct {
		SenderAddress func(childComplexity int) int
	}

	SaveDistroPayload struct {
		Distro    func(childComplexity int) int
		HostCount func(childComplexity int) int
	}

	SchedulerConfig struct {
		AcceptableHostIdleTimeSeconds func(childComplexity int) int
		CacheDurationSeconds          func(childComplexity int) int
		CommitQueueFactor             func(childComplexity int) int
		ExpectedRuntimeFactor         func(childComplexity int) int
		FutureHostFraction            func(childComplexity int) int
		GenerateTaskFactor            func(childComplexity int) int
		GroupVersions                 func(childComplexity int) int
		HostAllocator                 func(childComplexity int) int
		HostAllocatorFeedbackRule     func(childComplexity int) int
		HostAllocatorRoundingRule     func(childComplexity int) int
		HostsOverallocatedRule        func(childComplexity int) int
		MainlineTimeInQueueFactor     func(childComplexity int) int
		NumDependentsFactor           func(childComplexity int) int
		PatchFactor                   func(childComplexity int) int
		PatchTimeInQueueFactor        func(childComplexity int) int
		StepbackTaskFactor            func(childComplexity int) int
		TargetTimeSeconds             func(childComplexity int) int
		TaskFinder                    func(childComplexity int) int
	}

	SearchReturnInfo struct {
		FeaturesURL func(childComplexity int) int
		Issues      func(childComplexity int) int
		Search      func(childComplexity int) int
		Source      func(childComplexity int) int
	}

	Selector struct {
		Data func(childComplexity int) int
		Type func(childComplexity int) int
	}

	ServiceFlags struct {
		AdminParameterStoreDisabled     func(childComplexity int) int
		AgentStartDisabled              func(childComplexity int) int
		AlertsDisabled                  func(childComplexity int) int
		BackgroundReauthDisabled        func(childComplexity int) int
		BackgroundStatsDisabled         func(childComplexity int) int
		CLIUpdatesDisabled              func(childComplexity int) int
		CacheStatsEndpointDisabled      func(childComplexity int) int
		CacheStatsJobDisabled           func(childComplexity int) int
		CheckBlockedTasksDisabled       func(childComplexity int) int
		CloudCleanupDisabled            func(childComplexity int) int
		DegradedModeDisabled            func(childComplexity int) int
		ElasticIPsDisabled              func(childComplexity int) int
		EmailNotificationsDisabled      func(childComplexity int) int
		EventProcessingDisabled         func(childComplexity int) int
		GithubPRTestingDisabled         func(childComplexity int) int
		GithubStatusAPIDisabled         func(childComplexity int) int
		HostAllocatorDisabled           func(childComplexity int) int
		HostInitDisabled                func(childComplexity int) int
		JIRANotificationsDisabled       func(childComplexity int) int
		JWTTokenForCLIDisabled          func(childComplexity int) int
		LargeParserProjectsDisabled     func(childComplexity int) int
		MonitorDisabled                 func(childComplexity int) int
		PodAllocatorDisabled            func(childComplexity int) int
		PodInitDisabled                 func(childComplexity int) int
		ReleaseModeDisabled             func(childComplexity int) int
		RepotrackerDisabled             func(childComplexity int) int
		SchedulerDisabled               func(childComplexity int) int
		SlackNotificationsDisabled      func(childComplexity int) int
		SleepScheduleDisabled           func(childComplexity int) int
		StaticAPIKeysDisabled           func(childComplexity int) int
		SystemFailedTaskRestartDisabled func(childComplexity int) int
		TaskDispatchDisabled            func(childComplexity int) int
		TaskLoggingDisabled             func(childComplexity int) int
		TaskReliabilityDisabled         func(childComplexity int) int
		UnrecognizedPodCleanupDisabled  func(childComplexity int) int
		WebhookNotificationsDisabled    func(childComplexity int) int
	}

	SetLastRevisionPayload struct {
		MergeBaseRevision func(childComplexity int) int
	}

	SingleTaskDistroConfig struct {
		ProjectTasksPairs func(childComplexity int) int
	}

	SlackConfig struct {
		Level   func(childComplexity int) int
		Name    func(childComplexity int) int
		Options func(childComplexity int) int
		Token   func(childComplexity int) int
	}

	SlackOptions struct {
		AllFields     func(childComplexity int) int
		BasicMetadata func(childComplexity int) int
		Channel       func(childComplexity int) int
		Fields        func(childComplexity int) int
		FieldsSet     func(childComplexity int) int
		Hostname      func(childComplexity int) int
		Name          func(childComplexity int) int
		Username      func(childComplexity int) int
	}

	SleepSchedule struct {
		DailyStartTime         func(childComplexity int) int
		DailyStopTime          func(childComplexity int) int
		NextStartTime          func(childComplexity int) int
		NextStopTime           func(childComplexity int) int
		PermanentlyExempt      func(childComplexity int) int
		ShouldKeepOff          func(childComplexity int) int
		TemporarilyExemptUntil func(childComplexity int) int
		TimeZone               func(childComplexity int) int
		WholeWeekdaysOff       func(childComplexity int) int
	}

	Source struct {
		Author    func(childComplexity int) int
		Requester func(childComplexity int) int
		Time      func(childComplexity int) int
	}

	SpawnHostConfig struct {
		SpawnHostsPerUser         func(childComplexity int) int
		UnexpirableHostsPerUser   func(childComplexity int) int
		UnexpirableVolumesPerUser func(childComplexity int) int
	}

	SplunkConfig struct {
		SplunkConnectionInfo func(childComplexity int) int
	}

	SplunkConnectionInfo struct {
		Channel   func(childComplexity int) int
		ServerURL func(childComplexity int) int
		Token     func(childComplexity int) int
	}

	SpruceConfig struct {
		Banner           func(childComplexity int) int
		BannerTheme      func(childComplexity int) int
		ContainerPools   func(childComplexity int) int
		GithubOrgs       func(childComplexity int) int
		Jira             func(childComplexity int) int
		Providers        func(childComplexity int) int
		SecretFields     func(childComplexity int) int
		SingleTaskDistro func(childComplexity int) int
		Slack            func(childComplexity int) int
		Spawnhost        func(childComplexity int) int
		Ui               func(childComplexity int) int
	}

	StatusCount struct {
		Count  func(childComplexity int) int
		Status func(childComplexity int) int
	}

	StepbackInfo struct {
		LastFailingStepbackTaskId func(childComplexity int) int
		LastPassingStepbackTaskId func(childComplexity int) int
		NextStepbackTaskId        func(childComplexity int) int
		PreviousStepbackTaskId    func(childComplexity int) int
	}

	Subscriber struct {
		EmailSubscriber       func(childComplexity int) int
		GithubCheckSubscriber func(childComplexity int) int
		GithubPRSubscriber    func(childComplexity int) int
		JiraCommentSubscriber func(childComplexity int) int
		JiraIssueSubscriber   func(childComplexity int) int
		SlackSubscriber       func(childComplexity int) int
		WebhookSubscriber     func(childComplexity int) int
	}

	SubscriberWrapper struct {
		Subscriber func(childComplexity int) int
		Type       func(childComplexity int) int
	}

	Task struct {
		AbortInfo               func(childComplexity int) int
		Aborted                 func(childComplexity int) int
		Activated               func(childComplexity int) int
		ActivatedBy             func(childComplexity int) int
		ActivatedTime           func(childComplexity int) int
		Ami                     func(childComplexity int) int
		Annotation              func(childComplexity int) int
		BaseStatus              func(childComplexity int) int
		BaseTask                func(childComplexity int) int
		Blocked                 func(childComplexity int) int
		BuildId                 func(childComplexity int) int
		BuildVariant            func(childComplexity int) int
		BuildVariantDisplayName func(childComplexity int) int
		CanAbort                func(childComplexity int) int
		CanDisable              func(childComplexity int) int
		CanModifyAnnotation     func(childComplexity int) int
		CanOverrideDependencies func(childComplexity int) int
		CanRestart              func(childComplexity int) int
		CanSchedule             func(childComplexity int) int
		CanSetPriority          func(childComplexity int) int
		CanUnschedule           func(childComplexity int) int
		ContainerAllocatedTime  func(childComplexity int) int
		CreateTime              func(childComplexity int) int
		DependsOn               func(childComplexity int) int
		Details                 func(childComplexity int) int
		DispatchTime            func(childComplexity int) int
		DisplayName             func(childComplexity int) int
		DisplayOnly             func(childComplexity int) int
		DisplayStatus           func(childComplexity int) int
		DisplayTask             func(childComplexity int) int
		DistroId                func(childComplexity int) int
		EstimatedStart          func(childComplexity int) int
		Execution               func(childComplexity int) int
		ExecutionTasks          func(childComplexity int) int
		ExecutionTasksFull      func(childComplexity int) int
		ExpectedDuration        func(childComplexity int) int
		FailedTestCount         func(childComplexity int) int
		Files                   func(childComplexity int) int
		FinishTime              func(childComplexity int) int
		GenerateTask            func(childComplexity int) int
		GeneratedBy             func(childComplexity int) int
		GeneratedByName         func(childComplexity int) int
		HasTestResults          func(childComplexity int) int
		HostId                  func(childComplexity int) int
		Id                      func(childComplexity int) int
		ImageID                 func(childComplexity int) int
		IngestTime              func(childComplexity int) int
		IsPerfPluginEnabled     func(childComplexity int) int
		LatestExecution         func(childComplexity int) int
		Logs                    func(childComplexity int) int
		MinQueuePosition        func(childComplexity int) int
		Order                   func(childComplexity int) int
		Patch                   func(childComplexity int) int
		PatchNumber             func(childComplexity int) int
		Pod                     func(childComplexity int) int
		Priority                func(childComplexity int) int
		Project                 func(childComplexity int) int
		ProjectId               func(childComplexity int) int
		ProjectIdentifier       func(childComplexity int) int
		Requester               func(childComplexity int) int
		ResetWhenFinished       func(childComplexity int) int
		Revision                func(childComplexity int) int
		ScheduledTime           func(childComplexity int) int
		SpawnHostLink           func(childComplexity int) int
		StartTime               func(childComplexity int) int
		Status                  func(childComplexity int) int
		StepbackInfo            func(childComplexity int) int
		Tags                    func(childComplexity int) int
		TaskGroup               func(childComplexity int) int
		TaskGroupMaxHosts       func(childComplexity int) int
		TaskLogs                func(childComplexity int) int
		TaskOwnerTeam           func(childComplexity int) int
		Tests                   func(childComplexity int, opts *TestFilterOptions) int
		TimeTaken               func(childComplexity int) int
		TotalTestCount          func(childComplexity int) int
		VersionMetadata         func(childComplexity int) int
	}

	TaskAnnotationSettings struct {
		FileTicketWebhook func(childComplexity int) int
	}

	TaskContainerCreationOpts struct {
		Arch       func(childComplexity int) int
		CPU        func(childComplexity int) int
		Image      func(childComplexity int) int
		MemoryMB   func(childComplexity int) int
		Os         func(childComplexity int) int
		WorkingDir func(childComplexity int) int
	}

	TaskEndDetail struct {
		Description          func(childComplexity int) int
		DiskDevices          func(childComplexity int) int
		FailingCommand       func(childComplexity int) int
		FailureMetadataTags  func(childComplexity int) int
		OOMTracker           func(childComplexity int) int
		OtherFailingCommands func(childComplexity int) int
		Status               func(childComplexity int) int
		TimedOut             func(childComplexity int) int
		TimeoutType          func(childComplexity int) int
		TraceID              func(childComplexity int) int
		Type                 func(childComplexity int) int
	}

	TaskEventLogData struct {
		BlockedOn func(childComplexity int) int
		HostId    func(childComplexity int) int
		JiraIssue func(childComplexity int) int
		JiraLink  func(childComplexity int) int
		PodId     func(childComplexity int) int
		Priority  func(childComplexity int) int
		Status    func(childComplexity int) int
		Timestamp func(childComplexity int) int
		UserId    func(childComplexity int) int
	}

	TaskEventLogEntry struct {
		Data         func(childComplexity int) int
		EventType    func(childComplexity int) int
		ID           func(childComplexity int) int
		ProcessedAt  func(childComplexity int) int
		ResourceId   func(childComplexity int) int
		ResourceType func(childComplexity int) int
		Timestamp    func(childComplexity int) int
	}

	TaskFiles struct {
		FileCount    func(childComplexity int) int
		GroupedFiles func(childComplexity int) int
	}

	TaskHistory struct {
		Pagination func(childComplexity int) int
		Tasks      func(childComplexity int) int
	}

	TaskHistoryPagination struct {
		MostRecentTaskOrder func(childComplexity int) int
		OldestTaskOrder     func(childComplexity int) int
	}

	TaskInfo struct {
		Id   func(childComplexity int) int
		Name func(childComplexity int) int
	}

	TaskLimitsConfig struct {
		MaxConcurrentLargeParserProjectTasks             func(childComplexity int) int
		MaxDailyAutomaticRestarts                        func(childComplexity int) int
		MaxDegradedModeConcurrentLargeParserProjectTasks func(childComplexity int) int
		MaxDegradedModeParserProjectSize                 func(childComplexity int) int
		MaxExecTimeoutSecs                               func(childComplexity int) int
		MaxGenerateTaskJSONSize                          func(childComplexity int) int
		MaxHourlyPatchTasks                              func(childComplexity int) int
		MaxIncludesPerVersion                            func(childComplexity int) int
		MaxParserProjectSize                             func(childComplexity int) int
		MaxPendingGeneratedTasks                         func(childComplexity int) int
		MaxTaskExecution                                 func(childComplexity int) int
		MaxTasksPerVersion                               func(childComplexity int) int
	}

	TaskLogLinks struct {
		AgentLogLink  func(childComplexity int) int
		AllLogLink    func(childComplexity int) int
		EventLogLink  func(childComplexity int) int
		SystemLogLink func(childComplexity int) int
		TaskLogLink   func(childComplexity int) int
	}

	TaskLogs struct {
		AgentLogs  func(childComplexity int) int
		AllLogs    func(childComplexity int) int
		EventLogs  func(childComplexity int) int
		Execution  func(childComplexity int) int
		SystemLogs func(childComplexity int) int
		TaskID     func(childComplexity int) int
		TaskLogs   func(childComplexity int) int
	}

	TaskOwnerTeam struct {
		AssignmentType func(childComplexity int) int
		JiraProject    func(childComplexity int) int
		Messages       func(childComplexity int) int
		TeamName       func(childComplexity int) int
	}

	TaskQueueDistro struct {
		HostCount func(childComplexity int) int
		ID        func(childComplexity int) int
		TaskCount func(childComplexity int) int
	}

	TaskQueueItem struct {
		ActivatedBy       func(childComplexity int) int
		BuildVariant      func(childComplexity int) int
		DisplayName       func(childComplexity int) int
		ExpectedDuration  func(childComplexity int) int
		Id                func(childComplexity int) int
		Priority          func(childComplexity int) int
		Project           func(childComplexity int) int
		ProjectIdentifier func(childComplexity int) int
		Requester         func(childComplexity int) int
		Revision          func(childComplexity int) int
		Version           func(childComplexity int) int
	}

	TaskSpecifier struct {
		PatchAlias   func(childComplexity int) int
		TaskRegex    func(childComplexity int) int
		VariantRegex func(childComplexity int) int
	}

	TaskStats struct {
		Counts func(childComplexity int) int
		ETA    func(childComplexity int) int
	}

	TaskTestResult struct {
		FilteredTestCount func(childComplexity int) int
		TestResults       func(childComplexity int) int
		TotalTestCount    func(childComplexity int) int
	}

	TaskTestResultSample struct {
		Execution               func(childComplexity int) int
		MatchingFailedTestNames func(childComplexity int) int
		TaskID                  func(childComplexity int) int
		TotalTestCount          func(childComplexity int) int
	}

	TestLog struct {
		LineNum       func(childComplexity int) int
		RenderingType func(childComplexity int) int
		URL           func(childComplexity int) int
		URLParsley    func(childComplexity int) int
		URLRaw        func(childComplexity int) int
		Version       func(childComplexity int) int
	}

	TestResult struct {
		BaseStatus func(childComplexity int) int
		Duration   func(childComplexity int) int
		EndTime    func(childComplexity int) int
		Execution  func(childComplexity int) int
		ExitCode   func(childComplexity int) int
		GroupID    func(childComplexity int) int
		ID         func(childComplexity int) int
		Logs       func(childComplexity int) int
		StartTime  func(childComplexity int) int
		Status     func(childComplexity int) int
		TaskID     func(childComplexity int) int
		TestFile   func(childComplexity int) int
	}

	TestSelectionConfig struct {
		URL func(childComplexity int) int
	}

	TicketFields struct {
		AssignedTeam        func(childComplexity int) int
		AssigneeDisplayName func(childComplexity int) int
		Created             func(childComplexity int) int
		ResolutionName      func(childComplexity int) int
		Status              func(childComplexity int) int
		Summary             func(childComplexity int) int
		Updated             func(childComplexity int) int
	}

	Toolchain struct {
		Name    func(childComplexity int) int
		Path    func(childComplexity int) int
		Version func(childComplexity int) int
	}

	TriggerAlias struct {
		Alias                        func(childComplexity int) int
		BuildVariantRegex            func(childComplexity int) int
		ConfigFile                   func(childComplexity int) int
		DateCutoff                   func(childComplexity int) int
		Level                        func(childComplexity int) int
		Project                      func(childComplexity int) int
		Status                       func(childComplexity int) int
		TaskRegex                    func(childComplexity int) int
		UnscheduleDownstreamVersions func(childComplexity int) int
	}

	TriggerConfig struct {
		GenerateTaskDistro func(childComplexity int) int
	}

	UIConfig struct {
		BetaFeatures              func(childComplexity int) int
		CORSOrigins               func(childComplexity int) int
		CacheTemplates            func(childComplexity int) int
		CsrfKey                   func(childComplexity int) int
		DefaultProject            func(childComplexity int) int
		FileStreamingContentTypes func(childComplexity int) int
		HelpUrl                   func(childComplexity int) int
		HttpListenAddr            func(childComplexity int) int
		LoginDomain               func(childComplexity int) int
		ParsleyUrl                func(childComplexity int) int
		Secret                    func(childComplexity int) int
		StagingEnvironment        func(childComplexity int) int
		UIv2Url                   func(childComplexity int) int
		Url                       func(childComplexity int) int
		UserVoice                 func(childComplexity int) int
	}

	UpdateBetaFeaturesPayload struct {
		BetaFeatures func(childComplexity int) int
	}

	UpdateParsleySettingsPayload struct {
		ParsleySettings func(childComplexity int) int
	}

	UpstreamProject struct {
		Owner       func(childComplexity int) int
		Project     func(childComplexity int) int
		Repo        func(childComplexity int) int
		ResourceID  func(childComplexity int) int
		Revision    func(childComplexity int) int
		Task        func(childComplexity int) int
		TriggerID   func(childComplexity int) int
		TriggerType func(childComplexity int) int
		Version     func(childComplexity int) int
	}

	UseSpruceOptions struct {
		SpruceV1 func(childComplexity int) int
	}

	User struct {
		BetaFeatures    func(childComplexity int) int
		DisplayName     func(childComplexity int) int
		EmailAddress    func(childComplexity int) int
		ParsleyFilters  func(childComplexity int) int
		ParsleySettings func(childComplexity int) int
		Patches         func(childComplexity int, patchesInput PatchesInput) int
		Permissions     func(childComplexity int) int
		Settings        func(childComplexity int) int
		Subscriptions   func(childComplexity int) int
		UserID          func(childComplexity int) int
	}

	UserConfig struct {
		APIKey        func(childComplexity int) int
		APIServerHost func(childComplexity int) int
		UIServerHost  func(childComplexity int) int
		User          func(childComplexity int) int
	}

	UserSettings struct {
		DateFormat       func(childComplexity int) int
		GithubUser       func(childComplexity int) int
		Notifications    func(childComplexity int) int
		Region           func(childComplexity int) int
		SlackMemberId    func(childComplexity int) int
		SlackUsername    func(childComplexity int) int
		TimeFormat       func(childComplexity int) int
		Timezone         func(childComplexity int) int
		UseSpruceOptions func(childComplexity int) int
	}

	VariantTask struct {
		Name  func(childComplexity int) int
		Tasks func(childComplexity int) int
	}

	Version struct {
		Activated                func(childComplexity int) int
		Author                   func(childComplexity int) int
		AuthorEmail              func(childComplexity int) int
		BaseTaskStatuses         func(childComplexity int) int
		BaseVersion              func(childComplexity int) int
		Branch                   func(childComplexity int) int
		BuildVariantStats        func(childComplexity int, options BuildVariantOptions) int
		BuildVariants            func(childComplexity int, options BuildVariantOptions) int
		ChildVersions            func(childComplexity int) int
		CreateTime               func(childComplexity int) int
		Errors                   func(childComplexity int) int
		ExternalLinksForMetadata func(childComplexity int) int
		FinishTime               func(childComplexity int) int
		GeneratedTaskCounts      func(childComplexity int) int
		GitTags                  func(childComplexity int) int
		Id                       func(childComplexity int) int
		Ignored                  func(childComplexity int) int
		IsPatch                  func(childComplexity int) int
		Manifest                 func(childComplexity int) int
		Message                  func(childComplexity int) int
		Order                    func(childComplexity int) int
		Parameters               func(childComplexity int) int
		Patch                    func(childComplexity int) int
		PreviousVersion          func(childComplexity int) int
		Project                  func(childComplexity int) int
		ProjectIdentifier        func(childComplexity int) int
		ProjectMetadata          func(childComplexity int) int
		Repo                     func(childComplexity int) int
		Requester                func(childComplexity int) int
		Revision                 func(childComplexity int) int
		StartTime                func(childComplexity int) int
		Status                   func(childComplexity int) int
		TaskCount                func(childComplexity int, options *TaskCountOptions) int
		TaskStatusStats          func(childComplexity int, options BuildVariantOptions) int
		TaskStatuses             func(childComplexity int) int
		Tasks                    func(childComplexity int, options TaskFilterOptions) int
		UpstreamProject          func(childComplexity int) int
		VersionTiming            func(childComplexity int) int
		Warnings                 func(childComplexity int) int
		WaterfallBuilds          func(childComplexity int) int
	}

	VersionTasks struct {
		Count func(childComplexity int) int
		Data  func(childComplexity int) int
	}

	VersionTiming struct {
		Makespan  func(childComplexity int) int
		TimeTaken func(childComplexity int) int
	}

	Volume struct {
		AvailabilityZone func(childComplexity int) int
		CreatedBy        func(childComplexity int) int
		CreationTime     func(childComplexity int) int
		DeviceName       func(childComplexity int) int
		DisplayName      func(childComplexity int) int
		Expiration       func(childComplexity int) int
		HomeVolume       func(childComplexity int) int
		Host             func(childComplexity int) int
		HostID           func(childComplexity int) int
		ID               func(childComplexity int) int
		Migrating        func(childComplexity int) int
		NoExpiration     func(childComplexity int) int
		Size             func(childComplexity int) int
		Type             func(childComplexity int) int
	}

	Waterfall struct {
		FlattenedVersions func(childComplexity int) int
		Pagination        func(childComplexity int) int
	}

	WaterfallBuild struct {
		Activated    func(childComplexity int) int
		BuildVariant func(childComplexity int) int
		DisplayName  func(childComplexity int) int
		Id           func(childComplexity int) int
		Tasks        func(childComplexity int) int
		Version      func(childComplexity int) int
	}

	WaterfallBuildVariant struct {
		Builds      func(childComplexity int) int
		DisplayName func(childComplexity int) int
		Id          func(childComplexity int) int
		Version     func(childComplexity int) int
	}

	WaterfallPagination struct {
		ActiveVersionIds       func(childComplexity int) int
		HasNextPage            func(childComplexity int) int
		HasPrevPage            func(childComplexity int) int
		MostRecentVersionOrder func(childComplexity int) int
		NextPageOrder          func(childComplexity int) int
		PrevPageOrder          func(childComplexity int) int
	}

	WaterfallTask struct {
		DisplayName        func(childComplexity int) int
		DisplayStatusCache func(childComplexity int) int
		Execution          func(childComplexity int) int
		Id                 func(childComplexity int) int
		Status             func(childComplexity int) int
	}

	WaterfallVersion struct {
		InactiveVersions func(childComplexity int) int
		Version          func(childComplexity int) int
	}

	Webhook struct {
		Endpoint func(childComplexity int) int
		Secret   func(childComplexity int) int
	}

	WebhookHeader struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	WebhookSubscriber struct {
		Headers    func(childComplexity int) int
		MinDelayMS func(childComplexity int) int
		Retries    func(childComplexity int) int
		Secret     func(childComplexity int) int
		TimeoutMS  func(childComplexity int) int
		URL        func(childComplexity int) int
	}

	WorkstationConfig struct {
		GitClone      func(childComplexity int) int
		SetupCommands func(childComplexity int) int
	}

	WorkstationSetupCommand struct {
		Command   func(childComplexity int) int
		Directory func(childComplexity int) int
	}
}

type AdminSettingsResolver interface {
	BannerTheme(ctx context.Context, obj *model.APIAdminSettings) (*evergreen.BannerTheme, error)
}
type AnnotationResolver interface {
	WebhookConfigured(ctx context.Context, obj *model.APITaskAnnotation) (bool, error)
}
type ContainerPoolResolver interface {
	Port(ctx context.Context, obj *model.APIContainerPool) (int, error)
}
type DistroResolver interface {
	AvailableRegions(ctx context.Context, obj *model.APIDistro) ([]string, error)

	ProviderSettingsList(ctx context.Context, obj *model.APIDistro) ([]map[string]any, error)
}
type HostResolver interface {
	Ami(ctx context.Context, obj *model.APIHost) (*string, error)

	DistroID(ctx context.Context, obj *model.APIHost) (*string, error)
	Elapsed(ctx context.Context, obj *model.APIHost) (*time.Time, error)
	Events(ctx context.Context, obj *model.APIHost, opts HostEventsInput) (*HostEvents, error)
	EventTypes(ctx context.Context, obj *model.APIHost) ([]string, error)

	HomeVolume(ctx context.Context, obj *model.APIHost) (*model.APIVolume, error)

	SleepSchedule(ctx context.Context, obj *model.APIHost) (*host.SleepScheduleInfo, error)

	Uptime(ctx context.Context, obj *model.APIHost) (*time.Time, error)

	Volumes(ctx context.Context, obj *model.APIHost) ([]*model.APIVolume, error)
}
type ImageResolver interface {
	Distros(ctx context.Context, obj *model.APIImage) ([]*model.APIDistro, error)
	Events(ctx context.Context, obj *model.APIImage, limit int, page int) (*ImageEventsPayload, error)

	LatestTask(ctx context.Context, obj *model.APIImage) (*model.APITask, error)
	OperatingSystem(ctx context.Context, obj *model.APIImage, opts thirdparty.OSInfoFilterOptions) (*ImageOperatingSystemPayload, error)
	Packages(ctx context.Context, obj *model.APIImage, opts thirdparty.PackageFilterOptions) (*ImagePackagesPayload, error)
	Toolchains(ctx context.Context, obj *model.APIImage, opts thirdparty.ToolchainFilterOptions) (*ImageToolchainsPayload, error)
}
type IssueLinkResolver interface {
	JiraTicket(ctx context.Context, obj *model.APIIssueLink) (*thirdparty.JiraTicket, error)
}
type LogkeeperBuildResolver interface {
	Task(ctx context.Context, obj *plank.Build) (*model.APITask, error)
}
type MutationResolver interface {
	BbCreateTicket(ctx context.Context, taskID string, execution *int) (bool, error)
	AddAnnotationIssue(ctx context.Context, taskID string, execution int, apiIssue model.APIIssueLink, isIssue bool) (bool, error)
	EditAnnotationNote(ctx context.Context, taskID string, execution int, originalMessage string, newMessage string) (bool, error)
	MoveAnnotationIssue(ctx context.Context, taskID string, execution int, apiIssue model.APIIssueLink, isIssue bool) (bool, error)
	RemoveAnnotationIssue(ctx context.Context, taskID string, execution int, apiIssue model.APIIssueLink, isIssue bool) (bool, error)
	SetAnnotationMetadataLinks(ctx context.Context, taskID string, execution int, metadataLinks []*model.APIMetadataLink) (bool, error)
	SaveAdminSettings(ctx context.Context, adminSettings model.APIAdminSettings) (*model.APIAdminSettings, error)
	RestartAdminTasks(ctx context.Context, opts model1.RestartOptions) (*RestartAdminTasksPayload, error)
	DeleteDistro(ctx context.Context, opts DeleteDistroInput) (*DeleteDistroPayload, error)
	CopyDistro(ctx context.Context, opts model.CopyDistroOpts) (*NewDistroPayload, error)
	CreateDistro(ctx context.Context, opts CreateDistroInput) (*NewDistroPayload, error)
	SaveDistro(ctx context.Context, opts SaveDistroInput) (*SaveDistroPayload, error)
	ReprovisionToNew(ctx context.Context, hostIds []string) (int, error)
	RestartJasper(ctx context.Context, hostIds []string) (int, error)
	UpdateHostStatus(ctx context.Context, hostIds []string, status string, notes *string) (int, error)
	SetPatchVisibility(ctx context.Context, patchIds []string, hidden bool) ([]*model.APIPatch, error)
	SchedulePatch(ctx context.Context, patchID string, configure PatchConfigure) (*model.APIPatch, error)
	AttachProjectToNewRepo(ctx context.Context, project MoveProjectInput) (*model.APIProjectRef, error)
	AttachProjectToRepo(ctx context.Context, projectID string) (*model.APIProjectRef, error)
	CreateProject(ctx context.Context, project model.APIProjectRef, requestS3Creds *bool) (*model.APIProjectRef, error)
	CopyProject(ctx context.Context, project model.CopyProjectOpts, requestS3Creds *bool) (*model.APIProjectRef, error)
	DeactivateStepbackTask(ctx context.Context, opts DeactivateStepbackTaskInput) (bool, error)
	DefaultSectionToRepo(ctx context.Context, opts DefaultSectionToRepoInput) (*string, error)
	DeleteGithubAppCredentials(ctx context.Context, opts DeleteGithubAppCredentialsInput) (*DeleteGithubAppCredentialsPayload, error)
	DeleteProject(ctx context.Context, projectID string) (bool, error)
	DetachProjectFromRepo(ctx context.Context, projectID string) (*model.APIProjectRef, error)
	ForceRepotrackerRun(ctx context.Context, projectID string) (bool, error)
	PromoteVarsToRepo(ctx context.Context, opts PromoteVarsToRepoInput) (bool, error)
	SaveProjectSettingsForSection(ctx context.Context, projectSettings *model.APIProjectSettings, section ProjectSettingsSection) (*model.APIProjectSettings, error)
	SaveRepoSettingsForSection(ctx context.Context, repoSettings *model.APIProjectSettings, section ProjectSettingsSection) (*model.APIProjectSettings, error)
	SetLastRevision(ctx context.Context, opts SetLastRevisionInput) (*SetLastRevisionPayload, error)
	AttachVolumeToHost(ctx context.Context, volumeAndHost VolumeHost) (bool, error)
	DetachVolumeFromHost(ctx context.Context, volumeID string) (bool, error)
	EditSpawnHost(ctx context.Context, spawnHost *EditSpawnHostInput) (*model.APIHost, error)
	MigrateVolume(ctx context.Context, volumeID string, spawnHostInput *SpawnHostInput) (bool, error)
	SpawnHost(ctx context.Context, spawnHostInput *SpawnHostInput) (*model.APIHost, error)
	SpawnVolume(ctx context.Context, spawnVolumeInput SpawnVolumeInput) (bool, error)
	RemoveVolume(ctx context.Context, volumeID string) (bool, error)
	UpdateSpawnHostStatus(ctx context.Context, updateSpawnHostStatusInput UpdateSpawnHostStatusInput) (*model.APIHost, error)
	UpdateVolume(ctx context.Context, updateVolumeInput UpdateVolumeInput) (bool, error)
	AbortTask(ctx context.Context, taskID string) (*model.APITask, error)
	OverrideTaskDependencies(ctx context.Context, taskID string) (*model.APITask, error)
	RestartTask(ctx context.Context, taskID string, failedOnly bool) (*model.APITask, error)
	ScheduleTasks(ctx context.Context, versionID string, taskIds []string) ([]*model.APITask, error)
	SetTaskPriority(ctx context.Context, taskID string, priority int) (*model.APITask, error)
	SetTaskPriorities(ctx context.Context, taskPriorities []*TaskPriority) ([]*model.APITask, error)
	UnscheduleTask(ctx context.Context, taskID string) (*model.APITask, error)
	AddFavoriteProject(ctx context.Context, opts AddFavoriteProjectInput) (*model.APIProjectRef, error)
	ClearMySubscriptions(ctx context.Context) (int, error)
	CreatePublicKey(ctx context.Context, publicKeyInput PublicKeyInput) ([]*model.APIPubKey, error)
	DeleteSubscriptions(ctx context.Context, subscriptionIds []string) (int, error)
	RemoveFavoriteProject(ctx context.Context, opts RemoveFavoriteProjectInput) (*model.APIProjectRef, error)
	RemovePublicKey(ctx context.Context, keyName string) ([]*model.APIPubKey, error)
	SaveSubscription(ctx context.Context, subscription model.APISubscription) (bool, error)
	UpdateBetaFeatures(ctx context.Context, opts UpdateBetaFeaturesInput) (*UpdateBetaFeaturesPayload, error)
	UpdateParsleySettings(ctx context.Context, opts UpdateParsleySettingsInput) (*UpdateParsleySettingsPayload, error)
	UpdatePublicKey(ctx context.Context, targetKeyName string, updateInfo PublicKeyInput) ([]*model.APIPubKey, error)
	UpdateUserSettings(ctx context.Context, userSettings *model.APIUserSettings) (bool, error)
	RestartVersions(ctx context.Context, versionID string, abort bool, versionsToRestart []*model1.VersionToRestart) ([]*model.APIVersion, error)
	ScheduleUndispatchedBaseTasks(ctx context.Context, versionID string) ([]*model.APITask, error)
	SetVersionPriority(ctx context.Context, versionID string, priority int) (*string, error)
	UnscheduleVersionTasks(ctx context.Context, versionID string, abort bool) (*string, error)
}
type PatchResolver interface {
	AuthorDisplayName(ctx context.Context, obj *model.APIPatch) (string, error)
	BaseTaskStatuses(ctx context.Context, obj *model.APIPatch) ([]string, error)
	Builds(ctx context.Context, obj *model.APIPatch) ([]*model.APIBuild, error)

	Duration(ctx context.Context, obj *model.APIPatch) (*PatchDuration, error)
	GeneratedTaskCounts(ctx context.Context, obj *model.APIPatch) ([]*GeneratedTaskCountResults, error)

	PatchTriggerAliases(ctx context.Context, obj *model.APIPatch) ([]*model.APIPatchTriggerDefinition, error)
	Project(ctx context.Context, obj *model.APIPatch) (*PatchProject, error)

	ProjectIdentifier(ctx context.Context, obj *model.APIPatch) (string, error)
	ProjectMetadata(ctx context.Context, obj *model.APIPatch) (*model.APIProjectRef, error)

	TaskCount(ctx context.Context, obj *model.APIPatch) (*int, error)

	TaskStatuses(ctx context.Context, obj *model.APIPatch) ([]string, error)
	Time(ctx context.Context, obj *model.APIPatch) (*PatchTime, error)

	VersionFull(ctx context.Context, obj *model.APIPatch) (*model.APIVersion, error)
}
type PermissionsResolver interface {
	CanCreateDistro(ctx context.Context, obj *Permissions) (bool, error)
	CanCreateProject(ctx context.Context, obj *Permissions) (bool, error)
	CanEditAdminSettings(ctx context.Context, obj *Permissions) (bool, error)
	DistroPermissions(ctx context.Context, obj *Permissions, options DistroPermissionsOptions) (*DistroPermissions, error)
	ProjectPermissions(ctx context.Context, obj *Permissions, options ProjectPermissionsOptions) (*ProjectPermissions, error)
	RepoPermissions(ctx context.Context, obj *Permissions, options RepoPermissionsOptions) (*RepoPermissions, error)
}
type PodResolver interface {
	Events(ctx context.Context, obj *model.APIPod, limit *int, page *int) (*PodEvents, error)

	Status(ctx context.Context, obj *model.APIPod) (string, error)
	Task(ctx context.Context, obj *model.APIPod) (*model.APITask, error)

	Type(ctx context.Context, obj *model.APIPod) (string, error)
}
type PodEventLogDataResolver interface {
	Task(ctx context.Context, obj *model.PodAPIEventData) (*model.APITask, error)
}
type ProjectResolver interface {
	GithubTriggerAliases(ctx context.Context, obj *model.APIProjectRef) ([]string, error)

	IsFavorite(ctx context.Context, obj *model.APIProjectRef) (bool, error)

	Patches(ctx context.Context, obj *model.APIProjectRef, patchesInput PatchesInput) (*Patches, error)
}
type ProjectSettingsResolver interface {
	Aliases(ctx context.Context, obj *model.APIProjectSettings) ([]*model.APIProjectAlias, error)
	GithubAppAuth(ctx context.Context, obj *model.APIProjectSettings) (*model.APIGithubAppAuth, error)
	GithubWebhooksEnabled(ctx context.Context, obj *model.APIProjectSettings) (bool, error)

	Subscriptions(ctx context.Context, obj *model.APIProjectSettings) ([]*model.APISubscription, error)
	Vars(ctx context.Context, obj *model.APIProjectSettings) (*model.APIProjectVars, error)
}
type ProjectVarsResolver interface {
	AdminOnlyVars(ctx context.Context, obj *model.APIProjectVars) ([]string, error)
	PrivateVars(ctx context.Context, obj *model.APIProjectVars) ([]string, error)
}
type QueryResolver interface {
	BbGetCreatedTickets(ctx context.Context, taskID string) ([]*thirdparty.JiraTicket, error)
	BuildBaron(ctx context.Context, taskID string, execution int) (*BuildBaron, error)
	AdminEvents(ctx context.Context, opts AdminEventsInput) (*AdminEventsPayload, error)
	AdminSettings(ctx context.Context) (*model.APIAdminSettings, error)
	AdminTasksToRestart(ctx context.Context, opts model1.RestartOptions) (*AdminTasksToRestartPayload, error)
	AWSRegions(ctx context.Context) ([]string, error)
	ClientConfig(ctx context.Context) (*model.APIClientConfig, error)
	InstanceTypes(ctx context.Context) ([]string, error)
	SpruceConfig(ctx context.Context) (*model.APIAdminSettings, error)
	SubnetAvailabilityZones(ctx context.Context) ([]string, error)
	Distro(ctx context.Context, distroID string) (*model.APIDistro, error)
	DistroEvents(ctx context.Context, opts DistroEventsInput) (*DistroEventsPayload, error)
	Distros(ctx context.Context, onlySpawnable bool) ([]*model.APIDistro, error)
	DistroTaskQueue(ctx context.Context, distroID string) ([]*model.APITaskQueueItem, error)
	Host(ctx context.Context, hostID string) (*model.APIHost, error)
	HostEvents(ctx context.Context, hostID string, hostTag *string, limit *int, page *int) (*HostEvents, error)
	Hosts(ctx context.Context, hostID *string, distroID *string, currentTaskID *string, statuses []string, startedBy *string, sortBy *HostSortBy, sortDir *SortDirection, page *int, limit *int) (*HostsResponse, error)
	TaskQueueDistros(ctx context.Context) ([]*TaskQueueDistro, error)
	Pod(ctx context.Context, podID string) (*model.APIPod, error)
	Patch(ctx context.Context, patchID string) (*model.APIPatch, error)
	GithubProjectConflicts(ctx context.Context, projectID string) (*model1.GithubProjectConflicts, error)
	Project(ctx context.Context, projectIdentifier string) (*model.APIProjectRef, error)
	Projects(ctx context.Context) ([]*GroupedProjects, error)
	ProjectEvents(ctx context.Context, projectIdentifier string, limit *int, before *time.Time) (*ProjectEvents, error)
	ProjectSettings(ctx context.Context, projectIdentifier string) (*model.APIProjectSettings, error)
	RepoEvents(ctx context.Context, repoID string, limit *int, before *time.Time) (*ProjectEvents, error)
	RepoSettings(ctx context.Context, repoID string) (*model.APIProjectSettings, error)
	ViewableProjectRefs(ctx context.Context) ([]*GroupedProjects, error)
	IsRepo(ctx context.Context, projectOrRepoID string) (bool, error)
	MyHosts(ctx context.Context) ([]*model.APIHost, error)
	MyVolumes(ctx context.Context) ([]*model.APIVolume, error)
	LogkeeperBuildMetadata(ctx context.Context, buildID string) (*plank.Build, error)
	Task(ctx context.Context, taskID string, execution *int) (*model.APITask, error)
	TaskAllExecutions(ctx context.Context, taskID string) ([]*model.APITask, error)
	TaskTestSample(ctx context.Context, versionID string, taskIds []string, filters []*TestFilter) ([]*TaskTestResultSample, error)
	MyPublicKeys(ctx context.Context) ([]*model.APIPubKey, error)
	User(ctx context.Context, userID *string) (*model.APIDBUser, error)
	UserConfig(ctx context.Context) (*UserConfig, error)
	BuildVariantsForTaskName(ctx context.Context, projectIdentifier string, taskName string) ([]*task.BuildVariantTuple, error)
	MainlineCommits(ctx context.Context, options MainlineCommitsOptions, buildVariantOptions *BuildVariantOptions) (*MainlineCommits, error)
	TaskNamesForBuildVariant(ctx context.Context, projectIdentifier string, buildVariant string) ([]string, error)
	Waterfall(ctx context.Context, options WaterfallOptions) (*Waterfall, error)
	TaskHistory(ctx context.Context, options TaskHistoryOpts) (*TaskHistory, error)
	HasVersion(ctx context.Context, patchID string) (bool, error)
	Version(ctx context.Context, versionID string) (*model.APIVersion, error)
	Image(ctx context.Context, imageID string) (*model.APIImage, error)
	Images(ctx context.Context) ([]string, error)
}
type RepoRefResolver interface {
	GithubTriggerAliases(ctx context.Context, obj *model.APIProjectRef) ([]string, error)
}
type RepoSettingsResolver interface {
	Aliases(ctx context.Context, obj *model.APIProjectSettings) ([]*model.APIProjectAlias, error)
	GithubAppAuth(ctx context.Context, obj *model.APIProjectSettings) (*model.APIGithubAppAuth, error)
	GithubWebhooksEnabled(ctx context.Context, obj *model.APIProjectSettings) (bool, error)

	Subscriptions(ctx context.Context, obj *model.APIProjectSettings) ([]*model.APISubscription, error)
	Vars(ctx context.Context, obj *model.APIProjectSettings) (*model.APIProjectVars, error)
}
type SleepScheduleResolver interface {
	WholeWeekdaysOff(ctx context.Context, obj *host.SleepScheduleInfo) ([]int, error)
}
type SpruceConfigResolver interface {
	SecretFields(ctx context.Context, obj *model.APIAdminSettings) ([]string, error)
}
type SubscriberWrapperResolver interface {
	Subscriber(ctx context.Context, obj *model.APISubscriber) (*Subscriber, error)
}
type TaskResolver interface {
	AbortInfo(ctx context.Context, obj *model.APITask) (*AbortInfo, error)

	Ami(ctx context.Context, obj *model.APITask) (*string, error)
	Annotation(ctx context.Context, obj *model.APITask) (*model.APITaskAnnotation, error)

	BaseStatus(ctx context.Context, obj *model.APITask) (*string, error)
	BaseTask(ctx context.Context, obj *model.APITask) (*model.APITask, error)

	BuildVariantDisplayName(ctx context.Context, obj *model.APITask) (*string, error)
	CanAbort(ctx context.Context, obj *model.APITask) (bool, error)
	CanDisable(ctx context.Context, obj *model.APITask) (bool, error)
	CanModifyAnnotation(ctx context.Context, obj *model.APITask) (bool, error)
	CanOverrideDependencies(ctx context.Context, obj *model.APITask) (bool, error)
	CanRestart(ctx context.Context, obj *model.APITask) (bool, error)
	CanSchedule(ctx context.Context, obj *model.APITask) (bool, error)
	CanSetPriority(ctx context.Context, obj *model.APITask) (bool, error)
	CanUnschedule(ctx context.Context, obj *model.APITask) (bool, error)

	DependsOn(ctx context.Context, obj *model.APITask) ([]*Dependency, error)

	DisplayTask(ctx context.Context, obj *model.APITask) (*model.APITask, error)

	EstimatedStart(ctx context.Context, obj *model.APITask) (*model.APIDuration, error)

	ExecutionTasksFull(ctx context.Context, obj *model.APITask) ([]*model.APITask, error)

	FailedTestCount(ctx context.Context, obj *model.APITask) (int, error)
	Files(ctx context.Context, obj *model.APITask) (*TaskFiles, error)

	GeneratedByName(ctx context.Context, obj *model.APITask) (*string, error)

	ImageID(ctx context.Context, obj *model.APITask) (string, error)

	IsPerfPluginEnabled(ctx context.Context, obj *model.APITask) (bool, error)
	LatestExecution(ctx context.Context, obj *model.APITask) (int, error)

	MinQueuePosition(ctx context.Context, obj *model.APITask) (int, error)

	Patch(ctx context.Context, obj *model.APITask) (*model.APIPatch, error)
	PatchNumber(ctx context.Context, obj *model.APITask) (*int, error)
	Pod(ctx context.Context, obj *model.APITask) (*model.APIPod, error)

	Project(ctx context.Context, obj *model.APITask) (*model.APIProjectRef, error)

	ProjectIdentifier(ctx context.Context, obj *model.APITask) (*string, error)

	SpawnHostLink(ctx context.Context, obj *model.APITask) (*string, error)

	TaskLogs(ctx context.Context, obj *model.APITask) (*TaskLogs, error)
	TaskOwnerTeam(ctx context.Context, obj *model.APITask) (*TaskOwnerTeam, error)
	Tests(ctx context.Context, obj *model.APITask, opts *TestFilterOptions) (*TaskTestResult, error)

	TotalTestCount(ctx context.Context, obj *model.APITask) (int, error)
	VersionMetadata(ctx context.Context, obj *model.APITask) (*model.APIVersion, error)
}
type TaskContainerCreationOptsResolver interface {
	Os(ctx context.Context, obj *model.APIPodTaskContainerCreationOptions) (string, error)
	Arch(ctx context.Context, obj *model.APIPodTaskContainerCreationOptions) (string, error)
}
type TaskLogsResolver interface {
	AgentLogs(ctx context.Context, obj *TaskLogs) ([]*apimodels.LogMessage, error)
	AllLogs(ctx context.Context, obj *TaskLogs) ([]*apimodels.LogMessage, error)
	EventLogs(ctx context.Context, obj *TaskLogs) ([]*model.TaskAPIEventLogEntry, error)

	SystemLogs(ctx context.Context, obj *TaskLogs) ([]*apimodels.LogMessage, error)

	TaskLogs(ctx context.Context, obj *TaskLogs) ([]*apimodels.LogMessage, error)
}
type TaskQueueItemResolver interface {
	Requester(ctx context.Context, obj *model.APITaskQueueItem) (TaskQueueItemType, error)
}
type TicketFieldsResolver interface {
	AssignedTeam(ctx context.Context, obj *thirdparty.TicketFields) (*string, error)
	AssigneeDisplayName(ctx context.Context, obj *thirdparty.TicketFields) (*string, error)

	ResolutionName(ctx context.Context, obj *thirdparty.TicketFields) (*string, error)
}
type UserResolver interface {
	Patches(ctx context.Context, obj *model.APIDBUser, patchesInput PatchesInput) (*Patches, error)
	Permissions(ctx context.Context, obj *model.APIDBUser) (*Permissions, error)

	Subscriptions(ctx context.Context, obj *model.APIDBUser) ([]*model.APISubscription, error)
}
type VersionResolver interface {
	BaseTaskStatuses(ctx context.Context, obj *model.APIVersion) ([]string, error)
	BaseVersion(ctx context.Context, obj *model.APIVersion) (*model.APIVersion, error)

	BuildVariants(ctx context.Context, obj *model.APIVersion, options BuildVariantOptions) ([]*GroupedBuildVariant, error)
	BuildVariantStats(ctx context.Context, obj *model.APIVersion, options BuildVariantOptions) ([]*task.GroupedTaskStatusCount, error)
	ChildVersions(ctx context.Context, obj *model.APIVersion) ([]*model.APIVersion, error)

	ExternalLinksForMetadata(ctx context.Context, obj *model.APIVersion) ([]*ExternalLinkForMetadata, error)

	GeneratedTaskCounts(ctx context.Context, obj *model.APIVersion) ([]*GeneratedTaskCountResults, error)

	IsPatch(ctx context.Context, obj *model.APIVersion) (bool, error)
	Manifest(ctx context.Context, obj *model.APIVersion) (*Manifest, error)

	Patch(ctx context.Context, obj *model.APIVersion) (*model.APIPatch, error)
	PreviousVersion(ctx context.Context, obj *model.APIVersion) (*model.APIVersion, error)

	ProjectMetadata(ctx context.Context, obj *model.APIVersion) (*model.APIProjectRef, error)

	Status(ctx context.Context, obj *model.APIVersion) (string, error)
	TaskCount(ctx context.Context, obj *model.APIVersion, options *TaskCountOptions) (*int, error)
	Tasks(ctx context.Context, obj *model.APIVersion, options TaskFilterOptions) (*VersionTasks, error)
	TaskStatuses(ctx context.Context, obj *model.APIVersion) ([]string, error)
	TaskStatusStats(ctx context.Context, obj *model.APIVersion, options BuildVariantOptions) (*task.TaskStats, error)
	UpstreamProject(ctx context.Context, obj *model.APIVersion) (*UpstreamProject, error)
	VersionTiming(ctx context.Context, obj *model.APIVersion) (*VersionTiming, error)
	Warnings(ctx context.Context, obj *model.APIVersion) ([]string, error)
	WaterfallBuilds(ctx context.Context, obj *model.APIVersion) ([]*model1.WaterfallBuild, error)
}
type VolumeResolver interface {
	Host(ctx context.Context, obj *model.APIVolume) (*model.APIHost, error)
}

type AdminSettingsInputResolver interface {
	BannerTheme(ctx context.Context, obj *model.APIAdminSettings, data *evergreen.BannerTheme) error
}
type DistroInputResolver interface {
	ProviderSettingsList(ctx context.Context, obj *model.APIDistro, data []map[string]any) error
}
type HostAllocatorSettingsInputResolver interface {
	AcceptableHostIdleTime(ctx context.Context, obj *model.APIHostAllocatorSettings, data int) error
}
type PlannerSettingsInputResolver interface {
	TargetTime(ctx context.Context, obj *model.APIPlannerSettings, data int) error
}
type ProjectInputResolver interface {
	GithubTriggerAliases(ctx context.Context, obj *model.APIProjectRef, data []string) error
}
type ProjectSettingsInputResolver interface {
	ProjectID(ctx context.Context, obj *model.APIProjectSettings, data string) error
}
type RepoRefInputResolver interface {
	GithubTriggerAliases(ctx context.Context, obj *model.APIProjectRef, data []string) error
}
type RepoSettingsInputResolver interface {
	RepoID(ctx context.Context, obj *model.APIProjectSettings, data string) error
}
type SleepScheduleInputResolver interface {
	WholeWeekdaysOff(ctx context.Context, obj *host.SleepScheduleInfo, data []int) error
}
type SubscriberInputResolver interface {
	Target(ctx context.Context, obj *model.APISubscriber, data string) error
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "APIConfig.corpUrl":
		if e.complexity.APIConfig.CorpURL == nil {
			break
		}

		return e.complexity.APIConfig.CorpURL(childComplexity), true

	case "APIConfig.httpListenAddr":
		if e.complexity.APIConfig.HttpListenAddr == nil {
			break
		}

		return e.complexity.APIConfig.HttpListenAddr(childComplexity), true

	case "APIConfig.url":
		if e.complexity.APIConfig.URL == nil {
			break
		}

		return e.complexity.APIConfig.URL(childComplexity), true

	case "AWSConfig.maxVolumeSizePerUser":
		if e.complexity.AWSConfig.MaxVolumeSizePerUser == nil {
			break
		}

		return e.complexity.AWSConfig.MaxVolumeSizePerUser(childComplexity), true

	case "AWSConfig.pod":
		if e.complexity.AWSConfig.Pod == nil {
			break
		}

		return e.complexity.AWSConfig.Pod(childComplexity), true

	case "AWSPodConfig.ecs":
		if e.complexity.AWSPodConfig.ECS == nil {
			break
		}

		return e.complexity.AWSPodConfig.ECS(childComplexity), true

	case "AbortInfo.buildVariantDisplayName":
		if e.complexity.AbortInfo.BuildVariantDisplayName == nil {
			break
		}

		return e.complexity.AbortInfo.BuildVariantDisplayName(childComplexity), true

	case "AbortInfo.newVersion":
		if e.complexity.AbortInfo.NewVersion == nil {
			break
		}

		return e.complexity.AbortInfo.NewVersion(childComplexity), true

	case "AbortInfo.prClosed":
		if e.complexity.AbortInfo.PrClosed == nil {
			break
		}

		return e.complexity.AbortInfo.PrClosed(childComplexity), true

	case "AbortInfo.taskDisplayName":
		if e.complexity.AbortInfo.TaskDisplayName == nil {
			break
		}

		return e.complexity.AbortInfo.TaskDisplayName(childComplexity), true

	case "AbortInfo.taskID":
		if e.complexity.AbortInfo.TaskID == nil {
			break
		}

		return e.complexity.AbortInfo.TaskID(childComplexity), true

	case "AbortInfo.user":
		if e.complexity.AbortInfo.User == nil {
			break
		}

		return e.complexity.AbortInfo.User(childComplexity), true

	case "AdminEvent.after":
		if e.complexity.AdminEvent.After == nil {
			break
		}

		return e.complexity.AdminEvent.After(childComplexity), true

	case "AdminEvent.before":
		if e.complexity.AdminEvent.Before == nil {
			break
		}

		return e.complexity.AdminEvent.Before(childComplexity), true

	case "AdminEvent.section":
		if e.complexity.AdminEvent.Section == nil {
			break
		}

		return e.complexity.AdminEvent.Section(childComplexity), true

	case "AdminEvent.timestamp":
		if e.complexity.AdminEvent.Timestamp == nil {
			break
		}

		return e.complexity.AdminEvent.Timestamp(childComplexity), true

	case "AdminEvent.user":
		if e.complexity.AdminEvent.User == nil {
			break
		}

		return e.complexity.AdminEvent.User(childComplexity), true

	case "AdminEventsPayload.count":
		if e.complexity.AdminEventsPayload.Count == nil {
			break
		}

		return e.complexity.AdminEventsPayload.Count(childComplexity), true

	case "AdminEventsPayload.eventLogEntries":
		if e.complexity.AdminEventsPayload.EventLogEntries == nil {
			break
		}

		return e.complexity.AdminEventsPayload.EventLogEntries(childComplexity), true

	case "AdminSettings.amboy":
		if e.complexity.AdminSettings.Amboy == nil {
			break
		}

		return e.complexity.AdminSettings.Amboy(childComplexity), true

	case "AdminSettings.amboyDB":
		if e.complexity.AdminSettings.AmboyDB == nil {
			break
		}

		return e.complexity.AdminSettings.AmboyDB(childComplexity), true

	case "AdminSettings.api":
		if e.complexity.AdminSettings.Api == nil {
			break
		}

		return e.complexity.AdminSettings.Api(childComplexity), true

	case "AdminSettings.authConfig":
		if e.complexity.AdminSettings.AuthConfig == nil {
			break
		}

		return e.complexity.AdminSettings.AuthConfig(childComplexity), true

	case "AdminSettings.banner":
		if e.complexity.AdminSettings.Banner == nil {
			break
		}

		return e.complexity.AdminSettings.Banner(childComplexity), true

	case "AdminSettings.bannerTheme":
		if e.complexity.AdminSettings.BannerTheme == nil {
			break
		}

		return e.complexity.AdminSettings.BannerTheme(childComplexity), true

	case "AdminSettings.cedar":
		if e.complexity.AdminSettings.Cedar == nil {
			break
		}

		return e.complexity.AdminSettings.Cedar(childComplexity), true

	case "AdminSettings.disabledGQLQueries":
		if e.complexity.AdminSettings.DisabledGQLQueries == nil {
			break
		}

		return e.complexity.AdminSettings.DisabledGQLQueries(childComplexity), true

	case "AdminSettings.fws":
		if e.complexity.AdminSettings.FWS == nil {
			break
		}

		return e.complexity.AdminSettings.FWS(childComplexity), true

	case "AdminSettings.hostInit":
		if e.complexity.AdminSettings.HostInit == nil {
			break
		}

		return e.complexity.AdminSettings.HostInit(childComplexity), true

	case "AdminSettings.jira":
		if e.complexity.AdminSettings.Jira == nil {
			break
		}

		return e.complexity.AdminSettings.Jira(childComplexity), true

	case "AdminSettings.loggerConfig":
		if e.complexity.AdminSettings.LoggerConfig == nil {
			break
		}

		return e.complexity.AdminSettings.LoggerConfig(childComplexity), true

	case "AdminSettings.notify":
		if e.complexity.AdminSettings.Notify == nil {
			break
		}

		return e.complexity.AdminSettings.Notify(childComplexity), true

	case "AdminSettings.podLifecycle":
		if e.complexity.AdminSettings.PodLifecycle == nil {
			break
		}

		return e.complexity.AdminSettings.PodLifecycle(childComplexity), true

	case "AdminSettings.repotracker":
		if e.complexity.AdminSettings.RepoTracker == nil {
			break
		}

		return e.complexity.AdminSettings.RepoTracker(childComplexity), true

	case "AdminSettings.runtimeEnvironments":
		if e.complexity.AdminSettings.RuntimeEnvironments == nil {
			break
		}

		return e.complexity.AdminSettings.RuntimeEnvironments(childComplexity), true

	case "AdminSettings.scheduler":
		if e.complexity.AdminSettings.Scheduler == nil {
			break
		}

		return e.complexity.AdminSettings.Scheduler(childComplexity), true

	case "AdminSettings.serviceFlags":
		if e.complexity.AdminSettings.ServiceFlags == nil {
			break
		}

		return e.complexity.AdminSettings.ServiceFlags(childComplexity), true

	case "AdminSettings.slack":
		if e.complexity.AdminSettings.Slack == nil {
			break
		}

		return e.complexity.AdminSettings.Slack(childComplexity), true

	case "AdminSettings.splunk":
		if e.complexity.AdminSettings.Splunk == nil {
			break
		}

		return e.complexity.AdminSettings.Splunk(childComplexity), true

	case "AdminSettings.taskLimits":
		if e.complexity.AdminSettings.TaskLimits == nil {
			break
		}

		return e.complexity.AdminSettings.TaskLimits(childComplexity), true

	case "AdminSettings.testSelection":
		if e.complexity.AdminSettings.TestSelection == nil {
			break
		}

		return e.complexity.AdminSettings.TestSelection(childComplexity), true

	case "AdminSettings.triggers":
		if e.complexity.AdminSettings.Triggers == nil {
			break
		}

		return e.complexity.AdminSettings.Triggers(childComplexity), true

	case "AdminSettings.ui":
		if e.complexity.AdminSettings.Ui == nil {
			break
		}

		return e.complexity.AdminSettings.Ui(childComplexity), true

	case "AdminTasksToRestartPayload.tasksToRestart":
		if e.complexity.AdminTasksToRestartPayload.TasksToRestart == nil {
			break
		}

		return e.complexity.AdminTasksToRestartPayload.TasksToRestart(childComplexity), true

	case "AmboyConfig.groupBackgroundCreateFrequencyMinutes":
		if e.complexity.AmboyConfig.GroupBackgroundCreateFrequencyMinutes == nil {
			break
		}

		return e.complexity.AmboyConfig.GroupBackgroundCreateFrequencyMinutes(childComplexity), true

	case "AmboyConfig.groupDefaultWorkers":
		if e.complexity.AmboyConfig.GroupDefaultWorkers == nil {
			break
		}

		return e.complexity.AmboyConfig.GroupDefaultWorkers(childComplexity), true

	case "AmboyConfig.groupPruneFrequencyMinutes":
		if e.complexity.AmboyConfig.GroupPruneFrequencyMinutes == nil {
			break
		}

		return e.complexity.AmboyConfig.GroupPruneFrequencyMinutes(childComplexity), true

	case "AmboyConfig.groupTTLMinutes":
		if e.complexity.AmboyConfig.GroupTTLMinutes == nil {
			break
		}

		return e.complexity.AmboyConfig.GroupTTLMinutes(childComplexity), true

	case "AmboyConfig.localStorage":
		if e.complexity.AmboyConfig.LocalStorage == nil {
			break
		}

		return e.complexity.AmboyConfig.LocalStorage(childComplexity), true

	case "AmboyConfig.lockTimeoutMinutes":
		if e.complexity.AmboyConfig.LockTimeoutMinutes == nil {
			break
		}

		return e.complexity.AmboyConfig.LockTimeoutMinutes(childComplexity), true

	case "AmboyConfig.name":
		if e.complexity.AmboyConfig.Name == nil {
			break
		}

		return e.complexity.AmboyConfig.Name(childComplexity), true

	case "AmboyConfig.namedQueues":
		if e.complexity.AmboyConfig.NamedQueues == nil {
			break
		}

		return e.complexity.AmboyConfig.NamedQueues(childComplexity), true

	case "AmboyConfig.poolSizeLocal":
		if e.complexity.AmboyConfig.PoolSizeLocal == nil {
			break
		}

		return e.complexity.AmboyConfig.PoolSizeLocal(childComplexity), true

	case "AmboyConfig.poolSizeRemote":
		if e.complexity.AmboyConfig.PoolSizeRemote == nil {
			break
		}

		return e.complexity.AmboyConfig.PoolSizeRemote(childComplexity), true

	case "AmboyConfig.retry":
		if e.complexity.AmboyConfig.Retry == nil {
			break
		}

		return e.complexity.AmboyConfig.Retry(childComplexity), true

	case "AmboyConfig.sampleSize":
		if e.complexity.AmboyConfig.SampleSize == nil {
			break
		}

		return e.complexity.AmboyConfig.SampleSize(childComplexity), true

	case "AmboyConfig.singleName":
		if e.complexity.AmboyConfig.SingleName == nil {
			break
		}

		return e.complexity.AmboyConfig.SingleName(childComplexity), true

	case "AmboyDBConfig.database":
		if e.complexity.AmboyDBConfig.Database == nil {
			break
		}

		return e.complexity.AmboyDBConfig.Database(childComplexity), true

	case "AmboyDBConfig.url":
		if e.complexity.AmboyDBConfig.URL == nil {
			break
		}

		return e.complexity.AmboyDBConfig.URL(childComplexity), true

	case "AmboyNamedQueueConfig.lockTimeoutSeconds":
		if e.complexity.AmboyNamedQueueConfig.LockTimeoutSeconds == nil {
			break
		}

		return e.complexity.AmboyNamedQueueConfig.LockTimeoutSeconds(childComplexity), true

	case "AmboyNamedQueueConfig.name":
		if e.complexity.AmboyNamedQueueConfig.Name == nil {
			break
		}

		return e.complexity.AmboyNamedQueueConfig.Name(childComplexity), true

	case "AmboyNamedQueueConfig.numWorkers":
		if e.complexity.AmboyNamedQueueConfig.NumWorkers == nil {
			break
		}

		return e.complexity.AmboyNamedQueueConfig.NumWorkers(childComplexity), true

	case "AmboyNamedQueueConfig.regexp":
		if e.complexity.AmboyNamedQueueConfig.Regexp == nil {
			break
		}

		return e.complexity.AmboyNamedQueueConfig.Regexp(childComplexity), true

	case "AmboyNamedQueueConfig.sampleSize":
		if e.complexity.AmboyNamedQueueConfig.SampleSize == nil {
			break
		}

		return e.complexity.AmboyNamedQueueConfig.SampleSize(childComplexity), true

	case "AmboyRetryConfig.maxCapacity":
		if e.complexity.AmboyRetryConfig.MaxCapacity == nil {
			break
		}

		return e.complexity.AmboyRetryConfig.MaxCapacity(childComplexity), true

	case "AmboyRetryConfig.maxRetryAttempts":
		if e.complexity.AmboyRetryConfig.MaxRetryAttempts == nil {
			break
		}

		return e.complexity.AmboyRetryConfig.MaxRetryAttempts(childComplexity), true

	case "AmboyRetryConfig.maxRetryTimeSeconds":
		if e.complexity.AmboyRetryConfig.MaxRetryTimeSeconds == nil {
			break
		}

		return e.complexity.AmboyRetryConfig.MaxRetryTimeSeconds(childComplexity), true

	case "AmboyRetryConfig.numWorkers":
		if e.complexity.AmboyRetryConfig.NumWorkers == nil {
			break
		}

		return e.complexity.AmboyRetryConfig.NumWorkers(childComplexity), true

	case "AmboyRetryConfig.retryBackoffSeconds":
		if e.complexity.AmboyRetryConfig.RetryBackoffSeconds == nil {
			break
		}

		return e.complexity.AmboyRetryConfig.RetryBackoffSeconds(childComplexity), true

	case "AmboyRetryConfig.staleRetryingMonitorIntervalSeconds":
		if e.complexity.AmboyRetryConfig.StaleRetryingMonitorIntervalSeconds == nil {
			break
		}

		return e.complexity.AmboyRetryConfig.StaleRetryingMonitorIntervalSeconds(childComplexity), true

	case "Annotation.createdIssues":
		if e.complexity.Annotation.CreatedIssues == nil {
			break
		}

		return e.complexity.Annotation.CreatedIssues(childComplexity), true

	case "Annotation.id":
		if e.complexity.Annotation.Id == nil {
			break
		}

		return e.complexity.Annotation.Id(childComplexity), true

	case "Annotation.issues":
		if e.complexity.Annotation.Issues == nil {
			break
		}

		return e.complexity.Annotation.Issues(childComplexity), true

	case "Annotation.metadataLinks":
		if e.complexity.Annotation.MetadataLinks == nil {
			break
		}

		return e.complexity.Annotation.MetadataLinks(childComplexity), true

	case "Annotation.note":
		if e.complexity.Annotation.Note == nil {
			break
		}

		return e.complexity.Annotation.Note(childComplexity), true

	case "Annotation.suspectedIssues":
		if e.complexity.Annotation.SuspectedIssues == nil {
			break
		}

		return e.complexity.Annotation.SuspectedIssues(childComplexity), true

	case "Annotation.taskExecution":
		if e.complexity.Annotation.TaskExecution == nil {
			break
		}

		return e.complexity.Annotation.TaskExecution(childComplexity), true

	case "Annotation.taskId":
		if e.complexity.Annotation.TaskId == nil {
			break
		}

		return e.complexity.Annotation.TaskId(childComplexity), true

	case "Annotation.webhookConfigured":
		if e.complexity.Annotation.WebhookConfigured == nil {
			break
		}

		return e.complexity.Annotation.WebhookConfigured(childComplexity), true

	case "AuthConfig.allowServiceUsers":
		if e.complexity.AuthConfig.AllowServiceUsers == nil {
			break
		}

		return e.complexity.AuthConfig.AllowServiceUsers(childComplexity), true

	case "AuthConfig.backgroundReauthMinutes":
		if e.complexity.AuthConfig.BackgroundReauthMinutes == nil {
			break
		}

		return e.complexity.AuthConfig.BackgroundReauthMinutes(childComplexity), true

	case "AuthConfig.github":
		if e.complexity.AuthConfig.Github == nil {
			break
		}

		return e.complexity.AuthConfig.Github(childComplexity), true

	case "AuthConfig.kanopy":
		if e.complexity.AuthConfig.Kanopy == nil {
			break
		}

		return e.complexity.AuthConfig.Kanopy(childComplexity), true

	case "AuthConfig.multi":
		if e.complexity.AuthConfig.Multi == nil {
			break
		}

		return e.complexity.AuthConfig.Multi(childComplexity), true

	case "AuthConfig.naive":
		if e.complexity.AuthConfig.Naive == nil {
			break
		}

		return e.complexity.AuthConfig.Naive(childComplexity), true

	case "AuthConfig.okta":
		if e.complexity.AuthConfig.Okta == nil {
			break
		}

		return e.complexity.AuthConfig.Okta(childComplexity), true

	case "AuthConfig.preferredType":
		if e.complexity.AuthConfig.PreferredType == nil {
			break
		}

		return e.complexity.AuthConfig.PreferredType(childComplexity), true

	case "AuthUser.displayName":
		if e.complexity.AuthUser.DisplayName == nil {
			break
		}

		return e.complexity.AuthUser.DisplayName(childComplexity), true

	case "AuthUser.email":
		if e.complexity.AuthUser.Email == nil {
			break
		}

		return e.complexity.AuthUser.Email(childComplexity), true

	case "AuthUser.password":
		if e.complexity.AuthUser.Password == nil {
			break
		}

		return e.complexity.AuthUser.Password(childComplexity), true

	case "AuthUser.username":
		if e.complexity.AuthUser.Username == nil {
			break
		}

		return e.complexity.AuthUser.Username(childComplexity), true

	case "BetaFeatures.spruceWaterfallEnabled":
		if e.complexity.BetaFeatures.SpruceWaterfallEnabled == nil {
			break
		}

		return e.complexity.BetaFeatures.SpruceWaterfallEnabled(childComplexity), true

	case "BootstrapSettings.clientDir":
		if e.complexity.BootstrapSettings.ClientDir == nil {
			break
		}

		return e.complexity.BootstrapSettings.ClientDir(childComplexity), true

	case "BootstrapSettings.communication":
		if e.complexity.BootstrapSettings.Communication == nil {
			break
		}

		return e.complexity.BootstrapSettings.Communication(childComplexity), true

	case "BootstrapSettings.env":
		if e.complexity.BootstrapSettings.Env == nil {
			break
		}

		return e.complexity.BootstrapSettings.Env(childComplexity), true

	case "BootstrapSettings.jasperBinaryDir":
		if e.complexity.BootstrapSettings.JasperBinaryDir == nil {
			break
		}

		return e.complexity.BootstrapSettings.JasperBinaryDir(childComplexity), true

	case "BootstrapSettings.jasperCredentialsPath":
		if e.complexity.BootstrapSettings.JasperCredentialsPath == nil {
			break
		}

		return e.complexity.BootstrapSettings.JasperCredentialsPath(childComplexity), true

	case "BootstrapSettings.method":
		if e.complexity.BootstrapSettings.Method == nil {
			break
		}

		return e.complexity.BootstrapSettings.Method(childComplexity), true

	case "BootstrapSettings.preconditionScripts":
		if e.complexity.BootstrapSettings.PreconditionScripts == nil {
			break
		}

		return e.complexity.BootstrapSettings.PreconditionScripts(childComplexity), true

	case "BootstrapSettings.resourceLimits":
		if e.complexity.BootstrapSettings.ResourceLimits == nil {
			break
		}

		return e.complexity.BootstrapSettings.ResourceLimits(childComplexity), true

	case "BootstrapSettings.rootDir":
		if e.complexity.BootstrapSettings.RootDir == nil {
			break
		}

		return e.complexity.BootstrapSettings.RootDir(childComplexity), true

	case "BootstrapSettings.serviceUser":
		if e.complexity.BootstrapSettings.ServiceUser == nil {
			break
		}

		return e.complexity.BootstrapSettings.ServiceUser(childComplexity), true

	case "BootstrapSettings.shellPath":
		if e.complexity.BootstrapSettings.ShellPath == nil {
			break
		}

		return e.complexity.BootstrapSettings.ShellPath(childComplexity), true

	case "Build.actualMakespan":
		if e.complexity.Build.ActualMakespan == nil {
			break
		}

		return e.complexity.Build.ActualMakespan(childComplexity), true

	case "Build.buildVariant":
		if e.complexity.Build.BuildVariant == nil {
			break
		}

		return e.complexity.Build.BuildVariant(childComplexity), true

	case "Build.id":
		if e.complexity.Build.Id == nil {
			break
		}

		return e.complexity.Build.Id(childComplexity), true

	case "Build.predictedMakespan":
		if e.complexity.Build.PredictedMakespan == nil {
			break
		}

		return e.complexity.Build.PredictedMakespan(childComplexity), true

	case "Build.status":
		if e.complexity.Build.Status == nil {
			break
		}

		return e.complexity.Build.Status(childComplexity), true

	case "BuildBaron.bbTicketCreationDefined":
		if e.complexity.BuildBaron.BbTicketCreationDefined == nil {
			break
		}

		return e.complexity.BuildBaron.BbTicketCreationDefined(childComplexity), true

	case "BuildBaron.buildBaronConfigured":
		if e.complexity.BuildBaron.BuildBaronConfigured == nil {
			break
		}

		return e.complexity.BuildBaron.BuildBaronConfigured(childComplexity), true

	case "BuildBaron.searchReturnInfo":
		if e.complexity.BuildBaron.SearchReturnInfo == nil {
			break
		}

		return e.complexity.BuildBaron.SearchReturnInfo(childComplexity), true

	case "BuildBaronSettings.bfSuggestionFeaturesURL":
		if e.complexity.BuildBaronSettings.BFSuggestionFeaturesURL == nil {
			break
		}

		return e.complexity.BuildBaronSettings.BFSuggestionFeaturesURL(childComplexity), true

	case "BuildBaronSettings.bfSuggestionPassword":
		if e.complexity.BuildBaronSettings.BFSuggestionPassword == nil {
			break
		}

		return e.complexity.BuildBaronSettings.BFSuggestionPassword(childComplexity), true

	case "BuildBaronSettings.bfSuggestionServer":
		if e.complexity.BuildBaronSettings.BFSuggestionServer == nil {
			break
		}

		return e.complexity.BuildBaronSettings.BFSuggestionServer(childComplexity), true

	case "BuildBaronSettings.bfSuggestionTimeoutSecs":
		if e.complexity.BuildBaronSettings.BFSuggestionTimeoutSecs == nil {
			break
		}

		return e.complexity.BuildBaronSettings.BFSuggestionTimeoutSecs(childComplexity), true

	case "BuildBaronSettings.bfSuggestionUsername":
		if e.complexity.BuildBaronSettings.BFSuggestionUsername == nil {
			break
		}

		return e.complexity.BuildBaronSettings.BFSuggestionUsername(childComplexity), true

	case "BuildBaronSettings.ticketCreateIssueType":
		if e.complexity.BuildBaronSettings.TicketCreateIssueType == nil {
			break
		}

		return e.complexity.BuildBaronSettings.TicketCreateIssueType(childComplexity), true

	case "BuildBaronSettings.ticketCreateProject":
		if e.complexity.BuildBaronSettings.TicketCreateProject == nil {
			break
		}

		return e.complexity.BuildBaronSettings.TicketCreateProject(childComplexity), true

	case "BuildBaronSettings.ticketSearchProjects":
		if e.complexity.BuildBaronSettings.TicketSearchProjects == nil {
			break
		}

		return e.complexity.BuildBaronSettings.TicketSearchProjects(childComplexity), true

	case "BuildVariantTuple.buildVariant":
		if e.complexity.BuildVariantTuple.BuildVariant == nil {
			break
		}

		return e.complexity.BuildVariantTuple.BuildVariant(childComplexity), true

	case "BuildVariantTuple.displayName":
		if e.complexity.BuildVariantTuple.DisplayName == nil {
			break
		}

		return e.complexity.BuildVariantTuple.DisplayName(childComplexity), true

	case "CedarConfig.dbName":
		if e.complexity.CedarConfig.DBName == nil {
			break
		}

		return e.complexity.CedarConfig.DBName(childComplexity), true

	case "CedarConfig.dbUrl":
		if e.complexity.CedarConfig.DBURL == nil {
			break
		}

		return e.complexity.CedarConfig.DBURL(childComplexity), true

	case "ChildPatchAlias.alias":
		if e.complexity.ChildPatchAlias.Alias == nil {
			break
		}

		return e.complexity.ChildPatchAlias.Alias(childComplexity), true

	case "ChildPatchAlias.patchId":
		if e.complexity.ChildPatchAlias.PatchID == nil {
			break
		}

		return e.complexity.ChildPatchAlias.PatchID(childComplexity), true

	case "ClientBinary.arch":
		if e.complexity.ClientBinary.Arch == nil {
			break
		}

		return e.complexity.ClientBinary.Arch(childComplexity), true

	case "ClientBinary.displayName":
		if e.complexity.ClientBinary.DisplayName == nil {
			break
		}

		return e.complexity.ClientBinary.DisplayName(childComplexity), true

	case "ClientBinary.os":
		if e.complexity.ClientBinary.OS == nil {
			break
		}

		return e.complexity.ClientBinary.OS(childComplexity), true

	case "ClientBinary.url":
		if e.complexity.ClientBinary.URL == nil {
			break
		}

		return e.complexity.ClientBinary.URL(childComplexity), true

	case "ClientConfig.clientBinaries":
		if e.complexity.ClientConfig.ClientBinaries == nil {
			break
		}

		return e.complexity.ClientConfig.ClientBinaries(childComplexity), true

	case "ClientConfig.latestRevision":
		if e.complexity.ClientConfig.LatestRevision == nil {
			break
		}

		return e.complexity.ClientConfig.LatestRevision(childComplexity), true

	case "CloudProviderConfig.aws":
		if e.complexity.CloudProviderConfig.AWS == nil {
			break
		}

		return e.complexity.CloudProviderConfig.AWS(childComplexity), true

	case "CommitQueueParams.enabled":
		if e.complexity.CommitQueueParams.Enabled == nil {
			break
		}

		return e.complexity.CommitQueueParams.Enabled(childComplexity), true

	case "CommitQueueParams.mergeMethod":
		if e.complexity.CommitQueueParams.MergeMethod == nil {
			break
		}

		return e.complexity.CommitQueueParams.MergeMethod(childComplexity), true

	case "CommitQueueParams.message":
		if e.complexity.CommitQueueParams.Message == nil {
			break
		}

		return e.complexity.CommitQueueParams.Message(childComplexity), true

	case "ContainerPool.distro":
		if e.complexity.ContainerPool.Distro == nil {
			break
		}

		return e.complexity.ContainerPool.Distro(childComplexity), true

	case "ContainerPool.id":
		if e.complexity.ContainerPool.Id == nil {
			break
		}

		return e.complexity.ContainerPool.Id(childComplexity), true

	case "ContainerPool.maxContainers":
		if e.complexity.ContainerPool.MaxContainers == nil {
			break
		}

		return e.complexity.ContainerPool.MaxContainers(childComplexity), true

	case "ContainerPool.port":
		if e.complexity.ContainerPool.Port == nil {
			break
		}

		return e.complexity.ContainerPool.Port(childComplexity), true

	case "ContainerPoolsConfig.pools":
		if e.complexity.ContainerPoolsConfig.Pools == nil {
			break
		}

		return e.complexity.ContainerPoolsConfig.Pools(childComplexity), true

	case "ContainerResources.cpu":
		if e.complexity.ContainerResources.CPU == nil {
			break
		}

		return e.complexity.ContainerResources.CPU(childComplexity), true

	case "ContainerResources.memoryMb":
		if e.complexity.ContainerResources.MemoryMB == nil {
			break
		}

		return e.complexity.ContainerResources.MemoryMB(childComplexity), true

	case "ContainerResources.name":
		if e.complexity.ContainerResources.Name == nil {
			break
		}

		return e.complexity.ContainerResources.Name(childComplexity), true

	case "DeleteDistroPayload.deletedDistroId":
		if e.complexity.DeleteDistroPayload.DeletedDistroID == nil {
			break
		}

		return e.complexity.DeleteDistroPayload.DeletedDistroID(childComplexity), true

	case "DeleteGithubAppCredentialsPayload.oldAppId":
		if e.complexity.DeleteGithubAppCredentialsPayload.OldAppID == nil {
			break
		}

		return e.complexity.DeleteGithubAppCredentialsPayload.OldAppID(childComplexity), true

	case "Dependency.buildVariant":
		if e.complexity.Dependency.BuildVariant == nil {
			break
		}

		return e.complexity.Dependency.BuildVariant(childComplexity), true

	case "Dependency.metStatus":
		if e.complexity.Dependency.MetStatus == nil {
			break
		}

		return e.complexity.Dependency.MetStatus(childComplexity), true

	case "Dependency.name":
		if e.complexity.Dependency.Name == nil {
			break
		}

		return e.complexity.Dependency.Name(childComplexity), true

	case "Dependency.requiredStatus":
		if e.complexity.Dependency.RequiredStatus == nil {
			break
		}

		return e.complexity.Dependency.RequiredStatus(childComplexity), true

	case "Dependency.taskId":
		if e.complexity.Dependency.TaskID == nil {
			break
		}

		return e.complexity.Dependency.TaskID(childComplexity), true

	case "DispatcherSettings.version":
		if e.complexity.DispatcherSettings.Version == nil {
			break
		}

		return e.complexity.DispatcherSettings.Version(childComplexity), true

	case "Distro.adminOnly":
		if e.complexity.Distro.AdminOnly == nil {
			break
		}

		return e.complexity.Distro.AdminOnly(childComplexity), true

	case "Distro.aliases":
		if e.complexity.Distro.Aliases == nil {
			break
		}

		return e.complexity.Distro.Aliases(childComplexity), true

	case "Distro.arch":
		if e.complexity.Distro.Arch == nil {
			break
		}

		return e.complexity.Distro.Arch(childComplexity), true

	case "Distro.authorizedKeysFile":
		if e.complexity.Distro.AuthorizedKeysFile == nil {
			break
		}

		return e.complexity.Distro.AuthorizedKeysFile(childComplexity), true

	case "Distro.availableRegions":
		if e.complexity.Distro.AvailableRegions == nil {
			break
		}

		return e.complexity.Distro.AvailableRegions(childComplexity), true

	case "Distro.bootstrapSettings":
		if e.complexity.Distro.BootstrapSettings == nil {
			break
		}

		return e.complexity.Distro.BootstrapSettings(childComplexity), true

	case "Distro.containerPool":
		if e.complexity.Distro.ContainerPool == nil {
			break
		}

		return e.complexity.Distro.ContainerPool(childComplexity), true

	case "Distro.disableShallowClone":
		if e.complexity.Distro.DisableShallowClone == nil {
			break
		}

		return e.complexity.Distro.DisableShallowClone(childComplexity), true

	case "Distro.disabled":
		if e.complexity.Distro.Disabled == nil {
			break
		}

		return e.complexity.Distro.Disabled(childComplexity), true

	case "Distro.dispatcherSettings":
		if e.complexity.Distro.DispatcherSettings == nil {
			break
		}

		return e.complexity.Distro.DispatcherSettings(childComplexity), true

	case "Distro.execUser":
		if e.complexity.Distro.ExecUser == nil {
			break
		}

		return e.complexity.Distro.ExecUser(childComplexity), true

	case "Distro.expansions":
		if e.complexity.Distro.Expansions == nil {
			break
		}

		return e.complexity.Distro.Expansions(childComplexity), true

	case "Distro.finderSettings":
		if e.complexity.Distro.FinderSettings == nil {
			break
		}

		return e.complexity.Distro.FinderSettings(childComplexity), true

	case "Distro.homeVolumeSettings":
		if e.complexity.Distro.HomeVolumeSettings == nil {
			break
		}

		return e.complexity.Distro.HomeVolumeSettings(childComplexity), true

	case "Distro.hostAllocatorSettings":
		if e.complexity.Distro.HostAllocatorSettings == nil {
			break
		}

		return e.complexity.Distro.HostAllocatorSettings(childComplexity), true

	case "Distro.iceCreamSettings":
		if e.complexity.Distro.IcecreamSettings == nil {
			break
		}

		return e.complexity.Distro.IcecreamSettings(childComplexity), true

	case "Distro.imageId":
		if e.complexity.Distro.ImageID == nil {
			break
		}

		return e.complexity.Distro.ImageID(childComplexity), true

	case "Distro.isCluster":
		if e.complexity.Distro.IsCluster == nil {
			break
		}

		return e.complexity.Distro.IsCluster(childComplexity), true

	case "Distro.isVirtualWorkStation":
		if e.complexity.Distro.IsVirtualWorkstation == nil {
			break
		}

		return e.complexity.Distro.IsVirtualWorkstation(childComplexity), true

	case "Distro.mountpoints":
		if e.complexity.Distro.Mountpoints == nil {
			break
		}

		return e.complexity.Distro.Mountpoints(childComplexity), true

	case "Distro.name":
		if e.complexity.Distro.Name == nil {
			break
		}

		return e.complexity.Distro.Name(childComplexity), true

	case "Distro.note":
		if e.complexity.Distro.Note == nil {
			break
		}

		return e.complexity.Distro.Note(childComplexity), true

	case "Distro.plannerSettings":
		if e.complexity.Distro.PlannerSettings == nil {
			break
		}

		return e.complexity.Distro.PlannerSettings(childComplexity), true

	case "Distro.provider":
		if e.complexity.Distro.Provider == nil {
			break
		}

		return e.complexity.Distro.Provider(childComplexity), true

	case "Distro.providerAccount":
		if e.complexity.Distro.ProviderAccount == nil {
			break
		}

		return e.complexity.Distro.ProviderAccount(childComplexity), true

	case "Distro.providerSettingsList":
		if e.complexity.Distro.ProviderSettingsList == nil {
			break
		}

		return e.complexity.Distro.ProviderSettingsList(childComplexity), true

	case "Distro.sshOptions":
		if e.complexity.Distro.SSHOptions == nil {
			break
		}

		return e.complexity.Distro.SSHOptions(childComplexity), true

	case "Distro.setup":
		if e.complexity.Distro.Setup == nil {
			break
		}

		return e.complexity.Distro.Setup(childComplexity), true

	case "Distro.setupAsSudo":
		if e.complexity.Distro.SetupAsSudo == nil {
			break
		}

		return e.complexity.Distro.SetupAsSudo(childComplexity), true

	case "Distro.singleTaskDistro":
		if e.complexity.Distro.SingleTaskDistro == nil {
			break
		}

		return e.complexity.Distro.SingleTaskDistro(childComplexity), true

	case "Distro.user":
		if e.complexity.Distro.User == nil {
			break
		}

		return e.complexity.Distro.User(childComplexity), true

	case "Distro.userSpawnAllowed":
		if e.complexity.Distro.UserSpawnAllowed == nil {
			break
		}

		return e.complexity.Distro.UserSpawnAllowed(childComplexity), true

	case "Distro.validProjects":
		if e.complexity.Distro.ValidProjects == nil {
			break
		}

		return e.complexity.Distro.ValidProjects(childComplexity), true

	case "Distro.warningNote":
		if e.complexity.Distro.WarningNote == nil {
			break
		}

		return e.complexity.Distro.WarningNote(childComplexity), true

	case "Distro.workDir":
		if e.complexity.Distro.WorkDir == nil {
			break
		}

		return e.complexity.Distro.WorkDir(childComplexity), true

	case "DistroEvent.after":
		if e.complexity.DistroEvent.After == nil {
			break
		}

		return e.complexity.DistroEvent.After(childComplexity), true

	case "DistroEvent.before":
		if e.complexity.DistroEvent.Before == nil {
			break
		}

		return e.complexity.DistroEvent.Before(childComplexity), true

	case "DistroEvent.data":
		if e.complexity.DistroEvent.Data == nil {
			break
		}

		return e.complexity.DistroEvent.Data(childComplexity), true

	case "DistroEvent.timestamp":
		if e.complexity.DistroEvent.Timestamp == nil {
			break
		}

		return e.complexity.DistroEvent.Timestamp(childComplexity), true

	case "DistroEvent.user":
		if e.complexity.DistroEvent.User == nil {
			break
		}

		return e.complexity.DistroEvent.User(childComplexity), true

	case "DistroEventsPayload.count":
		if e.complexity.DistroEventsPayload.Count == nil {
			break
		}

		return e.complexity.DistroEventsPayload.Count(childComplexity), true

	case "DistroEventsPayload.eventLogEntries":
		if e.complexity.DistroEventsPayload.EventLogEntries == nil {
			break
		}

		return e.complexity.DistroEventsPayload.EventLogEntries(childComplexity), true

	case "DistroInfo.bootstrapMethod":
		if e.complexity.DistroInfo.BootstrapMethod == nil {
			break
		}

		return e.complexity.DistroInfo.BootstrapMethod(childComplexity), true

	case "DistroInfo.id":
		if e.complexity.DistroInfo.Id == nil {
			break
		}

		return e.complexity.DistroInfo.Id(childComplexity), true

	case "DistroInfo.isVirtualWorkStation":
		if e.complexity.DistroInfo.IsVirtualWorkstation == nil {
			break
		}

		return e.complexity.DistroInfo.IsVirtualWorkstation(childComplexity), true

	case "DistroInfo.isWindows":
		if e.complexity.DistroInfo.IsWindows == nil {
			break
		}

		return e.complexity.DistroInfo.IsWindows(childComplexity), true

	case "DistroInfo.user":
		if e.complexity.DistroInfo.User == nil {
			break
		}

		return e.complexity.DistroInfo.User(childComplexity), true

	case "DistroInfo.workDir":
		if e.complexity.DistroInfo.WorkDir == nil {
			break
		}

		return e.complexity.DistroInfo.WorkDir(childComplexity), true

	case "DistroPermissions.admin":
		if e.complexity.DistroPermissions.Admin == nil {
			break
		}

		return e.complexity.DistroPermissions.Admin(childComplexity), true

	case "DistroPermissions.edit":
		if e.complexity.DistroPermissions.Edit == nil {
			break
		}

		return e.complexity.DistroPermissions.Edit(childComplexity), true

	case "DistroPermissions.view":
		if e.complexity.DistroPermissions.View == nil {
			break
		}

		return e.complexity.DistroPermissions.View(childComplexity), true

	case "ECSConfig.maxCPU":
		if e.complexity.ECSConfig.MaxCPU == nil {
			break
		}

		return e.complexity.ECSConfig.MaxCPU(childComplexity), true

	case "ECSConfig.maxMemoryMb":
		if e.complexity.ECSConfig.MaxMemoryMB == nil {
			break
		}

		return e.complexity.ECSConfig.MaxMemoryMB(childComplexity), true

	case "EnvVar.key":
		if e.complexity.EnvVar.Key == nil {
			break
		}

		return e.complexity.EnvVar.Key(childComplexity), true

	case "EnvVar.value":
		if e.complexity.EnvVar.Value == nil {
			break
		}

		return e.complexity.EnvVar.Value(childComplexity), true

	case "Expansion.key":
		if e.complexity.Expansion.Key == nil {
			break
		}

		return e.complexity.Expansion.Key(childComplexity), true

	case "Expansion.value":
		if e.complexity.Expansion.Value == nil {
			break
		}

		return e.complexity.Expansion.Value(childComplexity), true

	case "ExternalLink.displayName":
		if e.complexity.ExternalLink.DisplayName == nil {
			break
		}

		return e.complexity.ExternalLink.DisplayName(childComplexity), true

	case "ExternalLink.requesters":
		if e.complexity.ExternalLink.Requesters == nil {
			break
		}

		return e.complexity.ExternalLink.Requesters(childComplexity), true

	case "ExternalLink.urlTemplate":
		if e.complexity.ExternalLink.URLTemplate == nil {
			break
		}

		return e.complexity.ExternalLink.URLTemplate(childComplexity), true

	case "ExternalLinkForMetadata.displayName":
		if e.complexity.ExternalLinkForMetadata.DisplayName == nil {
			break
		}

		return e.complexity.ExternalLinkForMetadata.DisplayName(childComplexity), true

	case "ExternalLinkForMetadata.url":
		if e.complexity.ExternalLinkForMetadata.URL == nil {
			break
		}

		return e.complexity.ExternalLinkForMetadata.URL(childComplexity), true

	case "FWSConfig.url":
		if e.complexity.FWSConfig.URL == nil {
			break
		}

		return e.complexity.FWSConfig.URL(childComplexity), true

	case "FailingCommand.failureMetadataTags":
		if e.complexity.FailingCommand.FailureMetadataTags == nil {
			break
		}

		return e.complexity.FailingCommand.FailureMetadataTags(childComplexity), true

	case "FailingCommand.fullDisplayName":
		if e.complexity.FailingCommand.FullDisplayName == nil {
			break
		}

		return e.complexity.FailingCommand.FullDisplayName(childComplexity), true

	case "File.link":
		if e.complexity.File.Link == nil {
			break
		}

		return e.complexity.File.Link(childComplexity), true

	case "File.name":
		if e.complexity.File.Name == nil {
			break
		}

		return e.complexity.File.Name(childComplexity), true

	case "File.urlParsley":
		if e.complexity.File.URLParsley == nil {
			break
		}

		return e.complexity.File.URLParsley(childComplexity), true

	case "File.visibility":
		if e.complexity.File.Visibility == nil {
			break
		}

		return e.complexity.File.Visibility(childComplexity), true

	case "FileDiff.additions":
		if e.complexity.FileDiff.Additions == nil {
			break
		}

		return e.complexity.FileDiff.Additions(childComplexity), true

	case "FileDiff.deletions":
		if e.complexity.FileDiff.Deletions == nil {
			break
		}

		return e.complexity.FileDiff.Deletions(childComplexity), true

	case "FileDiff.description":
		if e.complexity.FileDiff.Description == nil {
			break
		}

		return e.complexity.FileDiff.Description(childComplexity), true

	case "FileDiff.diffLink":
		if e.complexity.FileDiff.DiffLink == nil {
			break
		}

		return e.complexity.FileDiff.DiffLink(childComplexity), true

	case "FileDiff.fileName":
		if e.complexity.FileDiff.FileName == nil {
			break
		}

		return e.complexity.FileDiff.FileName(childComplexity), true

	case "FinderSettings.version":
		if e.complexity.FinderSettings.Version == nil {
			break
		}

		return e.complexity.FinderSettings.Version(childComplexity), true

	case "GeneralSubscription.id":
		if e.complexity.GeneralSubscription.ID == nil {
			break
		}

		return e.complexity.GeneralSubscription.ID(childComplexity), true

	case "GeneralSubscription.ownerType":
		if e.complexity.GeneralSubscription.OwnerType == nil {
			break
		}

		return e.complexity.GeneralSubscription.OwnerType(childComplexity), true

	case "GeneralSubscription.regexSelectors":
		if e.complexity.GeneralSubscription.RegexSelectors == nil {
			break
		}

		return e.complexity.GeneralSubscription.RegexSelectors(childComplexity), true

	case "GeneralSubscription.resourceType":
		if e.complexity.GeneralSubscription.ResourceType == nil {
			break
		}

		return e.complexity.GeneralSubscription.ResourceType(childComplexity), true

	case "GeneralSubscription.selectors":
		if e.complexity.GeneralSubscription.Selectors == nil {
			break
		}

		return e.complexity.GeneralSubscription.Selectors(childComplexity), true

	case "GeneralSubscription.subscriber":
		if e.complexity.GeneralSubscription.Subscriber == nil {
			break
		}

		return e.complexity.GeneralSubscription.Subscriber(childComplexity), true

	case "GeneralSubscription.trigger":
		if e.complexity.GeneralSubscription.Trigger == nil {
			break
		}

		return e.complexity.GeneralSubscription.Trigger(childComplexity), true

	case "GeneralSubscription.triggerData":
		if e.complexity.GeneralSubscription.TriggerData == nil {
			break
		}

		return e.complexity.GeneralSubscription.TriggerData(childComplexity), true

	case "GeneratedTaskCountResults.buildVariantName":
		if e.complexity.GeneratedTaskCountResults.BuildVariantName == nil {
			break
		}

		return e.complexity.GeneratedTaskCountResults.BuildVariantName(childComplexity), true

	case "GeneratedTaskCountResults.estimatedTasks":
		if e.complexity.GeneratedTaskCountResults.EstimatedTasks == nil {
			break
		}

		return e.complexity.GeneratedTaskCountResults.EstimatedTasks(childComplexity), true

	case "GeneratedTaskCountResults.taskId":
		if e.complexity.GeneratedTaskCountResults.TaskID == nil {
			break
		}

		return e.complexity.GeneratedTaskCountResults.TaskID(childComplexity), true

	case "GeneratedTaskCountResults.taskName":
		if e.complexity.GeneratedTaskCountResults.TaskName == nil {
			break
		}

		return e.complexity.GeneratedTaskCountResults.TaskName(childComplexity), true

	case "GitHubAuthConfig.appId":
		if e.complexity.GitHubAuthConfig.AppId == nil {
			break
		}

		return e.complexity.GitHubAuthConfig.AppId(childComplexity), true

	case "GitHubAuthConfig.clientId":
		if e.complexity.GitHubAuthConfig.ClientId == nil {
			break
		}

		return e.complexity.GitHubAuthConfig.ClientId(childComplexity), true

	case "GitHubAuthConfig.clientSecret":
		if e.complexity.GitHubAuthConfig.ClientSecret == nil {
			break
		}

		return e.complexity.GitHubAuthConfig.ClientSecret(childComplexity), true

	case "GitHubAuthConfig.defaultOwner":
		if e.complexity.GitHubAuthConfig.DefaultOwner == nil {
			break
		}

		return e.complexity.GitHubAuthConfig.DefaultOwner(childComplexity), true

	case "GitHubAuthConfig.defaultRepo":
		if e.complexity.GitHubAuthConfig.DefaultRepo == nil {
			break
		}

		return e.complexity.GitHubAuthConfig.DefaultRepo(childComplexity), true

	case "GitHubAuthConfig.organization":
		if e.complexity.GitHubAuthConfig.Organization == nil {
			break
		}

		return e.complexity.GitHubAuthConfig.Organization(childComplexity), true

	case "GitHubAuthConfig.users":
		if e.complexity.GitHubAuthConfig.Users == nil {
			break
		}

		return e.complexity.GitHubAuthConfig.Users(childComplexity), true

	case "GitHubDynamicTokenPermissionGroup.name":
		if e.complexity.GitHubDynamicTokenPermissionGroup.Name == nil {
			break
		}

		return e.complexity.GitHubDynamicTokenPermissionGroup.Name(childComplexity), true

	case "GitHubDynamicTokenPermissionGroup.permissions":
		if e.complexity.GitHubDynamicTokenPermissionGroup.Permissions == nil {
			break
		}

		return e.complexity.GitHubDynamicTokenPermissionGroup.Permissions(childComplexity), true

	case "GitTag.pusher":
		if e.complexity.GitTag.Pusher == nil {
			break
		}

		return e.complexity.GitTag.Pusher(childComplexity), true

	case "GitTag.tag":
		if e.complexity.GitTag.Tag == nil {
			break
		}

		return e.complexity.GitTag.Tag(childComplexity), true

	case "GithubAppAuth.appId":
		if e.complexity.GithubAppAuth.AppID == nil {
			break
		}

		return e.complexity.GithubAppAuth.AppID(childComplexity), true

	case "GithubAppAuth.privateKey":
		if e.complexity.GithubAppAuth.PrivateKey == nil {
			break
		}

		return e.complexity.GithubAppAuth.PrivateKey(childComplexity), true

	case "GithubCheckSubscriber.owner":
		if e.complexity.GithubCheckSubscriber.Owner == nil {
			break
		}

		return e.complexity.GithubCheckSubscriber.Owner(childComplexity), true

	case "GithubCheckSubscriber.ref":
		if e.complexity.GithubCheckSubscriber.Ref == nil {
			break
		}

		return e.complexity.GithubCheckSubscriber.Ref(childComplexity), true

	case "GithubCheckSubscriber.repo":
		if e.complexity.GithubCheckSubscriber.Repo == nil {
			break
		}

		return e.complexity.GithubCheckSubscriber.Repo(childComplexity), true

	case "GithubPRSubscriber.owner":
		if e.complexity.GithubPRSubscriber.Owner == nil {
			break
		}

		return e.complexity.GithubPRSubscriber.Owner(childComplexity), true

	case "GithubPRSubscriber.prNumber":
		if e.complexity.GithubPRSubscriber.PRNumber == nil {
			break
		}

		return e.complexity.GithubPRSubscriber.PRNumber(childComplexity), true

	case "GithubPRSubscriber.ref":
		if e.complexity.GithubPRSubscriber.Ref == nil {
			break
		}

		return e.complexity.GithubPRSubscriber.Ref(childComplexity), true

	case "GithubPRSubscriber.repo":
		if e.complexity.GithubPRSubscriber.Repo == nil {
			break
		}

		return e.complexity.GithubPRSubscriber.Repo(childComplexity), true

	case "GithubPatch.author":
		if e.complexity.GithubPatch.Author == nil {
			break
		}

		return e.complexity.GithubPatch.Author(childComplexity), true

	case "GithubPatch.baseOwner":
		if e.complexity.GithubPatch.BaseOwner == nil {
			break
		}

		return e.complexity.GithubPatch.BaseOwner(childComplexity), true

	case "GithubPatch.baseRepo":
		if e.complexity.GithubPatch.BaseRepo == nil {
			break
		}

		return e.complexity.GithubPatch.BaseRepo(childComplexity), true

	case "GithubPatch.headBranch":
		if e.complexity.GithubPatch.HeadBranch == nil {
			break
		}

		return e.complexity.GithubPatch.HeadBranch(childComplexity), true

	case "GithubPatch.headHash":
		if e.complexity.GithubPatch.HeadHash == nil {
			break
		}

		return e.complexity.GithubPatch.HeadHash(childComplexity), true

	case "GithubPatch.headOwner":
		if e.complexity.GithubPatch.HeadOwner == nil {
			break
		}

		return e.complexity.GithubPatch.HeadOwner(childComplexity), true

	case "GithubPatch.headRepo":
		if e.complexity.GithubPatch.HeadRepo == nil {
			break
		}

		return e.complexity.GithubPatch.HeadRepo(childComplexity), true

	case "GithubPatch.prNumber":
		if e.complexity.GithubPatch.PRNumber == nil {
			break
		}

		return e.complexity.GithubPatch.PRNumber(childComplexity), true

	case "GithubProjectConflicts.commitCheckIdentifiers":
		if e.complexity.GithubProjectConflicts.CommitCheckIdentifiers == nil {
			break
		}

		return e.complexity.GithubProjectConflicts.CommitCheckIdentifiers(childComplexity), true

	case "GithubProjectConflicts.commitQueueIdentifiers":
		if e.complexity.GithubProjectConflicts.CommitQueueIdentifiers == nil {
			break
		}

		return e.complexity.GithubProjectConflicts.CommitQueueIdentifiers(childComplexity), true

	case "GithubProjectConflicts.prTestingIdentifiers":
		if e.complexity.GithubProjectConflicts.PRTestingIdentifiers == nil {
			break
		}

		return e.complexity.GithubProjectConflicts.PRTestingIdentifiers(childComplexity), true

	case "GithubUser.lastKnownAs":
		if e.complexity.GithubUser.LastKnownAs == nil {
			break
		}

		return e.complexity.GithubUser.LastKnownAs(childComplexity), true

	case "GithubUser.uid":
		if e.complexity.GithubUser.UID == nil {
			break
		}

		return e.complexity.GithubUser.UID(childComplexity), true

	case "GroupedBuildVariant.displayName":
		if e.complexity.GroupedBuildVariant.DisplayName == nil {
			break
		}

		return e.complexity.GroupedBuildVariant.DisplayName(childComplexity), true

	case "GroupedBuildVariant.tasks":
		if e.complexity.GroupedBuildVariant.Tasks == nil {
			break
		}

		return e.complexity.GroupedBuildVariant.Tasks(childComplexity), true

	case "GroupedBuildVariant.variant":
		if e.complexity.GroupedBuildVariant.Variant == nil {
			break
		}

		return e.complexity.GroupedBuildVariant.Variant(childComplexity), true

	case "GroupedFiles.execution":
		if e.complexity.GroupedFiles.Execution == nil {
			break
		}

		return e.complexity.GroupedFiles.Execution(childComplexity), true

	case "GroupedFiles.files":
		if e.complexity.GroupedFiles.Files == nil {
			break
		}

		return e.complexity.GroupedFiles.Files(childComplexity), true

	case "GroupedFiles.taskId":
		if e.complexity.GroupedFiles.TaskID == nil {
			break
		}

		return e.complexity.GroupedFiles.TaskID(childComplexity), true

	case "GroupedFiles.taskName":
		if e.complexity.GroupedFiles.TaskName == nil {
			break
		}

		return e.complexity.GroupedFiles.TaskName(childComplexity), true

	case "GroupedProjects.groupDisplayName":
		if e.complexity.GroupedProjects.GroupDisplayName == nil {
			break
		}

		return e.complexity.GroupedProjects.GroupDisplayName(childComplexity), true

	case "GroupedProjects.projects":
		if e.complexity.GroupedProjects.Projects == nil {
			break
		}

		return e.complexity.GroupedProjects.Projects(childComplexity), true

	case "GroupedProjects.repo":
		if e.complexity.GroupedProjects.Repo == nil {
			break
		}

		return e.complexity.GroupedProjects.Repo(childComplexity), true

	case "GroupedTaskStatusCount.displayName":
		if e.complexity.GroupedTaskStatusCount.DisplayName == nil {
			break
		}

		return e.complexity.GroupedTaskStatusCount.DisplayName(childComplexity), true

	case "GroupedTaskStatusCount.statusCounts":
		if e.complexity.GroupedTaskStatusCount.StatusCounts == nil {
			break
		}

		return e.complexity.GroupedTaskStatusCount.StatusCounts(childComplexity), true

	case "GroupedTaskStatusCount.variant":
		if e.complexity.GroupedTaskStatusCount.Variant == nil {
			break
		}

		return e.complexity.GroupedTaskStatusCount.Variant(childComplexity), true

	case "HomeVolumeSettings.formatCommand":
		if e.complexity.HomeVolumeSettings.FormatCommand == nil {
			break
		}

		return e.complexity.HomeVolumeSettings.FormatCommand(childComplexity), true

	case "Host.ami":
		if e.complexity.Host.Ami == nil {
			break
		}

		return e.complexity.Host.Ami(childComplexity), true

	case "Host.availabilityZone":
		if e.complexity.Host.AvailabilityZone == nil {
			break
		}

		return e.complexity.Host.AvailabilityZone(childComplexity), true

	case "Host.displayName":
		if e.complexity.Host.DisplayName == nil {
			break
		}

		return e.complexity.Host.DisplayName(childComplexity), true

	case "Host.distro":
		if e.complexity.Host.Distro == nil {
			break
		}

		return e.complexity.Host.Distro(childComplexity), true

	case "Host.distroId":
		if e.complexity.Host.DistroID == nil {
			break
		}

		return e.complexity.Host.DistroID(childComplexity), true

	case "Host.elapsed":
		if e.complexity.Host.Elapsed == nil {
			break
		}

		return e.complexity.Host.Elapsed(childComplexity), true

	case "Host.eventTypes":
		if e.complexity.Host.EventTypes == nil {
			break
		}

		return e.complexity.Host.EventTypes(childComplexity), true

	case "Host.events":
		if e.complexity.Host.Events == nil {
			break
		}

		args, err := ec.field_Host_events_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Host.Events(childComplexity, args["opts"].(HostEventsInput)), true

	case "Host.expiration":
		if e.complexity.Host.Expiration == nil {
			break
		}

		return e.complexity.Host.Expiration(childComplexity), true

	case "Host.homeVolume":
		if e.complexity.Host.HomeVolume == nil {
			break
		}

		return e.complexity.Host.HomeVolume(childComplexity), true

	case "Host.homeVolumeID":
		if e.complexity.Host.HomeVolumeID == nil {
			break
		}

		return e.complexity.Host.HomeVolumeID(childComplexity), true

	case "Host.hostUrl":
		if e.complexity.Host.HostURL == nil {
			break
		}

		return e.complexity.Host.HostURL(childComplexity), true

	case "Host.id":
		if e.complexity.Host.Id == nil {
			break
		}

		return e.complexity.Host.Id(childComplexity), true

	case "Host.instanceTags":
		if e.complexity.Host.InstanceTags == nil {
			break
		}

		return e.complexity.Host.InstanceTags(childComplexity), true

	case "Host.instanceType":
		if e.complexity.Host.InstanceType == nil {
			break
		}

		return e.complexity.Host.InstanceType(childComplexity), true

	case "Host.lastCommunicationTime":
		if e.complexity.Host.LastCommunicationTime == nil {
			break
		}

		return e.complexity.Host.LastCommunicationTime(childComplexity), true

	case "Host.noExpiration":
		if e.complexity.Host.NoExpiration == nil {
			break
		}

		return e.complexity.Host.NoExpiration(childComplexity), true

	case "Host.persistentDnsName":
		if e.complexity.Host.PersistentDNSName == nil {
			break
		}

		return e.complexity.Host.PersistentDNSName(childComplexity), true

	case "Host.provider":
		if e.complexity.Host.Provider == nil {
			break
		}

		return e.complexity.Host.Provider(childComplexity), true

	case "Host.runningTask":
		if e.complexity.Host.RunningTask == nil {
			break
		}

		return e.complexity.Host.RunningTask(childComplexity), true

	case "Host.sleepSchedule":
		if e.complexity.Host.SleepSchedule == nil {
			break
		}

		return e.complexity.Host.SleepSchedule(childComplexity), true

	case "Host.startedBy":
		if e.complexity.Host.StartedBy == nil {
			break
		}

		return e.complexity.Host.StartedBy(childComplexity), true

	case "Host.status":
		if e.complexity.Host.Status == nil {
			break
		}

		return e.complexity.Host.Status(childComplexity), true

	case "Host.tag":
		if e.complexity.Host.Tag == nil {
			break
		}

		return e.complexity.Host.Tag(childComplexity), true

	case "Host.totalIdleTime":
		if e.complexity.Host.TotalIdleTime == nil {
			break
		}

		return e.complexity.Host.TotalIdleTime(childComplexity), true

	case "Host.uptime":
		if e.complexity.Host.Uptime == nil {
			break
		}

		return e.complexity.Host.Uptime(childComplexity), true

	case "Host.user":
		if e.complexity.Host.User == nil {
			break
		}

		return e.complexity.Host.User(childComplexity), true

	case "Host.volumes":
		if e.complexity.Host.Volumes == nil {
			break
		}

		return e.complexity.Host.Volumes(childComplexity), true

	case "HostAllocatorSettings.acceptableHostIdleTime":
		if e.complexity.HostAllocatorSettings.AcceptableHostIdleTime == nil {
			break
		}

		return e.complexity.HostAllocatorSettings.AcceptableHostIdleTime(childComplexity), true

	case "HostAllocatorSettings.autoTuneMaximumHosts":
		if e.complexity.HostAllocatorSettings.AutoTuneMaximumHosts == nil {
			break
		}

		return e.complexity.HostAllocatorSettings.AutoTuneMaximumHosts(childComplexity), true

	case "HostAllocatorSettings.feedbackRule":
		if e.complexity.HostAllocatorSettings.FeedbackRule == nil {
			break
		}

		return e.complexity.HostAllocatorSettings.FeedbackRule(childComplexity), true

	case "HostAllocatorSettings.futureHostFraction":
		if e.complexity.HostAllocatorSettings.FutureHostFraction == nil {
			break
		}

		return e.complexity.HostAllocatorSettings.FutureHostFraction(childComplexity), true

	case "HostAllocatorSettings.hostsOverallocatedRule":
		if e.complexity.HostAllocatorSettings.HostsOverallocatedRule == nil {
			break
		}

		return e.complexity.HostAllocatorSettings.HostsOverallocatedRule(childComplexity), true

	case "HostAllocatorSettings.maximumHosts":
		if e.complexity.HostAllocatorSettings.MaximumHosts == nil {
			break
		}

		return e.complexity.HostAllocatorSettings.MaximumHosts(childComplexity), true

	case "HostAllocatorSettings.minimumHosts":
		if e.complexity.HostAllocatorSettings.MinimumHosts == nil {
			break
		}

		return e.complexity.HostAllocatorSettings.MinimumHosts(childComplexity), true

	case "HostAllocatorSettings.roundingRule":
		if e.complexity.HostAllocatorSettings.RoundingRule == nil {
			break
		}

		return e.complexity.HostAllocatorSettings.RoundingRule(childComplexity), true

	case "HostAllocatorSettings.version":
		if e.complexity.HostAllocatorSettings.Version == nil {
			break
		}

		return e.complexity.HostAllocatorSettings.Version(childComplexity), true

	case "HostEventLogData.agentBuild":
		if e.complexity.HostEventLogData.AgentBuild == nil {
			break
		}

		return e.complexity.HostEventLogData.AgentBuild(childComplexity), true

	case "HostEventLogData.agentRevision":
		if e.complexity.HostEventLogData.AgentRevision == nil {
			break
		}

		return e.complexity.HostEventLogData.AgentRevision(childComplexity), true

	case "HostEventLogData.duration":
		if e.complexity.HostEventLogData.Duration == nil {
			break
		}

		return e.complexity.HostEventLogData.Duration(childComplexity), true

	case "HostEventLogData.execution":
		if e.complexity.HostEventLogData.Execution == nil {
			break
		}

		return e.complexity.HostEventLogData.Execution(childComplexity), true

	case "HostEventLogData.hostname":
		if e.complexity.HostEventLogData.Hostname == nil {
			break
		}

		return e.complexity.HostEventLogData.Hostname(childComplexity), true

	case "HostEventLogData.jasperRevision":
		if e.complexity.HostEventLogData.JasperRevision == nil {
			break
		}

		return e.complexity.HostEventLogData.JasperRevision(childComplexity), true

	case "HostEventLogData.logs":
		if e.complexity.HostEventLogData.Logs == nil {
			break
		}

		return e.complexity.HostEventLogData.Logs(childComplexity), true

	case "HostEventLogData.monitorOp":
		if e.complexity.HostEventLogData.MonitorOp == nil {
			break
		}

		return e.complexity.HostEventLogData.MonitorOp(childComplexity), true

	case "HostEventLogData.newStatus":
		if e.complexity.HostEventLogData.NewStatus == nil {
			break
		}

		return e.complexity.HostEventLogData.NewStatus(childComplexity), true

	case "HostEventLogData.oldStatus":
		if e.complexity.HostEventLogData.OldStatus == nil {
			break
		}

		return e.complexity.HostEventLogData.OldStatus(childComplexity), true

	case "HostEventLogData.provisioningMethod":
		if e.complexity.HostEventLogData.ProvisioningMethod == nil {
			break
		}

		return e.complexity.HostEventLogData.ProvisioningMethod(childComplexity), true

	case "HostEventLogData.successful":
		if e.complexity.HostEventLogData.Successful == nil {
			break
		}

		return e.complexity.HostEventLogData.Successful(childComplexity), true

	case "HostEventLogData.taskId":
		if e.complexity.HostEventLogData.TaskId == nil {
			break
		}

		return e.complexity.HostEventLogData.TaskId(childComplexity), true

	case "HostEventLogData.taskPid":
		if e.complexity.HostEventLogData.TaskPid == nil {
			break
		}

		return e.complexity.HostEventLogData.TaskPid(childComplexity), true

	case "HostEventLogData.taskStatus":
		if e.complexity.HostEventLogData.TaskStatus == nil {
			break
		}

		return e.complexity.HostEventLogData.TaskStatus(childComplexity), true

	case "HostEventLogData.user":
		if e.complexity.HostEventLogData.User == nil {
			break
		}

		return e.complexity.HostEventLogData.User(childComplexity), true

	case "HostEventLogEntry.data":
		if e.complexity.HostEventLogEntry.Data == nil {
			break
		}

		return e.complexity.HostEventLogEntry.Data(childComplexity), true

	case "HostEventLogEntry.eventType":
		if e.complexity.HostEventLogEntry.EventType == nil {
			break
		}

		return e.complexity.HostEventLogEntry.EventType(childComplexity), true

	case "HostEventLogEntry.id":
		if e.complexity.HostEventLogEntry.ID == nil {
			break
		}

		return e.complexity.HostEventLogEntry.ID(childComplexity), true

	case "HostEventLogEntry.processedAt":
		if e.complexity.HostEventLogEntry.ProcessedAt == nil {
			break
		}

		return e.complexity.HostEventLogEntry.ProcessedAt(childComplexity), true

	case "HostEventLogEntry.resourceId":
		if e.complexity.HostEventLogEntry.ResourceId == nil {
			break
		}

		return e.complexity.HostEventLogEntry.ResourceId(childComplexity), true

	case "HostEventLogEntry.resourceType":
		if e.complexity.HostEventLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.HostEventLogEntry.ResourceType(childComplexity), true

	case "HostEventLogEntry.timestamp":
		if e.complexity.HostEventLogEntry.Timestamp == nil {
			break
		}

		return e.complexity.HostEventLogEntry.Timestamp(childComplexity), true

	case "HostEvents.count":
		if e.complexity.HostEvents.Count == nil {
			break
		}

		return e.complexity.HostEvents.Count(childComplexity), true

	case "HostEvents.eventLogEntries":
		if e.complexity.HostEvents.EventLogEntries == nil {
			break
		}

		return e.complexity.HostEvents.EventLogEntries(childComplexity), true

	case "HostInitConfig.cloudStatusBatchSize":
		if e.complexity.HostInitConfig.CloudStatusBatchSize == nil {
			break
		}

		return e.complexity.HostInitConfig.CloudStatusBatchSize(childComplexity), true

	case "HostInitConfig.hostThrottle":
		if e.complexity.HostInitConfig.HostThrottle == nil {
			break
		}

		return e.complexity.HostInitConfig.HostThrottle(childComplexity), true

	case "HostInitConfig.maxTotalDynamicHosts":
		if e.complexity.HostInitConfig.MaxTotalDynamicHosts == nil {
			break
		}

		return e.complexity.HostInitConfig.MaxTotalDynamicHosts(childComplexity), true

	case "HostInitConfig.provisioningThrottle":
		if e.complexity.HostInitConfig.ProvisioningThrottle == nil {
			break
		}

		return e.complexity.HostInitConfig.ProvisioningThrottle(childComplexity), true

	case "HostsResponse.filteredHostsCount":
		if e.complexity.HostsResponse.FilteredHostsCount == nil {
			break
		}

		return e.complexity.HostsResponse.FilteredHostsCount(childComplexity), true

	case "HostsResponse.hosts":
		if e.complexity.HostsResponse.Hosts == nil {
			break
		}

		return e.complexity.HostsResponse.Hosts(childComplexity), true

	case "HostsResponse.totalHostsCount":
		if e.complexity.HostsResponse.TotalHostsCount == nil {
			break
		}

		return e.complexity.HostsResponse.TotalHostsCount(childComplexity), true

	case "IceCreamSettings.configPath":
		if e.complexity.IceCreamSettings.ConfigPath == nil {
			break
		}

		return e.complexity.IceCreamSettings.ConfigPath(childComplexity), true

	case "IceCreamSettings.schedulerHost":
		if e.complexity.IceCreamSettings.SchedulerHost == nil {
			break
		}

		return e.complexity.IceCreamSettings.SchedulerHost(childComplexity), true

	case "Image.ami":
		if e.complexity.Image.AMI == nil {
			break
		}

		return e.complexity.Image.AMI(childComplexity), true

	case "Image.distros":
		if e.complexity.Image.Distros == nil {
			break
		}

		return e.complexity.Image.Distros(childComplexity), true

	case "Image.events":
		if e.complexity.Image.Events == nil {
			break
		}

		args, err := ec.field_Image_events_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Image.Events(childComplexity, args["limit"].(int), args["page"].(int)), true

	case "Image.id":
		if e.complexity.Image.ID == nil {
			break
		}

		return e.complexity.Image.ID(childComplexity), true

	case "Image.lastDeployed":
		if e.complexity.Image.LastDeployed == nil {
			break
		}

		return e.complexity.Image.LastDeployed(childComplexity), true

	case "Image.latestTask":
		if e.complexity.Image.LatestTask == nil {
			break
		}

		return e.complexity.Image.LatestTask(childComplexity), true

	case "Image.operatingSystem":
		if e.complexity.Image.OperatingSystem == nil {
			break
		}

		args, err := ec.field_Image_operatingSystem_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Image.OperatingSystem(childComplexity, args["opts"].(thirdparty.OSInfoFilterOptions)), true

	case "Image.packages":
		if e.complexity.Image.Packages == nil {
			break
		}

		args, err := ec.field_Image_packages_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Image.Packages(childComplexity, args["opts"].(thirdparty.PackageFilterOptions)), true

	case "Image.toolchains":
		if e.complexity.Image.Toolchains == nil {
			break
		}

		args, err := ec.field_Image_toolchains_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Image.Toolchains(childComplexity, args["opts"].(thirdparty.ToolchainFilterOptions)), true

	case "ImageEvent.amiAfter":
		if e.complexity.ImageEvent.AMIAfter == nil {
			break
		}

		return e.complexity.ImageEvent.AMIAfter(childComplexity), true

	case "ImageEvent.amiBefore":
		if e.complexity.ImageEvent.AMIBefore == nil {
			break
		}

		return e.complexity.ImageEvent.AMIBefore(childComplexity), true

	case "ImageEvent.entries":
		if e.complexity.ImageEvent.Entries == nil {
			break
		}

		return e.complexity.ImageEvent.Entries(childComplexity), true

	case "ImageEvent.timestamp":
		if e.complexity.ImageEvent.Timestamp == nil {
			break
		}

		return e.complexity.ImageEvent.Timestamp(childComplexity), true

	case "ImageEventEntry.action":
		if e.complexity.ImageEventEntry.Action == nil {
			break
		}

		return e.complexity.ImageEventEntry.Action(childComplexity), true

	case "ImageEventEntry.after":
		if e.complexity.ImageEventEntry.After == nil {
			break
		}

		return e.complexity.ImageEventEntry.After(childComplexity), true

	case "ImageEventEntry.before":
		if e.complexity.ImageEventEntry.Before == nil {
			break
		}

		return e.complexity.ImageEventEntry.Before(childComplexity), true

	case "ImageEventEntry.name":
		if e.complexity.ImageEventEntry.Name == nil {
			break
		}

		return e.complexity.ImageEventEntry.Name(childComplexity), true

	case "ImageEventEntry.type":
		if e.complexity.ImageEventEntry.Type == nil {
			break
		}

		return e.complexity.ImageEventEntry.Type(childComplexity), true

	case "ImageEventsPayload.count":
		if e.complexity.ImageEventsPayload.Count == nil {
			break
		}

		return e.complexity.ImageEventsPayload.Count(childComplexity), true

	case "ImageEventsPayload.eventLogEntries":
		if e.complexity.ImageEventsPayload.EventLogEntries == nil {
			break
		}

		return e.complexity.ImageEventsPayload.EventLogEntries(childComplexity), true

	case "ImageOperatingSystemPayload.data":
		if e.complexity.ImageOperatingSystemPayload.Data == nil {
			break
		}

		return e.complexity.ImageOperatingSystemPayload.Data(childComplexity), true

	case "ImageOperatingSystemPayload.filteredCount":
		if e.complexity.ImageOperatingSystemPayload.FilteredCount == nil {
			break
		}

		return e.complexity.ImageOperatingSystemPayload.FilteredCount(childComplexity), true

	case "ImageOperatingSystemPayload.totalCount":
		if e.complexity.ImageOperatingSystemPayload.TotalCount == nil {
			break
		}

		return e.complexity.ImageOperatingSystemPayload.TotalCount(childComplexity), true

	case "ImagePackagesPayload.data":
		if e.complexity.ImagePackagesPayload.Data == nil {
			break
		}

		return e.complexity.ImagePackagesPayload.Data(childComplexity), true

	case "ImagePackagesPayload.filteredCount":
		if e.complexity.ImagePackagesPayload.FilteredCount == nil {
			break
		}

		return e.complexity.ImagePackagesPayload.FilteredCount(childComplexity), true

	case "ImagePackagesPayload.totalCount":
		if e.complexity.ImagePackagesPayload.TotalCount == nil {
			break
		}

		return e.complexity.ImagePackagesPayload.TotalCount(childComplexity), true

	case "ImageToolchainsPayload.data":
		if e.complexity.ImageToolchainsPayload.Data == nil {
			break
		}

		return e.complexity.ImageToolchainsPayload.Data(childComplexity), true

	case "ImageToolchainsPayload.filteredCount":
		if e.complexity.ImageToolchainsPayload.FilteredCount == nil {
			break
		}

		return e.complexity.ImageToolchainsPayload.FilteredCount(childComplexity), true

	case "ImageToolchainsPayload.totalCount":
		if e.complexity.ImageToolchainsPayload.TotalCount == nil {
			break
		}

		return e.complexity.ImageToolchainsPayload.TotalCount(childComplexity), true

	case "InstanceTag.canBeModified":
		if e.complexity.InstanceTag.CanBeModified == nil {
			break
		}

		return e.complexity.InstanceTag.CanBeModified(childComplexity), true

	case "InstanceTag.key":
		if e.complexity.InstanceTag.Key == nil {
			break
		}

		return e.complexity.InstanceTag.Key(childComplexity), true

	case "InstanceTag.value":
		if e.complexity.InstanceTag.Value == nil {
			break
		}

		return e.complexity.InstanceTag.Value(childComplexity), true

	case "IssueLink.confidenceScore":
		if e.complexity.IssueLink.ConfidenceScore == nil {
			break
		}

		return e.complexity.IssueLink.ConfidenceScore(childComplexity), true

	case "IssueLink.issueKey":
		if e.complexity.IssueLink.IssueKey == nil {
			break
		}

		return e.complexity.IssueLink.IssueKey(childComplexity), true

	case "IssueLink.jiraTicket":
		if e.complexity.IssueLink.JiraTicket == nil {
			break
		}

		return e.complexity.IssueLink.JiraTicket(childComplexity), true

	case "IssueLink.source":
		if e.complexity.IssueLink.Source == nil {
			break
		}

		return e.complexity.IssueLink.Source(childComplexity), true

	case "IssueLink.url":
		if e.complexity.IssueLink.URL == nil {
			break
		}

		return e.complexity.IssueLink.URL(childComplexity), true

	case "JiraConfig.email":
		if e.complexity.JiraConfig.Email == nil {
			break
		}

		return e.complexity.JiraConfig.Email(childComplexity), true

	case "JiraConfig.host":
		if e.complexity.JiraConfig.Host == nil {
			break
		}

		return e.complexity.JiraConfig.Host(childComplexity), true

	case "JiraConfig.personalAccessToken":
		if e.complexity.JiraConfig.PersonalAccessToken == nil {
			break
		}

		return e.complexity.JiraConfig.PersonalAccessToken(childComplexity), true

	case "JiraIssueSubscriber.issueType":
		if e.complexity.JiraIssueSubscriber.IssueType == nil {
			break
		}

		return e.complexity.JiraIssueSubscriber.IssueType(childComplexity), true

	case "JiraIssueSubscriber.project":
		if e.complexity.JiraIssueSubscriber.Project == nil {
			break
		}

		return e.complexity.JiraIssueSubscriber.Project(childComplexity), true

	case "JiraStatus.id":
		if e.complexity.JiraStatus.Id == nil {
			break
		}

		return e.complexity.JiraStatus.Id(childComplexity), true

	case "JiraStatus.name":
		if e.complexity.JiraStatus.Name == nil {
			break
		}

		return e.complexity.JiraStatus.Name(childComplexity), true

	case "JiraTicket.fields":
		if e.complexity.JiraTicket.Fields == nil {
			break
		}

		return e.complexity.JiraTicket.Fields(childComplexity), true

	case "JiraTicket.key":
		if e.complexity.JiraTicket.Key == nil {
			break
		}

		return e.complexity.JiraTicket.Key(childComplexity), true

	case "KanopyAuthConfig.headerName":
		if e.complexity.KanopyAuthConfig.HeaderName == nil {
			break
		}

		return e.complexity.KanopyAuthConfig.HeaderName(childComplexity), true

	case "KanopyAuthConfig.issuer":
		if e.complexity.KanopyAuthConfig.Issuer == nil {
			break
		}

		return e.complexity.KanopyAuthConfig.Issuer(childComplexity), true

	case "KanopyAuthConfig.keysetURL":
		if e.complexity.KanopyAuthConfig.KeysetURL == nil {
			break
		}

		return e.complexity.KanopyAuthConfig.KeysetURL(childComplexity), true

	case "LogBuffering.count":
		if e.complexity.LogBuffering.Count == nil {
			break
		}

		return e.complexity.LogBuffering.Count(childComplexity), true

	case "LogBuffering.durationSeconds":
		if e.complexity.LogBuffering.DurationSeconds == nil {
			break
		}

		return e.complexity.LogBuffering.DurationSeconds(childComplexity), true

	case "LogBuffering.incomingBufferFactor":
		if e.complexity.LogBuffering.IncomingBufferFactor == nil {
			break
		}

		return e.complexity.LogBuffering.IncomingBufferFactor(childComplexity), true

	case "LogBuffering.useAsync":
		if e.complexity.LogBuffering.UseAsync == nil {
			break
		}

		return e.complexity.LogBuffering.UseAsync(childComplexity), true

	case "LogMessage.message":
		if e.complexity.LogMessage.Message == nil {
			break
		}

		return e.complexity.LogMessage.Message(childComplexity), true

	case "LogMessage.severity":
		if e.complexity.LogMessage.Severity == nil {
			break
		}

		return e.complexity.LogMessage.Severity(childComplexity), true

	case "LogMessage.timestamp":
		if e.complexity.LogMessage.Timestamp == nil {
			break
		}

		return e.complexity.LogMessage.Timestamp(childComplexity), true

	case "LogMessage.type":
		if e.complexity.LogMessage.Type == nil {
			break
		}

		return e.complexity.LogMessage.Type(childComplexity), true

	case "LogMessage.version":
		if e.complexity.LogMessage.Version == nil {
			break
		}

		return e.complexity.LogMessage.Version(childComplexity), true

	case "LoggerConfig.buffer":
		if e.complexity.LoggerConfig.Buffer == nil {
			break
		}

		return e.complexity.LoggerConfig.Buffer(childComplexity), true

	case "LoggerConfig.defaultLevel":
		if e.complexity.LoggerConfig.DefaultLevel == nil {
			break
		}

		return e.complexity.LoggerConfig.DefaultLevel(childComplexity), true

	case "LoggerConfig.logkeeperURL":
		if e.complexity.LoggerConfig.LogkeeperURL == nil {
			break
		}

		return e.complexity.LoggerConfig.LogkeeperURL(childComplexity), true

	case "LoggerConfig.redactKeys":
		if e.complexity.LoggerConfig.RedactKeys == nil {
			break
		}

		return e.complexity.LoggerConfig.RedactKeys(childComplexity), true

	case "LoggerConfig.thresholdLevel":
		if e.complexity.LoggerConfig.ThresholdLevel == nil {
			break
		}

		return e.complexity.LoggerConfig.ThresholdLevel(childComplexity), true

	case "LogkeeperBuild.buildNum":
		if e.complexity.LogkeeperBuild.BuildNum == nil {
			break
		}

		return e.complexity.LogkeeperBuild.BuildNum(childComplexity), true

	case "LogkeeperBuild.builder":
		if e.complexity.LogkeeperBuild.Builder == nil {
			break
		}

		return e.complexity.LogkeeperBuild.Builder(childComplexity), true

	case "LogkeeperBuild.id":
		if e.complexity.LogkeeperBuild.ID == nil {
			break
		}

		return e.complexity.LogkeeperBuild.ID(childComplexity), true

	case "LogkeeperBuild.task":
		if e.complexity.LogkeeperBuild.Task == nil {
			break
		}

		return e.complexity.LogkeeperBuild.Task(childComplexity), true

	case "LogkeeperBuild.taskExecution":
		if e.complexity.LogkeeperBuild.TaskExecution == nil {
			break
		}

		return e.complexity.LogkeeperBuild.TaskExecution(childComplexity), true

	case "LogkeeperBuild.taskId":
		if e.complexity.LogkeeperBuild.TaskID == nil {
			break
		}

		return e.complexity.LogkeeperBuild.TaskID(childComplexity), true

	case "LogkeeperBuild.tests":
		if e.complexity.LogkeeperBuild.Tests == nil {
			break
		}

		return e.complexity.LogkeeperBuild.Tests(childComplexity), true

	case "LogkeeperTest.buildId":
		if e.complexity.LogkeeperTest.BuildID == nil {
			break
		}

		return e.complexity.LogkeeperTest.BuildID(childComplexity), true

	case "LogkeeperTest.command":
		if e.complexity.LogkeeperTest.Command == nil {
			break
		}

		return e.complexity.LogkeeperTest.Command(childComplexity), true

	case "LogkeeperTest.id":
		if e.complexity.LogkeeperTest.ID == nil {
			break
		}

		return e.complexity.LogkeeperTest.ID(childComplexity), true

	case "LogkeeperTest.name":
		if e.complexity.LogkeeperTest.Name == nil {
			break
		}

		return e.complexity.LogkeeperTest.Name(childComplexity), true

	case "LogkeeperTest.phase":
		if e.complexity.LogkeeperTest.Phase == nil {
			break
		}

		return e.complexity.LogkeeperTest.Phase(childComplexity), true

	case "LogkeeperTest.taskExecution":
		if e.complexity.LogkeeperTest.TaskExecution == nil {
			break
		}

		return e.complexity.LogkeeperTest.TaskExecution(childComplexity), true

	case "LogkeeperTest.taskId":
		if e.complexity.LogkeeperTest.TaskID == nil {
			break
		}

		return e.complexity.LogkeeperTest.TaskID(childComplexity), true

	case "MainlineCommitVersion.rolledUpVersions":
		if e.complexity.MainlineCommitVersion.RolledUpVersions == nil {
			break
		}

		return e.complexity.MainlineCommitVersion.RolledUpVersions(childComplexity), true

	case "MainlineCommitVersion.version":
		if e.complexity.MainlineCommitVersion.Version == nil {
			break
		}

		return e.complexity.MainlineCommitVersion.Version(childComplexity), true

	case "MainlineCommits.nextPageOrderNumber":
		if e.complexity.MainlineCommits.NextPageOrderNumber == nil {
			break
		}

		return e.complexity.MainlineCommits.NextPageOrderNumber(childComplexity), true

	case "MainlineCommits.prevPageOrderNumber":
		if e.complexity.MainlineCommits.PrevPageOrderNumber == nil {
			break
		}

		return e.complexity.MainlineCommits.PrevPageOrderNumber(childComplexity), true

	case "MainlineCommits.versions":
		if e.complexity.MainlineCommits.Versions == nil {
			break
		}

		return e.complexity.MainlineCommits.Versions(childComplexity), true

	case "Manifest.branch":
		if e.complexity.Manifest.Branch == nil {
			break
		}

		return e.complexity.Manifest.Branch(childComplexity), true

	case "Manifest.id":
		if e.complexity.Manifest.ID == nil {
			break
		}

		return e.complexity.Manifest.ID(childComplexity), true

	case "Manifest.isBase":
		if e.complexity.Manifest.IsBase == nil {
			break
		}

		return e.complexity.Manifest.IsBase(childComplexity), true

	case "Manifest.moduleOverrides":
		if e.complexity.Manifest.ModuleOverrides == nil {
			break
		}

		return e.complexity.Manifest.ModuleOverrides(childComplexity), true

	case "Manifest.modules":
		if e.complexity.Manifest.Modules == nil {
			break
		}

		return e.complexity.Manifest.Modules(childComplexity), true

	case "Manifest.project":
		if e.complexity.Manifest.Project == nil {
			break
		}

		return e.complexity.Manifest.Project(childComplexity), true

	case "Manifest.revision":
		if e.complexity.Manifest.Revision == nil {
			break
		}

		return e.complexity.Manifest.Revision(childComplexity), true

	case "MetadataLink.source":
		if e.complexity.MetadataLink.Source == nil {
			break
		}

		return e.complexity.MetadataLink.Source(childComplexity), true

	case "MetadataLink.text":
		if e.complexity.MetadataLink.Text == nil {
			break
		}

		return e.complexity.MetadataLink.Text(childComplexity), true

	case "MetadataLink.url":
		if e.complexity.MetadataLink.URL == nil {
			break
		}

		return e.complexity.MetadataLink.URL(childComplexity), true

	case "ModuleCodeChange.branchName":
		if e.complexity.ModuleCodeChange.BranchName == nil {
			break
		}

		return e.complexity.ModuleCodeChange.BranchName(childComplexity), true

	case "ModuleCodeChange.fileDiffs":
		if e.complexity.ModuleCodeChange.FileDiffs == nil {
			break
		}

		return e.complexity.ModuleCodeChange.FileDiffs(childComplexity), true

	case "ModuleCodeChange.htmlLink":
		if e.complexity.ModuleCodeChange.HTMLLink == nil {
			break
		}

		return e.complexity.ModuleCodeChange.HTMLLink(childComplexity), true

	case "ModuleCodeChange.rawLink":
		if e.complexity.ModuleCodeChange.RawLink == nil {
			break
		}

		return e.complexity.ModuleCodeChange.RawLink(childComplexity), true

	case "MultiAuthConfig.readOnly":
		if e.complexity.MultiAuthConfig.ReadOnly == nil {
			break
		}

		return e.complexity.MultiAuthConfig.ReadOnly(childComplexity), true

	case "MultiAuthConfig.readWrite":
		if e.complexity.MultiAuthConfig.ReadWrite == nil {
			break
		}

		return e.complexity.MultiAuthConfig.ReadWrite(childComplexity), true

	case "Mutation.abortTask":
		if e.complexity.Mutation.AbortTask == nil {
			break
		}

		args, err := ec.field_Mutation_abortTask_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AbortTask(childComplexity, args["taskId"].(string)), true

	case "Mutation.addAnnotationIssue":
		if e.complexity.Mutation.AddAnnotationIssue == nil {
			break
		}

		args, err := ec.field_Mutation_addAnnotationIssue_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddAnnotationIssue(childComplexity, args["taskId"].(string), args["execution"].(int), args["apiIssue"].(model.APIIssueLink), args["isIssue"].(bool)), true

	case "Mutation.addFavoriteProject":
		if e.complexity.Mutation.AddFavoriteProject == nil {
			break
		}

		args, err := ec.field_Mutation_addFavoriteProject_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddFavoriteProject(childComplexity, args["opts"].(AddFavoriteProjectInput)), true

	case "Mutation.attachProjectToNewRepo":
		if e.complexity.Mutation.AttachProjectToNewRepo == nil {
			break
		}

		args, err := ec.field_Mutation_attachProjectToNewRepo_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AttachProjectToNewRepo(childComplexity, args["project"].(MoveProjectInput)), true

	case "Mutation.attachProjectToRepo":
		if e.complexity.Mutation.AttachProjectToRepo == nil {
			break
		}

		args, err := ec.field_Mutation_attachProjectToRepo_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AttachProjectToRepo(childComplexity, args["projectId"].(string)), true

	case "Mutation.attachVolumeToHost":
		if e.complexity.Mutation.AttachVolumeToHost == nil {
			break
		}

		args, err := ec.field_Mutation_attachVolumeToHost_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AttachVolumeToHost(childComplexity, args["volumeAndHost"].(VolumeHost)), true

	case "Mutation.bbCreateTicket":
		if e.complexity.Mutation.BbCreateTicket == nil {
			break
		}

		args, err := ec.field_Mutation_bbCreateTicket_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BbCreateTicket(childComplexity, args["taskId"].(string), args["execution"].(*int)), true

	case "Mutation.clearMySubscriptions":
		if e.complexity.Mutation.ClearMySubscriptions == nil {
			break
		}

		return e.complexity.Mutation.ClearMySubscriptions(childComplexity), true

	case "Mutation.copyDistro":
		if e.complexity.Mutation.CopyDistro == nil {
			break
		}

		args, err := ec.field_Mutation_copyDistro_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CopyDistro(childComplexity, args["opts"].(model.CopyDistroOpts)), true

	case "Mutation.copyProject":
		if e.complexity.Mutation.CopyProject == nil {
			break
		}

		args, err := ec.field_Mutation_copyProject_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CopyProject(childComplexity, args["project"].(model.CopyProjectOpts), args["requestS3Creds"].(*bool)), true

	case "Mutation.createDistro":
		if e.complexity.Mutation.CreateDistro == nil {
			break
		}

		args, err := ec.field_Mutation_createDistro_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateDistro(childComplexity, args["opts"].(CreateDistroInput)), true

	case "Mutation.createProject":
		if e.complexity.Mutation.CreateProject == nil {
			break
		}

		args, err := ec.field_Mutation_createProject_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateProject(childComplexity, args["project"].(model.APIProjectRef), args["requestS3Creds"].(*bool)), true

	case "Mutation.createPublicKey":
		if e.complexity.Mutation.CreatePublicKey == nil {
			break
		}

		args, err := ec.field_Mutation_createPublicKey_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreatePublicKey(childComplexity, args["publicKeyInput"].(PublicKeyInput)), true

	case "Mutation.deactivateStepbackTask":
		if e.complexity.Mutation.DeactivateStepbackTask == nil {
			break
		}

		args, err := ec.field_Mutation_deactivateStepbackTask_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeactivateStepbackTask(childComplexity, args["opts"].(DeactivateStepbackTaskInput)), true

	case "Mutation.defaultSectionToRepo":
		if e.complexity.Mutation.DefaultSectionToRepo == nil {
			break
		}

		args, err := ec.field_Mutation_defaultSectionToRepo_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DefaultSectionToRepo(childComplexity, args["opts"].(DefaultSectionToRepoInput)), true

	case "Mutation.deleteDistro":
		if e.complexity.Mutation.DeleteDistro == nil {
			break
		}

		args, err := ec.field_Mutation_deleteDistro_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteDistro(childComplexity, args["opts"].(DeleteDistroInput)), true

	case "Mutation.deleteGithubAppCredentials":
		if e.complexity.Mutation.DeleteGithubAppCredentials == nil {
			break
		}

		args, err := ec.field_Mutation_deleteGithubAppCredentials_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteGithubAppCredentials(childComplexity, args["opts"].(DeleteGithubAppCredentialsInput)), true

	case "Mutation.deleteProject":
		if e.complexity.Mutation.DeleteProject == nil {
			break
		}

		args, err := ec.field_Mutation_deleteProject_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteProject(childComplexity, args["projectId"].(string)), true

	case "Mutation.deleteSubscriptions":
		if e.complexity.Mutation.DeleteSubscriptions == nil {
			break
		}

		args, err := ec.field_Mutation_deleteSubscriptions_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteSubscriptions(childComplexity, args["subscriptionIds"].([]string)), true

	case "Mutation.detachProjectFromRepo":
		if e.complexity.Mutation.DetachProjectFromRepo == nil {
			break
		}

		args, err := ec.field_Mutation_detachProjectFromRepo_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DetachProjectFromRepo(childComplexity, args["projectId"].(string)), true

	case "Mutation.detachVolumeFromHost":
		if e.complexity.Mutation.DetachVolumeFromHost == nil {
			break
		}

		args, err := ec.field_Mutation_detachVolumeFromHost_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DetachVolumeFromHost(childComplexity, args["volumeId"].(string)), true

	case "Mutation.editAnnotationNote":
		if e.complexity.Mutation.EditAnnotationNote == nil {
			break
		}

		args, err := ec.field_Mutation_editAnnotationNote_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.EditAnnotationNote(childComplexity, args["taskId"].(string), args["execution"].(int), args["originalMessage"].(string), args["newMessage"].(string)), true

	case "Mutation.editSpawnHost":
		if e.complexity.Mutation.EditSpawnHost == nil {
			break
		}

		args, err := ec.field_Mutation_editSpawnHost_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.EditSpawnHost(childComplexity, args["spawnHost"].(*EditSpawnHostInput)), true

	case "Mutation.forceRepotrackerRun":
		if e.complexity.Mutation.ForceRepotrackerRun == nil {
			break
		}

		args, err := ec.field_Mutation_forceRepotrackerRun_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ForceRepotrackerRun(childComplexity, args["projectId"].(string)), true

	case "Mutation.migrateVolume":
		if e.complexity.Mutation.MigrateVolume == nil {
			break
		}

		args, err := ec.field_Mutation_migrateVolume_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MigrateVolume(childComplexity, args["volumeId"].(string), args["spawnHostInput"].(*SpawnHostInput)), true

	case "Mutation.moveAnnotationIssue":
		if e.complexity.Mutation.MoveAnnotationIssue == nil {
			break
		}

		args, err := ec.field_Mutation_moveAnnotationIssue_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MoveAnnotationIssue(childComplexity, args["taskId"].(string), args["execution"].(int), args["apiIssue"].(model.APIIssueLink), args["isIssue"].(bool)), true

	case "Mutation.overrideTaskDependencies":
		if e.complexity.Mutation.OverrideTaskDependencies == nil {
			break
		}

		args, err := ec.field_Mutation_overrideTaskDependencies_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.OverrideTaskDependencies(childComplexity, args["taskId"].(string)), true

	case "Mutation.promoteVarsToRepo":
		if e.complexity.Mutation.PromoteVarsToRepo == nil {
			break
		}

		args, err := ec.field_Mutation_promoteVarsToRepo_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PromoteVarsToRepo(childComplexity, args["opts"].(PromoteVarsToRepoInput)), true

	case "Mutation.removeAnnotationIssue":
		if e.complexity.Mutation.RemoveAnnotationIssue == nil {
			break
		}

		args, err := ec.field_Mutation_removeAnnotationIssue_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveAnnotationIssue(childComplexity, args["taskId"].(string), args["execution"].(int), args["apiIssue"].(model.APIIssueLink), args["isIssue"].(bool)), true

	case "Mutation.removeFavoriteProject":
		if e.complexity.Mutation.RemoveFavoriteProject == nil {
			break
		}

		args, err := ec.field_Mutation_removeFavoriteProject_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveFavoriteProject(childComplexity, args["opts"].(RemoveFavoriteProjectInput)), true

	case "Mutation.removePublicKey":
		if e.complexity.Mutation.RemovePublicKey == nil {
			break
		}

		args, err := ec.field_Mutation_removePublicKey_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemovePublicKey(childComplexity, args["keyName"].(string)), true

	case "Mutation.removeVolume":
		if e.complexity.Mutation.RemoveVolume == nil {
			break
		}

		args, err := ec.field_Mutation_removeVolume_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveVolume(childComplexity, args["volumeId"].(string)), true

	case "Mutation.reprovisionToNew":
		if e.complexity.Mutation.ReprovisionToNew == nil {
			break
		}

		args, err := ec.field_Mutation_reprovisionToNew_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ReprovisionToNew(childComplexity, args["hostIds"].([]string)), true

	case "Mutation.restartAdminTasks":
		if e.complexity.Mutation.RestartAdminTasks == nil {
			break
		}

		args, err := ec.field_Mutation_restartAdminTasks_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RestartAdminTasks(childComplexity, args["opts"].(model1.RestartOptions)), true

	case "Mutation.restartJasper":
		if e.complexity.Mutation.RestartJasper == nil {
			break
		}

		args, err := ec.field_Mutation_restartJasper_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RestartJasper(childComplexity, args["hostIds"].([]string)), true

	case "Mutation.restartTask":
		if e.complexity.Mutation.RestartTask == nil {
			break
		}

		args, err := ec.field_Mutation_restartTask_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RestartTask(childComplexity, args["taskId"].(string), args["failedOnly"].(bool)), true

	case "Mutation.restartVersions":
		if e.complexity.Mutation.RestartVersions == nil {
			break
		}

		args, err := ec.field_Mutation_restartVersions_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RestartVersions(childComplexity, args["versionId"].(string), args["abort"].(bool), args["versionsToRestart"].([]*model1.VersionToRestart)), true

	case "Mutation.saveAdminSettings":
		if e.complexity.Mutation.SaveAdminSettings == nil {
			break
		}

		args, err := ec.field_Mutation_saveAdminSettings_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SaveAdminSettings(childComplexity, args["adminSettings"].(model.APIAdminSettings)), true

	case "Mutation.saveDistro":
		if e.complexity.Mutation.SaveDistro == nil {
			break
		}

		args, err := ec.field_Mutation_saveDistro_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SaveDistro(childComplexity, args["opts"].(SaveDistroInput)), true

	case "Mutation.saveProjectSettingsForSection":
		if e.complexity.Mutation.SaveProjectSettingsForSection == nil {
			break
		}

		args, err := ec.field_Mutation_saveProjectSettingsForSection_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SaveProjectSettingsForSection(childComplexity, args["projectSettings"].(*model.APIProjectSettings), args["section"].(ProjectSettingsSection)), true

	case "Mutation.saveRepoSettingsForSection":
		if e.complexity.Mutation.SaveRepoSettingsForSection == nil {
			break
		}

		args, err := ec.field_Mutation_saveRepoSettingsForSection_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SaveRepoSettingsForSection(childComplexity, args["repoSettings"].(*model.APIProjectSettings), args["section"].(ProjectSettingsSection)), true

	case "Mutation.saveSubscription":
		if e.complexity.Mutation.SaveSubscription == nil {
			break
		}

		args, err := ec.field_Mutation_saveSubscription_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SaveSubscription(childComplexity, args["subscription"].(model.APISubscription)), true

	case "Mutation.schedulePatch":
		if e.complexity.Mutation.SchedulePatch == nil {
			break
		}

		args, err := ec.field_Mutation_schedulePatch_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SchedulePatch(childComplexity, args["patchId"].(string), args["configure"].(PatchConfigure)), true

	case "Mutation.scheduleTasks":
		if e.complexity.Mutation.ScheduleTasks == nil {
			break
		}

		args, err := ec.field_Mutation_scheduleTasks_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ScheduleTasks(childComplexity, args["versionId"].(string), args["taskIds"].([]string)), true

	case "Mutation.scheduleUndispatchedBaseTasks":
		if e.complexity.Mutation.ScheduleUndispatchedBaseTasks == nil {
			break
		}

		args, err := ec.field_Mutation_scheduleUndispatchedBaseTasks_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ScheduleUndispatchedBaseTasks(childComplexity, args["versionId"].(string)), true

	case "Mutation.setAnnotationMetadataLinks":
		if e.complexity.Mutation.SetAnnotationMetadataLinks == nil {
			break
		}

		args, err := ec.field_Mutation_setAnnotationMetadataLinks_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetAnnotationMetadataLinks(childComplexity, args["taskId"].(string), args["execution"].(int), args["metadataLinks"].([]*model.APIMetadataLink)), true

	case "Mutation.setLastRevision":
		if e.complexity.Mutation.SetLastRevision == nil {
			break
		}

		args, err := ec.field_Mutation_setLastRevision_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetLastRevision(childComplexity, args["opts"].(SetLastRevisionInput)), true

	case "Mutation.setPatchVisibility":
		if e.complexity.Mutation.SetPatchVisibility == nil {
			break
		}

		args, err := ec.field_Mutation_setPatchVisibility_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetPatchVisibility(childComplexity, args["patchIds"].([]string), args["hidden"].(bool)), true

	case "Mutation.setTaskPriorities":
		if e.complexity.Mutation.SetTaskPriorities == nil {
			break
		}

		args, err := ec.field_Mutation_setTaskPriorities_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetTaskPriorities(childComplexity, args["taskPriorities"].([]*TaskPriority)), true

	case "Mutation.setTaskPriority":
		if e.complexity.Mutation.SetTaskPriority == nil {
			break
		}

		args, err := ec.field_Mutation_setTaskPriority_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetTaskPriority(childComplexity, args["taskId"].(string), args["priority"].(int)), true

	case "Mutation.setVersionPriority":
		if e.complexity.Mutation.SetVersionPriority == nil {
			break
		}

		args, err := ec.field_Mutation_setVersionPriority_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetVersionPriority(childComplexity, args["versionId"].(string), args["priority"].(int)), true

	case "Mutation.spawnHost":
		if e.complexity.Mutation.SpawnHost == nil {
			break
		}

		args, err := ec.field_Mutation_spawnHost_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SpawnHost(childComplexity, args["spawnHostInput"].(*SpawnHostInput)), true

	case "Mutation.spawnVolume":
		if e.complexity.Mutation.SpawnVolume == nil {
			break
		}

		args, err := ec.field_Mutation_spawnVolume_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SpawnVolume(childComplexity, args["spawnVolumeInput"].(SpawnVolumeInput)), true

	case "Mutation.unscheduleTask":
		if e.complexity.Mutation.UnscheduleTask == nil {
			break
		}

		args, err := ec.field_Mutation_unscheduleTask_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UnscheduleTask(childComplexity, args["taskId"].(string)), true

	case "Mutation.unscheduleVersionTasks":
		if e.complexity.Mutation.UnscheduleVersionTasks == nil {
			break
		}

		args, err := ec.field_Mutation_unscheduleVersionTasks_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UnscheduleVersionTasks(childComplexity, args["versionId"].(string), args["abort"].(bool)), true

	case "Mutation.updateBetaFeatures":
		if e.complexity.Mutation.UpdateBetaFeatures == nil {
			break
		}

		args, err := ec.field_Mutation_updateBetaFeatures_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateBetaFeatures(childComplexity, args["opts"].(UpdateBetaFeaturesInput)), true

	case "Mutation.updateHostStatus":
		if e.complexity.Mutation.UpdateHostStatus == nil {
			break
		}

		args, err := ec.field_Mutation_updateHostStatus_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateHostStatus(childComplexity, args["hostIds"].([]string), args["status"].(string), args["notes"].(*string)), true

	case "Mutation.updateParsleySettings":
		if e.complexity.Mutation.UpdateParsleySettings == nil {
			break
		}

		args, err := ec.field_Mutation_updateParsleySettings_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateParsleySettings(childComplexity, args["opts"].(UpdateParsleySettingsInput)), true

	case "Mutation.updatePublicKey":
		if e.complexity.Mutation.UpdatePublicKey == nil {
			break
		}

		args, err := ec.field_Mutation_updatePublicKey_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdatePublicKey(childComplexity, args["targetKeyName"].(string), args["updateInfo"].(PublicKeyInput)), true

	case "Mutation.updateSpawnHostStatus":
		if e.complexity.Mutation.UpdateSpawnHostStatus == nil {
			break
		}

		args, err := ec.field_Mutation_updateSpawnHostStatus_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateSpawnHostStatus(childComplexity, args["updateSpawnHostStatusInput"].(UpdateSpawnHostStatusInput)), true

	case "Mutation.updateUserSettings":
		if e.complexity.Mutation.UpdateUserSettings == nil {
			break
		}

		args, err := ec.field_Mutation_updateUserSettings_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUserSettings(childComplexity, args["userSettings"].(*model.APIUserSettings)), true

	case "Mutation.updateVolume":
		if e.complexity.Mutation.UpdateVolume == nil {
			break
		}

		args, err := ec.field_Mutation_updateVolume_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateVolume(childComplexity, args["updateVolumeInput"].(UpdateVolumeInput)), true

	case "NaiveAuthConfig.users":
		if e.complexity.NaiveAuthConfig.Users == nil {
			break
		}

		return e.complexity.NaiveAuthConfig.Users(childComplexity), true

	case "NewDistroPayload.newDistroId":
		if e.complexity.NewDistroPayload.NewDistroID == nil {
			break
		}

		return e.complexity.NewDistroPayload.NewDistroID(childComplexity), true

	case "Note.message":
		if e.complexity.Note.Message == nil {
			break
		}

		return e.complexity.Note.Message(childComplexity), true

	case "Note.source":
		if e.complexity.Note.Source == nil {
			break
		}

		return e.complexity.Note.Source(childComplexity), true

	case "Notifications.buildBreak":
		if e.complexity.Notifications.BuildBreak == nil {
			break
		}

		return e.complexity.Notifications.BuildBreak(childComplexity), true

	case "Notifications.buildBreakId":
		if e.complexity.Notifications.BuildBreakID == nil {
			break
		}

		return e.complexity.Notifications.BuildBreakID(childComplexity), true

	case "Notifications.patchFinish":
		if e.complexity.Notifications.PatchFinish == nil {
			break
		}

		return e.complexity.Notifications.PatchFinish(childComplexity), true

	case "Notifications.patchFinishId":
		if e.complexity.Notifications.PatchFinishID == nil {
			break
		}

		return e.complexity.Notifications.PatchFinishID(childComplexity), true

	case "Notifications.patchFirstFailure":
		if e.complexity.Notifications.PatchFirstFailure == nil {
			break
		}

		return e.complexity.Notifications.PatchFirstFailure(childComplexity), true

	case "Notifications.patchFirstFailureId":
		if e.complexity.Notifications.PatchFirstFailureID == nil {
			break
		}

		return e.complexity.Notifications.PatchFirstFailureID(childComplexity), true

	case "Notifications.spawnHostExpiration":
		if e.complexity.Notifications.SpawnHostExpiration == nil {
			break
		}

		return e.complexity.Notifications.SpawnHostExpiration(childComplexity), true

	case "Notifications.spawnHostExpirationId":
		if e.complexity.Notifications.SpawnHostExpirationID == nil {
			break
		}

		return e.complexity.Notifications.SpawnHostExpirationID(childComplexity), true

	case "Notifications.spawnHostOutcome":
		if e.complexity.Notifications.SpawnHostOutcome == nil {
			break
		}

		return e.complexity.Notifications.SpawnHostOutcome(childComplexity), true

	case "Notifications.spawnHostOutcomeId":
		if e.complexity.Notifications.SpawnHostOutcomeID == nil {
			break
		}

		return e.complexity.Notifications.SpawnHostOutcomeID(childComplexity), true

	case "NotifyConfig.bufferIntervalSeconds":
		if e.complexity.NotifyConfig.BufferIntervalSeconds == nil {
			break
		}

		return e.complexity.NotifyConfig.BufferIntervalSeconds(childComplexity), true

	case "NotifyConfig.bufferTargetPerInterval":
		if e.complexity.NotifyConfig.BufferTargetPerInterval == nil {
			break
		}

		return e.complexity.NotifyConfig.BufferTargetPerInterval(childComplexity), true

	case "NotifyConfig.ses":
		if e.complexity.NotifyConfig.SES == nil {
			break
		}

		return e.complexity.NotifyConfig.SES(childComplexity), true

	case "OSInfo.name":
		if e.complexity.OSInfo.Name == nil {
			break
		}

		return e.complexity.OSInfo.Name(childComplexity), true

	case "OSInfo.version":
		if e.complexity.OSInfo.Version == nil {
			break
		}

		return e.complexity.OSInfo.Version(childComplexity), true

	case "OktaConfig.clientId":
		if e.complexity.OktaConfig.ClientID == nil {
			break
		}

		return e.complexity.OktaConfig.ClientID(childComplexity), true

	case "OktaConfig.clientSecret":
		if e.complexity.OktaConfig.ClientSecret == nil {
			break
		}

		return e.complexity.OktaConfig.ClientSecret(childComplexity), true

	case "OktaConfig.expireAfterMinutes":
		if e.complexity.OktaConfig.ExpireAfterMinutes == nil {
			break
		}

		return e.complexity.OktaConfig.ExpireAfterMinutes(childComplexity), true

	case "OktaConfig.issuer":
		if e.complexity.OktaConfig.Issuer == nil {
			break
		}

		return e.complexity.OktaConfig.Issuer(childComplexity), true

	case "OktaConfig.scopes":
		if e.complexity.OktaConfig.Scopes == nil {
			break
		}

		return e.complexity.OktaConfig.Scopes(childComplexity), true

	case "OktaConfig.userGroup":
		if e.complexity.OktaConfig.UserGroup == nil {
			break
		}

		return e.complexity.OktaConfig.UserGroup(childComplexity), true

	case "OomTrackerInfo.detected":
		if e.complexity.OomTrackerInfo.Detected == nil {
			break
		}

		return e.complexity.OomTrackerInfo.Detected(childComplexity), true

	case "OomTrackerInfo.pids":
		if e.complexity.OomTrackerInfo.Pids == nil {
			break
		}

		return e.complexity.OomTrackerInfo.Pids(childComplexity), true

	case "Package.manager":
		if e.complexity.Package.Manager == nil {
			break
		}

		return e.complexity.Package.Manager(childComplexity), true

	case "Package.name":
		if e.complexity.Package.Name == nil {
			break
		}

		return e.complexity.Package.Name(childComplexity), true

	case "Package.version":
		if e.complexity.Package.Version == nil {
			break
		}

		return e.complexity.Package.Version(childComplexity), true

	case "Parameter.key":
		if e.complexity.Parameter.Key == nil {
			break
		}

		return e.complexity.Parameter.Key(childComplexity), true

	case "Parameter.value":
		if e.complexity.Parameter.Value == nil {
			break
		}

		return e.complexity.Parameter.Value(childComplexity), true

	case "ParsleyFilter.caseSensitive":
		if e.complexity.ParsleyFilter.CaseSensitive == nil {
			break
		}

		return e.complexity.ParsleyFilter.CaseSensitive(childComplexity), true

	case "ParsleyFilter.description":
		if e.complexity.ParsleyFilter.Description == nil {
			break
		}

		return e.complexity.ParsleyFilter.Description(childComplexity), true

	case "ParsleyFilter.exactMatch":
		if e.complexity.ParsleyFilter.ExactMatch == nil {
			break
		}

		return e.complexity.ParsleyFilter.ExactMatch(childComplexity), true

	case "ParsleyFilter.expression":
		if e.complexity.ParsleyFilter.Expression == nil {
			break
		}

		return e.complexity.ParsleyFilter.Expression(childComplexity), true

	case "ParsleySettings.jumpToFailingLineEnabled":
		if e.complexity.ParsleySettings.JumpToFailingLineEnabled == nil {
			break
		}

		return e.complexity.ParsleySettings.JumpToFailingLineEnabled(childComplexity), true

	case "ParsleySettings.sectionsEnabled":
		if e.complexity.ParsleySettings.SectionsEnabled == nil {
			break
		}

		return e.complexity.ParsleySettings.SectionsEnabled(childComplexity), true

	case "Patch.activated":
		if e.complexity.Patch.Activated == nil {
			break
		}

		return e.complexity.Patch.Activated(childComplexity), true

	case "Patch.alias":
		if e.complexity.Patch.Alias == nil {
			break
		}

		return e.complexity.Patch.Alias(childComplexity), true

	case "Patch.author":
		if e.complexity.Patch.Author == nil {
			break
		}

		return e.complexity.Patch.Author(childComplexity), true

	case "Patch.authorDisplayName":
		if e.complexity.Patch.AuthorDisplayName == nil {
			break
		}

		return e.complexity.Patch.AuthorDisplayName(childComplexity), true

	case "Patch.baseTaskStatuses":
		if e.complexity.Patch.BaseTaskStatuses == nil {
			break
		}

		return e.complexity.Patch.BaseTaskStatuses(childComplexity), true

	case "Patch.builds":
		if e.complexity.Patch.Builds == nil {
			break
		}

		return e.complexity.Patch.Builds(childComplexity), true

	case "Patch.childPatchAliases":
		if e.complexity.Patch.ChildPatchAliases == nil {
			break
		}

		return e.complexity.Patch.ChildPatchAliases(childComplexity), true

	case "Patch.childPatches":
		if e.complexity.Patch.ChildPatches == nil {
			break
		}

		return e.complexity.Patch.ChildPatches(childComplexity), true

	case "Patch.createTime":
		if e.complexity.Patch.CreateTime == nil {
			break
		}

		return e.complexity.Patch.CreateTime(childComplexity), true

	case "Patch.description":
		if e.complexity.Patch.Description == nil {
			break
		}

		return e.complexity.Patch.Description(childComplexity), true

	case "Patch.duration":
		if e.complexity.Patch.Duration == nil {
			break
		}

		return e.complexity.Patch.Duration(childComplexity), true

	case "Patch.generatedTaskCounts":
		if e.complexity.Patch.GeneratedTaskCounts == nil {
			break
		}

		return e.complexity.Patch.GeneratedTaskCounts(childComplexity), true

	case "Patch.githash":
		if e.complexity.Patch.Githash == nil {
			break
		}

		return e.complexity.Patch.Githash(childComplexity), true

	case "Patch.githubPatchData":
		if e.complexity.Patch.GithubPatchData == nil {
			break
		}

		return e.complexity.Patch.GithubPatchData(childComplexity), true

	case "Patch.hidden":
		if e.complexity.Patch.Hidden == nil {
			break
		}

		return e.complexity.Patch.Hidden(childComplexity), true

	case "Patch.id":
		if e.complexity.Patch.Id == nil {
			break
		}

		return e.complexity.Patch.Id(childComplexity), true

	case "Patch.moduleCodeChanges":
		if e.complexity.Patch.ModuleCodeChanges == nil {
			break
		}

		return e.complexity.Patch.ModuleCodeChanges(childComplexity), true

	case "Patch.parameters":
		if e.complexity.Patch.Parameters == nil {
			break
		}

		return e.complexity.Patch.Parameters(childComplexity), true

	case "Patch.patchNumber":
		if e.complexity.Patch.PatchNumber == nil {
			break
		}

		return e.complexity.Patch.PatchNumber(childComplexity), true

	case "Patch.patchTriggerAliases":
		if e.complexity.Patch.PatchTriggerAliases == nil {
			break
		}

		return e.complexity.Patch.PatchTriggerAliases(childComplexity), true

	case "Patch.project":
		if e.complexity.Patch.Project == nil {
			break
		}

		return e.complexity.Patch.Project(childComplexity), true

	case "Patch.projectID":
		if e.complexity.Patch.ProjectId == nil {
			break
		}

		return e.complexity.Patch.ProjectId(childComplexity), true

	case "Patch.projectIdentifier":
		if e.complexity.Patch.ProjectIdentifier == nil {
			break
		}

		return e.complexity.Patch.ProjectIdentifier(childComplexity), true

	case "Patch.projectMetadata":
		if e.complexity.Patch.ProjectMetadata == nil {
			break
		}

		return e.complexity.Patch.ProjectMetadata(childComplexity), true

	case "Patch.status":
		if e.complexity.Patch.Status == nil {
			break
		}

		return e.complexity.Patch.Status(childComplexity), true

	case "Patch.taskCount":
		if e.complexity.Patch.TaskCount == nil {
			break
		}

		return e.complexity.Patch.TaskCount(childComplexity), true

	case "Patch.taskStatuses":
		if e.complexity.Patch.TaskStatuses == nil {
			break
		}

		return e.complexity.Patch.TaskStatuses(childComplexity), true

	case "Patch.tasks":
		if e.complexity.Patch.Tasks == nil {
			break
		}

		return e.complexity.Patch.Tasks(childComplexity), true

	case "Patch.time":
		if e.complexity.Patch.Time == nil {
			break
		}

		return e.complexity.Patch.Time(childComplexity), true

	case "Patch.variants":
		if e.complexity.Patch.Variants == nil {
			break
		}

		return e.complexity.Patch.Variants(childComplexity), true

	case "Patch.variantsTasks":
		if e.complexity.Patch.VariantsTasks == nil {
			break
		}

		return e.complexity.Patch.VariantsTasks(childComplexity), true

	case "Patch.versionFull":
		if e.complexity.Patch.VersionFull == nil {
			break
		}

		return e.complexity.Patch.VersionFull(childComplexity), true

	case "PatchDuration.makespan":
		if e.complexity.PatchDuration.Makespan == nil {
			break
		}

		return e.complexity.PatchDuration.Makespan(childComplexity), true

	case "PatchDuration.time":
		if e.complexity.PatchDuration.Time == nil {
			break
		}

		return e.complexity.PatchDuration.Time(childComplexity), true

	case "PatchDuration.timeTaken":
		if e.complexity.PatchDuration.TimeTaken == nil {
			break
		}

		return e.complexity.PatchDuration.TimeTaken(childComplexity), true

	case "PatchProject.variants":
		if e.complexity.PatchProject.Variants == nil {
			break
		}

		return e.complexity.PatchProject.Variants(childComplexity), true

	case "PatchTime.finished":
		if e.complexity.PatchTime.Finished == nil {
			break
		}

		return e.complexity.PatchTime.Finished(childComplexity), true

	case "PatchTime.started":
		if e.complexity.PatchTime.Started == nil {
			break
		}

		return e.complexity.PatchTime.Started(childComplexity), true

	case "PatchTime.submittedAt":
		if e.complexity.PatchTime.SubmittedAt == nil {
			break
		}

		return e.complexity.PatchTime.SubmittedAt(childComplexity), true

	case "PatchTriggerAlias.alias":
		if e.complexity.PatchTriggerAlias.Alias == nil {
			break
		}

		return e.complexity.PatchTriggerAlias.Alias(childComplexity), true

	case "PatchTriggerAlias.childProjectId":
		if e.complexity.PatchTriggerAlias.ChildProjectId == nil {
			break
		}

		return e.complexity.PatchTriggerAlias.ChildProjectId(childComplexity), true

	case "PatchTriggerAlias.childProjectIdentifier":
		if e.complexity.PatchTriggerAlias.ChildProjectIdentifier == nil {
			break
		}

		return e.complexity.PatchTriggerAlias.ChildProjectIdentifier(childComplexity), true

	case "PatchTriggerAlias.downstreamRevision":
		if e.complexity.PatchTriggerAlias.DownstreamRevision == nil {
			break
		}

		return e.complexity.PatchTriggerAlias.DownstreamRevision(childComplexity), true

	case "PatchTriggerAlias.parentAsModule":
		if e.complexity.PatchTriggerAlias.ParentAsModule == nil {
			break
		}

		return e.complexity.PatchTriggerAlias.ParentAsModule(childComplexity), true

	case "PatchTriggerAlias.status":
		if e.complexity.PatchTriggerAlias.Status == nil {
			break
		}

		return e.complexity.PatchTriggerAlias.Status(childComplexity), true

	case "PatchTriggerAlias.taskSpecifiers":
		if e.complexity.PatchTriggerAlias.TaskSpecifiers == nil {
			break
		}

		return e.complexity.PatchTriggerAlias.TaskSpecifiers(childComplexity), true

	case "PatchTriggerAlias.variantsTasks":
		if e.complexity.PatchTriggerAlias.VariantsTasks == nil {
			break
		}

		return e.complexity.PatchTriggerAlias.VariantsTasks(childComplexity), true

	case "Patches.filteredPatchCount":
		if e.complexity.Patches.FilteredPatchCount == nil {
			break
		}

		return e.complexity.Patches.FilteredPatchCount(childComplexity), true

	case "Patches.patches":
		if e.complexity.Patches.Patches == nil {
			break
		}

		return e.complexity.Patches.Patches(childComplexity), true

	case "PeriodicBuild.alias":
		if e.complexity.PeriodicBuild.Alias == nil {
			break
		}

		return e.complexity.PeriodicBuild.Alias(childComplexity), true

	case "PeriodicBuild.configFile":
		if e.complexity.PeriodicBuild.ConfigFile == nil {
			break
		}

		return e.complexity.PeriodicBuild.ConfigFile(childComplexity), true

	case "PeriodicBuild.cron":
		if e.complexity.PeriodicBuild.Cron == nil {
			break
		}

		return e.complexity.PeriodicBuild.Cron(childComplexity), true

	case "PeriodicBuild.id":
		if e.complexity.PeriodicBuild.ID == nil {
			break
		}

		return e.complexity.PeriodicBuild.ID(childComplexity), true

	case "PeriodicBuild.intervalHours":
		if e.complexity.PeriodicBuild.IntervalHours == nil {
			break
		}

		return e.complexity.PeriodicBuild.IntervalHours(childComplexity), true

	case "PeriodicBuild.message":
		if e.complexity.PeriodicBuild.Message == nil {
			break
		}

		return e.complexity.PeriodicBuild.Message(childComplexity), true

	case "PeriodicBuild.nextRunTime":
		if e.complexity.PeriodicBuild.NextRunTime == nil {
			break
		}

		return e.complexity.PeriodicBuild.NextRunTime(childComplexity), true

	case "Permissions.canCreateDistro":
		if e.complexity.Permissions.CanCreateDistro == nil {
			break
		}

		return e.complexity.Permissions.CanCreateDistro(childComplexity), true

	case "Permissions.canCreateProject":
		if e.complexity.Permissions.CanCreateProject == nil {
			break
		}

		return e.complexity.Permissions.CanCreateProject(childComplexity), true

	case "Permissions.canEditAdminSettings":
		if e.complexity.Permissions.CanEditAdminSettings == nil {
			break
		}

		return e.complexity.Permissions.CanEditAdminSettings(childComplexity), true

	case "Permissions.distroPermissions":
		if e.complexity.Permissions.DistroPermissions == nil {
			break
		}

		args, err := ec.field_Permissions_distroPermissions_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Permissions.DistroPermissions(childComplexity, args["options"].(DistroPermissionsOptions)), true

	case "Permissions.projectPermissions":
		if e.complexity.Permissions.ProjectPermissions == nil {
			break
		}

		args, err := ec.field_Permissions_projectPermissions_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Permissions.ProjectPermissions(childComplexity, args["options"].(ProjectPermissionsOptions)), true

	case "Permissions.repoPermissions":
		if e.complexity.Permissions.RepoPermissions == nil {
			break
		}

		args, err := ec.field_Permissions_repoPermissions_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Permissions.RepoPermissions(childComplexity, args["options"].(RepoPermissionsOptions)), true

	case "Permissions.userId":
		if e.complexity.Permissions.UserID == nil {
			break
		}

		return e.complexity.Permissions.UserID(childComplexity), true

	case "PlannerSettings.commitQueueFactor":
		if e.complexity.PlannerSettings.CommitQueueFactor == nil {
			break
		}

		return e.complexity.PlannerSettings.CommitQueueFactor(childComplexity), true

	case "PlannerSettings.expectedRuntimeFactor":
		if e.complexity.PlannerSettings.ExpectedRuntimeFactor == nil {
			break
		}

		return e.complexity.PlannerSettings.ExpectedRuntimeFactor(childComplexity), true

	case "PlannerSettings.generateTaskFactor":
		if e.complexity.PlannerSettings.GenerateTaskFactor == nil {
			break
		}

		return e.complexity.PlannerSettings.GenerateTaskFactor(childComplexity), true

	case "PlannerSettings.groupVersions":
		if e.complexity.PlannerSettings.GroupVersions == nil {
			break
		}

		return e.complexity.PlannerSettings.GroupVersions(childComplexity), true

	case "PlannerSettings.mainlineTimeInQueueFactor":
		if e.complexity.PlannerSettings.MainlineTimeInQueueFactor == nil {
			break
		}

		return e.complexity.PlannerSettings.MainlineTimeInQueueFactor(childComplexity), true

	case "PlannerSettings.numDependentsFactor":
		if e.complexity.PlannerSettings.NumDependentsFactor == nil {
			break
		}

		return e.complexity.PlannerSettings.NumDependentsFactor(childComplexity), true

	case "PlannerSettings.patchFactor":
		if e.complexity.PlannerSettings.PatchFactor == nil {
			break
		}

		return e.complexity.PlannerSettings.PatchFactor(childComplexity), true

	case "PlannerSettings.patchTimeInQueueFactor":
		if e.complexity.PlannerSettings.PatchTimeInQueueFactor == nil {
			break
		}

		return e.complexity.PlannerSettings.PatchTimeInQueueFactor(childComplexity), true

	case "PlannerSettings.targetTime":
		if e.complexity.PlannerSettings.TargetTime == nil {
			break
		}

		return e.complexity.PlannerSettings.TargetTime(childComplexity), true

	case "PlannerSettings.version":
		if e.complexity.PlannerSettings.Version == nil {
			break
		}

		return e.complexity.PlannerSettings.Version(childComplexity), true

	case "Pod.events":
		if e.complexity.Pod.Events == nil {
			break
		}

		args, err := ec.field_Pod_events_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Pod.Events(childComplexity, args["limit"].(*int), args["page"].(*int)), true

	case "Pod.id":
		if e.complexity.Pod.ID == nil {
			break
		}

		return e.complexity.Pod.ID(childComplexity), true

	case "Pod.status":
		if e.complexity.Pod.Status == nil {
			break
		}

		return e.complexity.Pod.Status(childComplexity), true

	case "Pod.task":
		if e.complexity.Pod.Task == nil {
			break
		}

		return e.complexity.Pod.Task(childComplexity), true

	case "Pod.taskContainerCreationOpts":
		if e.complexity.Pod.TaskContainerCreationOpts == nil {
			break
		}

		return e.complexity.Pod.TaskContainerCreationOpts(childComplexity), true

	case "Pod.type":
		if e.complexity.Pod.Type == nil {
			break
		}

		return e.complexity.Pod.Type(childComplexity), true

	case "PodEventLogData.newStatus":
		if e.complexity.PodEventLogData.NewStatus == nil {
			break
		}

		return e.complexity.PodEventLogData.NewStatus(childComplexity), true

	case "PodEventLogData.oldStatus":
		if e.complexity.PodEventLogData.OldStatus == nil {
			break
		}

		return e.complexity.PodEventLogData.OldStatus(childComplexity), true

	case "PodEventLogData.reason":
		if e.complexity.PodEventLogData.Reason == nil {
			break
		}

		return e.complexity.PodEventLogData.Reason(childComplexity), true

	case "PodEventLogData.task":
		if e.complexity.PodEventLogData.Task == nil {
			break
		}

		return e.complexity.PodEventLogData.Task(childComplexity), true

	case "PodEventLogData.taskExecution":
		if e.complexity.PodEventLogData.TaskExecution == nil {
			break
		}

		return e.complexity.PodEventLogData.TaskExecution(childComplexity), true

	case "PodEventLogData.taskID":
		if e.complexity.PodEventLogData.TaskID == nil {
			break
		}

		return e.complexity.PodEventLogData.TaskID(childComplexity), true

	case "PodEventLogData.taskStatus":
		if e.complexity.PodEventLogData.TaskStatus == nil {
			break
		}

		return e.complexity.PodEventLogData.TaskStatus(childComplexity), true

	case "PodEventLogEntry.data":
		if e.complexity.PodEventLogEntry.Data == nil {
			break
		}

		return e.complexity.PodEventLogEntry.Data(childComplexity), true

	case "PodEventLogEntry.eventType":
		if e.complexity.PodEventLogEntry.EventType == nil {
			break
		}

		return e.complexity.PodEventLogEntry.EventType(childComplexity), true

	case "PodEventLogEntry.id":
		if e.complexity.PodEventLogEntry.ID == nil {
			break
		}

		return e.complexity.PodEventLogEntry.ID(childComplexity), true

	case "PodEventLogEntry.processedAt":
		if e.complexity.PodEventLogEntry.ProcessedAt == nil {
			break
		}

		return e.complexity.PodEventLogEntry.ProcessedAt(childComplexity), true

	case "PodEventLogEntry.resourceId":
		if e.complexity.PodEventLogEntry.ResourceId == nil {
			break
		}

		return e.complexity.PodEventLogEntry.ResourceId(childComplexity), true

	case "PodEventLogEntry.resourceType":
		if e.complexity.PodEventLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.PodEventLogEntry.ResourceType(childComplexity), true

	case "PodEventLogEntry.timestamp":
		if e.complexity.PodEventLogEntry.Timestamp == nil {
			break
		}

		return e.complexity.PodEventLogEntry.Timestamp(childComplexity), true

	case "PodEvents.count":
		if e.complexity.PodEvents.Count == nil {
			break
		}

		return e.complexity.PodEvents.Count(childComplexity), true

	case "PodEvents.eventLogEntries":
		if e.complexity.PodEvents.EventLogEntries == nil {
			break
		}

		return e.complexity.PodEvents.EventLogEntries(childComplexity), true

	case "PodLifecycleConfig.maxParallelPodRequests":
		if e.complexity.PodLifecycleConfig.MaxParallelPodRequests == nil {
			break
		}

		return e.complexity.PodLifecycleConfig.MaxParallelPodRequests(childComplexity), true

	case "PodLifecycleConfig.maxPodDefinitionCleanupRate":
		if e.complexity.PodLifecycleConfig.MaxPodDefinitionCleanupRate == nil {
			break
		}

		return e.complexity.PodLifecycleConfig.MaxPodDefinitionCleanupRate(childComplexity), true

	case "PodLifecycleConfig.maxSecretCleanupRate":
		if e.complexity.PodLifecycleConfig.MaxSecretCleanupRate == nil {
			break
		}

		return e.complexity.PodLifecycleConfig.MaxSecretCleanupRate(childComplexity), true

	case "PreconditionScript.path":
		if e.complexity.PreconditionScript.Path == nil {
			break
		}

		return e.complexity.PreconditionScript.Path(childComplexity), true

	case "PreconditionScript.script":
		if e.complexity.PreconditionScript.Script == nil {
			break
		}

		return e.complexity.PreconditionScript.Script(childComplexity), true

	case "Project.admins":
		if e.complexity.Project.Admins == nil {
			break
		}

		return e.complexity.Project.Admins(childComplexity), true

	case "Project.banner":
		if e.complexity.Project.Banner == nil {
			break
		}

		return e.complexity.Project.Banner(childComplexity), true

	case "Project.batchTime":
		if e.complexity.Project.BatchTime == nil {
			break
		}

		return e.complexity.Project.BatchTime(childComplexity), true

	case "Project.branch":
		if e.complexity.Project.Branch == nil {
			break
		}

		return e.complexity.Project.Branch(childComplexity), true

	case "Project.buildBaronSettings":
		if e.complexity.Project.BuildBaronSettings == nil {
			break
		}

		return e.complexity.Project.BuildBaronSettings(childComplexity), true

	case "Project.commitQueue":
		if e.complexity.Project.CommitQueue == nil {
			break
		}

		return e.complexity.Project.CommitQueue(childComplexity), true

	case "Project.containerSizeDefinitions":
		if e.complexity.Project.ContainerSizeDefinitions == nil {
			break
		}

		return e.complexity.Project.ContainerSizeDefinitions(childComplexity), true

	case "Project.deactivatePrevious":
		if e.complexity.Project.DeactivatePrevious == nil {
			break
		}

		return e.complexity.Project.DeactivatePrevious(childComplexity), true

	case "Project.disabledStatsCache":
		if e.complexity.Project.DisabledStatsCache == nil {
			break
		}

		return e.complexity.Project.DisabledStatsCache(childComplexity), true

	case "Project.dispatchingDisabled":
		if e.complexity.Project.DispatchingDisabled == nil {
			break
		}

		return e.complexity.Project.DispatchingDisabled(childComplexity), true

	case "Project.displayName":
		if e.complexity.Project.DisplayName == nil {
			break
		}

		return e.complexity.Project.DisplayName(childComplexity), true

	case "Project.enabled":
		if e.complexity.Project.Enabled == nil {
			break
		}

		return e.complexity.Project.Enabled(childComplexity), true

	case "Project.externalLinks":
		if e.complexity.Project.ExternalLinks == nil {
			break
		}

		return e.complexity.Project.ExternalLinks(childComplexity), true

	case "Project.githubDynamicTokenPermissionGroups":
		if e.complexity.Project.GitHubDynamicTokenPermissionGroups == nil {
			break
		}

		return e.complexity.Project.GitHubDynamicTokenPermissionGroups(childComplexity), true

	case "Project.githubPermissionGroupByRequester":
		if e.complexity.Project.GitHubPermissionGroupByRequester == nil {
			break
		}

		return e.complexity.Project.GitHubPermissionGroupByRequester(childComplexity), true

	case "Project.gitTagAuthorizedTeams":
		if e.complexity.Project.GitTagAuthorizedTeams == nil {
			break
		}

		return e.complexity.Project.GitTagAuthorizedTeams(childComplexity), true

	case "Project.gitTagAuthorizedUsers":
		if e.complexity.Project.GitTagAuthorizedUsers == nil {
			break
		}

		return e.complexity.Project.GitTagAuthorizedUsers(childComplexity), true

	case "Project.gitTagVersionsEnabled":
		if e.complexity.Project.GitTagVersionsEnabled == nil {
			break
		}

		return e.complexity.Project.GitTagVersionsEnabled(childComplexity), true

	case "Project.githubChecksEnabled":
		if e.complexity.Project.GithubChecksEnabled == nil {
			break
		}

		return e.complexity.Project.GithubChecksEnabled(childComplexity), true

	case "Project.githubMQTriggerAliases":
		if e.complexity.Project.GithubMQTriggerAliases == nil {
			break
		}

		return e.complexity.Project.GithubMQTriggerAliases(childComplexity), true

	case "Project.githubPRTriggerAliases":
		if e.complexity.Project.GithubPRTriggerAliases == nil {
			break
		}

		return e.complexity.Project.GithubPRTriggerAliases(childComplexity), true

	case "Project.githubTriggerAliases":
		if e.complexity.Project.GithubTriggerAliases == nil {
			break
		}

		return e.complexity.Project.GithubTriggerAliases(childComplexity), true

	case "Project.hidden":
		if e.complexity.Project.Hidden == nil {
			break
		}

		return e.complexity.Project.Hidden(childComplexity), true

	case "Project.id":
		if e.complexity.Project.Id == nil {
			break
		}

		return e.complexity.Project.Id(childComplexity), true

	case "Project.identifier":
		if e.complexity.Project.Identifier == nil {
			break
		}

		return e.complexity.Project.Identifier(childComplexity), true

	case "Project.isFavorite":
		if e.complexity.Project.IsFavorite == nil {
			break
		}

		return e.complexity.Project.IsFavorite(childComplexity), true

	case "Project.manualPrTestingEnabled":
		if e.complexity.Project.ManualPRTestingEnabled == nil {
			break
		}

		return e.complexity.Project.ManualPRTestingEnabled(childComplexity), true

	case "Project.notifyOnBuildFailure":
		if e.complexity.Project.NotifyOnBuildFailure == nil {
			break
		}

		return e.complexity.Project.NotifyOnBuildFailure(childComplexity), true

	case "Project.oldestAllowedMergeBase":
		if e.complexity.Project.OldestAllowedMergeBase == nil {
			break
		}

		return e.complexity.Project.OldestAllowedMergeBase(childComplexity), true

	case "Project.owner":
		if e.complexity.Project.Owner == nil {
			break
		}

		return e.complexity.Project.Owner(childComplexity), true

	case "Project.prTestingEnabled":
		if e.complexity.Project.PRTestingEnabled == nil {
			break
		}

		return e.complexity.Project.PRTestingEnabled(childComplexity), true

	case "Project.parsleyFilters":
		if e.complexity.Project.ParsleyFilters == nil {
			break
		}

		return e.complexity.Project.ParsleyFilters(childComplexity), true

	case "Project.patchTriggerAliases":
		if e.complexity.Project.PatchTriggerAliases == nil {
			break
		}

		return e.complexity.Project.PatchTriggerAliases(childComplexity), true

	case "Project.patches":
		if e.complexity.Project.Patches == nil {
			break
		}

		args, err := ec.field_Project_patches_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Project.Patches(childComplexity, args["patchesInput"].(PatchesInput)), true

	case "Project.patchingDisabled":
		if e.complexity.Project.PatchingDisabled == nil {
			break
		}

		return e.complexity.Project.PatchingDisabled(childComplexity), true

	case "Project.perfEnabled":
		if e.complexity.Project.PerfEnabled == nil {
			break
		}

		return e.complexity.Project.PerfEnabled(childComplexity), true

	case "Project.periodicBuilds":
		if e.complexity.Project.PeriodicBuilds == nil {
			break
		}

		return e.complexity.Project.PeriodicBuilds(childComplexity), true

	case "Project.projectHealthView":
		if e.complexity.Project.ProjectHealthView == nil {
			break
		}

		return e.complexity.Project.ProjectHealthView(childComplexity), true

	case "Project.remotePath":
		if e.complexity.Project.RemotePath == nil {
			break
		}

		return e.complexity.Project.RemotePath(childComplexity), true

	case "Project.repo":
		if e.complexity.Project.Repo == nil {
			break
		}

		return e.complexity.Project.Repo(childComplexity), true

	case "Project.repoRefId":
		if e.complexity.Project.RepoRefId == nil {
			break
		}

		return e.complexity.Project.RepoRefId(childComplexity), true

	case "Project.repotrackerDisabled":
		if e.complexity.Project.RepotrackerDisabled == nil {
			break
		}

		return e.complexity.Project.RepotrackerDisabled(childComplexity), true

	case "Project.repotrackerError":
		if e.complexity.Project.RepotrackerError == nil {
			break
		}

		return e.complexity.Project.RepotrackerError(childComplexity), true

	case "Project.restricted":
		if e.complexity.Project.Restricted == nil {
			break
		}

		return e.complexity.Project.Restricted(childComplexity), true

	case "Project.spawnHostScriptPath":
		if e.complexity.Project.SpawnHostScriptPath == nil {
			break
		}

		return e.complexity.Project.SpawnHostScriptPath(childComplexity), true

	case "Project.stepbackBisect":
		if e.complexity.Project.StepbackBisect == nil {
			break
		}

		return e.complexity.Project.StepbackBisect(childComplexity), true

	case "Project.stepbackDisabled":
		if e.complexity.Project.StepbackDisabled == nil {
			break
		}

		return e.complexity.Project.StepbackDisabled(childComplexity), true

	case "Project.taskAnnotationSettings":
		if e.complexity.Project.TaskAnnotationSettings == nil {
			break
		}

		return e.complexity.Project.TaskAnnotationSettings(childComplexity), true

	case "Project.tracksPushEvents":
		if e.complexity.Project.TracksPushEvents == nil {
			break
		}

		return e.complexity.Project.TracksPushEvents(childComplexity), true

	case "Project.triggers":
		if e.complexity.Project.Triggers == nil {
			break
		}

		return e.complexity.Project.Triggers(childComplexity), true

	case "Project.versionControlEnabled":
		if e.complexity.Project.VersionControlEnabled == nil {
			break
		}

		return e.complexity.Project.VersionControlEnabled(childComplexity), true

	case "Project.workstationConfig":
		if e.complexity.Project.WorkstationConfig == nil {
			break
		}

		return e.complexity.Project.WorkstationConfig(childComplexity), true

	case "ProjectAlias.alias":
		if e.complexity.ProjectAlias.Alias == nil {
			break
		}

		return e.complexity.ProjectAlias.Alias(childComplexity), true

	case "ProjectAlias.description":
		if e.complexity.ProjectAlias.Description == nil {
			break
		}

		return e.complexity.ProjectAlias.Description(childComplexity), true

	case "ProjectAlias.gitTag":
		if e.complexity.ProjectAlias.GitTag == nil {
			break
		}

		return e.complexity.ProjectAlias.GitTag(childComplexity), true

	case "ProjectAlias.id":
		if e.complexity.ProjectAlias.ID == nil {
			break
		}

		return e.complexity.ProjectAlias.ID(childComplexity), true

	case "ProjectAlias.parameters":
		if e.complexity.ProjectAlias.Parameters == nil {
			break
		}

		return e.complexity.ProjectAlias.Parameters(childComplexity), true

	case "ProjectAlias.remotePath":
		if e.complexity.ProjectAlias.RemotePath == nil {
			break
		}

		return e.complexity.ProjectAlias.RemotePath(childComplexity), true

	case "ProjectAlias.task":
		if e.complexity.ProjectAlias.Task == nil {
			break
		}

		return e.complexity.ProjectAlias.Task(childComplexity), true

	case "ProjectAlias.taskTags":
		if e.complexity.ProjectAlias.TaskTags == nil {
			break
		}

		return e.complexity.ProjectAlias.TaskTags(childComplexity), true

	case "ProjectAlias.variant":
		if e.complexity.ProjectAlias.Variant == nil {
			break
		}

		return e.complexity.ProjectAlias.Variant(childComplexity), true

	case "ProjectAlias.variantTags":
		if e.complexity.ProjectAlias.VariantTags == nil {
			break
		}

		return e.complexity.ProjectAlias.VariantTags(childComplexity), true

	case "ProjectBanner.text":
		if e.complexity.ProjectBanner.Text == nil {
			break
		}

		return e.complexity.ProjectBanner.Text(childComplexity), true

	case "ProjectBanner.theme":
		if e.complexity.ProjectBanner.Theme == nil {
			break
		}

		return e.complexity.ProjectBanner.Theme(childComplexity), true

	case "ProjectBuildVariant.displayName":
		if e.complexity.ProjectBuildVariant.DisplayName == nil {
			break
		}

		return e.complexity.ProjectBuildVariant.DisplayName(childComplexity), true

	case "ProjectBuildVariant.name":
		if e.complexity.ProjectBuildVariant.Name == nil {
			break
		}

		return e.complexity.ProjectBuildVariant.Name(childComplexity), true

	case "ProjectBuildVariant.tasks":
		if e.complexity.ProjectBuildVariant.Tasks == nil {
			break
		}

		return e.complexity.ProjectBuildVariant.Tasks(childComplexity), true

	case "ProjectEventLogEntry.after":
		if e.complexity.ProjectEventLogEntry.After == nil {
			break
		}

		return e.complexity.ProjectEventLogEntry.After(childComplexity), true

	case "ProjectEventLogEntry.before":
		if e.complexity.ProjectEventLogEntry.Before == nil {
			break
		}

		return e.complexity.ProjectEventLogEntry.Before(childComplexity), true

	case "ProjectEventLogEntry.timestamp":
		if e.complexity.ProjectEventLogEntry.Timestamp == nil {
			break
		}

		return e.complexity.ProjectEventLogEntry.Timestamp(childComplexity), true

	case "ProjectEventLogEntry.user":
		if e.complexity.ProjectEventLogEntry.User == nil {
			break
		}

		return e.complexity.ProjectEventLogEntry.User(childComplexity), true

	case "ProjectEventSettings.aliases":
		if e.complexity.ProjectEventSettings.Aliases == nil {
			break
		}

		return e.complexity.ProjectEventSettings.Aliases(childComplexity), true

	case "ProjectEventSettings.githubAppAuth":
		if e.complexity.ProjectEventSettings.GithubAppAuth == nil {
			break
		}

		return e.complexity.ProjectEventSettings.GithubAppAuth(childComplexity), true

	case "ProjectEventSettings.githubWebhooksEnabled":
		if e.complexity.ProjectEventSettings.GithubWebhooksEnabled == nil {
			break
		}

		return e.complexity.ProjectEventSettings.GithubWebhooksEnabled(childComplexity), true

	case "ProjectEventSettings.projectRef":
		if e.complexity.ProjectEventSettings.ProjectRef == nil {
			break
		}

		return e.complexity.ProjectEventSettings.ProjectRef(childComplexity), true

	case "ProjectEventSettings.subscriptions":
		if e.complexity.ProjectEventSettings.Subscriptions == nil {
			break
		}

		return e.complexity.ProjectEventSettings.Subscriptions(childComplexity), true

	case "ProjectEventSettings.vars":
		if e.complexity.ProjectEventSettings.Vars == nil {
			break
		}

		return e.complexity.ProjectEventSettings.Vars(childComplexity), true

	case "ProjectEvents.count":
		if e.complexity.ProjectEvents.Count == nil {
			break
		}

		return e.complexity.ProjectEvents.Count(childComplexity), true

	case "ProjectEvents.eventLogEntries":
		if e.complexity.ProjectEvents.EventLogEntries == nil {
			break
		}

		return e.complexity.ProjectEvents.EventLogEntries(childComplexity), true

	case "ProjectPermissions.edit":
		if e.complexity.ProjectPermissions.Edit == nil {
			break
		}

		return e.complexity.ProjectPermissions.Edit(childComplexity), true

	case "ProjectPermissions.view":
		if e.complexity.ProjectPermissions.View == nil {
			break
		}

		return e.complexity.ProjectPermissions.View(childComplexity), true

	case "ProjectSettings.aliases":
		if e.complexity.ProjectSettings.Aliases == nil {
			break
		}

		return e.complexity.ProjectSettings.Aliases(childComplexity), true

	case "ProjectSettings.githubAppAuth":
		if e.complexity.ProjectSettings.GithubAppAuth == nil {
			break
		}

		return e.complexity.ProjectSettings.GithubAppAuth(childComplexity), true

	case "ProjectSettings.githubWebhooksEnabled":
		if e.complexity.ProjectSettings.GithubWebhooksEnabled == nil {
			break
		}

		return e.complexity.ProjectSettings.GithubWebhooksEnabled(childComplexity), true

	case "ProjectSettings.projectRef":
		if e.complexity.ProjectSettings.ProjectRef == nil {
			break
		}

		return e.complexity.ProjectSettings.ProjectRef(childComplexity), true

	case "ProjectSettings.subscriptions":
		if e.complexity.ProjectSettings.Subscriptions == nil {
			break
		}

		return e.complexity.ProjectSettings.Subscriptions(childComplexity), true

	case "ProjectSettings.vars":
		if e.complexity.ProjectSettings.Vars == nil {
			break
		}

		return e.complexity.ProjectSettings.Vars(childComplexity), true

	case "ProjectTasksPair.allowedBVs":
		if e.complexity.ProjectTasksPair.AllowedBVs == nil {
			break
		}

		return e.complexity.ProjectTasksPair.AllowedBVs(childComplexity), true

	case "ProjectTasksPair.allowedTasks":
		if e.complexity.ProjectTasksPair.AllowedTasks == nil {
			break
		}

		return e.complexity.ProjectTasksPair.AllowedTasks(childComplexity), true

	case "ProjectTasksPair.projectId":
		if e.complexity.ProjectTasksPair.ProjectID == nil {
			break
		}

		return e.complexity.ProjectTasksPair.ProjectID(childComplexity), true

	case "ProjectVars.adminOnlyVars":
		if e.complexity.ProjectVars.AdminOnlyVars == nil {
			break
		}

		return e.complexity.ProjectVars.AdminOnlyVars(childComplexity), true

	case "ProjectVars.privateVars":
		if e.complexity.ProjectVars.PrivateVars == nil {
			break
		}

		return e.complexity.ProjectVars.PrivateVars(childComplexity), true

	case "ProjectVars.vars":
		if e.complexity.ProjectVars.Vars == nil {
			break
		}

		return e.complexity.ProjectVars.Vars(childComplexity), true

	case "PublicKey.key":
		if e.complexity.PublicKey.Key == nil {
			break
		}

		return e.complexity.PublicKey.Key(childComplexity), true

	case "PublicKey.name":
		if e.complexity.PublicKey.Name == nil {
			break
		}

		return e.complexity.PublicKey.Name(childComplexity), true

	case "Query.awsRegions":
		if e.complexity.Query.AWSRegions == nil {
			break
		}

		return e.complexity.Query.AWSRegions(childComplexity), true

	case "Query.adminEvents":
		if e.complexity.Query.AdminEvents == nil {
			break
		}

		args, err := ec.field_Query_adminEvents_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AdminEvents(childComplexity, args["opts"].(AdminEventsInput)), true

	case "Query.adminSettings":
		if e.complexity.Query.AdminSettings == nil {
			break
		}

		return e.complexity.Query.AdminSettings(childComplexity), true

	case "Query.adminTasksToRestart":
		if e.complexity.Query.AdminTasksToRestart == nil {
			break
		}

		args, err := ec.field_Query_adminTasksToRestart_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.AdminTasksToRestart(childComplexity, args["opts"].(model1.RestartOptions)), true

	case "Query.bbGetCreatedTickets":
		if e.complexity.Query.BbGetCreatedTickets == nil {
			break
		}

		args, err := ec.field_Query_bbGetCreatedTickets_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BbGetCreatedTickets(childComplexity, args["taskId"].(string)), true

	case "Query.buildBaron":
		if e.complexity.Query.BuildBaron == nil {
			break
		}

		args, err := ec.field_Query_buildBaron_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BuildBaron(childComplexity, args["taskId"].(string), args["execution"].(int)), true

	case "Query.buildVariantsForTaskName":
		if e.complexity.Query.BuildVariantsForTaskName == nil {
			break
		}

		args, err := ec.field_Query_buildVariantsForTaskName_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BuildVariantsForTaskName(childComplexity, args["projectIdentifier"].(string), args["taskName"].(string)), true

	case "Query.clientConfig":
		if e.complexity.Query.ClientConfig == nil {
			break
		}

		return e.complexity.Query.ClientConfig(childComplexity), true

	case "Query.distro":
		if e.complexity.Query.Distro == nil {
			break
		}

		args, err := ec.field_Query_distro_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Distro(childComplexity, args["distroId"].(string)), true

	case "Query.distroEvents":
		if e.complexity.Query.DistroEvents == nil {
			break
		}

		args, err := ec.field_Query_distroEvents_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.DistroEvents(childComplexity, args["opts"].(DistroEventsInput)), true

	case "Query.distroTaskQueue":
		if e.complexity.Query.DistroTaskQueue == nil {
			break
		}

		args, err := ec.field_Query_distroTaskQueue_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.DistroTaskQueue(childComplexity, args["distroId"].(string)), true

	case "Query.distros":
		if e.complexity.Query.Distros == nil {
			break
		}

		args, err := ec.field_Query_distros_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Distros(childComplexity, args["onlySpawnable"].(bool)), true

	case "Query.githubProjectConflicts":
		if e.complexity.Query.GithubProjectConflicts == nil {
			break
		}

		args, err := ec.field_Query_githubProjectConflicts_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GithubProjectConflicts(childComplexity, args["projectId"].(string)), true

	case "Query.hasVersion":
		if e.complexity.Query.HasVersion == nil {
			break
		}

		args, err := ec.field_Query_hasVersion_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.HasVersion(childComplexity, args["patchId"].(string)), true

	case "Query.host":
		if e.complexity.Query.Host == nil {
			break
		}

		args, err := ec.field_Query_host_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Host(childComplexity, args["hostId"].(string)), true

	case "Query.hostEvents":
		if e.complexity.Query.HostEvents == nil {
			break
		}

		args, err := ec.field_Query_hostEvents_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.HostEvents(childComplexity, args["hostId"].(string), args["hostTag"].(*string), args["limit"].(*int), args["page"].(*int)), true

	case "Query.hosts":
		if e.complexity.Query.Hosts == nil {
			break
		}

		args, err := ec.field_Query_hosts_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Hosts(childComplexity, args["hostId"].(*string), args["distroId"].(*string), args["currentTaskId"].(*string), args["statuses"].([]string), args["startedBy"].(*string), args["sortBy"].(*HostSortBy), args["sortDir"].(*SortDirection), args["page"].(*int), args["limit"].(*int)), true

	case "Query.image":
		if e.complexity.Query.Image == nil {
			break
		}

		args, err := ec.field_Query_image_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Image(childComplexity, args["imageId"].(string)), true

	case "Query.images":
		if e.complexity.Query.Images == nil {
			break
		}

		return e.complexity.Query.Images(childComplexity), true

	case "Query.instanceTypes":
		if e.complexity.Query.InstanceTypes == nil {
			break
		}

		return e.complexity.Query.InstanceTypes(childComplexity), true

	case "Query.isRepo":
		if e.complexity.Query.IsRepo == nil {
			break
		}

		args, err := ec.field_Query_isRepo_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.IsRepo(childComplexity, args["projectOrRepoId"].(string)), true

	case "Query.logkeeperBuildMetadata":
		if e.complexity.Query.LogkeeperBuildMetadata == nil {
			break
		}

		args, err := ec.field_Query_logkeeperBuildMetadata_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.LogkeeperBuildMetadata(childComplexity, args["buildId"].(string)), true

	case "Query.mainlineCommits":
		if e.complexity.Query.MainlineCommits == nil {
			break
		}

		args, err := ec.field_Query_mainlineCommits_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MainlineCommits(childComplexity, args["options"].(MainlineCommitsOptions), args["buildVariantOptions"].(*BuildVariantOptions)), true

	case "Query.myHosts":
		if e.complexity.Query.MyHosts == nil {
			break
		}

		return e.complexity.Query.MyHosts(childComplexity), true

	case "Query.myPublicKeys":
		if e.complexity.Query.MyPublicKeys == nil {
			break
		}

		return e.complexity.Query.MyPublicKeys(childComplexity), true

	case "Query.myVolumes":
		if e.complexity.Query.MyVolumes == nil {
			break
		}

		return e.complexity.Query.MyVolumes(childComplexity), true

	case "Query.patch":
		if e.complexity.Query.Patch == nil {
			break
		}

		args, err := ec.field_Query_patch_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Patch(childComplexity, args["patchId"].(string)), true

	case "Query.pod":
		if e.complexity.Query.Pod == nil {
			break
		}

		args, err := ec.field_Query_pod_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Pod(childComplexity, args["podId"].(string)), true

	case "Query.project":
		if e.complexity.Query.Project == nil {
			break
		}

		args, err := ec.field_Query_project_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Project(childComplexity, args["projectIdentifier"].(string)), true

	case "Query.projectEvents":
		if e.complexity.Query.ProjectEvents == nil {
			break
		}

		args, err := ec.field_Query_projectEvents_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ProjectEvents(childComplexity, args["projectIdentifier"].(string), args["limit"].(*int), args["before"].(*time.Time)), true

	case "Query.projectSettings":
		if e.complexity.Query.ProjectSettings == nil {
			break
		}

		args, err := ec.field_Query_projectSettings_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ProjectSettings(childComplexity, args["projectIdentifier"].(string)), true

	case "Query.projects":
		if e.complexity.Query.Projects == nil {
			break
		}

		return e.complexity.Query.Projects(childComplexity), true

	case "Query.repoEvents":
		if e.complexity.Query.RepoEvents == nil {
			break
		}

		args, err := ec.field_Query_repoEvents_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.RepoEvents(childComplexity, args["repoId"].(string), args["limit"].(*int), args["before"].(*time.Time)), true

	case "Query.repoSettings":
		if e.complexity.Query.RepoSettings == nil {
			break
		}

		args, err := ec.field_Query_repoSettings_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.RepoSettings(childComplexity, args["repoId"].(string)), true

	case "Query.spruceConfig":
		if e.complexity.Query.SpruceConfig == nil {
			break
		}

		return e.complexity.Query.SpruceConfig(childComplexity), true

	case "Query.subnetAvailabilityZones":
		if e.complexity.Query.SubnetAvailabilityZones == nil {
			break
		}

		return e.complexity.Query.SubnetAvailabilityZones(childComplexity), true

	case "Query.task":
		if e.complexity.Query.Task == nil {
			break
		}

		args, err := ec.field_Query_task_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Task(childComplexity, args["taskId"].(string), args["execution"].(*int)), true

	case "Query.taskAllExecutions":
		if e.complexity.Query.TaskAllExecutions == nil {
			break
		}

		args, err := ec.field_Query_taskAllExecutions_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TaskAllExecutions(childComplexity, args["taskId"].(string)), true

	case "Query.taskHistory":
		if e.complexity.Query.TaskHistory == nil {
			break
		}

		args, err := ec.field_Query_taskHistory_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TaskHistory(childComplexity, args["options"].(TaskHistoryOpts)), true

	case "Query.taskNamesForBuildVariant":
		if e.complexity.Query.TaskNamesForBuildVariant == nil {
			break
		}

		args, err := ec.field_Query_taskNamesForBuildVariant_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TaskNamesForBuildVariant(childComplexity, args["projectIdentifier"].(string), args["buildVariant"].(string)), true

	case "Query.taskQueueDistros":
		if e.complexity.Query.TaskQueueDistros == nil {
			break
		}

		return e.complexity.Query.TaskQueueDistros(childComplexity), true

	case "Query.taskTestSample":
		if e.complexity.Query.TaskTestSample == nil {
			break
		}

		args, err := ec.field_Query_taskTestSample_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TaskTestSample(childComplexity, args["versionId"].(string), args["taskIds"].([]string), args["filters"].([]*TestFilter)), true

	case "Query.user":
		if e.complexity.Query.User == nil {
			break
		}

		args, err := ec.field_Query_user_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.User(childComplexity, args["userId"].(*string)), true

	case "Query.userConfig":
		if e.complexity.Query.UserConfig == nil {
			break
		}

		return e.complexity.Query.UserConfig(childComplexity), true

	case "Query.version":
		if e.complexity.Query.Version == nil {
			break
		}

		args, err := ec.field_Query_version_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Version(childComplexity, args["versionId"].(string)), true

	case "Query.viewableProjectRefs":
		if e.complexity.Query.ViewableProjectRefs == nil {
			break
		}

		return e.complexity.Query.ViewableProjectRefs(childComplexity), true

	case "Query.waterfall":
		if e.complexity.Query.Waterfall == nil {
			break
		}

		args, err := ec.field_Query_waterfall_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Waterfall(childComplexity, args["options"].(WaterfallOptions)), true

	case "RepoCommitQueueParams.enabled":
		if e.complexity.RepoCommitQueueParams.Enabled == nil {
			break
		}

		return e.complexity.RepoCommitQueueParams.Enabled(childComplexity), true

	case "RepoCommitQueueParams.mergeMethod":
		if e.complexity.RepoCommitQueueParams.MergeMethod == nil {
			break
		}

		return e.complexity.RepoCommitQueueParams.MergeMethod(childComplexity), true

	case "RepoCommitQueueParams.message":
		if e.complexity.RepoCommitQueueParams.Message == nil {
			break
		}

		return e.complexity.RepoCommitQueueParams.Message(childComplexity), true

	case "RepoPermissions.edit":
		if e.complexity.RepoPermissions.Edit == nil {
			break
		}

		return e.complexity.RepoPermissions.Edit(childComplexity), true

	case "RepoPermissions.view":
		if e.complexity.RepoPermissions.View == nil {
			break
		}

		return e.complexity.RepoPermissions.View(childComplexity), true

	case "RepoRef.admins":
		if e.complexity.RepoRef.Admins == nil {
			break
		}

		return e.complexity.RepoRef.Admins(childComplexity), true

	case "RepoRef.batchTime":
		if e.complexity.RepoRef.BatchTime == nil {
			break
		}

		return e.complexity.RepoRef.BatchTime(childComplexity), true

	case "RepoRef.buildBaronSettings":
		if e.complexity.RepoRef.BuildBaronSettings == nil {
			break
		}

		return e.complexity.RepoRef.BuildBaronSettings(childComplexity), true

	case "RepoRef.commitQueue":
		if e.complexity.RepoRef.CommitQueue == nil {
			break
		}

		return e.complexity.RepoRef.CommitQueue(childComplexity), true

	case "RepoRef.containerSizeDefinitions":
		if e.complexity.RepoRef.ContainerSizeDefinitions == nil {
			break
		}

		return e.complexity.RepoRef.ContainerSizeDefinitions(childComplexity), true

	case "RepoRef.deactivatePrevious":
		if e.complexity.RepoRef.DeactivatePrevious == nil {
			break
		}

		return e.complexity.RepoRef.DeactivatePrevious(childComplexity), true

	case "RepoRef.disabledStatsCache":
		if e.complexity.RepoRef.DisabledStatsCache == nil {
			break
		}

		return e.complexity.RepoRef.DisabledStatsCache(childComplexity), true

	case "RepoRef.dispatchingDisabled":
		if e.complexity.RepoRef.DispatchingDisabled == nil {
			break
		}

		return e.complexity.RepoRef.DispatchingDisabled(childComplexity), true

	case "RepoRef.displayName":
		if e.complexity.RepoRef.DisplayName == nil {
			break
		}

		return e.complexity.RepoRef.DisplayName(childComplexity), true

	case "RepoRef.enabled":
		if e.complexity.RepoRef.Enabled == nil {
			break
		}

		return e.complexity.RepoRef.Enabled(childComplexity), true

	case "RepoRef.externalLinks":
		if e.complexity.RepoRef.ExternalLinks == nil {
			break
		}

		return e.complexity.RepoRef.ExternalLinks(childComplexity), true

	case "RepoRef.githubDynamicTokenPermissionGroups":
		if e.complexity.RepoRef.GitHubDynamicTokenPermissionGroups == nil {
			break
		}

		return e.complexity.RepoRef.GitHubDynamicTokenPermissionGroups(childComplexity), true

	case "RepoRef.githubPermissionGroupByRequester":
		if e.complexity.RepoRef.GitHubPermissionGroupByRequester == nil {
			break
		}

		return e.complexity.RepoRef.GitHubPermissionGroupByRequester(childComplexity), true

	case "RepoRef.gitTagAuthorizedTeams":
		if e.complexity.RepoRef.GitTagAuthorizedTeams == nil {
			break
		}

		return e.complexity.RepoRef.GitTagAuthorizedTeams(childComplexity), true

	case "RepoRef.gitTagAuthorizedUsers":
		if e.complexity.RepoRef.GitTagAuthorizedUsers == nil {
			break
		}

		return e.complexity.RepoRef.GitTagAuthorizedUsers(childComplexity), true

	case "RepoRef.gitTagVersionsEnabled":
		if e.complexity.RepoRef.GitTagVersionsEnabled == nil {
			break
		}

		return e.complexity.RepoRef.GitTagVersionsEnabled(childComplexity), true

	case "RepoRef.githubChecksEnabled":
		if e.complexity.RepoRef.GithubChecksEnabled == nil {
			break
		}

		return e.complexity.RepoRef.GithubChecksEnabled(childComplexity), true

	case "RepoRef.githubMQTriggerAliases":
		if e.complexity.RepoRef.GithubMQTriggerAliases == nil {
			break
		}

		return e.complexity.RepoRef.GithubMQTriggerAliases(childComplexity), true

	case "RepoRef.githubPRTriggerAliases":
		if e.complexity.RepoRef.GithubPRTriggerAliases == nil {
			break
		}

		return e.complexity.RepoRef.GithubPRTriggerAliases(childComplexity), true

	case "RepoRef.githubTriggerAliases":
		if e.complexity.RepoRef.GithubTriggerAliases == nil {
			break
		}

		return e.complexity.RepoRef.GithubTriggerAliases(childComplexity), true

	case "RepoRef.id":
		if e.complexity.RepoRef.Id == nil {
			break
		}

		return e.complexity.RepoRef.Id(childComplexity), true

	case "RepoRef.manualPrTestingEnabled":
		if e.complexity.RepoRef.ManualPRTestingEnabled == nil {
			break
		}

		return e.complexity.RepoRef.ManualPRTestingEnabled(childComplexity), true

	case "RepoRef.notifyOnBuildFailure":
		if e.complexity.RepoRef.NotifyOnBuildFailure == nil {
			break
		}

		return e.complexity.RepoRef.NotifyOnBuildFailure(childComplexity), true

	case "RepoRef.oldestAllowedMergeBase":
		if e.complexity.RepoRef.OldestAllowedMergeBase == nil {
			break
		}

		return e.complexity.RepoRef.OldestAllowedMergeBase(childComplexity), true

	case "RepoRef.owner":
		if e.complexity.RepoRef.Owner == nil {
			break
		}

		return e.complexity.RepoRef.Owner(childComplexity), true

	case "RepoRef.prTestingEnabled":
		if e.complexity.RepoRef.PRTestingEnabled == nil {
			break
		}

		return e.complexity.RepoRef.PRTestingEnabled(childComplexity), true

	case "RepoRef.parsleyFilters":
		if e.complexity.RepoRef.ParsleyFilters == nil {
			break
		}

		return e.complexity.RepoRef.ParsleyFilters(childComplexity), true

	case "RepoRef.patchTriggerAliases":
		if e.complexity.RepoRef.PatchTriggerAliases == nil {
			break
		}

		return e.complexity.RepoRef.PatchTriggerAliases(childComplexity), true

	case "RepoRef.patchingDisabled":
		if e.complexity.RepoRef.PatchingDisabled == nil {
			break
		}

		return e.complexity.RepoRef.PatchingDisabled(childComplexity), true

	case "RepoRef.perfEnabled":
		if e.complexity.RepoRef.PerfEnabled == nil {
			break
		}

		return e.complexity.RepoRef.PerfEnabled(childComplexity), true

	case "RepoRef.periodicBuilds":
		if e.complexity.RepoRef.PeriodicBuilds == nil {
			break
		}

		return e.complexity.RepoRef.PeriodicBuilds(childComplexity), true

	case "RepoRef.remotePath":
		if e.complexity.RepoRef.RemotePath == nil {
			break
		}

		return e.complexity.RepoRef.RemotePath(childComplexity), true

	case "RepoRef.repo":
		if e.complexity.RepoRef.Repo == nil {
			break
		}

		return e.complexity.RepoRef.Repo(childComplexity), true

	case "RepoRef.repotrackerDisabled":
		if e.complexity.RepoRef.RepotrackerDisabled == nil {
			break
		}

		return e.complexity.RepoRef.RepotrackerDisabled(childComplexity), true

	case "RepoRef.restricted":
		if e.complexity.RepoRef.Restricted == nil {
			break
		}

		return e.complexity.RepoRef.Restricted(childComplexity), true

	case "RepoRef.spawnHostScriptPath":
		if e.complexity.RepoRef.SpawnHostScriptPath == nil {
			break
		}

		return e.complexity.RepoRef.SpawnHostScriptPath(childComplexity), true

	case "RepoRef.stepbackBisect":
		if e.complexity.RepoRef.StepbackBisect == nil {
			break
		}

		return e.complexity.RepoRef.StepbackBisect(childComplexity), true

	case "RepoRef.stepbackDisabled":
		if e.complexity.RepoRef.StepbackDisabled == nil {
			break
		}

		return e.complexity.RepoRef.StepbackDisabled(childComplexity), true

	case "RepoRef.taskAnnotationSettings":
		if e.complexity.RepoRef.TaskAnnotationSettings == nil {
			break
		}

		return e.complexity.RepoRef.TaskAnnotationSettings(childComplexity), true

	case "RepoRef.tracksPushEvents":
		if e.complexity.RepoRef.TracksPushEvents == nil {
			break
		}

		return e.complexity.RepoRef.TracksPushEvents(childComplexity), true

	case "RepoRef.triggers":
		if e.complexity.RepoRef.Triggers == nil {
			break
		}

		return e.complexity.RepoRef.Triggers(childComplexity), true

	case "RepoRef.versionControlEnabled":
		if e.complexity.RepoRef.VersionControlEnabled == nil {
			break
		}

		return e.complexity.RepoRef.VersionControlEnabled(childComplexity), true

	case "RepoRef.workstationConfig":
		if e.complexity.RepoRef.WorkstationConfig == nil {
			break
		}

		return e.complexity.RepoRef.WorkstationConfig(childComplexity), true

	case "RepoSettings.aliases":
		if e.complexity.RepoSettings.Aliases == nil {
			break
		}

		return e.complexity.RepoSettings.Aliases(childComplexity), true

	case "RepoSettings.githubAppAuth":
		if e.complexity.RepoSettings.GithubAppAuth == nil {
			break
		}

		return e.complexity.RepoSettings.GithubAppAuth(childComplexity), true

	case "RepoSettings.githubWebhooksEnabled":
		if e.complexity.RepoSettings.GithubWebhooksEnabled == nil {
			break
		}

		return e.complexity.RepoSettings.GithubWebhooksEnabled(childComplexity), true

	case "RepoSettings.projectRef":
		if e.complexity.RepoSettings.ProjectRef == nil {
			break
		}

		return e.complexity.RepoSettings.ProjectRef(childComplexity), true

	case "RepoSettings.subscriptions":
		if e.complexity.RepoSettings.Subscriptions == nil {
			break
		}

		return e.complexity.RepoSettings.Subscriptions(childComplexity), true

	case "RepoSettings.vars":
		if e.complexity.RepoSettings.Vars == nil {
			break
		}

		return e.complexity.RepoSettings.Vars(childComplexity), true

	case "RepoWorkstationConfig.gitClone":
		if e.complexity.RepoWorkstationConfig.GitClone == nil {
			break
		}

		return e.complexity.RepoWorkstationConfig.GitClone(childComplexity), true

	case "RepoWorkstationConfig.setupCommands":
		if e.complexity.RepoWorkstationConfig.SetupCommands == nil {
			break
		}

		return e.complexity.RepoWorkstationConfig.SetupCommands(childComplexity), true

	case "RepotrackerConfig.maxConcurrentRequests":
		if e.complexity.RepotrackerConfig.MaxConcurrentRequests == nil {
			break
		}

		return e.complexity.RepotrackerConfig.MaxConcurrentRequests(childComplexity), true

	case "RepotrackerConfig.maxRepoRevisionsToSearch":
		if e.complexity.RepotrackerConfig.MaxRepoRevisionsToSearch == nil {
			break
		}

		return e.complexity.RepotrackerConfig.MaxRepoRevisionsToSearch(childComplexity), true

	case "RepotrackerConfig.numNewRepoRevisionsToFetch":
		if e.complexity.RepotrackerConfig.NumNewRepoRevisionsToFetch == nil {
			break
		}

		return e.complexity.RepotrackerConfig.NumNewRepoRevisionsToFetch(childComplexity), true

	case "RepotrackerError.exists":
		if e.complexity.RepotrackerError.Exists == nil {
			break
		}

		return e.complexity.RepotrackerError.Exists(childComplexity), true

	case "RepotrackerError.invalidRevision":
		if e.complexity.RepotrackerError.InvalidRevision == nil {
			break
		}

		return e.complexity.RepotrackerError.InvalidRevision(childComplexity), true

	case "RepotrackerError.mergeBaseRevision":
		if e.complexity.RepotrackerError.MergeBaseRevision == nil {
			break
		}

		return e.complexity.RepotrackerError.MergeBaseRevision(childComplexity), true

	case "ResourceLimits.lockedMemoryKb":
		if e.complexity.ResourceLimits.LockedMemoryKB == nil {
			break
		}

		return e.complexity.ResourceLimits.LockedMemoryKB(childComplexity), true

	case "ResourceLimits.numFiles":
		if e.complexity.ResourceLimits.NumFiles == nil {
			break
		}

		return e.complexity.ResourceLimits.NumFiles(childComplexity), true

	case "ResourceLimits.numProcesses":
		if e.complexity.ResourceLimits.NumProcesses == nil {
			break
		}

		return e.complexity.ResourceLimits.NumProcesses(childComplexity), true

	case "ResourceLimits.numTasks":
		if e.complexity.ResourceLimits.NumTasks == nil {
			break
		}

		return e.complexity.ResourceLimits.NumTasks(childComplexity), true

	case "ResourceLimits.virtualMemoryKb":
		if e.complexity.ResourceLimits.VirtualMemoryKB == nil {
			break
		}

		return e.complexity.ResourceLimits.VirtualMemoryKB(childComplexity), true

	case "RestartAdminTasksPayload.numRestartedTasks":
		if e.complexity.RestartAdminTasksPayload.NumRestartedTasks == nil {
			break
		}

		return e.complexity.RestartAdminTasksPayload.NumRestartedTasks(childComplexity), true

	case "RuntimeEnvironmentConfig.apiKey":
		if e.complexity.RuntimeEnvironmentConfig.APIKey == nil {
			break
		}

		return e.complexity.RuntimeEnvironmentConfig.APIKey(childComplexity), true

	case "RuntimeEnvironmentConfig.baseUrl":
		if e.complexity.RuntimeEnvironmentConfig.BaseURL == nil {
			break
		}

		return e.complexity.RuntimeEnvironmentConfig.BaseURL(childComplexity), true

	case "SESConfig.senderAddress":
		if e.complexity.SESConfig.SenderAddress == nil {
			break
		}

		return e.complexity.SESConfig.SenderAddress(childComplexity), true

	case "SaveDistroPayload.distro":
		if e.complexity.SaveDistroPayload.Distro == nil {
			break
		}

		return e.complexity.SaveDistroPayload.Distro(childComplexity), true

	case "SaveDistroPayload.hostCount":
		if e.complexity.SaveDistroPayload.HostCount == nil {
			break
		}

		return e.complexity.SaveDistroPayload.HostCount(childComplexity), true

	case "SchedulerConfig.acceptableHostIdleTimeSeconds":
		if e.complexity.SchedulerConfig.AcceptableHostIdleTimeSeconds == nil {
			break
		}

		return e.complexity.SchedulerConfig.AcceptableHostIdleTimeSeconds(childComplexity), true

	case "SchedulerConfig.cacheDurationSeconds":
		if e.complexity.SchedulerConfig.CacheDurationSeconds == nil {
			break
		}

		return e.complexity.SchedulerConfig.CacheDurationSeconds(childComplexity), true

	case "SchedulerConfig.commitQueueFactor":
		if e.complexity.SchedulerConfig.CommitQueueFactor == nil {
			break
		}

		return e.complexity.SchedulerConfig.CommitQueueFactor(childComplexity), true

	case "SchedulerConfig.expectedRuntimeFactor":
		if e.complexity.SchedulerConfig.ExpectedRuntimeFactor == nil {
			break
		}

		return e.complexity.SchedulerConfig.ExpectedRuntimeFactor(childComplexity), true

	case "SchedulerConfig.futureHostFraction":
		if e.complexity.SchedulerConfig.FutureHostFraction == nil {
			break
		}

		return e.complexity.SchedulerConfig.FutureHostFraction(childComplexity), true

	case "SchedulerConfig.generateTaskFactor":
		if e.complexity.SchedulerConfig.GenerateTaskFactor == nil {
			break
		}

		return e.complexity.SchedulerConfig.GenerateTaskFactor(childComplexity), true

	case "SchedulerConfig.groupVersions":
		if e.complexity.SchedulerConfig.GroupVersions == nil {
			break
		}

		return e.complexity.SchedulerConfig.GroupVersions(childComplexity), true

	case "SchedulerConfig.hostAllocator":
		if e.complexity.SchedulerConfig.HostAllocator == nil {
			break
		}

		return e.complexity.SchedulerConfig.HostAllocator(childComplexity), true

	case "SchedulerConfig.hostAllocatorFeedbackRule":
		if e.complexity.SchedulerConfig.HostAllocatorFeedbackRule == nil {
			break
		}

		return e.complexity.SchedulerConfig.HostAllocatorFeedbackRule(childComplexity), true

	case "SchedulerConfig.hostAllocatorRoundingRule":
		if e.complexity.SchedulerConfig.HostAllocatorRoundingRule == nil {
			break
		}

		return e.complexity.SchedulerConfig.HostAllocatorRoundingRule(childComplexity), true

	case "SchedulerConfig.hostsOverallocatedRule":
		if e.complexity.SchedulerConfig.HostsOverallocatedRule == nil {
			break
		}

		return e.complexity.SchedulerConfig.HostsOverallocatedRule(childComplexity), true

	case "SchedulerConfig.mainlineTimeInQueueFactor":
		if e.complexity.SchedulerConfig.MainlineTimeInQueueFactor == nil {
			break
		}

		return e.complexity.SchedulerConfig.MainlineTimeInQueueFactor(childComplexity), true

	case "SchedulerConfig.numDependentsFactor":
		if e.complexity.SchedulerConfig.NumDependentsFactor == nil {
			break
		}

		return e.complexity.SchedulerConfig.NumDependentsFactor(childComplexity), true

	case "SchedulerConfig.patchFactor":
		if e.complexity.SchedulerConfig.PatchFactor == nil {
			break
		}

		return e.complexity.SchedulerConfig.PatchFactor(childComplexity), true

	case "SchedulerConfig.patchTimeInQueueFactor":
		if e.complexity.SchedulerConfig.PatchTimeInQueueFactor == nil {
			break
		}

		return e.complexity.SchedulerConfig.PatchTimeInQueueFactor(childComplexity), true

	case "SchedulerConfig.stepbackTaskFactor":
		if e.complexity.SchedulerConfig.StepbackTaskFactor == nil {
			break
		}

		return e.complexity.SchedulerConfig.StepbackTaskFactor(childComplexity), true

	case "SchedulerConfig.targetTimeSeconds":
		if e.complexity.SchedulerConfig.TargetTimeSeconds == nil {
			break
		}

		return e.complexity.SchedulerConfig.TargetTimeSeconds(childComplexity), true

	case "SchedulerConfig.taskFinder":
		if e.complexity.SchedulerConfig.TaskFinder == nil {
			break
		}

		return e.complexity.SchedulerConfig.TaskFinder(childComplexity), true

	case "SearchReturnInfo.featuresURL":
		if e.complexity.SearchReturnInfo.FeaturesURL == nil {
			break
		}

		return e.complexity.SearchReturnInfo.FeaturesURL(childComplexity), true

	case "SearchReturnInfo.issues":
		if e.complexity.SearchReturnInfo.Issues == nil {
			break
		}

		return e.complexity.SearchReturnInfo.Issues(childComplexity), true

	case "SearchReturnInfo.search":
		if e.complexity.SearchReturnInfo.Search == nil {
			break
		}

		return e.complexity.SearchReturnInfo.Search(childComplexity), true

	case "SearchReturnInfo.source":
		if e.complexity.SearchReturnInfo.Source == nil {
			break
		}

		return e.complexity.SearchReturnInfo.Source(childComplexity), true

	case "Selector.data":
		if e.complexity.Selector.Data == nil {
			break
		}

		return e.complexity.Selector.Data(childComplexity), true

	case "Selector.type":
		if e.complexity.Selector.Type == nil {
			break
		}

		return e.complexity.Selector.Type(childComplexity), true

	case "ServiceFlags.adminParameterStoreDisabled":
		if e.complexity.ServiceFlags.AdminParameterStoreDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.AdminParameterStoreDisabled(childComplexity), true

	case "ServiceFlags.agentStartDisabled":
		if e.complexity.ServiceFlags.AgentStartDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.AgentStartDisabled(childComplexity), true

	case "ServiceFlags.alertsDisabled":
		if e.complexity.ServiceFlags.AlertsDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.AlertsDisabled(childComplexity), true

	case "ServiceFlags.backgroundReauthDisabled":
		if e.complexity.ServiceFlags.BackgroundReauthDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.BackgroundReauthDisabled(childComplexity), true

	case "ServiceFlags.backgroundStatsDisabled":
		if e.complexity.ServiceFlags.BackgroundStatsDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.BackgroundStatsDisabled(childComplexity), true

	case "ServiceFlags.cliUpdatesDisabled":
		if e.complexity.ServiceFlags.CLIUpdatesDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.CLIUpdatesDisabled(childComplexity), true

	case "ServiceFlags.cacheStatsEndpointDisabled":
		if e.complexity.ServiceFlags.CacheStatsEndpointDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.CacheStatsEndpointDisabled(childComplexity), true

	case "ServiceFlags.cacheStatsJobDisabled":
		if e.complexity.ServiceFlags.CacheStatsJobDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.CacheStatsJobDisabled(childComplexity), true

	case "ServiceFlags.checkBlockedTasksDisabled":
		if e.complexity.ServiceFlags.CheckBlockedTasksDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.CheckBlockedTasksDisabled(childComplexity), true

	case "ServiceFlags.cloudCleanupDisabled":
		if e.complexity.ServiceFlags.CloudCleanupDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.CloudCleanupDisabled(childComplexity), true

	case "ServiceFlags.degradedModeDisabled":
		if e.complexity.ServiceFlags.DegradedModeDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.DegradedModeDisabled(childComplexity), true

	case "ServiceFlags.elasticIPsDisabled":
		if e.complexity.ServiceFlags.ElasticIPsDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.ElasticIPsDisabled(childComplexity), true

	case "ServiceFlags.emailNotificationsDisabled":
		if e.complexity.ServiceFlags.EmailNotificationsDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.EmailNotificationsDisabled(childComplexity), true

	case "ServiceFlags.eventProcessingDisabled":
		if e.complexity.ServiceFlags.EventProcessingDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.EventProcessingDisabled(childComplexity), true

	case "ServiceFlags.githubPRTestingDisabled":
		if e.complexity.ServiceFlags.GithubPRTestingDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.GithubPRTestingDisabled(childComplexity), true

	case "ServiceFlags.githubStatusAPIDisabled":
		if e.complexity.ServiceFlags.GithubStatusAPIDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.GithubStatusAPIDisabled(childComplexity), true

	case "ServiceFlags.hostAllocatorDisabled":
		if e.complexity.ServiceFlags.HostAllocatorDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.HostAllocatorDisabled(childComplexity), true

	case "ServiceFlags.hostInitDisabled":
		if e.complexity.ServiceFlags.HostInitDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.HostInitDisabled(childComplexity), true

	case "ServiceFlags.jiraNotificationsDisabled":
		if e.complexity.ServiceFlags.JIRANotificationsDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.JIRANotificationsDisabled(childComplexity), true

	case "ServiceFlags.jwtTokenForCLIDisabled":
		if e.complexity.ServiceFlags.JWTTokenForCLIDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.JWTTokenForCLIDisabled(childComplexity), true

	case "ServiceFlags.largeParserProjectsDisabled":
		if e.complexity.ServiceFlags.LargeParserProjectsDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.LargeParserProjectsDisabled(childComplexity), true

	case "ServiceFlags.monitorDisabled":
		if e.complexity.ServiceFlags.MonitorDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.MonitorDisabled(childComplexity), true

	case "ServiceFlags.podAllocatorDisabled":
		if e.complexity.ServiceFlags.PodAllocatorDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.PodAllocatorDisabled(childComplexity), true

	case "ServiceFlags.podInitDisabled":
		if e.complexity.ServiceFlags.PodInitDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.PodInitDisabled(childComplexity), true

	case "ServiceFlags.releaseModeDisabled":
		if e.complexity.ServiceFlags.ReleaseModeDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.ReleaseModeDisabled(childComplexity), true

	case "ServiceFlags.repotrackerDisabled":
		if e.complexity.ServiceFlags.RepotrackerDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.RepotrackerDisabled(childComplexity), true

	case "ServiceFlags.schedulerDisabled":
		if e.complexity.ServiceFlags.SchedulerDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.SchedulerDisabled(childComplexity), true

	case "ServiceFlags.slackNotificationsDisabled":
		if e.complexity.ServiceFlags.SlackNotificationsDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.SlackNotificationsDisabled(childComplexity), true

	case "ServiceFlags.sleepScheduleDisabled":
		if e.complexity.ServiceFlags.SleepScheduleDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.SleepScheduleDisabled(childComplexity), true

	case "ServiceFlags.staticAPIKeysDisabled":
		if e.complexity.ServiceFlags.StaticAPIKeysDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.StaticAPIKeysDisabled(childComplexity), true

	case "ServiceFlags.systemFailedTaskRestartDisabled":
		if e.complexity.ServiceFlags.SystemFailedTaskRestartDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.SystemFailedTaskRestartDisabled(childComplexity), true

	case "ServiceFlags.taskDispatchDisabled":
		if e.complexity.ServiceFlags.TaskDispatchDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.TaskDispatchDisabled(childComplexity), true

	case "ServiceFlags.taskLoggingDisabled":
		if e.complexity.ServiceFlags.TaskLoggingDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.TaskLoggingDisabled(childComplexity), true

	case "ServiceFlags.taskReliabilityDisabled":
		if e.complexity.ServiceFlags.TaskReliabilityDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.TaskReliabilityDisabled(childComplexity), true

	case "ServiceFlags.unrecognizedPodCleanupDisabled":
		if e.complexity.ServiceFlags.UnrecognizedPodCleanupDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.UnrecognizedPodCleanupDisabled(childComplexity), true

	case "ServiceFlags.webhookNotificationsDisabled":
		if e.complexity.ServiceFlags.WebhookNotificationsDisabled == nil {
			break
		}

		return e.complexity.ServiceFlags.WebhookNotificationsDisabled(childComplexity), true

	case "SetLastRevisionPayload.mergeBaseRevision":
		if e.complexity.SetLastRevisionPayload.MergeBaseRevision == nil {
			break
		}

		return e.complexity.SetLastRevisionPayload.MergeBaseRevision(childComplexity), true

	case "SingleTaskDistroConfig.projectTasksPairs":
		if e.complexity.SingleTaskDistroConfig.ProjectTasksPairs == nil {
			break
		}

		return e.complexity.SingleTaskDistroConfig.ProjectTasksPairs(childComplexity), true

	case "SlackConfig.level":
		if e.complexity.SlackConfig.Level == nil {
			break
		}

		return e.complexity.SlackConfig.Level(childComplexity), true

	case "SlackConfig.name":
		if e.complexity.SlackConfig.Name == nil {
			break
		}

		return e.complexity.SlackConfig.Name(childComplexity), true

	case "SlackConfig.options":
		if e.complexity.SlackConfig.Options == nil {
			break
		}

		return e.complexity.SlackConfig.Options(childComplexity), true

	case "SlackConfig.token":
		if e.complexity.SlackConfig.Token == nil {
			break
		}

		return e.complexity.SlackConfig.Token(childComplexity), true

	case "SlackOptions.allFields":
		if e.complexity.SlackOptions.AllFields == nil {
			break
		}

		return e.complexity.SlackOptions.AllFields(childComplexity), true

	case "SlackOptions.basicMetadata":
		if e.complexity.SlackOptions.BasicMetadata == nil {
			break
		}

		return e.complexity.SlackOptions.BasicMetadata(childComplexity), true

	case "SlackOptions.channel":
		if e.complexity.SlackOptions.Channel == nil {
			break
		}

		return e.complexity.SlackOptions.Channel(childComplexity), true

	case "SlackOptions.fields":
		if e.complexity.SlackOptions.Fields == nil {
			break
		}

		return e.complexity.SlackOptions.Fields(childComplexity), true

	case "SlackOptions.fieldsSet":
		if e.complexity.SlackOptions.FieldsSet == nil {
			break
		}

		return e.complexity.SlackOptions.FieldsSet(childComplexity), true

	case "SlackOptions.hostname":
		if e.complexity.SlackOptions.Hostname == nil {
			break
		}

		return e.complexity.SlackOptions.Hostname(childComplexity), true

	case "SlackOptions.name":
		if e.complexity.SlackOptions.Name == nil {
			break
		}

		return e.complexity.SlackOptions.Name(childComplexity), true

	case "SlackOptions.username":
		if e.complexity.SlackOptions.Username == nil {
			break
		}

		return e.complexity.SlackOptions.Username(childComplexity), true

	case "SleepSchedule.dailyStartTime":
		if e.complexity.SleepSchedule.DailyStartTime == nil {
			break
		}

		return e.complexity.SleepSchedule.DailyStartTime(childComplexity), true

	case "SleepSchedule.dailyStopTime":
		if e.complexity.SleepSchedule.DailyStopTime == nil {
			break
		}

		return e.complexity.SleepSchedule.DailyStopTime(childComplexity), true

	case "SleepSchedule.nextStartTime":
		if e.complexity.SleepSchedule.NextStartTime == nil {
			break
		}

		return e.complexity.SleepSchedule.NextStartTime(childComplexity), true

	case "SleepSchedule.nextStopTime":
		if e.complexity.SleepSchedule.NextStopTime == nil {
			break
		}

		return e.complexity.SleepSchedule.NextStopTime(childComplexity), true

	case "SleepSchedule.permanentlyExempt":
		if e.complexity.SleepSchedule.PermanentlyExempt == nil {
			break
		}

		return e.complexity.SleepSchedule.PermanentlyExempt(childComplexity), true

	case "SleepSchedule.shouldKeepOff":
		if e.complexity.SleepSchedule.ShouldKeepOff == nil {
			break
		}

		return e.complexity.SleepSchedule.ShouldKeepOff(childComplexity), true

	case "SleepSchedule.temporarilyExemptUntil":
		if e.complexity.SleepSchedule.TemporarilyExemptUntil == nil {
			break
		}

		return e.complexity.SleepSchedule.TemporarilyExemptUntil(childComplexity), true

	case "SleepSchedule.timeZone":
		if e.complexity.SleepSchedule.TimeZone == nil {
			break
		}

		return e.complexity.SleepSchedule.TimeZone(childComplexity), true

	case "SleepSchedule.wholeWeekdaysOff":
		if e.complexity.SleepSchedule.WholeWeekdaysOff == nil {
			break
		}

		return e.complexity.SleepSchedule.WholeWeekdaysOff(childComplexity), true

	case "Source.author":
		if e.complexity.Source.Author == nil {
			break
		}

		return e.complexity.Source.Author(childComplexity), true

	case "Source.requester":
		if e.complexity.Source.Requester == nil {
			break
		}

		return e.complexity.Source.Requester(childComplexity), true

	case "Source.time":
		if e.complexity.Source.Time == nil {
			break
		}

		return e.complexity.Source.Time(childComplexity), true

	case "SpawnHostConfig.spawnHostsPerUser":
		if e.complexity.SpawnHostConfig.SpawnHostsPerUser == nil {
			break
		}

		return e.complexity.SpawnHostConfig.SpawnHostsPerUser(childComplexity), true

	case "SpawnHostConfig.unexpirableHostsPerUser":
		if e.complexity.SpawnHostConfig.UnexpirableHostsPerUser == nil {
			break
		}

		return e.complexity.SpawnHostConfig.UnexpirableHostsPerUser(childComplexity), true

	case "SpawnHostConfig.unexpirableVolumesPerUser":
		if e.complexity.SpawnHostConfig.UnexpirableVolumesPerUser == nil {
			break
		}

		return e.complexity.SpawnHostConfig.UnexpirableVolumesPerUser(childComplexity), true

	case "SplunkConfig.splunkConnectionInfo":
		if e.complexity.SplunkConfig.SplunkConnectionInfo == nil {
			break
		}

		return e.complexity.SplunkConfig.SplunkConnectionInfo(childComplexity), true

	case "SplunkConnectionInfo.channel":
		if e.complexity.SplunkConnectionInfo.Channel == nil {
			break
		}

		return e.complexity.SplunkConnectionInfo.Channel(childComplexity), true

	case "SplunkConnectionInfo.serverUrl":
		if e.complexity.SplunkConnectionInfo.ServerURL == nil {
			break
		}

		return e.complexity.SplunkConnectionInfo.ServerURL(childComplexity), true

	case "SplunkConnectionInfo.token":
		if e.complexity.SplunkConnectionInfo.Token == nil {
			break
		}

		return e.complexity.SplunkConnectionInfo.Token(childComplexity), true

	case "SpruceConfig.banner":
		if e.complexity.SpruceConfig.Banner == nil {
			break
		}

		return e.complexity.SpruceConfig.Banner(childComplexity), true

	case "SpruceConfig.bannerTheme":
		if e.complexity.SpruceConfig.BannerTheme == nil {
			break
		}

		return e.complexity.SpruceConfig.BannerTheme(childComplexity), true

	case "SpruceConfig.containerPools":
		if e.complexity.SpruceConfig.ContainerPools == nil {
			break
		}

		return e.complexity.SpruceConfig.ContainerPools(childComplexity), true

	case "SpruceConfig.githubOrgs":
		if e.complexity.SpruceConfig.GithubOrgs == nil {
			break
		}

		return e.complexity.SpruceConfig.GithubOrgs(childComplexity), true

	case "SpruceConfig.jira":
		if e.complexity.SpruceConfig.Jira == nil {
			break
		}

		return e.complexity.SpruceConfig.Jira(childComplexity), true

	case "SpruceConfig.providers":
		if e.complexity.SpruceConfig.Providers == nil {
			break
		}

		return e.complexity.SpruceConfig.Providers(childComplexity), true

	case "SpruceConfig.secretFields":
		if e.complexity.SpruceConfig.SecretFields == nil {
			break
		}

		return e.complexity.SpruceConfig.SecretFields(childComplexity), true

	case "SpruceConfig.singleTaskDistro":
		if e.complexity.SpruceConfig.SingleTaskDistro == nil {
			break
		}

		return e.complexity.SpruceConfig.SingleTaskDistro(childComplexity), true

	case "SpruceConfig.slack":
		if e.complexity.SpruceConfig.Slack == nil {
			break
		}

		return e.complexity.SpruceConfig.Slack(childComplexity), true

	case "SpruceConfig.spawnHost":
		if e.complexity.SpruceConfig.Spawnhost == nil {
			break
		}

		return e.complexity.SpruceConfig.Spawnhost(childComplexity), true

	case "SpruceConfig.ui":
		if e.complexity.SpruceConfig.Ui == nil {
			break
		}

		return e.complexity.SpruceConfig.Ui(childComplexity), true

	case "StatusCount.count":
		if e.complexity.StatusCount.Count == nil {
			break
		}

		return e.complexity.StatusCount.Count(childComplexity), true

	case "StatusCount.status":
		if e.complexity.StatusCount.Status == nil {
			break
		}

		return e.complexity.StatusCount.Status(childComplexity), true

	case "StepbackInfo.lastFailingStepbackTaskId":
		if e.complexity.StepbackInfo.LastFailingStepbackTaskId == nil {
			break
		}

		return e.complexity.StepbackInfo.LastFailingStepbackTaskId(childComplexity), true

	case "StepbackInfo.lastPassingStepbackTaskId":
		if e.complexity.StepbackInfo.LastPassingStepbackTaskId == nil {
			break
		}

		return e.complexity.StepbackInfo.LastPassingStepbackTaskId(childComplexity), true

	case "StepbackInfo.nextStepbackTaskId":
		if e.complexity.StepbackInfo.NextStepbackTaskId == nil {
			break
		}

		return e.complexity.StepbackInfo.NextStepbackTaskId(childComplexity), true

	case "StepbackInfo.previousStepbackTaskId":
		if e.complexity.StepbackInfo.PreviousStepbackTaskId == nil {
			break
		}

		return e.complexity.StepbackInfo.PreviousStepbackTaskId(childComplexity), true

	case "Subscriber.emailSubscriber":
		if e.complexity.Subscriber.EmailSubscriber == nil {
			break
		}

		return e.complexity.Subscriber.EmailSubscriber(childComplexity), true

	case "Subscriber.githubCheckSubscriber":
		if e.complexity.Subscriber.GithubCheckSubscriber == nil {
			break
		}

		return e.complexity.Subscriber.GithubCheckSubscriber(childComplexity), true

	case "Subscriber.githubPRSubscriber":
		if e.complexity.Subscriber.GithubPRSubscriber == nil {
			break
		}

		return e.complexity.Subscriber.GithubPRSubscriber(childComplexity), true

	case "Subscriber.jiraCommentSubscriber":
		if e.complexity.Subscriber.JiraCommentSubscriber == nil {
			break
		}

		return e.complexity.Subscriber.JiraCommentSubscriber(childComplexity), true

	case "Subscriber.jiraIssueSubscriber":
		if e.complexity.Subscriber.JiraIssueSubscriber == nil {
			break
		}

		return e.complexity.Subscriber.JiraIssueSubscriber(childComplexity), true

	case "Subscriber.slackSubscriber":
		if e.complexity.Subscriber.SlackSubscriber == nil {
			break
		}

		return e.complexity.Subscriber.SlackSubscriber(childComplexity), true

	case "Subscriber.webhookSubscriber":
		if e.complexity.Subscriber.WebhookSubscriber == nil {
			break
		}

		return e.complexity.Subscriber.WebhookSubscriber(childComplexity), true

	case "SubscriberWrapper.subscriber":
		if e.complexity.SubscriberWrapper.Subscriber == nil {
			break
		}

		return e.complexity.SubscriberWrapper.Subscriber(childComplexity), true

	case "SubscriberWrapper.type":
		if e.complexity.SubscriberWrapper.Type == nil {
			break
		}

		return e.complexity.SubscriberWrapper.Type(childComplexity), true

	case "Task.abortInfo":
		if e.complexity.Task.AbortInfo == nil {
			break
		}

		return e.complexity.Task.AbortInfo(childComplexity), true

	case "Task.aborted":
		if e.complexity.Task.Aborted == nil {
			break
		}

		return e.complexity.Task.Aborted(childComplexity), true

	case "Task.activated":
		if e.complexity.Task.Activated == nil {
			break
		}

		return e.complexity.Task.Activated(childComplexity), true

	case "Task.activatedBy":
		if e.complexity.Task.ActivatedBy == nil {
			break
		}

		return e.complexity.Task.ActivatedBy(childComplexity), true

	case "Task.activatedTime":
		if e.complexity.Task.ActivatedTime == nil {
			break
		}

		return e.complexity.Task.ActivatedTime(childComplexity), true

	case "Task.ami":
		if e.complexity.Task.Ami == nil {
			break
		}

		return e.complexity.Task.Ami(childComplexity), true

	case "Task.annotation":
		if e.complexity.Task.Annotation == nil {
			break
		}

		return e.complexity.Task.Annotation(childComplexity), true

	case "Task.baseStatus":
		if e.complexity.Task.BaseStatus == nil {
			break
		}

		return e.complexity.Task.BaseStatus(childComplexity), true

	case "Task.baseTask":
		if e.complexity.Task.BaseTask == nil {
			break
		}

		return e.complexity.Task.BaseTask(childComplexity), true

	case "Task.blocked":
		if e.complexity.Task.Blocked == nil {
			break
		}

		return e.complexity.Task.Blocked(childComplexity), true

	case "Task.buildId":
		if e.complexity.Task.BuildId == nil {
			break
		}

		return e.complexity.Task.BuildId(childComplexity), true

	case "Task.buildVariant":
		if e.complexity.Task.BuildVariant == nil {
			break
		}

		return e.complexity.Task.BuildVariant(childComplexity), true

	case "Task.buildVariantDisplayName":
		if e.complexity.Task.BuildVariantDisplayName == nil {
			break
		}

		return e.complexity.Task.BuildVariantDisplayName(childComplexity), true

	case "Task.canAbort":
		if e.complexity.Task.CanAbort == nil {
			break
		}

		return e.complexity.Task.CanAbort(childComplexity), true

	case "Task.canDisable":
		if e.complexity.Task.CanDisable == nil {
			break
		}

		return e.complexity.Task.CanDisable(childComplexity), true

	case "Task.canModifyAnnotation":
		if e.complexity.Task.CanModifyAnnotation == nil {
			break
		}

		return e.complexity.Task.CanModifyAnnotation(childComplexity), true

	case "Task.canOverrideDependencies":
		if e.complexity.Task.CanOverrideDependencies == nil {
			break
		}

		return e.complexity.Task.CanOverrideDependencies(childComplexity), true

	case "Task.canRestart":
		if e.complexity.Task.CanRestart == nil {
			break
		}

		return e.complexity.Task.CanRestart(childComplexity), true

	case "Task.canSchedule":
		if e.complexity.Task.CanSchedule == nil {
			break
		}

		return e.complexity.Task.CanSchedule(childComplexity), true

	case "Task.canSetPriority":
		if e.complexity.Task.CanSetPriority == nil {
			break
		}

		return e.complexity.Task.CanSetPriority(childComplexity), true

	case "Task.canUnschedule":
		if e.complexity.Task.CanUnschedule == nil {
			break
		}

		return e.complexity.Task.CanUnschedule(childComplexity), true

	case "Task.containerAllocatedTime":
		if e.complexity.Task.ContainerAllocatedTime == nil {
			break
		}

		return e.complexity.Task.ContainerAllocatedTime(childComplexity), true

	case "Task.createTime":
		if e.complexity.Task.CreateTime == nil {
			break
		}

		return e.complexity.Task.CreateTime(childComplexity), true

	case "Task.dependsOn":
		if e.complexity.Task.DependsOn == nil {
			break
		}

		return e.complexity.Task.DependsOn(childComplexity), true

	case "Task.details":
		if e.complexity.Task.Details == nil {
			break
		}

		return e.complexity.Task.Details(childComplexity), true

	case "Task.dispatchTime":
		if e.complexity.Task.DispatchTime == nil {
			break
		}

		return e.complexity.Task.DispatchTime(childComplexity), true

	case "Task.displayName":
		if e.complexity.Task.DisplayName == nil {
			break
		}

		return e.complexity.Task.DisplayName(childComplexity), true

	case "Task.displayOnly":
		if e.complexity.Task.DisplayOnly == nil {
			break
		}

		return e.complexity.Task.DisplayOnly(childComplexity), true

	case "Task.displayStatus":
		if e.complexity.Task.DisplayStatus == nil {
			break
		}

		return e.complexity.Task.DisplayStatus(childComplexity), true

	case "Task.displayTask":
		if e.complexity.Task.DisplayTask == nil {
			break
		}

		return e.complexity.Task.DisplayTask(childComplexity), true

	case "Task.distroId":
		if e.complexity.Task.DistroId == nil {
			break
		}

		return e.complexity.Task.DistroId(childComplexity), true

	case "Task.estimatedStart":
		if e.complexity.Task.EstimatedStart == nil {
			break
		}

		return e.complexity.Task.EstimatedStart(childComplexity), true

	case "Task.execution":
		if e.complexity.Task.Execution == nil {
			break
		}

		return e.complexity.Task.Execution(childComplexity), true

	case "Task.executionTasks":
		if e.complexity.Task.ExecutionTasks == nil {
			break
		}

		return e.complexity.Task.ExecutionTasks(childComplexity), true

	case "Task.executionTasksFull":
		if e.complexity.Task.ExecutionTasksFull == nil {
			break
		}

		return e.complexity.Task.ExecutionTasksFull(childComplexity), true

	case "Task.expectedDuration":
		if e.complexity.Task.ExpectedDuration == nil {
			break
		}

		return e.complexity.Task.ExpectedDuration(childComplexity), true

	case "Task.failedTestCount":
		if e.complexity.Task.FailedTestCount == nil {
			break
		}

		return e.complexity.Task.FailedTestCount(childComplexity), true

	case "Task.files":
		if e.complexity.Task.Files == nil {
			break
		}

		return e.complexity.Task.Files(childComplexity), true

	case "Task.finishTime":
		if e.complexity.Task.FinishTime == nil {
			break
		}

		return e.complexity.Task.FinishTime(childComplexity), true

	case "Task.generateTask":
		if e.complexity.Task.GenerateTask == nil {
			break
		}

		return e.complexity.Task.GenerateTask(childComplexity), true

	case "Task.generatedBy":
		if e.complexity.Task.GeneratedBy == nil {
			break
		}

		return e.complexity.Task.GeneratedBy(childComplexity), true

	case "Task.generatedByName":
		if e.complexity.Task.GeneratedByName == nil {
			break
		}

		return e.complexity.Task.GeneratedByName(childComplexity), true

	case "Task.hasTestResults":
		if e.complexity.Task.HasTestResults == nil {
			break
		}

		return e.complexity.Task.HasTestResults(childComplexity), true

	case "Task.hostId":
		if e.complexity.Task.HostId == nil {
			break
		}

		return e.complexity.Task.HostId(childComplexity), true

	case "Task.id":
		if e.complexity.Task.Id == nil {
			break
		}

		return e.complexity.Task.Id(childComplexity), true

	case "Task.imageId":
		if e.complexity.Task.ImageID == nil {
			break
		}

		return e.complexity.Task.ImageID(childComplexity), true

	case "Task.ingestTime":
		if e.complexity.Task.IngestTime == nil {
			break
		}

		return e.complexity.Task.IngestTime(childComplexity), true

	case "Task.isPerfPluginEnabled":
		if e.complexity.Task.IsPerfPluginEnabled == nil {
			break
		}

		return e.complexity.Task.IsPerfPluginEnabled(childComplexity), true

	case "Task.latestExecution":
		if e.complexity.Task.LatestExecution == nil {
			break
		}

		return e.complexity.Task.LatestExecution(childComplexity), true

	case "Task.logs":
		if e.complexity.Task.Logs == nil {
			break
		}

		return e.complexity.Task.Logs(childComplexity), true

	case "Task.minQueuePosition":
		if e.complexity.Task.MinQueuePosition == nil {
			break
		}

		return e.complexity.Task.MinQueuePosition(childComplexity), true

	case "Task.order":
		if e.complexity.Task.Order == nil {
			break
		}

		return e.complexity.Task.Order(childComplexity), true

	case "Task.patch":
		if e.complexity.Task.Patch == nil {
			break
		}

		return e.complexity.Task.Patch(childComplexity), true

	case "Task.patchNumber":
		if e.complexity.Task.PatchNumber == nil {
			break
		}

		return e.complexity.Task.PatchNumber(childComplexity), true

	case "Task.pod":
		if e.complexity.Task.Pod == nil {
			break
		}

		return e.complexity.Task.Pod(childComplexity), true

	case "Task.priority":
		if e.complexity.Task.Priority == nil {
			break
		}

		return e.complexity.Task.Priority(childComplexity), true

	case "Task.project":
		if e.complexity.Task.Project == nil {
			break
		}

		return e.complexity.Task.Project(childComplexity), true

	case "Task.projectId":
		if e.complexity.Task.ProjectId == nil {
			break
		}

		return e.complexity.Task.ProjectId(childComplexity), true

	case "Task.projectIdentifier":
		if e.complexity.Task.ProjectIdentifier == nil {
			break
		}

		return e.complexity.Task.ProjectIdentifier(childComplexity), true

	case "Task.requester":
		if e.complexity.Task.Requester == nil {
			break
		}

		return e.complexity.Task.Requester(childComplexity), true

	case "Task.resetWhenFinished":
		if e.complexity.Task.ResetWhenFinished == nil {
			break
		}

		return e.complexity.Task.ResetWhenFinished(childComplexity), true

	case "Task.revision":
		if e.complexity.Task.Revision == nil {
			break
		}

		return e.complexity.Task.Revision(childComplexity), true

	case "Task.scheduledTime":
		if e.complexity.Task.ScheduledTime == nil {
			break
		}

		return e.complexity.Task.ScheduledTime(childComplexity), true

	case "Task.spawnHostLink":
		if e.complexity.Task.SpawnHostLink == nil {
			break
		}

		return e.complexity.Task.SpawnHostLink(childComplexity), true

	case "Task.startTime":
		if e.complexity.Task.StartTime == nil {
			break
		}

		return e.complexity.Task.StartTime(childComplexity), true

	case "Task.status":
		if e.complexity.Task.Status == nil {
			break
		}

		return e.complexity.Task.Status(childComplexity), true

	case "Task.stepbackInfo":
		if e.complexity.Task.StepbackInfo == nil {
			break
		}

		return e.complexity.Task.StepbackInfo(childComplexity), true

	case "Task.tags":
		if e.complexity.Task.Tags == nil {
			break
		}

		return e.complexity.Task.Tags(childComplexity), true

	case "Task.taskGroup":
		if e.complexity.Task.TaskGroup == nil {
			break
		}

		return e.complexity.Task.TaskGroup(childComplexity), true

	case "Task.taskGroupMaxHosts":
		if e.complexity.Task.TaskGroupMaxHosts == nil {
			break
		}

		return e.complexity.Task.TaskGroupMaxHosts(childComplexity), true

	case "Task.taskLogs":
		if e.complexity.Task.TaskLogs == nil {
			break
		}

		return e.complexity.Task.TaskLogs(childComplexity), true

	case "Task.taskOwnerTeam":
		if e.complexity.Task.TaskOwnerTeam == nil {
			break
		}

		return e.complexity.Task.TaskOwnerTeam(childComplexity), true

	case "Task.tests":
		if e.complexity.Task.Tests == nil {
			break
		}

		args, err := ec.field_Task_tests_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Task.Tests(childComplexity, args["opts"].(*TestFilterOptions)), true

	case "Task.timeTaken":
		if e.complexity.Task.TimeTaken == nil {
			break
		}

		return e.complexity.Task.TimeTaken(childComplexity), true

	case "Task.totalTestCount":
		if e.complexity.Task.TotalTestCount == nil {
			break
		}

		return e.complexity.Task.TotalTestCount(childComplexity), true

	case "Task.versionMetadata":
		if e.complexity.Task.VersionMetadata == nil {
			break
		}

		return e.complexity.Task.VersionMetadata(childComplexity), true

	case "TaskAnnotationSettings.fileTicketWebhook":
		if e.complexity.TaskAnnotationSettings.FileTicketWebhook == nil {
			break
		}

		return e.complexity.TaskAnnotationSettings.FileTicketWebhook(childComplexity), true

	case "TaskContainerCreationOpts.arch":
		if e.complexity.TaskContainerCreationOpts.Arch == nil {
			break
		}

		return e.complexity.TaskContainerCreationOpts.Arch(childComplexity), true

	case "TaskContainerCreationOpts.cpu":
		if e.complexity.TaskContainerCreationOpts.CPU == nil {
			break
		}

		return e.complexity.TaskContainerCreationOpts.CPU(childComplexity), true

	case "TaskContainerCreationOpts.image":
		if e.complexity.TaskContainerCreationOpts.Image == nil {
			break
		}

		return e.complexity.TaskContainerCreationOpts.Image(childComplexity), true

	case "TaskContainerCreationOpts.memoryMB":
		if e.complexity.TaskContainerCreationOpts.MemoryMB == nil {
			break
		}

		return e.complexity.TaskContainerCreationOpts.MemoryMB(childComplexity), true

	case "TaskContainerCreationOpts.os":
		if e.complexity.TaskContainerCreationOpts.Os == nil {
			break
		}

		return e.complexity.TaskContainerCreationOpts.Os(childComplexity), true

	case "TaskContainerCreationOpts.workingDir":
		if e.complexity.TaskContainerCreationOpts.WorkingDir == nil {
			break
		}

		return e.complexity.TaskContainerCreationOpts.WorkingDir(childComplexity), true

	case "TaskEndDetail.description":
		if e.complexity.TaskEndDetail.Description == nil {
			break
		}

		return e.complexity.TaskEndDetail.Description(childComplexity), true

	case "TaskEndDetail.diskDevices":
		if e.complexity.TaskEndDetail.DiskDevices == nil {
			break
		}

		return e.complexity.TaskEndDetail.DiskDevices(childComplexity), true

	case "TaskEndDetail.failingCommand":
		if e.complexity.TaskEndDetail.FailingCommand == nil {
			break
		}

		return e.complexity.TaskEndDetail.FailingCommand(childComplexity), true

	case "TaskEndDetail.failureMetadataTags":
		if e.complexity.TaskEndDetail.FailureMetadataTags == nil {
			break
		}

		return e.complexity.TaskEndDetail.FailureMetadataTags(childComplexity), true

	case "TaskEndDetail.oomTracker":
		if e.complexity.TaskEndDetail.OOMTracker == nil {
			break
		}

		return e.complexity.TaskEndDetail.OOMTracker(childComplexity), true

	case "TaskEndDetail.otherFailingCommands":
		if e.complexity.TaskEndDetail.OtherFailingCommands == nil {
			break
		}

		return e.complexity.TaskEndDetail.OtherFailingCommands(childComplexity), true

	case "TaskEndDetail.status":
		if e.complexity.TaskEndDetail.Status == nil {
			break
		}

		return e.complexity.TaskEndDetail.Status(childComplexity), true

	case "TaskEndDetail.timedOut":
		if e.complexity.TaskEndDetail.TimedOut == nil {
			break
		}

		return e.complexity.TaskEndDetail.TimedOut(childComplexity), true

	case "TaskEndDetail.timeoutType":
		if e.complexity.TaskEndDetail.TimeoutType == nil {
			break
		}

		return e.complexity.TaskEndDetail.TimeoutType(childComplexity), true

	case "TaskEndDetail.traceID":
		if e.complexity.TaskEndDetail.TraceID == nil {
			break
		}

		return e.complexity.TaskEndDetail.TraceID(childComplexity), true

	case "TaskEndDetail.type":
		if e.complexity.TaskEndDetail.Type == nil {
			break
		}

		return e.complexity.TaskEndDetail.Type(childComplexity), true

	case "TaskEventLogData.blockedOn":
		if e.complexity.TaskEventLogData.BlockedOn == nil {
			break
		}

		return e.complexity.TaskEventLogData.BlockedOn(childComplexity), true

	case "TaskEventLogData.hostId":
		if e.complexity.TaskEventLogData.HostId == nil {
			break
		}

		return e.complexity.TaskEventLogData.HostId(childComplexity), true

	case "TaskEventLogData.jiraIssue":
		if e.complexity.TaskEventLogData.JiraIssue == nil {
			break
		}

		return e.complexity.TaskEventLogData.JiraIssue(childComplexity), true

	case "TaskEventLogData.jiraLink":
		if e.complexity.TaskEventLogData.JiraLink == nil {
			break
		}

		return e.complexity.TaskEventLogData.JiraLink(childComplexity), true

	case "TaskEventLogData.podId":
		if e.complexity.TaskEventLogData.PodId == nil {
			break
		}

		return e.complexity.TaskEventLogData.PodId(childComplexity), true

	case "TaskEventLogData.priority":
		if e.complexity.TaskEventLogData.Priority == nil {
			break
		}

		return e.complexity.TaskEventLogData.Priority(childComplexity), true

	case "TaskEventLogData.status":
		if e.complexity.TaskEventLogData.Status == nil {
			break
		}

		return e.complexity.TaskEventLogData.Status(childComplexity), true

	case "TaskEventLogData.timestamp":
		if e.complexity.TaskEventLogData.Timestamp == nil {
			break
		}

		return e.complexity.TaskEventLogData.Timestamp(childComplexity), true

	case "TaskEventLogData.userId":
		if e.complexity.TaskEventLogData.UserId == nil {
			break
		}

		return e.complexity.TaskEventLogData.UserId(childComplexity), true

	case "TaskEventLogEntry.data":
		if e.complexity.TaskEventLogEntry.Data == nil {
			break
		}

		return e.complexity.TaskEventLogEntry.Data(childComplexity), true

	case "TaskEventLogEntry.eventType":
		if e.complexity.TaskEventLogEntry.EventType == nil {
			break
		}

		return e.complexity.TaskEventLogEntry.EventType(childComplexity), true

	case "TaskEventLogEntry.id":
		if e.complexity.TaskEventLogEntry.ID == nil {
			break
		}

		return e.complexity.TaskEventLogEntry.ID(childComplexity), true

	case "TaskEventLogEntry.processedAt":
		if e.complexity.TaskEventLogEntry.ProcessedAt == nil {
			break
		}

		return e.complexity.TaskEventLogEntry.ProcessedAt(childComplexity), true

	case "TaskEventLogEntry.resourceId":
		if e.complexity.TaskEventLogEntry.ResourceId == nil {
			break
		}

		return e.complexity.TaskEventLogEntry.ResourceId(childComplexity), true

	case "TaskEventLogEntry.resourceType":
		if e.complexity.TaskEventLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.TaskEventLogEntry.ResourceType(childComplexity), true

	case "TaskEventLogEntry.timestamp":
		if e.complexity.TaskEventLogEntry.Timestamp == nil {
			break
		}

		return e.complexity.TaskEventLogEntry.Timestamp(childComplexity), true

	case "TaskFiles.fileCount":
		if e.complexity.TaskFiles.FileCount == nil {
			break
		}

		return e.complexity.TaskFiles.FileCount(childComplexity), true

	case "TaskFiles.groupedFiles":
		if e.complexity.TaskFiles.GroupedFiles == nil {
			break
		}

		return e.complexity.TaskFiles.GroupedFiles(childComplexity), true

	case "TaskHistory.pagination":
		if e.complexity.TaskHistory.Pagination == nil {
			break
		}

		return e.complexity.TaskHistory.Pagination(childComplexity), true

	case "TaskHistory.tasks":
		if e.complexity.TaskHistory.Tasks == nil {
			break
		}

		return e.complexity.TaskHistory.Tasks(childComplexity), true

	case "TaskHistoryPagination.mostRecentTaskOrder":
		if e.complexity.TaskHistoryPagination.MostRecentTaskOrder == nil {
			break
		}

		return e.complexity.TaskHistoryPagination.MostRecentTaskOrder(childComplexity), true

	case "TaskHistoryPagination.oldestTaskOrder":
		if e.complexity.TaskHistoryPagination.OldestTaskOrder == nil {
			break
		}

		return e.complexity.TaskHistoryPagination.OldestTaskOrder(childComplexity), true

	case "TaskInfo.id":
		if e.complexity.TaskInfo.Id == nil {
			break
		}

		return e.complexity.TaskInfo.Id(childComplexity), true

	case "TaskInfo.name":
		if e.complexity.TaskInfo.Name == nil {
			break
		}

		return e.complexity.TaskInfo.Name(childComplexity), true

	case "TaskLimitsConfig.maxConcurrentLargeParserProjectTasks":
		if e.complexity.TaskLimitsConfig.MaxConcurrentLargeParserProjectTasks == nil {
			break
		}

		return e.complexity.TaskLimitsConfig.MaxConcurrentLargeParserProjectTasks(childComplexity), true

	case "TaskLimitsConfig.maxDailyAutomaticRestarts":
		if e.complexity.TaskLimitsConfig.MaxDailyAutomaticRestarts == nil {
			break
		}

		return e.complexity.TaskLimitsConfig.MaxDailyAutomaticRestarts(childComplexity), true

	case "TaskLimitsConfig.maxDegradedModeConcurrentLargeParserProjectTasks":
		if e.complexity.TaskLimitsConfig.MaxDegradedModeConcurrentLargeParserProjectTasks == nil {
			break
		}

		return e.complexity.TaskLimitsConfig.MaxDegradedModeConcurrentLargeParserProjectTasks(childComplexity), true

	case "TaskLimitsConfig.maxDegradedModeParserProjectSize":
		if e.complexity.TaskLimitsConfig.MaxDegradedModeParserProjectSize == nil {
			break
		}

		return e.complexity.TaskLimitsConfig.MaxDegradedModeParserProjectSize(childComplexity), true

	case "TaskLimitsConfig.maxExecTimeoutSecs":
		if e.complexity.TaskLimitsConfig.MaxExecTimeoutSecs == nil {
			break
		}

		return e.complexity.TaskLimitsConfig.MaxExecTimeoutSecs(childComplexity), true

	case "TaskLimitsConfig.maxGenerateTaskJSONSize":
		if e.complexity.TaskLimitsConfig.MaxGenerateTaskJSONSize == nil {
			break
		}

		return e.complexity.TaskLimitsConfig.MaxGenerateTaskJSONSize(childComplexity), true

	case "TaskLimitsConfig.maxHourlyPatchTasks":
		if e.complexity.TaskLimitsConfig.MaxHourlyPatchTasks == nil {
			break
		}

		return e.complexity.TaskLimitsConfig.MaxHourlyPatchTasks(childComplexity), true

	case "TaskLimitsConfig.maxIncludesPerVersion":
		if e.complexity.TaskLimitsConfig.MaxIncludesPerVersion == nil {
			break
		}

		return e.complexity.TaskLimitsConfig.MaxIncludesPerVersion(childComplexity), true

	case "TaskLimitsConfig.maxParserProjectSize":
		if e.complexity.TaskLimitsConfig.MaxParserProjectSize == nil {
			break
		}

		return e.complexity.TaskLimitsConfig.MaxParserProjectSize(childComplexity), true

	case "TaskLimitsConfig.maxPendingGeneratedTasks":
		if e.complexity.TaskLimitsConfig.MaxPendingGeneratedTasks == nil {
			break
		}

		return e.complexity.TaskLimitsConfig.MaxPendingGeneratedTasks(childComplexity), true

	case "TaskLimitsConfig.maxTaskExecution":
		if e.complexity.TaskLimitsConfig.MaxTaskExecution == nil {
			break
		}

		return e.complexity.TaskLimitsConfig.MaxTaskExecution(childComplexity), true

	case "TaskLimitsConfig.maxTasksPerVersion":
		if e.complexity.TaskLimitsConfig.MaxTasksPerVersion == nil {
			break
		}

		return e.complexity.TaskLimitsConfig.MaxTasksPerVersion(childComplexity), true

	case "TaskLogLinks.agentLogLink":
		if e.complexity.TaskLogLinks.AgentLogLink == nil {
			break
		}

		return e.complexity.TaskLogLinks.AgentLogLink(childComplexity), true

	case "TaskLogLinks.allLogLink":
		if e.complexity.TaskLogLinks.AllLogLink == nil {
			break
		}

		return e.complexity.TaskLogLinks.AllLogLink(childComplexity), true

	case "TaskLogLinks.eventLogLink":
		if e.complexity.TaskLogLinks.EventLogLink == nil {
			break
		}

		return e.complexity.TaskLogLinks.EventLogLink(childComplexity), true

	case "TaskLogLinks.systemLogLink":
		if e.complexity.TaskLogLinks.SystemLogLink == nil {
			break
		}

		return e.complexity.TaskLogLinks.SystemLogLink(childComplexity), true

	case "TaskLogLinks.taskLogLink":
		if e.complexity.TaskLogLinks.TaskLogLink == nil {
			break
		}

		return e.complexity.TaskLogLinks.TaskLogLink(childComplexity), true

	case "TaskLogs.agentLogs":
		if e.complexity.TaskLogs.AgentLogs == nil {
			break
		}

		return e.complexity.TaskLogs.AgentLogs(childComplexity), true

	case "TaskLogs.allLogs":
		if e.complexity.TaskLogs.AllLogs == nil {
			break
		}

		return e.complexity.TaskLogs.AllLogs(childComplexity), true

	case "TaskLogs.eventLogs":
		if e.complexity.TaskLogs.EventLogs == nil {
			break
		}

		return e.complexity.TaskLogs.EventLogs(childComplexity), true

	case "TaskLogs.execution":
		if e.complexity.TaskLogs.Execution == nil {
			break
		}

		return e.complexity.TaskLogs.Execution(childComplexity), true

	case "TaskLogs.systemLogs":
		if e.complexity.TaskLogs.SystemLogs == nil {
			break
		}

		return e.complexity.TaskLogs.SystemLogs(childComplexity), true

	case "TaskLogs.taskId":
		if e.complexity.TaskLogs.TaskID == nil {
			break
		}

		return e.complexity.TaskLogs.TaskID(childComplexity), true

	case "TaskLogs.taskLogs":
		if e.complexity.TaskLogs.TaskLogs == nil {
			break
		}

		return e.complexity.TaskLogs.TaskLogs(childComplexity), true

	case "TaskOwnerTeam.assignmentType":
		if e.complexity.TaskOwnerTeam.AssignmentType == nil {
			break
		}

		return e.complexity.TaskOwnerTeam.AssignmentType(childComplexity), true

	case "TaskOwnerTeam.jiraProject":
		if e.complexity.TaskOwnerTeam.JiraProject == nil {
			break
		}

		return e.complexity.TaskOwnerTeam.JiraProject(childComplexity), true

	case "TaskOwnerTeam.messages":
		if e.complexity.TaskOwnerTeam.Messages == nil {
			break
		}

		return e.complexity.TaskOwnerTeam.Messages(childComplexity), true

	case "TaskOwnerTeam.teamName":
		if e.complexity.TaskOwnerTeam.TeamName == nil {
			break
		}

		return e.complexity.TaskOwnerTeam.TeamName(childComplexity), true

	case "TaskQueueDistro.hostCount":
		if e.complexity.TaskQueueDistro.HostCount == nil {
			break
		}

		return e.complexity.TaskQueueDistro.HostCount(childComplexity), true

	case "TaskQueueDistro.id":
		if e.complexity.TaskQueueDistro.ID == nil {
			break
		}

		return e.complexity.TaskQueueDistro.ID(childComplexity), true

	case "TaskQueueDistro.taskCount":
		if e.complexity.TaskQueueDistro.TaskCount == nil {
			break
		}

		return e.complexity.TaskQueueDistro.TaskCount(childComplexity), true

	case "TaskQueueItem.activatedBy":
		if e.complexity.TaskQueueItem.ActivatedBy == nil {
			break
		}

		return e.complexity.TaskQueueItem.ActivatedBy(childComplexity), true

	case "TaskQueueItem.buildVariant":
		if e.complexity.TaskQueueItem.BuildVariant == nil {
			break
		}

		return e.complexity.TaskQueueItem.BuildVariant(childComplexity), true

	case "TaskQueueItem.displayName":
		if e.complexity.TaskQueueItem.DisplayName == nil {
			break
		}

		return e.complexity.TaskQueueItem.DisplayName(childComplexity), true

	case "TaskQueueItem.expectedDuration":
		if e.complexity.TaskQueueItem.ExpectedDuration == nil {
			break
		}

		return e.complexity.TaskQueueItem.ExpectedDuration(childComplexity), true

	case "TaskQueueItem.id":
		if e.complexity.TaskQueueItem.Id == nil {
			break
		}

		return e.complexity.TaskQueueItem.Id(childComplexity), true

	case "TaskQueueItem.priority":
		if e.complexity.TaskQueueItem.Priority == nil {
			break
		}

		return e.complexity.TaskQueueItem.Priority(childComplexity), true

	case "TaskQueueItem.project":
		if e.complexity.TaskQueueItem.Project == nil {
			break
		}

		return e.complexity.TaskQueueItem.Project(childComplexity), true

	case "TaskQueueItem.projectIdentifier":
		if e.complexity.TaskQueueItem.ProjectIdentifier == nil {
			break
		}

		return e.complexity.TaskQueueItem.ProjectIdentifier(childComplexity), true

	case "TaskQueueItem.requester":
		if e.complexity.TaskQueueItem.Requester == nil {
			break
		}

		return e.complexity.TaskQueueItem.Requester(childComplexity), true

	case "TaskQueueItem.revision":
		if e.complexity.TaskQueueItem.Revision == nil {
			break
		}

		return e.complexity.TaskQueueItem.Revision(childComplexity), true

	case "TaskQueueItem.version":
		if e.complexity.TaskQueueItem.Version == nil {
			break
		}

		return e.complexity.TaskQueueItem.Version(childComplexity), true

	case "TaskSpecifier.patchAlias":
		if e.complexity.TaskSpecifier.PatchAlias == nil {
			break
		}

		return e.complexity.TaskSpecifier.PatchAlias(childComplexity), true

	case "TaskSpecifier.taskRegex":
		if e.complexity.TaskSpecifier.TaskRegex == nil {
			break
		}

		return e.complexity.TaskSpecifier.TaskRegex(childComplexity), true

	case "TaskSpecifier.variantRegex":
		if e.complexity.TaskSpecifier.VariantRegex == nil {
			break
		}

		return e.complexity.TaskSpecifier.VariantRegex(childComplexity), true

	case "TaskStats.counts":
		if e.complexity.TaskStats.Counts == nil {
			break
		}

		return e.complexity.TaskStats.Counts(childComplexity), true

	case "TaskStats.eta":
		if e.complexity.TaskStats.ETA == nil {
			break
		}

		return e.complexity.TaskStats.ETA(childComplexity), true

	case "TaskTestResult.filteredTestCount":
		if e.complexity.TaskTestResult.FilteredTestCount == nil {
			break
		}

		return e.complexity.TaskTestResult.FilteredTestCount(childComplexity), true

	case "TaskTestResult.testResults":
		if e.complexity.TaskTestResult.TestResults == nil {
			break
		}

		return e.complexity.TaskTestResult.TestResults(childComplexity), true

	case "TaskTestResult.totalTestCount":
		if e.complexity.TaskTestResult.TotalTestCount == nil {
			break
		}

		return e.complexity.TaskTestResult.TotalTestCount(childComplexity), true

	case "TaskTestResultSample.execution":
		if e.complexity.TaskTestResultSample.Execution == nil {
			break
		}

		return e.complexity.TaskTestResultSample.Execution(childComplexity), true

	case "TaskTestResultSample.matchingFailedTestNames":
		if e.complexity.TaskTestResultSample.MatchingFailedTestNames == nil {
			break
		}

		return e.complexity.TaskTestResultSample.MatchingFailedTestNames(childComplexity), true

	case "TaskTestResultSample.taskId":
		if e.complexity.TaskTestResultSample.TaskID == nil {
			break
		}

		return e.complexity.TaskTestResultSample.TaskID(childComplexity), true

	case "TaskTestResultSample.totalTestCount":
		if e.complexity.TaskTestResultSample.TotalTestCount == nil {
			break
		}

		return e.complexity.TaskTestResultSample.TotalTestCount(childComplexity), true

	case "TestLog.lineNum":
		if e.complexity.TestLog.LineNum == nil {
			break
		}

		return e.complexity.TestLog.LineNum(childComplexity), true

	case "TestLog.renderingType":
		if e.complexity.TestLog.RenderingType == nil {
			break
		}

		return e.complexity.TestLog.RenderingType(childComplexity), true

	case "TestLog.url":
		if e.complexity.TestLog.URL == nil {
			break
		}

		return e.complexity.TestLog.URL(childComplexity), true

	case "TestLog.urlParsley":
		if e.complexity.TestLog.URLParsley == nil {
			break
		}

		return e.complexity.TestLog.URLParsley(childComplexity), true

	case "TestLog.urlRaw":
		if e.complexity.TestLog.URLRaw == nil {
			break
		}

		return e.complexity.TestLog.URLRaw(childComplexity), true

	case "TestLog.version":
		if e.complexity.TestLog.Version == nil {
			break
		}

		return e.complexity.TestLog.Version(childComplexity), true

	case "TestResult.baseStatus":
		if e.complexity.TestResult.BaseStatus == nil {
			break
		}

		return e.complexity.TestResult.BaseStatus(childComplexity), true

	case "TestResult.duration":
		if e.complexity.TestResult.Duration == nil {
			break
		}

		return e.complexity.TestResult.Duration(childComplexity), true

	case "TestResult.endTime":
		if e.complexity.TestResult.EndTime == nil {
			break
		}

		return e.complexity.TestResult.EndTime(childComplexity), true

	case "TestResult.execution":
		if e.complexity.TestResult.Execution == nil {
			break
		}

		return e.complexity.TestResult.Execution(childComplexity), true

	case "TestResult.exitCode":
		if e.complexity.TestResult.ExitCode == nil {
			break
		}

		return e.complexity.TestResult.ExitCode(childComplexity), true

	case "TestResult.groupID":
		if e.complexity.TestResult.GroupID == nil {
			break
		}

		return e.complexity.TestResult.GroupID(childComplexity), true

	case "TestResult.id":
		if e.complexity.TestResult.ID == nil {
			break
		}

		return e.complexity.TestResult.ID(childComplexity), true

	case "TestResult.logs":
		if e.complexity.TestResult.Logs == nil {
			break
		}

		return e.complexity.TestResult.Logs(childComplexity), true

	case "TestResult.startTime":
		if e.complexity.TestResult.StartTime == nil {
			break
		}

		return e.complexity.TestResult.StartTime(childComplexity), true

	case "TestResult.status":
		if e.complexity.TestResult.Status == nil {
			break
		}

		return e.complexity.TestResult.Status(childComplexity), true

	case "TestResult.taskId":
		if e.complexity.TestResult.TaskID == nil {
			break
		}

		return e.complexity.TestResult.TaskID(childComplexity), true

	case "TestResult.testFile":
		if e.complexity.TestResult.TestFile == nil {
			break
		}

		return e.complexity.TestResult.TestFile(childComplexity), true

	case "TestSelectionConfig.url":
		if e.complexity.TestSelectionConfig.URL == nil {
			break
		}

		return e.complexity.TestSelectionConfig.URL(childComplexity), true

	case "TicketFields.assignedTeam":
		if e.complexity.TicketFields.AssignedTeam == nil {
			break
		}

		return e.complexity.TicketFields.AssignedTeam(childComplexity), true

	case "TicketFields.assigneeDisplayName":
		if e.complexity.TicketFields.AssigneeDisplayName == nil {
			break
		}

		return e.complexity.TicketFields.AssigneeDisplayName(childComplexity), true

	case "TicketFields.created":
		if e.complexity.TicketFields.Created == nil {
			break
		}

		return e.complexity.TicketFields.Created(childComplexity), true

	case "TicketFields.resolutionName":
		if e.complexity.TicketFields.ResolutionName == nil {
			break
		}

		return e.complexity.TicketFields.ResolutionName(childComplexity), true

	case "TicketFields.status":
		if e.complexity.TicketFields.Status == nil {
			break
		}

		return e.complexity.TicketFields.Status(childComplexity), true

	case "TicketFields.summary":
		if e.complexity.TicketFields.Summary == nil {
			break
		}

		return e.complexity.TicketFields.Summary(childComplexity), true

	case "TicketFields.updated":
		if e.complexity.TicketFields.Updated == nil {
			break
		}

		return e.complexity.TicketFields.Updated(childComplexity), true

	case "Toolchain.name":
		if e.complexity.Toolchain.Name == nil {
			break
		}

		return e.complexity.Toolchain.Name(childComplexity), true

	case "Toolchain.path":
		if e.complexity.Toolchain.Path == nil {
			break
		}

		return e.complexity.Toolchain.Path(childComplexity), true

	case "Toolchain.version":
		if e.complexity.Toolchain.Version == nil {
			break
		}

		return e.complexity.Toolchain.Version(childComplexity), true

	case "TriggerAlias.alias":
		if e.complexity.TriggerAlias.Alias == nil {
			break
		}

		return e.complexity.TriggerAlias.Alias(childComplexity), true

	case "TriggerAlias.buildVariantRegex":
		if e.complexity.TriggerAlias.BuildVariantRegex == nil {
			break
		}

		return e.complexity.TriggerAlias.BuildVariantRegex(childComplexity), true

	case "TriggerAlias.configFile":
		if e.complexity.TriggerAlias.ConfigFile == nil {
			break
		}

		return e.complexity.TriggerAlias.ConfigFile(childComplexity), true

	case "TriggerAlias.dateCutoff":
		if e.complexity.TriggerAlias.DateCutoff == nil {
			break
		}

		return e.complexity.TriggerAlias.DateCutoff(childComplexity), true

	case "TriggerAlias.level":
		if e.complexity.TriggerAlias.Level == nil {
			break
		}

		return e.complexity.TriggerAlias.Level(childComplexity), true

	case "TriggerAlias.project":
		if e.complexity.TriggerAlias.Project == nil {
			break
		}

		return e.complexity.TriggerAlias.Project(childComplexity), true

	case "TriggerAlias.status":
		if e.complexity.TriggerAlias.Status == nil {
			break
		}

		return e.complexity.TriggerAlias.Status(childComplexity), true

	case "TriggerAlias.taskRegex":
		if e.complexity.TriggerAlias.TaskRegex == nil {
			break
		}

		return e.complexity.TriggerAlias.TaskRegex(childComplexity), true

	case "TriggerAlias.unscheduleDownstreamVersions":
		if e.complexity.TriggerAlias.UnscheduleDownstreamVersions == nil {
			break
		}

		return e.complexity.TriggerAlias.UnscheduleDownstreamVersions(childComplexity), true

	case "TriggerConfig.generateTaskDistro":
		if e.complexity.TriggerConfig.GenerateTaskDistro == nil {
			break
		}

		return e.complexity.TriggerConfig.GenerateTaskDistro(childComplexity), true

	case "UIConfig.betaFeatures":
		if e.complexity.UIConfig.BetaFeatures == nil {
			break
		}

		return e.complexity.UIConfig.BetaFeatures(childComplexity), true

	case "UIConfig.corsOrigins":
		if e.complexity.UIConfig.CORSOrigins == nil {
			break
		}

		return e.complexity.UIConfig.CORSOrigins(childComplexity), true

	case "UIConfig.cacheTemplates":
		if e.complexity.UIConfig.CacheTemplates == nil {
			break
		}

		return e.complexity.UIConfig.CacheTemplates(childComplexity), true

	case "UIConfig.csrfKey":
		if e.complexity.UIConfig.CsrfKey == nil {
			break
		}

		return e.complexity.UIConfig.CsrfKey(childComplexity), true

	case "UIConfig.defaultProject":
		if e.complexity.UIConfig.DefaultProject == nil {
			break
		}

		return e.complexity.UIConfig.DefaultProject(childComplexity), true

	case "UIConfig.fileStreamingContentTypes":
		if e.complexity.UIConfig.FileStreamingContentTypes == nil {
			break
		}

		return e.complexity.UIConfig.FileStreamingContentTypes(childComplexity), true

	case "UIConfig.helpUrl":
		if e.complexity.UIConfig.HelpUrl == nil {
			break
		}

		return e.complexity.UIConfig.HelpUrl(childComplexity), true

	case "UIConfig.httpListenAddr":
		if e.complexity.UIConfig.HttpListenAddr == nil {
			break
		}

		return e.complexity.UIConfig.HttpListenAddr(childComplexity), true

	case "UIConfig.loginDomain":
		if e.complexity.UIConfig.LoginDomain == nil {
			break
		}

		return e.complexity.UIConfig.LoginDomain(childComplexity), true

	case "UIConfig.parsleyUrl":
		if e.complexity.UIConfig.ParsleyUrl == nil {
			break
		}

		return e.complexity.UIConfig.ParsleyUrl(childComplexity), true

	case "UIConfig.secret":
		if e.complexity.UIConfig.Secret == nil {
			break
		}

		return e.complexity.UIConfig.Secret(childComplexity), true

	case "UIConfig.stagingEnvironment":
		if e.complexity.UIConfig.StagingEnvironment == nil {
			break
		}

		return e.complexity.UIConfig.StagingEnvironment(childComplexity), true

	case "UIConfig.uiv2Url":
		if e.complexity.UIConfig.UIv2Url == nil {
			break
		}

		return e.complexity.UIConfig.UIv2Url(childComplexity), true

	case "UIConfig.url":
		if e.complexity.UIConfig.Url == nil {
			break
		}

		return e.complexity.UIConfig.Url(childComplexity), true

	case "UIConfig.userVoice":
		if e.complexity.UIConfig.UserVoice == nil {
			break
		}

		return e.complexity.UIConfig.UserVoice(childComplexity), true

	case "UpdateBetaFeaturesPayload.betaFeatures":
		if e.complexity.UpdateBetaFeaturesPayload.BetaFeatures == nil {
			break
		}

		return e.complexity.UpdateBetaFeaturesPayload.BetaFeatures(childComplexity), true

	case "UpdateParsleySettingsPayload.parsleySettings":
		if e.complexity.UpdateParsleySettingsPayload.ParsleySettings == nil {
			break
		}

		return e.complexity.UpdateParsleySettingsPayload.ParsleySettings(childComplexity), true

	case "UpstreamProject.owner":
		if e.complexity.UpstreamProject.Owner == nil {
			break
		}

		return e.complexity.UpstreamProject.Owner(childComplexity), true

	case "UpstreamProject.project":
		if e.complexity.UpstreamProject.Project == nil {
			break
		}

		return e.complexity.UpstreamProject.Project(childComplexity), true

	case "UpstreamProject.repo":
		if e.complexity.UpstreamProject.Repo == nil {
			break
		}

		return e.complexity.UpstreamProject.Repo(childComplexity), true

	case "UpstreamProject.resourceID":
		if e.complexity.UpstreamProject.ResourceID == nil {
			break
		}

		return e.complexity.UpstreamProject.ResourceID(childComplexity), true

	case "UpstreamProject.revision":
		if e.complexity.UpstreamProject.Revision == nil {
			break
		}

		return e.complexity.UpstreamProject.Revision(childComplexity), true

	case "UpstreamProject.task":
		if e.complexity.UpstreamProject.Task == nil {
			break
		}

		return e.complexity.UpstreamProject.Task(childComplexity), true

	case "UpstreamProject.triggerID":
		if e.complexity.UpstreamProject.TriggerID == nil {
			break
		}

		return e.complexity.UpstreamProject.TriggerID(childComplexity), true

	case "UpstreamProject.triggerType":
		if e.complexity.UpstreamProject.TriggerType == nil {
			break
		}

		return e.complexity.UpstreamProject.TriggerType(childComplexity), true

	case "UpstreamProject.version":
		if e.complexity.UpstreamProject.Version == nil {
			break
		}

		return e.complexity.UpstreamProject.Version(childComplexity), true

	case "UseSpruceOptions.spruceV1":
		if e.complexity.UseSpruceOptions.SpruceV1 == nil {
			break
		}

		return e.complexity.UseSpruceOptions.SpruceV1(childComplexity), true

	case "User.betaFeatures":
		if e.complexity.User.BetaFeatures == nil {
			break
		}

		return e.complexity.User.BetaFeatures(childComplexity), true

	case "User.displayName":
		if e.complexity.User.DisplayName == nil {
			break
		}

		return e.complexity.User.DisplayName(childComplexity), true

	case "User.emailAddress":
		if e.complexity.User.EmailAddress == nil {
			break
		}

		return e.complexity.User.EmailAddress(childComplexity), true

	case "User.parsleyFilters":
		if e.complexity.User.ParsleyFilters == nil {
			break
		}

		return e.complexity.User.ParsleyFilters(childComplexity), true

	case "User.parsleySettings":
		if e.complexity.User.ParsleySettings == nil {
			break
		}

		return e.complexity.User.ParsleySettings(childComplexity), true

	case "User.patches":
		if e.complexity.User.Patches == nil {
			break
		}

		args, err := ec.field_User_patches_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Patches(childComplexity, args["patchesInput"].(PatchesInput)), true

	case "User.permissions":
		if e.complexity.User.Permissions == nil {
			break
		}

		return e.complexity.User.Permissions(childComplexity), true

	case "User.settings":
		if e.complexity.User.Settings == nil {
			break
		}

		return e.complexity.User.Settings(childComplexity), true

	case "User.subscriptions":
		if e.complexity.User.Subscriptions == nil {
			break
		}

		return e.complexity.User.Subscriptions(childComplexity), true

	case "User.userId":
		if e.complexity.User.UserID == nil {
			break
		}

		return e.complexity.User.UserID(childComplexity), true

	case "UserConfig.api_key":
		if e.complexity.UserConfig.APIKey == nil {
			break
		}

		return e.complexity.UserConfig.APIKey(childComplexity), true

	case "UserConfig.api_server_host":
		if e.complexity.UserConfig.APIServerHost == nil {
			break
		}

		return e.complexity.UserConfig.APIServerHost(childComplexity), true

	case "UserConfig.ui_server_host":
		if e.complexity.UserConfig.UIServerHost == nil {
			break
		}

		return e.complexity.UserConfig.UIServerHost(childComplexity), true

	case "UserConfig.user":
		if e.complexity.UserConfig.User == nil {
			break
		}

		return e.complexity.UserConfig.User(childComplexity), true

	case "UserSettings.dateFormat":
		if e.complexity.UserSettings.DateFormat == nil {
			break
		}

		return e.complexity.UserSettings.DateFormat(childComplexity), true

	case "UserSettings.githubUser":
		if e.complexity.UserSettings.GithubUser == nil {
			break
		}

		return e.complexity.UserSettings.GithubUser(childComplexity), true

	case "UserSettings.notifications":
		if e.complexity.UserSettings.Notifications == nil {
			break
		}

		return e.complexity.UserSettings.Notifications(childComplexity), true

	case "UserSettings.region":
		if e.complexity.UserSettings.Region == nil {
			break
		}

		return e.complexity.UserSettings.Region(childComplexity), true

	case "UserSettings.slackMemberId":
		if e.complexity.UserSettings.SlackMemberId == nil {
			break
		}

		return e.complexity.UserSettings.SlackMemberId(childComplexity), true

	case "UserSettings.slackUsername":
		if e.complexity.UserSettings.SlackUsername == nil {
			break
		}

		return e.complexity.UserSettings.SlackUsername(childComplexity), true

	case "UserSettings.timeFormat":
		if e.complexity.UserSettings.TimeFormat == nil {
			break
		}

		return e.complexity.UserSettings.TimeFormat(childComplexity), true

	case "UserSettings.timezone":
		if e.complexity.UserSettings.Timezone == nil {
			break
		}

		return e.complexity.UserSettings.Timezone(childComplexity), true

	case "UserSettings.useSpruceOptions":
		if e.complexity.UserSettings.UseSpruceOptions == nil {
			break
		}

		return e.complexity.UserSettings.UseSpruceOptions(childComplexity), true

	case "VariantTask.name":
		if e.complexity.VariantTask.Name == nil {
			break
		}

		return e.complexity.VariantTask.Name(childComplexity), true

	case "VariantTask.tasks":
		if e.complexity.VariantTask.Tasks == nil {
			break
		}

		return e.complexity.VariantTask.Tasks(childComplexity), true

	case "Version.activated":
		if e.complexity.Version.Activated == nil {
			break
		}

		return e.complexity.Version.Activated(childComplexity), true

	case "Version.author":
		if e.complexity.Version.Author == nil {
			break
		}

		return e.complexity.Version.Author(childComplexity), true

	case "Version.authorEmail":
		if e.complexity.Version.AuthorEmail == nil {
			break
		}

		return e.complexity.Version.AuthorEmail(childComplexity), true

	case "Version.baseTaskStatuses":
		if e.complexity.Version.BaseTaskStatuses == nil {
			break
		}

		return e.complexity.Version.BaseTaskStatuses(childComplexity), true

	case "Version.baseVersion":
		if e.complexity.Version.BaseVersion == nil {
			break
		}

		return e.complexity.Version.BaseVersion(childComplexity), true

	case "Version.branch":
		if e.complexity.Version.Branch == nil {
			break
		}

		return e.complexity.Version.Branch(childComplexity), true

	case "Version.buildVariantStats":
		if e.complexity.Version.BuildVariantStats == nil {
			break
		}

		args, err := ec.field_Version_buildVariantStats_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Version.BuildVariantStats(childComplexity, args["options"].(BuildVariantOptions)), true

	case "Version.buildVariants":
		if e.complexity.Version.BuildVariants == nil {
			break
		}

		args, err := ec.field_Version_buildVariants_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Version.BuildVariants(childComplexity, args["options"].(BuildVariantOptions)), true

	case "Version.childVersions":
		if e.complexity.Version.ChildVersions == nil {
			break
		}

		return e.complexity.Version.ChildVersions(childComplexity), true

	case "Version.createTime":
		if e.complexity.Version.CreateTime == nil {
			break
		}

		return e.complexity.Version.CreateTime(childComplexity), true

	case "Version.errors":
		if e.complexity.Version.Errors == nil {
			break
		}

		return e.complexity.Version.Errors(childComplexity), true

	case "Version.externalLinksForMetadata":
		if e.complexity.Version.ExternalLinksForMetadata == nil {
			break
		}

		return e.complexity.Version.ExternalLinksForMetadata(childComplexity), true

	case "Version.finishTime":
		if e.complexity.Version.FinishTime == nil {
			break
		}

		return e.complexity.Version.FinishTime(childComplexity), true

	case "Version.generatedTaskCounts":
		if e.complexity.Version.GeneratedTaskCounts == nil {
			break
		}

		return e.complexity.Version.GeneratedTaskCounts(childComplexity), true

	case "Version.gitTags":
		if e.complexity.Version.GitTags == nil {
			break
		}

		return e.complexity.Version.GitTags(childComplexity), true

	case "Version.id":
		if e.complexity.Version.Id == nil {
			break
		}

		return e.complexity.Version.Id(childComplexity), true

	case "Version.ignored":
		if e.complexity.Version.Ignored == nil {
			break
		}

		return e.complexity.Version.Ignored(childComplexity), true

	case "Version.isPatch":
		if e.complexity.Version.IsPatch == nil {
			break
		}

		return e.complexity.Version.IsPatch(childComplexity), true

	case "Version.manifest":
		if e.complexity.Version.Manifest == nil {
			break
		}

		return e.complexity.Version.Manifest(childComplexity), true

	case "Version.message":
		if e.complexity.Version.Message == nil {
			break
		}

		return e.complexity.Version.Message(childComplexity), true

	case "Version.order":
		if e.complexity.Version.Order == nil {
			break
		}

		return e.complexity.Version.Order(childComplexity), true

	case "Version.parameters":
		if e.complexity.Version.Parameters == nil {
			break
		}

		return e.complexity.Version.Parameters(childComplexity), true

	case "Version.patch":
		if e.complexity.Version.Patch == nil {
			break
		}

		return e.complexity.Version.Patch(childComplexity), true

	case "Version.previousVersion":
		if e.complexity.Version.PreviousVersion == nil {
			break
		}

		return e.complexity.Version.PreviousVersion(childComplexity), true

	case "Version.project":
		if e.complexity.Version.Project == nil {
			break
		}

		return e.complexity.Version.Project(childComplexity), true

	case "Version.projectIdentifier":
		if e.complexity.Version.ProjectIdentifier == nil {
			break
		}

		return e.complexity.Version.ProjectIdentifier(childComplexity), true

	case "Version.projectMetadata":
		if e.complexity.Version.ProjectMetadata == nil {
			break
		}

		return e.complexity.Version.ProjectMetadata(childComplexity), true

	case "Version.repo":
		if e.complexity.Version.Repo == nil {
			break
		}

		return e.complexity.Version.Repo(childComplexity), true

	case "Version.requester":
		if e.complexity.Version.Requester == nil {
			break
		}

		return e.complexity.Version.Requester(childComplexity), true

	case "Version.revision":
		if e.complexity.Version.Revision == nil {
			break
		}

		return e.complexity.Version.Revision(childComplexity), true

	case "Version.startTime":
		if e.complexity.Version.StartTime == nil {
			break
		}

		return e.complexity.Version.StartTime(childComplexity), true

	case "Version.status":
		if e.complexity.Version.Status == nil {
			break
		}

		return e.complexity.Version.Status(childComplexity), true

	case "Version.taskCount":
		if e.complexity.Version.TaskCount == nil {
			break
		}

		args, err := ec.field_Version_taskCount_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Version.TaskCount(childComplexity, args["options"].(*TaskCountOptions)), true

	case "Version.taskStatusStats":
		if e.complexity.Version.TaskStatusStats == nil {
			break
		}

		args, err := ec.field_Version_taskStatusStats_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Version.TaskStatusStats(childComplexity, args["options"].(BuildVariantOptions)), true

	case "Version.taskStatuses":
		if e.complexity.Version.TaskStatuses == nil {
			break
		}

		return e.complexity.Version.TaskStatuses(childComplexity), true

	case "Version.tasks":
		if e.complexity.Version.Tasks == nil {
			break
		}

		args, err := ec.field_Version_tasks_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Version.Tasks(childComplexity, args["options"].(TaskFilterOptions)), true

	case "Version.upstreamProject":
		if e.complexity.Version.UpstreamProject == nil {
			break
		}

		return e.complexity.Version.UpstreamProject(childComplexity), true

	case "Version.versionTiming":
		if e.complexity.Version.VersionTiming == nil {
			break
		}

		return e.complexity.Version.VersionTiming(childComplexity), true

	case "Version.warnings":
		if e.complexity.Version.Warnings == nil {
			break
		}

		return e.complexity.Version.Warnings(childComplexity), true

	case "Version.waterfallBuilds":
		if e.complexity.Version.WaterfallBuilds == nil {
			break
		}

		return e.complexity.Version.WaterfallBuilds(childComplexity), true

	case "VersionTasks.count":
		if e.complexity.VersionTasks.Count == nil {
			break
		}

		return e.complexity.VersionTasks.Count(childComplexity), true

	case "VersionTasks.data":
		if e.complexity.VersionTasks.Data == nil {
			break
		}

		return e.complexity.VersionTasks.Data(childComplexity), true

	case "VersionTiming.makespan":
		if e.complexity.VersionTiming.Makespan == nil {
			break
		}

		return e.complexity.VersionTiming.Makespan(childComplexity), true

	case "VersionTiming.timeTaken":
		if e.complexity.VersionTiming.TimeTaken == nil {
			break
		}

		return e.complexity.VersionTiming.TimeTaken(childComplexity), true

	case "Volume.availabilityZone":
		if e.complexity.Volume.AvailabilityZone == nil {
			break
		}

		return e.complexity.Volume.AvailabilityZone(childComplexity), true

	case "Volume.createdBy":
		if e.complexity.Volume.CreatedBy == nil {
			break
		}

		return e.complexity.Volume.CreatedBy(childComplexity), true

	case "Volume.creationTime":
		if e.complexity.Volume.CreationTime == nil {
			break
		}

		return e.complexity.Volume.CreationTime(childComplexity), true

	case "Volume.deviceName":
		if e.complexity.Volume.DeviceName == nil {
			break
		}

		return e.complexity.Volume.DeviceName(childComplexity), true

	case "Volume.displayName":
		if e.complexity.Volume.DisplayName == nil {
			break
		}

		return e.complexity.Volume.DisplayName(childComplexity), true

	case "Volume.expiration":
		if e.complexity.Volume.Expiration == nil {
			break
		}

		return e.complexity.Volume.Expiration(childComplexity), true

	case "Volume.homeVolume":
		if e.complexity.Volume.HomeVolume == nil {
			break
		}

		return e.complexity.Volume.HomeVolume(childComplexity), true

	case "Volume.host":
		if e.complexity.Volume.Host == nil {
			break
		}

		return e.complexity.Volume.Host(childComplexity), true

	case "Volume.hostID":
		if e.complexity.Volume.HostID == nil {
			break
		}

		return e.complexity.Volume.HostID(childComplexity), true

	case "Volume.id":
		if e.complexity.Volume.ID == nil {
			break
		}

		return e.complexity.Volume.ID(childComplexity), true

	case "Volume.migrating":
		if e.complexity.Volume.Migrating == nil {
			break
		}

		return e.complexity.Volume.Migrating(childComplexity), true

	case "Volume.noExpiration":
		if e.complexity.Volume.NoExpiration == nil {
			break
		}

		return e.complexity.Volume.NoExpiration(childComplexity), true

	case "Volume.size":
		if e.complexity.Volume.Size == nil {
			break
		}

		return e.complexity.Volume.Size(childComplexity), true

	case "Volume.type":
		if e.complexity.Volume.Type == nil {
			break
		}

		return e.complexity.Volume.Type(childComplexity), true

	case "Waterfall.flattenedVersions":
		if e.complexity.Waterfall.FlattenedVersions == nil {
			break
		}

		return e.complexity.Waterfall.FlattenedVersions(childComplexity), true

	case "Waterfall.pagination":
		if e.complexity.Waterfall.Pagination == nil {
			break
		}

		return e.complexity.Waterfall.Pagination(childComplexity), true

	case "WaterfallBuild.activated":
		if e.complexity.WaterfallBuild.Activated == nil {
			break
		}

		return e.complexity.WaterfallBuild.Activated(childComplexity), true

	case "WaterfallBuild.buildVariant":
		if e.complexity.WaterfallBuild.BuildVariant == nil {
			break
		}

		return e.complexity.WaterfallBuild.BuildVariant(childComplexity), true

	case "WaterfallBuild.displayName":
		if e.complexity.WaterfallBuild.DisplayName == nil {
			break
		}

		return e.complexity.WaterfallBuild.DisplayName(childComplexity), true

	case "WaterfallBuild.id":
		if e.complexity.WaterfallBuild.Id == nil {
			break
		}

		return e.complexity.WaterfallBuild.Id(childComplexity), true

	case "WaterfallBuild.tasks":
		if e.complexity.WaterfallBuild.Tasks == nil {
			break
		}

		return e.complexity.WaterfallBuild.Tasks(childComplexity), true

	case "WaterfallBuild.version":
		if e.complexity.WaterfallBuild.Version == nil {
			break
		}

		return e.complexity.WaterfallBuild.Version(childComplexity), true

	case "WaterfallBuildVariant.builds":
		if e.complexity.WaterfallBuildVariant.Builds == nil {
			break
		}

		return e.complexity.WaterfallBuildVariant.Builds(childComplexity), true

	case "WaterfallBuildVariant.displayName":
		if e.complexity.WaterfallBuildVariant.DisplayName == nil {
			break
		}

		return e.complexity.WaterfallBuildVariant.DisplayName(childComplexity), true

	case "WaterfallBuildVariant.id":
		if e.complexity.WaterfallBuildVariant.Id == nil {
			break
		}

		return e.complexity.WaterfallBuildVariant.Id(childComplexity), true

	case "WaterfallBuildVariant.version":
		if e.complexity.WaterfallBuildVariant.Version == nil {
			break
		}

		return e.complexity.WaterfallBuildVariant.Version(childComplexity), true

	case "WaterfallPagination.activeVersionIds":
		if e.complexity.WaterfallPagination.ActiveVersionIds == nil {
			break
		}

		return e.complexity.WaterfallPagination.ActiveVersionIds(childComplexity), true

	case "WaterfallPagination.hasNextPage":
		if e.complexity.WaterfallPagination.HasNextPage == nil {
			break
		}

		return e.complexity.WaterfallPagination.HasNextPage(childComplexity), true

	case "WaterfallPagination.hasPrevPage":
		if e.complexity.WaterfallPagination.HasPrevPage == nil {
			break
		}

		return e.complexity.WaterfallPagination.HasPrevPage(childComplexity), true

	case "WaterfallPagination.mostRecentVersionOrder":
		if e.complexity.WaterfallPagination.MostRecentVersionOrder == nil {
			break
		}

		return e.complexity.WaterfallPagination.MostRecentVersionOrder(childComplexity), true

	case "WaterfallPagination.nextPageOrder":
		if e.complexity.WaterfallPagination.NextPageOrder == nil {
			break
		}

		return e.complexity.WaterfallPagination.NextPageOrder(childComplexity), true

	case "WaterfallPagination.prevPageOrder":
		if e.complexity.WaterfallPagination.PrevPageOrder == nil {
			break
		}

		return e.complexity.WaterfallPagination.PrevPageOrder(childComplexity), true

	case "WaterfallTask.displayName":
		if e.complexity.WaterfallTask.DisplayName == nil {
			break
		}

		return e.complexity.WaterfallTask.DisplayName(childComplexity), true

	case "WaterfallTask.displayStatusCache":
		if e.complexity.WaterfallTask.DisplayStatusCache == nil {
			break
		}

		return e.complexity.WaterfallTask.DisplayStatusCache(childComplexity), true

	case "WaterfallTask.execution":
		if e.complexity.WaterfallTask.Execution == nil {
			break
		}

		return e.complexity.WaterfallTask.Execution(childComplexity), true

	case "WaterfallTask.id":
		if e.complexity.WaterfallTask.Id == nil {
			break
		}

		return e.complexity.WaterfallTask.Id(childComplexity), true

	case "WaterfallTask.status":
		if e.complexity.WaterfallTask.Status == nil {
			break
		}

		return e.complexity.WaterfallTask.Status(childComplexity), true

	case "WaterfallVersion.inactiveVersions":
		if e.complexity.WaterfallVersion.InactiveVersions == nil {
			break
		}

		return e.complexity.WaterfallVersion.InactiveVersions(childComplexity), true

	case "WaterfallVersion.version":
		if e.complexity.WaterfallVersion.Version == nil {
			break
		}

		return e.complexity.WaterfallVersion.Version(childComplexity), true

	case "Webhook.endpoint":
		if e.complexity.Webhook.Endpoint == nil {
			break
		}

		return e.complexity.Webhook.Endpoint(childComplexity), true

	case "Webhook.secret":
		if e.complexity.Webhook.Secret == nil {
			break
		}

		return e.complexity.Webhook.Secret(childComplexity), true

	case "WebhookHeader.key":
		if e.complexity.WebhookHeader.Key == nil {
			break
		}

		return e.complexity.WebhookHeader.Key(childComplexity), true

	case "WebhookHeader.value":
		if e.complexity.WebhookHeader.Value == nil {
			break
		}

		return e.complexity.WebhookHeader.Value(childComplexity), true

	case "WebhookSubscriber.headers":
		if e.complexity.WebhookSubscriber.Headers == nil {
			break
		}

		return e.complexity.WebhookSubscriber.Headers(childComplexity), true

	case "WebhookSubscriber.minDelayMs":
		if e.complexity.WebhookSubscriber.MinDelayMS == nil {
			break
		}

		return e.complexity.WebhookSubscriber.MinDelayMS(childComplexity), true

	case "WebhookSubscriber.retries":
		if e.complexity.WebhookSubscriber.Retries == nil {
			break
		}

		return e.complexity.WebhookSubscriber.Retries(childComplexity), true

	case "WebhookSubscriber.secret":
		if e.complexity.WebhookSubscriber.Secret == nil {
			break
		}

		return e.complexity.WebhookSubscriber.Secret(childComplexity), true

	case "WebhookSubscriber.timeoutMs":
		if e.complexity.WebhookSubscriber.TimeoutMS == nil {
			break
		}

		return e.complexity.WebhookSubscriber.TimeoutMS(childComplexity), true

	case "WebhookSubscriber.url":
		if e.complexity.WebhookSubscriber.URL == nil {
			break
		}

		return e.complexity.WebhookSubscriber.URL(childComplexity), true

	case "WorkstationConfig.gitClone":
		if e.complexity.WorkstationConfig.GitClone == nil {
			break
		}

		return e.complexity.WorkstationConfig.GitClone(childComplexity), true

	case "WorkstationConfig.setupCommands":
		if e.complexity.WorkstationConfig.SetupCommands == nil {
			break
		}

		return e.complexity.WorkstationConfig.SetupCommands(childComplexity), true

	case "WorkstationSetupCommand.command":
		if e.complexity.WorkstationSetupCommand.Command == nil {
			break
		}

		return e.complexity.WorkstationSetupCommand.Command(childComplexity), true

	case "WorkstationSetupCommand.directory":
		if e.complexity.WorkstationSetupCommand.Directory == nil {
			break
		}

		return e.complexity.WorkstationSetupCommand.Directory(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAPIConfigInput,
		ec.unmarshalInputAddFavoriteProjectInput,
		ec.unmarshalInputAdminEventsInput,
		ec.unmarshalInputAdminSettingsInput,
		ec.unmarshalInputAmboyConfigInput,
		ec.unmarshalInputAmboyDBConfigInput,
		ec.unmarshalInputAmboyNamedQueueConfigInput,
		ec.unmarshalInputAmboyRetryConfigInput,
		ec.unmarshalInputAuthConfigInput,
		ec.unmarshalInputAuthUserInput,
		ec.unmarshalInputBetaFeaturesInput,
		ec.unmarshalInputBootstrapSettingsInput,
		ec.unmarshalInputBuildBaronSettingsInput,
		ec.unmarshalInputBuildVariantOptions,
		ec.unmarshalInputCedarConfigInput,
		ec.unmarshalInputCommitQueueParamsInput,
		ec.unmarshalInputContainerResourcesInput,
		ec.unmarshalInputCopyDistroInput,
		ec.unmarshalInputCopyProjectInput,
		ec.unmarshalInputCreateDistroInput,
		ec.unmarshalInputCreateProjectInput,
		ec.unmarshalInputCursorParams,
		ec.unmarshalInputDeactivateStepbackTaskInput,
		ec.unmarshalInputDefaultSectionToRepoInput,
		ec.unmarshalInputDeleteDistroInput,
		ec.unmarshalInputDeleteGithubAppCredentialsInput,
		ec.unmarshalInputDispatcherSettingsInput,
		ec.unmarshalInputDisplayTask,
		ec.unmarshalInputDistroEventsInput,
		ec.unmarshalInputDistroInput,
		ec.unmarshalInputDistroPermissionsOptions,
		ec.unmarshalInputEditSpawnHostInput,
		ec.unmarshalInputEnvVarInput,
		ec.unmarshalInputExpansionInput,
		ec.unmarshalInputExternalLinkInput,
		ec.unmarshalInputFWSConfigInput,
		ec.unmarshalInputFinderSettingsInput,
		ec.unmarshalInputGitHubAuthConfigInput,
		ec.unmarshalInputGitHubDynamicTokenPermissionGroupInput,
		ec.unmarshalInputGithubAppAuthInput,
		ec.unmarshalInputGithubUserInput,
		ec.unmarshalInputHomeVolumeSettingsInput,
		ec.unmarshalInputHostAllocatorSettingsInput,
		ec.unmarshalInputHostEventsInput,
		ec.unmarshalInputHostInitConfigInput,
		ec.unmarshalInputIceCreamSettingsInput,
		ec.unmarshalInputInstanceTagInput,
		ec.unmarshalInputIssueLinkInput,
		ec.unmarshalInputJiraConfigInput,
		ec.unmarshalInputJiraIssueSubscriberInput,
		ec.unmarshalInputKanopyAuthConfigInput,
		ec.unmarshalInputLogBufferingInput,
		ec.unmarshalInputLoggerConfigInput,
		ec.unmarshalInputMainlineCommitsOptions,
		ec.unmarshalInputMetadataLinkInput,
		ec.unmarshalInputMoveProjectInput,
		ec.unmarshalInputMultiAuthConfigInput,
		ec.unmarshalInputNaiveAuthConfigInput,
		ec.unmarshalInputNotificationsInput,
		ec.unmarshalInputNotifyConfigInput,
		ec.unmarshalInputOktaConfigInput,
		ec.unmarshalInputOperatingSystemOpts,
		ec.unmarshalInputPackageOpts,
		ec.unmarshalInputParameterInput,
		ec.unmarshalInputParsleyFilterInput,
		ec.unmarshalInputParsleySettingsInput,
		ec.unmarshalInputPatchConfigure,
		ec.unmarshalInputPatchTriggerAliasInput,
		ec.unmarshalInputPatchesInput,
		ec.unmarshalInputPeriodicBuildInput,
		ec.unmarshalInputPlannerSettingsInput,
		ec.unmarshalInputPodLifecycleConfigInput,
		ec.unmarshalInputPreconditionScriptInput,
		ec.unmarshalInputProjectAliasInput,
		ec.unmarshalInputProjectBannerInput,
		ec.unmarshalInputProjectInput,
		ec.unmarshalInputProjectPermissionsOptions,
		ec.unmarshalInputProjectSettingsInput,
		ec.unmarshalInputProjectVarsInput,
		ec.unmarshalInputPromoteVarsToRepoInput,
		ec.unmarshalInputPublicKeyInput,
		ec.unmarshalInputRemoveFavoriteProjectInput,
		ec.unmarshalInputRepoPermissionsOptions,
		ec.unmarshalInputRepoRefInput,
		ec.unmarshalInputRepoSettingsInput,
		ec.unmarshalInputRepotrackerConfigInput,
		ec.unmarshalInputResourceLimitsInput,
		ec.unmarshalInputRestartAdminTasksOptions,
		ec.unmarshalInputRuntimeEnvironmentConfigInput,
		ec.unmarshalInputSESConfigInput,
		ec.unmarshalInputSaveAdminSettingsInput,
		ec.unmarshalInputSaveDistroInput,
		ec.unmarshalInputSchedulerConfigInput,
		ec.unmarshalInputSelectorInput,
		ec.unmarshalInputServiceFlagsInput,
		ec.unmarshalInputSetLastRevisionInput,
		ec.unmarshalInputSlackConfigInput,
		ec.unmarshalInputSlackOptionsInput,
		ec.unmarshalInputSleepScheduleInput,
		ec.unmarshalInputSortOrder,
		ec.unmarshalInputSpawnHostInput,
		ec.unmarshalInputSpawnVolumeInput,
		ec.unmarshalInputSplunkConfigInput,
		ec.unmarshalInputSplunkConnectionInfoInput,
		ec.unmarshalInputSubscriberInput,
		ec.unmarshalInputSubscriptionInput,
		ec.unmarshalInputTaskAnnotationSettingsInput,
		ec.unmarshalInputTaskCountOptions,
		ec.unmarshalInputTaskFilterOptions,
		ec.unmarshalInputTaskHistoryOpts,
		ec.unmarshalInputTaskLimitsConfigInput,
		ec.unmarshalInputTaskPriority,
		ec.unmarshalInputTaskSpecifierInput,
		ec.unmarshalInputTestFilter,
		ec.unmarshalInputTestFilterOptions,
		ec.unmarshalInputTestSelectionConfigInput,
		ec.unmarshalInputTestSortOptions,
		ec.unmarshalInputToolchainOpts,
		ec.unmarshalInputTriggerAliasInput,
		ec.unmarshalInputTriggerConfigInput,
		ec.unmarshalInputUIConfigInput,
		ec.unmarshalInputUpdateBetaFeaturesInput,
		ec.unmarshalInputUpdateParsleySettingsInput,
		ec.unmarshalInputUpdateSpawnHostStatusInput,
		ec.unmarshalInputUpdateVolumeInput,
		ec.unmarshalInputUseSpruceOptionsInput,
		ec.unmarshalInputUserSettingsInput,
		ec.unmarshalInputVariantTasks,
		ec.unmarshalInputVersionToRestart,
		ec.unmarshalInputVolumeHost,
		ec.unmarshalInputWaterfallOptions,
		ec.unmarshalInputWebhookHeaderInput,
		ec.unmarshalInputWebhookInput,
		ec.unmarshalInputWebhookSubscriberInput,
		ec.unmarshalInputWorkstationConfigInput,
		ec.unmarshalInputWorkstationSetupCommandInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

//go:embed "schema/directives.graphql" "schema/mutation.graphql" "schema/query.graphql" "schema/scalars.graphql" "schema/types/annotation.graphql" "schema/types/auth.graphql" "schema/types/config.graphql" "schema/types/distro.graphql" "schema/types/external_communications.graphql" "schema/types/host.graphql" "schema/types/image.graphql" "schema/types/issue_link.graphql" "schema/types/logkeeper.graphql" "schema/types/mainline_commits.graphql" "schema/types/patch.graphql" "schema/types/permissions.graphql" "schema/types/pod.graphql" "schema/types/project.graphql" "schema/types/project_settings.graphql" "schema/types/project_subscriber.graphql" "schema/types/project_vars.graphql" "schema/types/repo_ref.graphql" "schema/types/repo_settings.graphql" "schema/types/spawn.graphql" "schema/types/subscriptions.graphql" "schema/types/task.graphql" "schema/types/task_history.graphql" "schema/types/task_logs.graphql" "schema/types/task_queue_item.graphql" "schema/types/ticket_fields.graphql" "schema/types/user.graphql" "schema/types/version.graphql" "schema/types/volume.graphql" "schema/types/waterfall.graphql"
var sourcesFS embed.FS

func sourceData(filename string) string {
	data, err := sourcesFS.ReadFile(filename)
	if err != nil {
		panic(fmt.Sprintf("codegen problem: %s not available", filename))
	}
	return string(data)
}

var sources = []*ast.Source{
	{Name: "schema/directives.graphql", Input: sourceData("schema/directives.graphql"), BuiltIn: false},
	{Name: "schema/mutation.graphql", Input: sourceData("schema/mutation.graphql"), BuiltIn: false},
	{Name: "schema/query.graphql", Input: sourceData("schema/query.graphql"), BuiltIn: false},
	{Name: "schema/scalars.graphql", Input: sourceData("schema/scalars.graphql"), BuiltIn: false},
	{Name: "schema/types/annotation.graphql", Input: sourceData("schema/types/annotation.graphql"), BuiltIn: false},
	{Name: "schema/types/auth.graphql", Input: sourceData("schema/types/auth.graphql"), BuiltIn: false},
	{Name: "schema/types/config.graphql", Input: sourceData("schema/types/config.graphql"), BuiltIn: false},
	{Name: "schema/types/distro.graphql", Input: sourceData("schema/types/distro.graphql"), BuiltIn: false},
	{Name: "schema/types/external_communications.graphql", Input: sourceData("schema/types/external_communications.graphql"), BuiltIn: false},
	{Name: "schema/types/host.graphql", Input: sourceData("schema/types/host.graphql"), BuiltIn: false},
	{Name: "schema/types/image.graphql", Input: sourceData("schema/types/image.graphql"), BuiltIn: false},
	{Name: "schema/types/issue_link.graphql", Input: sourceData("schema/types/issue_link.graphql"), BuiltIn: false},
	{Name: "schema/types/logkeeper.graphql", Input: sourceData("schema/types/logkeeper.graphql"), BuiltIn: false},
	{Name: "schema/types/mainline_commits.graphql", Input: sourceData("schema/types/mainline_commits.graphql"), BuiltIn: false},
	{Name: "schema/types/patch.graphql", Input: sourceData("schema/types/patch.graphql"), BuiltIn: false},
	{Name: "schema/types/permissions.graphql", Input: sourceData("schema/types/permissions.graphql"), BuiltIn: false},
	{Name: "schema/types/pod.graphql", Input: sourceData("schema/types/pod.graphql"), BuiltIn: false},
	{Name: "schema/types/project.graphql", Input: sourceData("schema/types/project.graphql"), BuiltIn: false},
	{Name: "schema/types/project_settings.graphql", Input: sourceData("schema/types/project_settings.graphql"), BuiltIn: false},
	{Name: "schema/types/project_subscriber.graphql", Input: sourceData("schema/types/project_subscriber.graphql"), BuiltIn: false},
	{Name: "schema/types/project_vars.graphql", Input: sourceData("schema/types/project_vars.graphql"), BuiltIn: false},
	{Name: "schema/types/repo_ref.graphql", Input: sourceData("schema/types/repo_ref.graphql"), BuiltIn: false},
	{Name: "schema/types/repo_settings.graphql", Input: sourceData("schema/types/repo_settings.graphql"), BuiltIn: false},
	{Name: "schema/types/spawn.graphql", Input: sourceData("schema/types/spawn.graphql"), BuiltIn: false},
	{Name: "schema/types/subscriptions.graphql", Input: sourceData("schema/types/subscriptions.graphql"), BuiltIn: false},
	{Name: "schema/types/task.graphql", Input: sourceData("schema/types/task.graphql"), BuiltIn: false},
	{Name: "schema/types/task_history.graphql", Input: sourceData("schema/types/task_history.graphql"), BuiltIn: false},
	{Name: "schema/types/task_logs.graphql", Input: sourceData("schema/types/task_logs.graphql"), BuiltIn: false},
	{Name: "schema/types/task_queue_item.graphql", Input: sourceData("schema/types/task_queue_item.graphql"), BuiltIn: false},
	{Name: "schema/types/ticket_fields.graphql", Input: sourceData("schema/types/ticket_fields.graphql"), BuiltIn: false},
	{Name: "schema/types/user.graphql", Input: sourceData("schema/types/user.graphql"), BuiltIn: false},
	{Name: "schema/types/version.graphql", Input: sourceData("schema/types/version.graphql"), BuiltIn: false},
	{Name: "schema/types/volume.graphql", Input: sourceData("schema/types/volume.graphql"), BuiltIn: false},
	{Name: "schema/types/waterfall.graphql", Input: sourceData("schema/types/waterfall.graphql"), BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) dir_requireDistroAccess_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.dir_requireDistroAccess_argsAccess(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["access"] = arg0
	return args, nil
}
func (ec *executionContext) dir_requireDistroAccess_argsAccess(
	ctx context.Context,
	rawArgs map[string]any,
) (DistroSettingsAccess, error) {
	if _, ok := rawArgs["access"]; !ok {
		var zeroVal DistroSettingsAccess
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("access"))
	if tmp, ok := rawArgs["access"]; ok {
		return ec.unmarshalNDistroSettingsAccess2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroSettingsAccess(ctx, tmp)
	}

	var zeroVal DistroSettingsAccess
	return zeroVal, nil
}

func (ec *executionContext) dir_requireHostAccess_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.dir_requireHostAccess_argsAccess(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["access"] = arg0
	return args, nil
}
func (ec *executionContext) dir_requireHostAccess_argsAccess(
	ctx context.Context,
	rawArgs map[string]any,
) (HostAccessLevel, error) {
	if _, ok := rawArgs["access"]; !ok {
		var zeroVal HostAccessLevel
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("access"))
	if tmp, ok := rawArgs["access"]; ok {
		return ec.unmarshalNHostAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐHostAccessLevel(ctx, tmp)
	}

	var zeroVal HostAccessLevel
	return zeroVal, nil
}

func (ec *executionContext) dir_requireProjectAccess_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.dir_requireProjectAccess_argsPermission(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["permission"] = arg0
	arg1, err := ec.dir_requireProjectAccess_argsAccess(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["access"] = arg1
	return args, nil
}
func (ec *executionContext) dir_requireProjectAccess_argsPermission(
	ctx context.Context,
	rawArgs map[string]any,
) (ProjectPermission, error) {
	if _, ok := rawArgs["permission"]; !ok {
		var zeroVal ProjectPermission
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("permission"))
	if tmp, ok := rawArgs["permission"]; ok {
		return ec.unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx, tmp)
	}

	var zeroVal ProjectPermission
	return zeroVal, nil
}

func (ec *executionContext) dir_requireProjectAccess_argsAccess(
	ctx context.Context,
	rawArgs map[string]any,
) (AccessLevel, error) {
	if _, ok := rawArgs["access"]; !ok {
		var zeroVal AccessLevel
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("access"))
	if tmp, ok := rawArgs["access"]; ok {
		return ec.unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx, tmp)
	}

	var zeroVal AccessLevel
	return zeroVal, nil
}

func (ec *executionContext) field_Host_events_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Host_events_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}
func (ec *executionContext) field_Host_events_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (HostEventsInput, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal HostEventsInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	if tmp, ok := rawArgs["opts"]; ok {
		return ec.unmarshalNHostEventsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐHostEventsInput(ctx, tmp)
	}

	var zeroVal HostEventsInput
	return zeroVal, nil
}

func (ec *executionContext) field_Image_events_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Image_events_argsLimit(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := ec.field_Image_events_argsPage(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["page"] = arg1
	return args, nil
}
func (ec *executionContext) field_Image_events_argsLimit(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["limit"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
	if tmp, ok := rawArgs["limit"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Image_events_argsPage(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["page"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
	if tmp, ok := rawArgs["page"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Image_operatingSystem_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Image_operatingSystem_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}
func (ec *executionContext) field_Image_operatingSystem_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (thirdparty.OSInfoFilterOptions, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal thirdparty.OSInfoFilterOptions
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	if tmp, ok := rawArgs["opts"]; ok {
		return ec.unmarshalNOperatingSystemOpts2githubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐOSInfoFilterOptions(ctx, tmp)
	}

	var zeroVal thirdparty.OSInfoFilterOptions
	return zeroVal, nil
}

func (ec *executionContext) field_Image_packages_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Image_packages_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}
func (ec *executionContext) field_Image_packages_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (thirdparty.PackageFilterOptions, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal thirdparty.PackageFilterOptions
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	if tmp, ok := rawArgs["opts"]; ok {
		return ec.unmarshalNPackageOpts2githubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐPackageFilterOptions(ctx, tmp)
	}

	var zeroVal thirdparty.PackageFilterOptions
	return zeroVal, nil
}

func (ec *executionContext) field_Image_toolchains_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Image_toolchains_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}
func (ec *executionContext) field_Image_toolchains_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (thirdparty.ToolchainFilterOptions, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal thirdparty.ToolchainFilterOptions
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	if tmp, ok := rawArgs["opts"]; ok {
		return ec.unmarshalNToolchainOpts2githubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐToolchainFilterOptions(ctx, tmp)
	}

	var zeroVal thirdparty.ToolchainFilterOptions
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_abortTask_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_abortTask_argsTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_abortTask_argsTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["taskId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["taskId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_addAnnotationIssue_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_addAnnotationIssue_argsTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	arg1, err := ec.field_Mutation_addAnnotationIssue_argsExecution(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["execution"] = arg1
	arg2, err := ec.field_Mutation_addAnnotationIssue_argsAPIIssue(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["apiIssue"] = arg2
	arg3, err := ec.field_Mutation_addAnnotationIssue_argsIsIssue(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["isIssue"] = arg3
	return args, nil
}
func (ec *executionContext) field_Mutation_addAnnotationIssue_argsTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["taskId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
	if tmp, ok := rawArgs["taskId"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_addAnnotationIssue_argsExecution(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["execution"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("execution"))
	if tmp, ok := rawArgs["execution"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_addAnnotationIssue_argsAPIIssue(
	ctx context.Context,
	rawArgs map[string]any,
) (model.APIIssueLink, error) {
	if _, ok := rawArgs["apiIssue"]; !ok {
		var zeroVal model.APIIssueLink
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("apiIssue"))
	if tmp, ok := rawArgs["apiIssue"]; ok {
		return ec.unmarshalNIssueLinkInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIIssueLink(ctx, tmp)
	}

	var zeroVal model.APIIssueLink
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_addAnnotationIssue_argsIsIssue(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	if _, ok := rawArgs["isIssue"]; !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("isIssue"))
	if tmp, ok := rawArgs["isIssue"]; ok {
		return ec.unmarshalNBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_addFavoriteProject_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_addFavoriteProject_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_addFavoriteProject_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (AddFavoriteProjectInput, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal AddFavoriteProjectInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	if tmp, ok := rawArgs["opts"]; ok {
		return ec.unmarshalNAddFavoriteProjectInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAddFavoriteProjectInput(ctx, tmp)
	}

	var zeroVal AddFavoriteProjectInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_attachProjectToNewRepo_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_attachProjectToNewRepo_argsProject(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["project"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_attachProjectToNewRepo_argsProject(
	ctx context.Context,
	rawArgs map[string]any,
) (MoveProjectInput, error) {
	if _, ok := rawArgs["project"]; !ok {
		var zeroVal MoveProjectInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("project"))
	if tmp, ok := rawArgs["project"]; ok {
		return ec.unmarshalNMoveProjectInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐMoveProjectInput(ctx, tmp)
	}

	var zeroVal MoveProjectInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_attachProjectToRepo_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_attachProjectToRepo_argsProjectID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["projectId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_attachProjectToRepo_argsProjectID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["projectId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["projectId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx, "SETTINGS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_attachVolumeToHost_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_attachVolumeToHost_argsVolumeAndHost(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["volumeAndHost"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_attachVolumeToHost_argsVolumeAndHost(
	ctx context.Context,
	rawArgs map[string]any,
) (VolumeHost, error) {
	if _, ok := rawArgs["volumeAndHost"]; !ok {
		var zeroVal VolumeHost
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("volumeAndHost"))
	if tmp, ok := rawArgs["volumeAndHost"]; ok {
		return ec.unmarshalNVolumeHost2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐVolumeHost(ctx, tmp)
	}

	var zeroVal VolumeHost
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_bbCreateTicket_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_bbCreateTicket_argsTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	arg1, err := ec.field_Mutation_bbCreateTicket_argsExecution(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["execution"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_bbCreateTicket_argsTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["taskId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
	if tmp, ok := rawArgs["taskId"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_bbCreateTicket_argsExecution(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["execution"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("execution"))
	if tmp, ok := rawArgs["execution"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_copyDistro_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_copyDistro_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_copyDistro_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (model.CopyDistroOpts, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal model.CopyDistroOpts
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["opts"]
		if !ok {
			var zeroVal model.CopyDistroOpts
			return zeroVal, nil
		}
		return ec.unmarshalNCopyDistroInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐCopyDistroOpts(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		access, err := ec.unmarshalNDistroSettingsAccess2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroSettingsAccess(ctx, "CREATE")
		if err != nil {
			var zeroVal model.CopyDistroOpts
			return zeroVal, err
		}
		if ec.directives.RequireDistroAccess == nil {
			var zeroVal model.CopyDistroOpts
			return zeroVal, errors.New("directive requireDistroAccess is not implemented")
		}
		return ec.directives.RequireDistroAccess(ctx, rawArgs, directive0, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal model.CopyDistroOpts
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(model.CopyDistroOpts); ok {
		return data, nil
	} else {
		var zeroVal model.CopyDistroOpts
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/rest/model.CopyDistroOpts`, tmp))
	}
}

func (ec *executionContext) field_Mutation_copyProject_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_copyProject_argsProject(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["project"] = arg0
	arg1, err := ec.field_Mutation_copyProject_argsRequestS3Creds(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["requestS3Creds"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_copyProject_argsProject(
	ctx context.Context,
	rawArgs map[string]any,
) (model.CopyProjectOpts, error) {
	if _, ok := rawArgs["project"]; !ok {
		var zeroVal model.CopyProjectOpts
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("project"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["project"]
		if !ok {
			var zeroVal model.CopyProjectOpts
			return zeroVal, nil
		}
		return ec.unmarshalNCopyProjectInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐCopyProjectOpts(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		if ec.directives.RequireProjectAdmin == nil {
			var zeroVal model.CopyProjectOpts
			return zeroVal, errors.New("directive requireProjectAdmin is not implemented")
		}
		return ec.directives.RequireProjectAdmin(ctx, rawArgs, directive0)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal model.CopyProjectOpts
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(model.CopyProjectOpts); ok {
		return data, nil
	} else {
		var zeroVal model.CopyProjectOpts
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/rest/model.CopyProjectOpts`, tmp))
	}
}

func (ec *executionContext) field_Mutation_copyProject_argsRequestS3Creds(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	if _, ok := rawArgs["requestS3Creds"]; !ok {
		var zeroVal *bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("requestS3Creds"))
	if tmp, ok := rawArgs["requestS3Creds"]; ok {
		return ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createDistro_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createDistro_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createDistro_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (CreateDistroInput, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal CreateDistroInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["opts"]
		if !ok {
			var zeroVal CreateDistroInput
			return zeroVal, nil
		}
		return ec.unmarshalNCreateDistroInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐCreateDistroInput(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		access, err := ec.unmarshalNDistroSettingsAccess2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroSettingsAccess(ctx, "CREATE")
		if err != nil {
			var zeroVal CreateDistroInput
			return zeroVal, err
		}
		if ec.directives.RequireDistroAccess == nil {
			var zeroVal CreateDistroInput
			return zeroVal, errors.New("directive requireDistroAccess is not implemented")
		}
		return ec.directives.RequireDistroAccess(ctx, rawArgs, directive0, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal CreateDistroInput
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(CreateDistroInput); ok {
		return data, nil
	} else {
		var zeroVal CreateDistroInput
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/graphql.CreateDistroInput`, tmp))
	}
}

func (ec *executionContext) field_Mutation_createProject_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createProject_argsProject(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["project"] = arg0
	arg1, err := ec.field_Mutation_createProject_argsRequestS3Creds(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["requestS3Creds"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_createProject_argsProject(
	ctx context.Context,
	rawArgs map[string]any,
) (model.APIProjectRef, error) {
	if _, ok := rawArgs["project"]; !ok {
		var zeroVal model.APIProjectRef
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("project"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["project"]
		if !ok {
			var zeroVal model.APIProjectRef
			return zeroVal, nil
		}
		return ec.unmarshalNCreateProjectInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		if ec.directives.RequireProjectAdmin == nil {
			var zeroVal model.APIProjectRef
			return zeroVal, errors.New("directive requireProjectAdmin is not implemented")
		}
		return ec.directives.RequireProjectAdmin(ctx, rawArgs, directive0)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal model.APIProjectRef
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(model.APIProjectRef); ok {
		return data, nil
	} else {
		var zeroVal model.APIProjectRef
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/rest/model.APIProjectRef`, tmp))
	}
}

func (ec *executionContext) field_Mutation_createProject_argsRequestS3Creds(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	if _, ok := rawArgs["requestS3Creds"]; !ok {
		var zeroVal *bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("requestS3Creds"))
	if tmp, ok := rawArgs["requestS3Creds"]; ok {
		return ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_createPublicKey_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_createPublicKey_argsPublicKeyInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["publicKeyInput"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_createPublicKey_argsPublicKeyInput(
	ctx context.Context,
	rawArgs map[string]any,
) (PublicKeyInput, error) {
	if _, ok := rawArgs["publicKeyInput"]; !ok {
		var zeroVal PublicKeyInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("publicKeyInput"))
	if tmp, ok := rawArgs["publicKeyInput"]; ok {
		return ec.unmarshalNPublicKeyInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPublicKeyInput(ctx, tmp)
	}

	var zeroVal PublicKeyInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deactivateStepbackTask_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deactivateStepbackTask_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deactivateStepbackTask_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (DeactivateStepbackTaskInput, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal DeactivateStepbackTaskInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	if tmp, ok := rawArgs["opts"]; ok {
		return ec.unmarshalNDeactivateStepbackTaskInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDeactivateStepbackTaskInput(ctx, tmp)
	}

	var zeroVal DeactivateStepbackTaskInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_defaultSectionToRepo_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_defaultSectionToRepo_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_defaultSectionToRepo_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (DefaultSectionToRepoInput, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal DefaultSectionToRepoInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	if tmp, ok := rawArgs["opts"]; ok {
		return ec.unmarshalNDefaultSectionToRepoInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDefaultSectionToRepoInput(ctx, tmp)
	}

	var zeroVal DefaultSectionToRepoInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteDistro_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteDistro_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteDistro_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (DeleteDistroInput, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal DeleteDistroInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	if tmp, ok := rawArgs["opts"]; ok {
		return ec.unmarshalNDeleteDistroInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDeleteDistroInput(ctx, tmp)
	}

	var zeroVal DeleteDistroInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteGithubAppCredentials_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteGithubAppCredentials_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteGithubAppCredentials_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (DeleteGithubAppCredentialsInput, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal DeleteGithubAppCredentialsInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	if tmp, ok := rawArgs["opts"]; ok {
		return ec.unmarshalNDeleteGithubAppCredentialsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDeleteGithubAppCredentialsInput(ctx, tmp)
	}

	var zeroVal DeleteGithubAppCredentialsInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_deleteProject_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteProject_argsProjectID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["projectId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteProject_argsProjectID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["projectId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["projectId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		if ec.directives.RequireProjectAdmin == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAdmin is not implemented")
		}
		return ec.directives.RequireProjectAdmin(ctx, rawArgs, directive0)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_deleteSubscriptions_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_deleteSubscriptions_argsSubscriptionIds(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["subscriptionIds"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_deleteSubscriptions_argsSubscriptionIds(
	ctx context.Context,
	rawArgs map[string]any,
) ([]string, error) {
	if _, ok := rawArgs["subscriptionIds"]; !ok {
		var zeroVal []string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("subscriptionIds"))
	if tmp, ok := rawArgs["subscriptionIds"]; ok {
		return ec.unmarshalNString2ᚕstringᚄ(ctx, tmp)
	}

	var zeroVal []string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_detachProjectFromRepo_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_detachProjectFromRepo_argsProjectID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["projectId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_detachProjectFromRepo_argsProjectID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["projectId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["projectId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx, "SETTINGS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_detachVolumeFromHost_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_detachVolumeFromHost_argsVolumeID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["volumeId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_detachVolumeFromHost_argsVolumeID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["volumeId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("volumeId"))
	if tmp, ok := rawArgs["volumeId"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_editAnnotationNote_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_editAnnotationNote_argsTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	arg1, err := ec.field_Mutation_editAnnotationNote_argsExecution(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["execution"] = arg1
	arg2, err := ec.field_Mutation_editAnnotationNote_argsOriginalMessage(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["originalMessage"] = arg2
	arg3, err := ec.field_Mutation_editAnnotationNote_argsNewMessage(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["newMessage"] = arg3
	return args, nil
}
func (ec *executionContext) field_Mutation_editAnnotationNote_argsTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["taskId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
	if tmp, ok := rawArgs["taskId"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_editAnnotationNote_argsExecution(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["execution"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("execution"))
	if tmp, ok := rawArgs["execution"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_editAnnotationNote_argsOriginalMessage(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["originalMessage"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("originalMessage"))
	if tmp, ok := rawArgs["originalMessage"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_editAnnotationNote_argsNewMessage(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["newMessage"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("newMessage"))
	if tmp, ok := rawArgs["newMessage"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_editSpawnHost_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_editSpawnHost_argsSpawnHost(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["spawnHost"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_editSpawnHost_argsSpawnHost(
	ctx context.Context,
	rawArgs map[string]any,
) (*EditSpawnHostInput, error) {
	if _, ok := rawArgs["spawnHost"]; !ok {
		var zeroVal *EditSpawnHostInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("spawnHost"))
	if tmp, ok := rawArgs["spawnHost"]; ok {
		return ec.unmarshalOEditSpawnHostInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐEditSpawnHostInput(ctx, tmp)
	}

	var zeroVal *EditSpawnHostInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_forceRepotrackerRun_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_forceRepotrackerRun_argsProjectID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["projectId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_forceRepotrackerRun_argsProjectID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["projectId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["projectId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx, "SETTINGS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_migrateVolume_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_migrateVolume_argsVolumeID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["volumeId"] = arg0
	arg1, err := ec.field_Mutation_migrateVolume_argsSpawnHostInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["spawnHostInput"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_migrateVolume_argsVolumeID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["volumeId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("volumeId"))
	if tmp, ok := rawArgs["volumeId"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_migrateVolume_argsSpawnHostInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*SpawnHostInput, error) {
	if _, ok := rawArgs["spawnHostInput"]; !ok {
		var zeroVal *SpawnHostInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("spawnHostInput"))
	if tmp, ok := rawArgs["spawnHostInput"]; ok {
		return ec.unmarshalOSpawnHostInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSpawnHostInput(ctx, tmp)
	}

	var zeroVal *SpawnHostInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_moveAnnotationIssue_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_moveAnnotationIssue_argsTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	arg1, err := ec.field_Mutation_moveAnnotationIssue_argsExecution(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["execution"] = arg1
	arg2, err := ec.field_Mutation_moveAnnotationIssue_argsAPIIssue(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["apiIssue"] = arg2
	arg3, err := ec.field_Mutation_moveAnnotationIssue_argsIsIssue(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["isIssue"] = arg3
	return args, nil
}
func (ec *executionContext) field_Mutation_moveAnnotationIssue_argsTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["taskId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
	if tmp, ok := rawArgs["taskId"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_moveAnnotationIssue_argsExecution(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["execution"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("execution"))
	if tmp, ok := rawArgs["execution"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_moveAnnotationIssue_argsAPIIssue(
	ctx context.Context,
	rawArgs map[string]any,
) (model.APIIssueLink, error) {
	if _, ok := rawArgs["apiIssue"]; !ok {
		var zeroVal model.APIIssueLink
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("apiIssue"))
	if tmp, ok := rawArgs["apiIssue"]; ok {
		return ec.unmarshalNIssueLinkInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIIssueLink(ctx, tmp)
	}

	var zeroVal model.APIIssueLink
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_moveAnnotationIssue_argsIsIssue(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	if _, ok := rawArgs["isIssue"]; !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("isIssue"))
	if tmp, ok := rawArgs["isIssue"]; ok {
		return ec.unmarshalNBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_overrideTaskDependencies_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_overrideTaskDependencies_argsTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_overrideTaskDependencies_argsTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["taskId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["taskId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_promoteVarsToRepo_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_promoteVarsToRepo_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_promoteVarsToRepo_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (PromoteVarsToRepoInput, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal PromoteVarsToRepoInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	if tmp, ok := rawArgs["opts"]; ok {
		return ec.unmarshalNPromoteVarsToRepoInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPromoteVarsToRepoInput(ctx, tmp)
	}

	var zeroVal PromoteVarsToRepoInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_removeAnnotationIssue_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_removeAnnotationIssue_argsTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	arg1, err := ec.field_Mutation_removeAnnotationIssue_argsExecution(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["execution"] = arg1
	arg2, err := ec.field_Mutation_removeAnnotationIssue_argsAPIIssue(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["apiIssue"] = arg2
	arg3, err := ec.field_Mutation_removeAnnotationIssue_argsIsIssue(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["isIssue"] = arg3
	return args, nil
}
func (ec *executionContext) field_Mutation_removeAnnotationIssue_argsTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["taskId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
	if tmp, ok := rawArgs["taskId"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_removeAnnotationIssue_argsExecution(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["execution"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("execution"))
	if tmp, ok := rawArgs["execution"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_removeAnnotationIssue_argsAPIIssue(
	ctx context.Context,
	rawArgs map[string]any,
) (model.APIIssueLink, error) {
	if _, ok := rawArgs["apiIssue"]; !ok {
		var zeroVal model.APIIssueLink
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("apiIssue"))
	if tmp, ok := rawArgs["apiIssue"]; ok {
		return ec.unmarshalNIssueLinkInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIIssueLink(ctx, tmp)
	}

	var zeroVal model.APIIssueLink
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_removeAnnotationIssue_argsIsIssue(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	if _, ok := rawArgs["isIssue"]; !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("isIssue"))
	if tmp, ok := rawArgs["isIssue"]; ok {
		return ec.unmarshalNBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_removeFavoriteProject_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_removeFavoriteProject_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_removeFavoriteProject_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (RemoveFavoriteProjectInput, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal RemoveFavoriteProjectInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	if tmp, ok := rawArgs["opts"]; ok {
		return ec.unmarshalNRemoveFavoriteProjectInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐRemoveFavoriteProjectInput(ctx, tmp)
	}

	var zeroVal RemoveFavoriteProjectInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_removePublicKey_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_removePublicKey_argsKeyName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["keyName"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_removePublicKey_argsKeyName(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["keyName"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("keyName"))
	if tmp, ok := rawArgs["keyName"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_removeVolume_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_removeVolume_argsVolumeID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["volumeId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_removeVolume_argsVolumeID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["volumeId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("volumeId"))
	if tmp, ok := rawArgs["volumeId"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_reprovisionToNew_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_reprovisionToNew_argsHostIds(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["hostIds"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_reprovisionToNew_argsHostIds(
	ctx context.Context,
	rawArgs map[string]any,
) ([]string, error) {
	if _, ok := rawArgs["hostIds"]; !ok {
		var zeroVal []string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("hostIds"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["hostIds"]
		if !ok {
			var zeroVal []string
			return zeroVal, nil
		}
		return ec.unmarshalNString2ᚕstringᚄ(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		access, err := ec.unmarshalNHostAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐHostAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal []string
			return zeroVal, err
		}
		if ec.directives.RequireHostAccess == nil {
			var zeroVal []string
			return zeroVal, errors.New("directive requireHostAccess is not implemented")
		}
		return ec.directives.RequireHostAccess(ctx, rawArgs, directive0, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal []string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.([]string); ok {
		return data, nil
	} else if tmp == nil {
		var zeroVal []string
		return zeroVal, nil
	} else {
		var zeroVal []string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be []string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_restartAdminTasks_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_restartAdminTasks_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_restartAdminTasks_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (model1.RestartOptions, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal model1.RestartOptions
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	if tmp, ok := rawArgs["opts"]; ok {
		return ec.unmarshalNRestartAdminTasksOptions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐRestartOptions(ctx, tmp)
	}

	var zeroVal model1.RestartOptions
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_restartJasper_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_restartJasper_argsHostIds(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["hostIds"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_restartJasper_argsHostIds(
	ctx context.Context,
	rawArgs map[string]any,
) ([]string, error) {
	if _, ok := rawArgs["hostIds"]; !ok {
		var zeroVal []string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("hostIds"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["hostIds"]
		if !ok {
			var zeroVal []string
			return zeroVal, nil
		}
		return ec.unmarshalNString2ᚕstringᚄ(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		access, err := ec.unmarshalNHostAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐHostAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal []string
			return zeroVal, err
		}
		if ec.directives.RequireHostAccess == nil {
			var zeroVal []string
			return zeroVal, errors.New("directive requireHostAccess is not implemented")
		}
		return ec.directives.RequireHostAccess(ctx, rawArgs, directive0, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal []string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.([]string); ok {
		return data, nil
	} else if tmp == nil {
		var zeroVal []string
		return zeroVal, nil
	} else {
		var zeroVal []string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be []string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_restartTask_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_restartTask_argsTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	arg1, err := ec.field_Mutation_restartTask_argsFailedOnly(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["failedOnly"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_restartTask_argsTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["taskId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["taskId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_restartTask_argsFailedOnly(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	if _, ok := rawArgs["failedOnly"]; !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("failedOnly"))
	if tmp, ok := rawArgs["failedOnly"]; ok {
		return ec.unmarshalNBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_restartVersions_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_restartVersions_argsVersionID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["versionId"] = arg0
	arg1, err := ec.field_Mutation_restartVersions_argsAbort(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["abort"] = arg1
	arg2, err := ec.field_Mutation_restartVersions_argsVersionsToRestart(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["versionsToRestart"] = arg2
	return args, nil
}
func (ec *executionContext) field_Mutation_restartVersions_argsVersionID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["versionId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["versionId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_restartVersions_argsAbort(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	if _, ok := rawArgs["abort"]; !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("abort"))
	if tmp, ok := rawArgs["abort"]; ok {
		return ec.unmarshalNBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_restartVersions_argsVersionsToRestart(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model1.VersionToRestart, error) {
	if _, ok := rawArgs["versionsToRestart"]; !ok {
		var zeroVal []*model1.VersionToRestart
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("versionsToRestart"))
	if tmp, ok := rawArgs["versionsToRestart"]; ok {
		return ec.unmarshalNVersionToRestart2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐVersionToRestartᚄ(ctx, tmp)
	}

	var zeroVal []*model1.VersionToRestart
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_saveAdminSettings_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_saveAdminSettings_argsAdminSettings(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["adminSettings"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_saveAdminSettings_argsAdminSettings(
	ctx context.Context,
	rawArgs map[string]any,
) (model.APIAdminSettings, error) {
	if _, ok := rawArgs["adminSettings"]; !ok {
		var zeroVal model.APIAdminSettings
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("adminSettings"))
	if tmp, ok := rawArgs["adminSettings"]; ok {
		return ec.unmarshalNAdminSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAdminSettings(ctx, tmp)
	}

	var zeroVal model.APIAdminSettings
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_saveDistro_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_saveDistro_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_saveDistro_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (SaveDistroInput, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal SaveDistroInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	if tmp, ok := rawArgs["opts"]; ok {
		return ec.unmarshalNSaveDistroInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSaveDistroInput(ctx, tmp)
	}

	var zeroVal SaveDistroInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_saveProjectSettingsForSection_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_saveProjectSettingsForSection_argsProjectSettings(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["projectSettings"] = arg0
	arg1, err := ec.field_Mutation_saveProjectSettingsForSection_argsSection(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["section"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_saveProjectSettingsForSection_argsProjectSettings(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.APIProjectSettings, error) {
	if _, ok := rawArgs["projectSettings"]; !ok {
		var zeroVal *model.APIProjectSettings
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("projectSettings"))
	if tmp, ok := rawArgs["projectSettings"]; ok {
		return ec.unmarshalOProjectSettingsInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectSettings(ctx, tmp)
	}

	var zeroVal *model.APIProjectSettings
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_saveProjectSettingsForSection_argsSection(
	ctx context.Context,
	rawArgs map[string]any,
) (ProjectSettingsSection, error) {
	if _, ok := rawArgs["section"]; !ok {
		var zeroVal ProjectSettingsSection
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("section"))
	if tmp, ok := rawArgs["section"]; ok {
		return ec.unmarshalNProjectSettingsSection2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectSettingsSection(ctx, tmp)
	}

	var zeroVal ProjectSettingsSection
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_saveRepoSettingsForSection_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_saveRepoSettingsForSection_argsRepoSettings(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["repoSettings"] = arg0
	arg1, err := ec.field_Mutation_saveRepoSettingsForSection_argsSection(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["section"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_saveRepoSettingsForSection_argsRepoSettings(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.APIProjectSettings, error) {
	if _, ok := rawArgs["repoSettings"]; !ok {
		var zeroVal *model.APIProjectSettings
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("repoSettings"))
	if tmp, ok := rawArgs["repoSettings"]; ok {
		return ec.unmarshalORepoSettingsInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectSettings(ctx, tmp)
	}

	var zeroVal *model.APIProjectSettings
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_saveRepoSettingsForSection_argsSection(
	ctx context.Context,
	rawArgs map[string]any,
) (ProjectSettingsSection, error) {
	if _, ok := rawArgs["section"]; !ok {
		var zeroVal ProjectSettingsSection
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("section"))
	if tmp, ok := rawArgs["section"]; ok {
		return ec.unmarshalNProjectSettingsSection2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectSettingsSection(ctx, tmp)
	}

	var zeroVal ProjectSettingsSection
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_saveSubscription_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_saveSubscription_argsSubscription(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["subscription"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_saveSubscription_argsSubscription(
	ctx context.Context,
	rawArgs map[string]any,
) (model.APISubscription, error) {
	if _, ok := rawArgs["subscription"]; !ok {
		var zeroVal model.APISubscription
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("subscription"))
	if tmp, ok := rawArgs["subscription"]; ok {
		return ec.unmarshalNSubscriptionInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISubscription(ctx, tmp)
	}

	var zeroVal model.APISubscription
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_schedulePatch_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_schedulePatch_argsPatchID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["patchId"] = arg0
	arg1, err := ec.field_Mutation_schedulePatch_argsConfigure(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["configure"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_schedulePatch_argsPatchID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["patchId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("patchId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["patchId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx, "PATCHES")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_schedulePatch_argsConfigure(
	ctx context.Context,
	rawArgs map[string]any,
) (PatchConfigure, error) {
	if _, ok := rawArgs["configure"]; !ok {
		var zeroVal PatchConfigure
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("configure"))
	if tmp, ok := rawArgs["configure"]; ok {
		return ec.unmarshalNPatchConfigure2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPatchConfigure(ctx, tmp)
	}

	var zeroVal PatchConfigure
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_scheduleTasks_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_scheduleTasks_argsVersionID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["versionId"] = arg0
	arg1, err := ec.field_Mutation_scheduleTasks_argsTaskIds(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskIds"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_scheduleTasks_argsVersionID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["versionId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["versionId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_scheduleTasks_argsTaskIds(
	ctx context.Context,
	rawArgs map[string]any,
) ([]string, error) {
	if _, ok := rawArgs["taskIds"]; !ok {
		var zeroVal []string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskIds"))
	if tmp, ok := rawArgs["taskIds"]; ok {
		return ec.unmarshalNString2ᚕstringᚄ(ctx, tmp)
	}

	var zeroVal []string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_scheduleUndispatchedBaseTasks_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_scheduleUndispatchedBaseTasks_argsVersionID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["versionId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_scheduleUndispatchedBaseTasks_argsVersionID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["versionId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["versionId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_setAnnotationMetadataLinks_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_setAnnotationMetadataLinks_argsTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	arg1, err := ec.field_Mutation_setAnnotationMetadataLinks_argsExecution(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["execution"] = arg1
	arg2, err := ec.field_Mutation_setAnnotationMetadataLinks_argsMetadataLinks(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["metadataLinks"] = arg2
	return args, nil
}
func (ec *executionContext) field_Mutation_setAnnotationMetadataLinks_argsTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["taskId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
	if tmp, ok := rawArgs["taskId"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_setAnnotationMetadataLinks_argsExecution(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["execution"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("execution"))
	if tmp, ok := rawArgs["execution"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_setAnnotationMetadataLinks_argsMetadataLinks(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*model.APIMetadataLink, error) {
	if _, ok := rawArgs["metadataLinks"]; !ok {
		var zeroVal []*model.APIMetadataLink
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("metadataLinks"))
	if tmp, ok := rawArgs["metadataLinks"]; ok {
		return ec.unmarshalNMetadataLinkInput2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIMetadataLinkᚄ(ctx, tmp)
	}

	var zeroVal []*model.APIMetadataLink
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_setLastRevision_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_setLastRevision_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_setLastRevision_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (SetLastRevisionInput, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal SetLastRevisionInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["opts"]
		if !ok {
			var zeroVal SetLastRevisionInput
			return zeroVal, nil
		}
		return ec.unmarshalNSetLastRevisionInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSetLastRevisionInput(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		if ec.directives.RequireProjectAdmin == nil {
			var zeroVal SetLastRevisionInput
			return zeroVal, errors.New("directive requireProjectAdmin is not implemented")
		}
		return ec.directives.RequireProjectAdmin(ctx, rawArgs, directive0)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal SetLastRevisionInput
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(SetLastRevisionInput); ok {
		return data, nil
	} else {
		var zeroVal SetLastRevisionInput
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/graphql.SetLastRevisionInput`, tmp))
	}
}

func (ec *executionContext) field_Mutation_setPatchVisibility_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_setPatchVisibility_argsPatchIds(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["patchIds"] = arg0
	arg1, err := ec.field_Mutation_setPatchVisibility_argsHidden(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["hidden"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_setPatchVisibility_argsPatchIds(
	ctx context.Context,
	rawArgs map[string]any,
) ([]string, error) {
	if _, ok := rawArgs["patchIds"]; !ok {
		var zeroVal []string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("patchIds"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["patchIds"]
		if !ok {
			var zeroVal []string
			return zeroVal, nil
		}
		return ec.unmarshalNString2ᚕstringᚄ(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		if ec.directives.RequirePatchOwner == nil {
			var zeroVal []string
			return zeroVal, errors.New("directive requirePatchOwner is not implemented")
		}
		return ec.directives.RequirePatchOwner(ctx, rawArgs, directive0)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal []string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.([]string); ok {
		return data, nil
	} else if tmp == nil {
		var zeroVal []string
		return zeroVal, nil
	} else {
		var zeroVal []string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be []string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_setPatchVisibility_argsHidden(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	if _, ok := rawArgs["hidden"]; !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("hidden"))
	if tmp, ok := rawArgs["hidden"]; ok {
		return ec.unmarshalNBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_setTaskPriorities_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_setTaskPriorities_argsTaskPriorities(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskPriorities"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_setTaskPriorities_argsTaskPriorities(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*TaskPriority, error) {
	if _, ok := rawArgs["taskPriorities"]; !ok {
		var zeroVal []*TaskPriority
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskPriorities"))
	if tmp, ok := rawArgs["taskPriorities"]; ok {
		return ec.unmarshalNTaskPriority2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskPriorityᚄ(ctx, tmp)
	}

	var zeroVal []*TaskPriority
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_setTaskPriority_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_setTaskPriority_argsTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	arg1, err := ec.field_Mutation_setTaskPriority_argsPriority(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["priority"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_setTaskPriority_argsTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["taskId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["taskId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_setTaskPriority_argsPriority(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["priority"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("priority"))
	if tmp, ok := rawArgs["priority"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_setVersionPriority_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_setVersionPriority_argsVersionID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["versionId"] = arg0
	arg1, err := ec.field_Mutation_setVersionPriority_argsPriority(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["priority"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_setVersionPriority_argsVersionID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["versionId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["versionId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_setVersionPriority_argsPriority(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["priority"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("priority"))
	if tmp, ok := rawArgs["priority"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_spawnHost_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_spawnHost_argsSpawnHostInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["spawnHostInput"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_spawnHost_argsSpawnHostInput(
	ctx context.Context,
	rawArgs map[string]any,
) (*SpawnHostInput, error) {
	if _, ok := rawArgs["spawnHostInput"]; !ok {
		var zeroVal *SpawnHostInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("spawnHostInput"))
	if tmp, ok := rawArgs["spawnHostInput"]; ok {
		return ec.unmarshalOSpawnHostInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSpawnHostInput(ctx, tmp)
	}

	var zeroVal *SpawnHostInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_spawnVolume_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_spawnVolume_argsSpawnVolumeInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["spawnVolumeInput"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_spawnVolume_argsSpawnVolumeInput(
	ctx context.Context,
	rawArgs map[string]any,
) (SpawnVolumeInput, error) {
	if _, ok := rawArgs["spawnVolumeInput"]; !ok {
		var zeroVal SpawnVolumeInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("spawnVolumeInput"))
	if tmp, ok := rawArgs["spawnVolumeInput"]; ok {
		return ec.unmarshalNSpawnVolumeInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSpawnVolumeInput(ctx, tmp)
	}

	var zeroVal SpawnVolumeInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_unscheduleTask_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_unscheduleTask_argsTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_unscheduleTask_argsTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["taskId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["taskId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_unscheduleVersionTasks_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_unscheduleVersionTasks_argsVersionID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["versionId"] = arg0
	arg1, err := ec.field_Mutation_unscheduleVersionTasks_argsAbort(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["abort"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_unscheduleVersionTasks_argsVersionID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["versionId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["versionId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_unscheduleVersionTasks_argsAbort(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	if _, ok := rawArgs["abort"]; !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("abort"))
	if tmp, ok := rawArgs["abort"]; ok {
		return ec.unmarshalNBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateBetaFeatures_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateBetaFeatures_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_updateBetaFeatures_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (UpdateBetaFeaturesInput, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal UpdateBetaFeaturesInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	if tmp, ok := rawArgs["opts"]; ok {
		return ec.unmarshalNUpdateBetaFeaturesInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐUpdateBetaFeaturesInput(ctx, tmp)
	}

	var zeroVal UpdateBetaFeaturesInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateHostStatus_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateHostStatus_argsHostIds(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["hostIds"] = arg0
	arg1, err := ec.field_Mutation_updateHostStatus_argsStatus(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["status"] = arg1
	arg2, err := ec.field_Mutation_updateHostStatus_argsNotes(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["notes"] = arg2
	return args, nil
}
func (ec *executionContext) field_Mutation_updateHostStatus_argsHostIds(
	ctx context.Context,
	rawArgs map[string]any,
) ([]string, error) {
	if _, ok := rawArgs["hostIds"]; !ok {
		var zeroVal []string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("hostIds"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["hostIds"]
		if !ok {
			var zeroVal []string
			return zeroVal, nil
		}
		return ec.unmarshalNString2ᚕstringᚄ(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		access, err := ec.unmarshalNHostAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐHostAccessLevel(ctx, "EDIT")
		if err != nil {
			var zeroVal []string
			return zeroVal, err
		}
		if ec.directives.RequireHostAccess == nil {
			var zeroVal []string
			return zeroVal, errors.New("directive requireHostAccess is not implemented")
		}
		return ec.directives.RequireHostAccess(ctx, rawArgs, directive0, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal []string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.([]string); ok {
		return data, nil
	} else if tmp == nil {
		var zeroVal []string
		return zeroVal, nil
	} else {
		var zeroVal []string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be []string`, tmp))
	}
}

func (ec *executionContext) field_Mutation_updateHostStatus_argsStatus(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["status"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
	if tmp, ok := rawArgs["status"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateHostStatus_argsNotes(
	ctx context.Context,
	rawArgs map[string]any,
) (*string, error) {
	if _, ok := rawArgs["notes"]; !ok {
		var zeroVal *string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("notes"))
	if tmp, ok := rawArgs["notes"]; ok {
		return ec.unmarshalOString2ᚖstring(ctx, tmp)
	}

	var zeroVal *string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateParsleySettings_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateParsleySettings_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_updateParsleySettings_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (UpdateParsleySettingsInput, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal UpdateParsleySettingsInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	if tmp, ok := rawArgs["opts"]; ok {
		return ec.unmarshalNUpdateParsleySettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐUpdateParsleySettingsInput(ctx, tmp)
	}

	var zeroVal UpdateParsleySettingsInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updatePublicKey_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updatePublicKey_argsTargetKeyName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["targetKeyName"] = arg0
	arg1, err := ec.field_Mutation_updatePublicKey_argsUpdateInfo(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["updateInfo"] = arg1
	return args, nil
}
func (ec *executionContext) field_Mutation_updatePublicKey_argsTargetKeyName(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["targetKeyName"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("targetKeyName"))
	if tmp, ok := rawArgs["targetKeyName"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updatePublicKey_argsUpdateInfo(
	ctx context.Context,
	rawArgs map[string]any,
) (PublicKeyInput, error) {
	if _, ok := rawArgs["updateInfo"]; !ok {
		var zeroVal PublicKeyInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("updateInfo"))
	if tmp, ok := rawArgs["updateInfo"]; ok {
		return ec.unmarshalNPublicKeyInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPublicKeyInput(ctx, tmp)
	}

	var zeroVal PublicKeyInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateSpawnHostStatus_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateSpawnHostStatus_argsUpdateSpawnHostStatusInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["updateSpawnHostStatusInput"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_updateSpawnHostStatus_argsUpdateSpawnHostStatusInput(
	ctx context.Context,
	rawArgs map[string]any,
) (UpdateSpawnHostStatusInput, error) {
	if _, ok := rawArgs["updateSpawnHostStatusInput"]; !ok {
		var zeroVal UpdateSpawnHostStatusInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("updateSpawnHostStatusInput"))
	if tmp, ok := rawArgs["updateSpawnHostStatusInput"]; ok {
		return ec.unmarshalNUpdateSpawnHostStatusInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐUpdateSpawnHostStatusInput(ctx, tmp)
	}

	var zeroVal UpdateSpawnHostStatusInput
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateUserSettings_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateUserSettings_argsUserSettings(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["userSettings"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_updateUserSettings_argsUserSettings(
	ctx context.Context,
	rawArgs map[string]any,
) (*model.APIUserSettings, error) {
	if _, ok := rawArgs["userSettings"]; !ok {
		var zeroVal *model.APIUserSettings
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("userSettings"))
	if tmp, ok := rawArgs["userSettings"]; ok {
		return ec.unmarshalOUserSettingsInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIUserSettings(ctx, tmp)
	}

	var zeroVal *model.APIUserSettings
	return zeroVal, nil
}

func (ec *executionContext) field_Mutation_updateVolume_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Mutation_updateVolume_argsUpdateVolumeInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["updateVolumeInput"] = arg0
	return args, nil
}
func (ec *executionContext) field_Mutation_updateVolume_argsUpdateVolumeInput(
	ctx context.Context,
	rawArgs map[string]any,
) (UpdateVolumeInput, error) {
	if _, ok := rawArgs["updateVolumeInput"]; !ok {
		var zeroVal UpdateVolumeInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("updateVolumeInput"))
	if tmp, ok := rawArgs["updateVolumeInput"]; ok {
		return ec.unmarshalNUpdateVolumeInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐUpdateVolumeInput(ctx, tmp)
	}

	var zeroVal UpdateVolumeInput
	return zeroVal, nil
}

func (ec *executionContext) field_Permissions_distroPermissions_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Permissions_distroPermissions_argsOptions(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["options"] = arg0
	return args, nil
}
func (ec *executionContext) field_Permissions_distroPermissions_argsOptions(
	ctx context.Context,
	rawArgs map[string]any,
) (DistroPermissionsOptions, error) {
	if _, ok := rawArgs["options"]; !ok {
		var zeroVal DistroPermissionsOptions
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("options"))
	if tmp, ok := rawArgs["options"]; ok {
		return ec.unmarshalNDistroPermissionsOptions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroPermissionsOptions(ctx, tmp)
	}

	var zeroVal DistroPermissionsOptions
	return zeroVal, nil
}

func (ec *executionContext) field_Permissions_projectPermissions_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Permissions_projectPermissions_argsOptions(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["options"] = arg0
	return args, nil
}
func (ec *executionContext) field_Permissions_projectPermissions_argsOptions(
	ctx context.Context,
	rawArgs map[string]any,
) (ProjectPermissionsOptions, error) {
	if _, ok := rawArgs["options"]; !ok {
		var zeroVal ProjectPermissionsOptions
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("options"))
	if tmp, ok := rawArgs["options"]; ok {
		return ec.unmarshalNProjectPermissionsOptions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermissionsOptions(ctx, tmp)
	}

	var zeroVal ProjectPermissionsOptions
	return zeroVal, nil
}

func (ec *executionContext) field_Permissions_repoPermissions_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Permissions_repoPermissions_argsOptions(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["options"] = arg0
	return args, nil
}
func (ec *executionContext) field_Permissions_repoPermissions_argsOptions(
	ctx context.Context,
	rawArgs map[string]any,
) (RepoPermissionsOptions, error) {
	if _, ok := rawArgs["options"]; !ok {
		var zeroVal RepoPermissionsOptions
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("options"))
	if tmp, ok := rawArgs["options"]; ok {
		return ec.unmarshalNRepoPermissionsOptions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐRepoPermissionsOptions(ctx, tmp)
	}

	var zeroVal RepoPermissionsOptions
	return zeroVal, nil
}

func (ec *executionContext) field_Pod_events_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Pod_events_argsLimit(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg0
	arg1, err := ec.field_Pod_events_argsPage(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["page"] = arg1
	return args, nil
}
func (ec *executionContext) field_Pod_events_argsLimit(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["limit"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
	if tmp, ok := rawArgs["limit"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Pod_events_argsPage(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["page"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
	if tmp, ok := rawArgs["page"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Project_patches_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Project_patches_argsPatchesInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["patchesInput"] = arg0
	return args, nil
}
func (ec *executionContext) field_Project_patches_argsPatchesInput(
	ctx context.Context,
	rawArgs map[string]any,
) (PatchesInput, error) {
	if _, ok := rawArgs["patchesInput"]; !ok {
		var zeroVal PatchesInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("patchesInput"))
	if tmp, ok := rawArgs["patchesInput"]; ok {
		return ec.unmarshalNPatchesInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPatchesInput(ctx, tmp)
	}

	var zeroVal PatchesInput
	return zeroVal, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query___type_argsName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["name"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query___type_argsName(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["name"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
	if tmp, ok := rawArgs["name"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_adminEvents_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_adminEvents_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_adminEvents_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (AdminEventsInput, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal AdminEventsInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	if tmp, ok := rawArgs["opts"]; ok {
		return ec.unmarshalNAdminEventsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAdminEventsInput(ctx, tmp)
	}

	var zeroVal AdminEventsInput
	return zeroVal, nil
}

func (ec *executionContext) field_Query_adminTasksToRestart_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_adminTasksToRestart_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_adminTasksToRestart_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (model1.RestartOptions, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal model1.RestartOptions
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	if tmp, ok := rawArgs["opts"]; ok {
		return ec.unmarshalNRestartAdminTasksOptions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐRestartOptions(ctx, tmp)
	}

	var zeroVal model1.RestartOptions
	return zeroVal, nil
}

func (ec *executionContext) field_Query_bbGetCreatedTickets_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_bbGetCreatedTickets_argsTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_bbGetCreatedTickets_argsTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["taskId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["taskId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx, "ANNOTATIONS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_buildBaron_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_buildBaron_argsTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	arg1, err := ec.field_Query_buildBaron_argsExecution(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["execution"] = arg1
	return args, nil
}
func (ec *executionContext) field_Query_buildBaron_argsTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["taskId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["taskId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx, "ANNOTATIONS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_buildBaron_argsExecution(
	ctx context.Context,
	rawArgs map[string]any,
) (int, error) {
	if _, ok := rawArgs["execution"]; !ok {
		var zeroVal int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("execution"))
	if tmp, ok := rawArgs["execution"]; ok {
		return ec.unmarshalNInt2int(ctx, tmp)
	}

	var zeroVal int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_buildVariantsForTaskName_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_buildVariantsForTaskName_argsProjectIdentifier(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["projectIdentifier"] = arg0
	arg1, err := ec.field_Query_buildVariantsForTaskName_argsTaskName(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskName"] = arg1
	return args, nil
}
func (ec *executionContext) field_Query_buildVariantsForTaskName_argsProjectIdentifier(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["projectIdentifier"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdentifier"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["projectIdentifier"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_buildVariantsForTaskName_argsTaskName(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["taskName"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskName"))
	if tmp, ok := rawArgs["taskName"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_distroEvents_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_distroEvents_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_distroEvents_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (DistroEventsInput, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal DistroEventsInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	if tmp, ok := rawArgs["opts"]; ok {
		return ec.unmarshalNDistroEventsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroEventsInput(ctx, tmp)
	}

	var zeroVal DistroEventsInput
	return zeroVal, nil
}

func (ec *executionContext) field_Query_distroTaskQueue_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_distroTaskQueue_argsDistroID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["distroId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_distroTaskQueue_argsDistroID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["distroId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("distroId"))
	if tmp, ok := rawArgs["distroId"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_distro_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_distro_argsDistroID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["distroId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_distro_argsDistroID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["distroId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("distroId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["distroId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		access, err := ec.unmarshalNDistroSettingsAccess2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroSettingsAccess(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireDistroAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireDistroAccess is not implemented")
		}
		return ec.directives.RequireDistroAccess(ctx, rawArgs, directive0, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_distros_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_distros_argsOnlySpawnable(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["onlySpawnable"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_distros_argsOnlySpawnable(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	if _, ok := rawArgs["onlySpawnable"]; !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("onlySpawnable"))
	if tmp, ok := rawArgs["onlySpawnable"]; ok {
		return ec.unmarshalNBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

func (ec *executionContext) field_Query_githubProjectConflicts_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_githubProjectConflicts_argsProjectID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["projectId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_githubProjectConflicts_argsProjectID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["projectId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["projectId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx, "SETTINGS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_hasVersion_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_hasVersion_argsPatchID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["patchId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_hasVersion_argsPatchID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["patchId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("patchId"))
	if tmp, ok := rawArgs["patchId"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_hostEvents_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_hostEvents_argsHostID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["hostId"] = arg0
	arg1, err := ec.field_Query_hostEvents_argsHostTag(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["hostTag"] = arg1
	arg2, err := ec.field_Query_hostEvents_argsLimit(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg2
	arg3, err := ec.field_Query_hostEvents_argsPage(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["page"] = arg3
	return args, nil
}
func (ec *executionContext) field_Query_hostEvents_argsHostID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["hostId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("hostId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["hostId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		access, err := ec.unmarshalNHostAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐHostAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireHostAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireHostAccess is not implemented")
		}
		return ec.directives.RequireHostAccess(ctx, rawArgs, directive0, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_hostEvents_argsHostTag(
	ctx context.Context,
	rawArgs map[string]any,
) (*string, error) {
	if _, ok := rawArgs["hostTag"]; !ok {
		var zeroVal *string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("hostTag"))
	if tmp, ok := rawArgs["hostTag"]; ok {
		return ec.unmarshalOString2ᚖstring(ctx, tmp)
	}

	var zeroVal *string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_hostEvents_argsLimit(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["limit"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
	if tmp, ok := rawArgs["limit"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_hostEvents_argsPage(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["page"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
	if tmp, ok := rawArgs["page"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_host_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_host_argsHostID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["hostId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_host_argsHostID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["hostId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("hostId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["hostId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		access, err := ec.unmarshalNHostAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐHostAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireHostAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireHostAccess is not implemented")
		}
		return ec.directives.RequireHostAccess(ctx, rawArgs, directive0, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_hosts_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_hosts_argsHostID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["hostId"] = arg0
	arg1, err := ec.field_Query_hosts_argsDistroID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["distroId"] = arg1
	arg2, err := ec.field_Query_hosts_argsCurrentTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["currentTaskId"] = arg2
	arg3, err := ec.field_Query_hosts_argsStatuses(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["statuses"] = arg3
	arg4, err := ec.field_Query_hosts_argsStartedBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["startedBy"] = arg4
	arg5, err := ec.field_Query_hosts_argsSortBy(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["sortBy"] = arg5
	arg6, err := ec.field_Query_hosts_argsSortDir(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["sortDir"] = arg6
	arg7, err := ec.field_Query_hosts_argsPage(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["page"] = arg7
	arg8, err := ec.field_Query_hosts_argsLimit(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg8
	return args, nil
}
func (ec *executionContext) field_Query_hosts_argsHostID(
	ctx context.Context,
	rawArgs map[string]any,
) (*string, error) {
	if _, ok := rawArgs["hostId"]; !ok {
		var zeroVal *string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("hostId"))
	if tmp, ok := rawArgs["hostId"]; ok {
		return ec.unmarshalOString2ᚖstring(ctx, tmp)
	}

	var zeroVal *string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_hosts_argsDistroID(
	ctx context.Context,
	rawArgs map[string]any,
) (*string, error) {
	if _, ok := rawArgs["distroId"]; !ok {
		var zeroVal *string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("distroId"))
	if tmp, ok := rawArgs["distroId"]; ok {
		return ec.unmarshalOString2ᚖstring(ctx, tmp)
	}

	var zeroVal *string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_hosts_argsCurrentTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (*string, error) {
	if _, ok := rawArgs["currentTaskId"]; !ok {
		var zeroVal *string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("currentTaskId"))
	if tmp, ok := rawArgs["currentTaskId"]; ok {
		return ec.unmarshalOString2ᚖstring(ctx, tmp)
	}

	var zeroVal *string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_hosts_argsStatuses(
	ctx context.Context,
	rawArgs map[string]any,
) ([]string, error) {
	if _, ok := rawArgs["statuses"]; !ok {
		var zeroVal []string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("statuses"))
	if tmp, ok := rawArgs["statuses"]; ok {
		return ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
	}

	var zeroVal []string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_hosts_argsStartedBy(
	ctx context.Context,
	rawArgs map[string]any,
) (*string, error) {
	if _, ok := rawArgs["startedBy"]; !ok {
		var zeroVal *string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("startedBy"))
	if tmp, ok := rawArgs["startedBy"]; ok {
		return ec.unmarshalOString2ᚖstring(ctx, tmp)
	}

	var zeroVal *string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_hosts_argsSortBy(
	ctx context.Context,
	rawArgs map[string]any,
) (*HostSortBy, error) {
	if _, ok := rawArgs["sortBy"]; !ok {
		var zeroVal *HostSortBy
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("sortBy"))
	if tmp, ok := rawArgs["sortBy"]; ok {
		return ec.unmarshalOHostSortBy2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐHostSortBy(ctx, tmp)
	}

	var zeroVal *HostSortBy
	return zeroVal, nil
}

func (ec *executionContext) field_Query_hosts_argsSortDir(
	ctx context.Context,
	rawArgs map[string]any,
) (*SortDirection, error) {
	if _, ok := rawArgs["sortDir"]; !ok {
		var zeroVal *SortDirection
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("sortDir"))
	if tmp, ok := rawArgs["sortDir"]; ok {
		return ec.unmarshalOSortDirection2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSortDirection(ctx, tmp)
	}

	var zeroVal *SortDirection
	return zeroVal, nil
}

func (ec *executionContext) field_Query_hosts_argsPage(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["page"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
	if tmp, ok := rawArgs["page"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_hosts_argsLimit(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["limit"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
	if tmp, ok := rawArgs["limit"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_image_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_image_argsImageID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["imageId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_image_argsImageID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["imageId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("imageId"))
	if tmp, ok := rawArgs["imageId"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_isRepo_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_isRepo_argsProjectOrRepoID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["projectOrRepoId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_isRepo_argsProjectOrRepoID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["projectOrRepoId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("projectOrRepoId"))
	if tmp, ok := rawArgs["projectOrRepoId"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_logkeeperBuildMetadata_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_logkeeperBuildMetadata_argsBuildID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["buildId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_logkeeperBuildMetadata_argsBuildID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["buildId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("buildId"))
	if tmp, ok := rawArgs["buildId"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_mainlineCommits_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_mainlineCommits_argsOptions(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["options"] = arg0
	arg1, err := ec.field_Query_mainlineCommits_argsBuildVariantOptions(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["buildVariantOptions"] = arg1
	return args, nil
}
func (ec *executionContext) field_Query_mainlineCommits_argsOptions(
	ctx context.Context,
	rawArgs map[string]any,
) (MainlineCommitsOptions, error) {
	if _, ok := rawArgs["options"]; !ok {
		var zeroVal MainlineCommitsOptions
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("options"))
	if tmp, ok := rawArgs["options"]; ok {
		return ec.unmarshalNMainlineCommitsOptions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐMainlineCommitsOptions(ctx, tmp)
	}

	var zeroVal MainlineCommitsOptions
	return zeroVal, nil
}

func (ec *executionContext) field_Query_mainlineCommits_argsBuildVariantOptions(
	ctx context.Context,
	rawArgs map[string]any,
) (*BuildVariantOptions, error) {
	if _, ok := rawArgs["buildVariantOptions"]; !ok {
		var zeroVal *BuildVariantOptions
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("buildVariantOptions"))
	if tmp, ok := rawArgs["buildVariantOptions"]; ok {
		return ec.unmarshalOBuildVariantOptions2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐBuildVariantOptions(ctx, tmp)
	}

	var zeroVal *BuildVariantOptions
	return zeroVal, nil
}

func (ec *executionContext) field_Query_patch_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_patch_argsPatchID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["patchId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_patch_argsPatchID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["patchId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("patchId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["patchId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_pod_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_pod_argsPodID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["podId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_pod_argsPodID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["podId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("podId"))
	if tmp, ok := rawArgs["podId"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_projectEvents_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_projectEvents_argsProjectIdentifier(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["projectIdentifier"] = arg0
	arg1, err := ec.field_Query_projectEvents_argsLimit(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg1
	arg2, err := ec.field_Query_projectEvents_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_projectEvents_argsProjectIdentifier(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["projectIdentifier"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdentifier"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["projectIdentifier"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx, "SETTINGS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_projectEvents_argsLimit(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["limit"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
	if tmp, ok := rawArgs["limit"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_projectEvents_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*time.Time, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *time.Time
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOTime2ᚖtimeᚐTime(ctx, tmp)
	}

	var zeroVal *time.Time
	return zeroVal, nil
}

func (ec *executionContext) field_Query_projectSettings_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_projectSettings_argsProjectIdentifier(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["projectIdentifier"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_projectSettings_argsProjectIdentifier(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["projectIdentifier"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdentifier"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["projectIdentifier"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx, "SETTINGS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_project_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_project_argsProjectIdentifier(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["projectIdentifier"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_project_argsProjectIdentifier(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["projectIdentifier"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdentifier"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["projectIdentifier"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_repoEvents_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_repoEvents_argsRepoID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["repoId"] = arg0
	arg1, err := ec.field_Query_repoEvents_argsLimit(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["limit"] = arg1
	arg2, err := ec.field_Query_repoEvents_argsBefore(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["before"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_repoEvents_argsRepoID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["repoId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("repoId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["repoId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx, "SETTINGS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_repoEvents_argsLimit(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["limit"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
	if tmp, ok := rawArgs["limit"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_repoEvents_argsBefore(
	ctx context.Context,
	rawArgs map[string]any,
) (*time.Time, error) {
	if _, ok := rawArgs["before"]; !ok {
		var zeroVal *time.Time
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
	if tmp, ok := rawArgs["before"]; ok {
		return ec.unmarshalOTime2ᚖtimeᚐTime(ctx, tmp)
	}

	var zeroVal *time.Time
	return zeroVal, nil
}

func (ec *executionContext) field_Query_repoSettings_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_repoSettings_argsRepoID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["repoId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_repoSettings_argsRepoID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["repoId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("repoId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["repoId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx, "SETTINGS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_taskAllExecutions_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_taskAllExecutions_argsTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_taskAllExecutions_argsTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["taskId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["taskId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_taskHistory_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_taskHistory_argsOptions(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["options"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_taskHistory_argsOptions(
	ctx context.Context,
	rawArgs map[string]any,
) (TaskHistoryOpts, error) {
	if _, ok := rawArgs["options"]; !ok {
		var zeroVal TaskHistoryOpts
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("options"))
	if tmp, ok := rawArgs["options"]; ok {
		return ec.unmarshalNTaskHistoryOpts2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskHistoryOpts(ctx, tmp)
	}

	var zeroVal TaskHistoryOpts
	return zeroVal, nil
}

func (ec *executionContext) field_Query_taskNamesForBuildVariant_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_taskNamesForBuildVariant_argsProjectIdentifier(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["projectIdentifier"] = arg0
	arg1, err := ec.field_Query_taskNamesForBuildVariant_argsBuildVariant(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["buildVariant"] = arg1
	return args, nil
}
func (ec *executionContext) field_Query_taskNamesForBuildVariant_argsProjectIdentifier(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["projectIdentifier"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdentifier"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["projectIdentifier"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_taskNamesForBuildVariant_argsBuildVariant(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["buildVariant"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("buildVariant"))
	if tmp, ok := rawArgs["buildVariant"]; ok {
		return ec.unmarshalNString2string(ctx, tmp)
	}

	var zeroVal string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_taskTestSample_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_taskTestSample_argsVersionID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["versionId"] = arg0
	arg1, err := ec.field_Query_taskTestSample_argsTaskIds(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskIds"] = arg1
	arg2, err := ec.field_Query_taskTestSample_argsFilters(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["filters"] = arg2
	return args, nil
}
func (ec *executionContext) field_Query_taskTestSample_argsVersionID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["versionId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["versionId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_taskTestSample_argsTaskIds(
	ctx context.Context,
	rawArgs map[string]any,
) ([]string, error) {
	if _, ok := rawArgs["taskIds"]; !ok {
		var zeroVal []string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskIds"))
	if tmp, ok := rawArgs["taskIds"]; ok {
		return ec.unmarshalNString2ᚕstringᚄ(ctx, tmp)
	}

	var zeroVal []string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_taskTestSample_argsFilters(
	ctx context.Context,
	rawArgs map[string]any,
) ([]*TestFilter, error) {
	if _, ok := rawArgs["filters"]; !ok {
		var zeroVal []*TestFilter
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("filters"))
	if tmp, ok := rawArgs["filters"]; ok {
		return ec.unmarshalNTestFilter2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTestFilterᚄ(ctx, tmp)
	}

	var zeroVal []*TestFilter
	return zeroVal, nil
}

func (ec *executionContext) field_Query_task_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_task_argsTaskID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["taskId"] = arg0
	arg1, err := ec.field_Query_task_argsExecution(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["execution"] = arg1
	return args, nil
}
func (ec *executionContext) field_Query_task_argsTaskID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["taskId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["taskId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_task_argsExecution(
	ctx context.Context,
	rawArgs map[string]any,
) (*int, error) {
	if _, ok := rawArgs["execution"]; !ok {
		var zeroVal *int
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("execution"))
	if tmp, ok := rawArgs["execution"]; ok {
		return ec.unmarshalOInt2ᚖint(ctx, tmp)
	}

	var zeroVal *int
	return zeroVal, nil
}

func (ec *executionContext) field_Query_user_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_user_argsUserID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["userId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_user_argsUserID(
	ctx context.Context,
	rawArgs map[string]any,
) (*string, error) {
	if _, ok := rawArgs["userId"]; !ok {
		var zeroVal *string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
	if tmp, ok := rawArgs["userId"]; ok {
		return ec.unmarshalOString2ᚖstring(ctx, tmp)
	}

	var zeroVal *string
	return zeroVal, nil
}

func (ec *executionContext) field_Query_version_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_version_argsVersionID(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["versionId"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_version_argsVersionID(
	ctx context.Context,
	rawArgs map[string]any,
) (string, error) {
	if _, ok := rawArgs["versionId"]; !ok {
		var zeroVal string
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
	directive0 := func(ctx context.Context) (any, error) {
		tmp, ok := rawArgs["versionId"]
		if !ok {
			var zeroVal string
			return zeroVal, nil
		}
		return ec.unmarshalNString2string(ctx, tmp)
	}

	directive1 := func(ctx context.Context) (any, error) {
		permission, err := ec.unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx, "TASKS")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		access, err := ec.unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx, "VIEW")
		if err != nil {
			var zeroVal string
			return zeroVal, err
		}
		if ec.directives.RequireProjectAccess == nil {
			var zeroVal string
			return zeroVal, errors.New("directive requireProjectAccess is not implemented")
		}
		return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, permission, access)
	}

	tmp, err := directive1(ctx)
	if err != nil {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, err)
	}
	if data, ok := tmp.(string); ok {
		return data, nil
	} else {
		var zeroVal string
		return zeroVal, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
	}
}

func (ec *executionContext) field_Query_waterfall_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Query_waterfall_argsOptions(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["options"] = arg0
	return args, nil
}
func (ec *executionContext) field_Query_waterfall_argsOptions(
	ctx context.Context,
	rawArgs map[string]any,
) (WaterfallOptions, error) {
	if _, ok := rawArgs["options"]; !ok {
		var zeroVal WaterfallOptions
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("options"))
	if tmp, ok := rawArgs["options"]; ok {
		return ec.unmarshalNWaterfallOptions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐWaterfallOptions(ctx, tmp)
	}

	var zeroVal WaterfallOptions
	return zeroVal, nil
}

func (ec *executionContext) field_Task_tests_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Task_tests_argsOpts(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["opts"] = arg0
	return args, nil
}
func (ec *executionContext) field_Task_tests_argsOpts(
	ctx context.Context,
	rawArgs map[string]any,
) (*TestFilterOptions, error) {
	if _, ok := rawArgs["opts"]; !ok {
		var zeroVal *TestFilterOptions
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
	if tmp, ok := rawArgs["opts"]; ok {
		return ec.unmarshalOTestFilterOptions2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTestFilterOptions(ctx, tmp)
	}

	var zeroVal *TestFilterOptions
	return zeroVal, nil
}

func (ec *executionContext) field_User_patches_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_User_patches_argsPatchesInput(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["patchesInput"] = arg0
	return args, nil
}
func (ec *executionContext) field_User_patches_argsPatchesInput(
	ctx context.Context,
	rawArgs map[string]any,
) (PatchesInput, error) {
	if _, ok := rawArgs["patchesInput"]; !ok {
		var zeroVal PatchesInput
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("patchesInput"))
	if tmp, ok := rawArgs["patchesInput"]; ok {
		return ec.unmarshalNPatchesInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPatchesInput(ctx, tmp)
	}

	var zeroVal PatchesInput
	return zeroVal, nil
}

func (ec *executionContext) field_Version_buildVariantStats_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Version_buildVariantStats_argsOptions(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["options"] = arg0
	return args, nil
}
func (ec *executionContext) field_Version_buildVariantStats_argsOptions(
	ctx context.Context,
	rawArgs map[string]any,
) (BuildVariantOptions, error) {
	if _, ok := rawArgs["options"]; !ok {
		var zeroVal BuildVariantOptions
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("options"))
	if tmp, ok := rawArgs["options"]; ok {
		return ec.unmarshalNBuildVariantOptions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐBuildVariantOptions(ctx, tmp)
	}

	var zeroVal BuildVariantOptions
	return zeroVal, nil
}

func (ec *executionContext) field_Version_buildVariants_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Version_buildVariants_argsOptions(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["options"] = arg0
	return args, nil
}
func (ec *executionContext) field_Version_buildVariants_argsOptions(
	ctx context.Context,
	rawArgs map[string]any,
) (BuildVariantOptions, error) {
	if _, ok := rawArgs["options"]; !ok {
		var zeroVal BuildVariantOptions
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("options"))
	if tmp, ok := rawArgs["options"]; ok {
		return ec.unmarshalNBuildVariantOptions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐBuildVariantOptions(ctx, tmp)
	}

	var zeroVal BuildVariantOptions
	return zeroVal, nil
}

func (ec *executionContext) field_Version_taskCount_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Version_taskCount_argsOptions(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["options"] = arg0
	return args, nil
}
func (ec *executionContext) field_Version_taskCount_argsOptions(
	ctx context.Context,
	rawArgs map[string]any,
) (*TaskCountOptions, error) {
	if _, ok := rawArgs["options"]; !ok {
		var zeroVal *TaskCountOptions
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("options"))
	if tmp, ok := rawArgs["options"]; ok {
		return ec.unmarshalOTaskCountOptions2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskCountOptions(ctx, tmp)
	}

	var zeroVal *TaskCountOptions
	return zeroVal, nil
}

func (ec *executionContext) field_Version_taskStatusStats_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Version_taskStatusStats_argsOptions(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["options"] = arg0
	return args, nil
}
func (ec *executionContext) field_Version_taskStatusStats_argsOptions(
	ctx context.Context,
	rawArgs map[string]any,
) (BuildVariantOptions, error) {
	if _, ok := rawArgs["options"]; !ok {
		var zeroVal BuildVariantOptions
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("options"))
	if tmp, ok := rawArgs["options"]; ok {
		return ec.unmarshalNBuildVariantOptions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐBuildVariantOptions(ctx, tmp)
	}

	var zeroVal BuildVariantOptions
	return zeroVal, nil
}

func (ec *executionContext) field_Version_tasks_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field_Version_tasks_argsOptions(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["options"] = arg0
	return args, nil
}
func (ec *executionContext) field_Version_tasks_argsOptions(
	ctx context.Context,
	rawArgs map[string]any,
) (TaskFilterOptions, error) {
	if _, ok := rawArgs["options"]; !ok {
		var zeroVal TaskFilterOptions
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("options"))
	if tmp, ok := rawArgs["options"]; ok {
		return ec.unmarshalNTaskFilterOptions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskFilterOptions(ctx, tmp)
	}

	var zeroVal TaskFilterOptions
	return zeroVal, nil
}

func (ec *executionContext) field___Directive_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Directive_args_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Directive_args_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal *bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field___Field_args_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Field_args_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Field_args_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (*bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal *bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
	}

	var zeroVal *bool
	return zeroVal, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Type_enumValues_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Type_enumValues_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]any) (map[string]any, error) {
	var err error
	args := map[string]any{}
	arg0, err := ec.field___Type_fields_argsIncludeDeprecated(ctx, rawArgs)
	if err != nil {
		return nil, err
	}
	args["includeDeprecated"] = arg0
	return args, nil
}
func (ec *executionContext) field___Type_fields_argsIncludeDeprecated(
	ctx context.Context,
	rawArgs map[string]any,
) (bool, error) {
	if _, ok := rawArgs["includeDeprecated"]; !ok {
		var zeroVal bool
		return zeroVal, nil
	}

	ctx = graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		return ec.unmarshalOBoolean2bool(ctx, tmp)
	}

	var zeroVal bool
	return zeroVal, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _APIConfig_httpListenAddr(ctx context.Context, field graphql.CollectedField, obj *model.APIapiConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_APIConfig_httpListenAddr(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HttpListenAddr, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_APIConfig_httpListenAddr(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _APIConfig_url(ctx context.Context, field graphql.CollectedField, obj *model.APIapiConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_APIConfig_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_APIConfig_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _APIConfig_corpUrl(ctx context.Context, field graphql.CollectedField, obj *model.APIapiConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_APIConfig_corpUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CorpURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_APIConfig_corpUrl(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "APIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AWSConfig_maxVolumeSizePerUser(ctx context.Context, field graphql.CollectedField, obj *model.APIAWSConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AWSConfig_maxVolumeSizePerUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxVolumeSizePerUser, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AWSConfig_maxVolumeSizePerUser(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AWSConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AWSConfig_pod(ctx context.Context, field graphql.CollectedField, obj *model.APIAWSConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AWSConfig_pod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pod, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIAWSPodConfig)
	fc.Result = res
	return ec.marshalOAWSPodConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAWSPodConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AWSConfig_pod(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AWSConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ecs":
				return ec.fieldContext_AWSPodConfig_ecs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AWSPodConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AWSPodConfig_ecs(ctx context.Context, field graphql.CollectedField, obj *model.APIAWSPodConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AWSPodConfig_ecs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ECS, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIECSConfig)
	fc.Result = res
	return ec.marshalOECSConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIECSConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AWSPodConfig_ecs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AWSPodConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "maxCPU":
				return ec.fieldContext_ECSConfig_maxCPU(ctx, field)
			case "maxMemoryMb":
				return ec.fieldContext_ECSConfig_maxMemoryMb(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ECSConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AbortInfo_buildVariantDisplayName(ctx context.Context, field graphql.CollectedField, obj *AbortInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AbortInfo_buildVariantDisplayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildVariantDisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AbortInfo_buildVariantDisplayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbortInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AbortInfo_newVersion(ctx context.Context, field graphql.CollectedField, obj *AbortInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AbortInfo_newVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AbortInfo_newVersion(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbortInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AbortInfo_prClosed(ctx context.Context, field graphql.CollectedField, obj *AbortInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AbortInfo_prClosed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrClosed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AbortInfo_prClosed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbortInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AbortInfo_taskDisplayName(ctx context.Context, field graphql.CollectedField, obj *AbortInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AbortInfo_taskDisplayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskDisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AbortInfo_taskDisplayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbortInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AbortInfo_taskID(ctx context.Context, field graphql.CollectedField, obj *AbortInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AbortInfo_taskID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AbortInfo_taskID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbortInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AbortInfo_user(ctx context.Context, field graphql.CollectedField, obj *AbortInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AbortInfo_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AbortInfo_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbortInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminEvent_section(ctx context.Context, field graphql.CollectedField, obj *AdminEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminEvent_section(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Section, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminEvent_section(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminEvent_after(ctx context.Context, field graphql.CollectedField, obj *AdminEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminEvent_after(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.After, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]any)
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminEvent_after(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminEvent_before(ctx context.Context, field graphql.CollectedField, obj *AdminEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminEvent_before(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Before, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]any)
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminEvent_before(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminEvent_timestamp(ctx context.Context, field graphql.CollectedField, obj *AdminEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminEvent_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminEvent_timestamp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminEvent_user(ctx context.Context, field graphql.CollectedField, obj *AdminEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminEvent_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminEvent_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminEventsPayload_count(ctx context.Context, field graphql.CollectedField, obj *AdminEventsPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminEventsPayload_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminEventsPayload_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminEventsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminEventsPayload_eventLogEntries(ctx context.Context, field graphql.CollectedField, obj *AdminEventsPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminEventsPayload_eventLogEntries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventLogEntries, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*AdminEvent)
	fc.Result = res
	return ec.marshalNAdminEvent2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAdminEventᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminEventsPayload_eventLogEntries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminEventsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "section":
				return ec.fieldContext_AdminEvent_section(ctx, field)
			case "after":
				return ec.fieldContext_AdminEvent_after(ctx, field)
			case "before":
				return ec.fieldContext_AdminEvent_before(ctx, field)
			case "timestamp":
				return ec.fieldContext_AdminEvent_timestamp(ctx, field)
			case "user":
				return ec.fieldContext_AdminEvent_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdminEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_amboy(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminSettings_amboy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Amboy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIAmboyConfig)
	fc.Result = res
	return ec.marshalOAmboyConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAmboyConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminSettings_amboy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_AmboyConfig_name(ctx, field)
			case "singleName":
				return ec.fieldContext_AmboyConfig_singleName(ctx, field)
			case "poolSizeLocal":
				return ec.fieldContext_AmboyConfig_poolSizeLocal(ctx, field)
			case "poolSizeRemote":
				return ec.fieldContext_AmboyConfig_poolSizeRemote(ctx, field)
			case "localStorage":
				return ec.fieldContext_AmboyConfig_localStorage(ctx, field)
			case "groupDefaultWorkers":
				return ec.fieldContext_AmboyConfig_groupDefaultWorkers(ctx, field)
			case "groupBackgroundCreateFrequencyMinutes":
				return ec.fieldContext_AmboyConfig_groupBackgroundCreateFrequencyMinutes(ctx, field)
			case "groupPruneFrequencyMinutes":
				return ec.fieldContext_AmboyConfig_groupPruneFrequencyMinutes(ctx, field)
			case "groupTTLMinutes":
				return ec.fieldContext_AmboyConfig_groupTTLMinutes(ctx, field)
			case "lockTimeoutMinutes":
				return ec.fieldContext_AmboyConfig_lockTimeoutMinutes(ctx, field)
			case "sampleSize":
				return ec.fieldContext_AmboyConfig_sampleSize(ctx, field)
			case "retry":
				return ec.fieldContext_AmboyConfig_retry(ctx, field)
			case "namedQueues":
				return ec.fieldContext_AmboyConfig_namedQueues(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AmboyConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_amboyDB(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminSettings_amboyDB(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AmboyDB, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIAmboyDBConfig)
	fc.Result = res
	return ec.marshalOAmboyDBConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAmboyDBConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminSettings_amboyDB(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "url":
				return ec.fieldContext_AmboyDBConfig_url(ctx, field)
			case "database":
				return ec.fieldContext_AmboyDBConfig_database(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AmboyDBConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_authConfig(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminSettings_authConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthConfig, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIAuthConfig)
	fc.Result = res
	return ec.marshalOAuthConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAuthConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminSettings_authConfig(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "okta":
				return ec.fieldContext_AuthConfig_okta(ctx, field)
			case "naive":
				return ec.fieldContext_AuthConfig_naive(ctx, field)
			case "github":
				return ec.fieldContext_AuthConfig_github(ctx, field)
			case "multi":
				return ec.fieldContext_AuthConfig_multi(ctx, field)
			case "kanopy":
				return ec.fieldContext_AuthConfig_kanopy(ctx, field)
			case "preferredType":
				return ec.fieldContext_AuthConfig_preferredType(ctx, field)
			case "backgroundReauthMinutes":
				return ec.fieldContext_AuthConfig_backgroundReauthMinutes(ctx, field)
			case "allowServiceUsers":
				return ec.fieldContext_AuthConfig_allowServiceUsers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AuthConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_banner(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminSettings_banner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Banner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminSettings_banner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_bannerTheme(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminSettings_bannerTheme(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.AdminSettings().BannerTheme(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*evergreen.BannerTheme)
	fc.Result = res
	return ec.marshalOBannerTheme2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚐBannerTheme(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminSettings_bannerTheme(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BannerTheme does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_cedar(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminSettings_cedar(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cedar, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APICedarConfig)
	fc.Result = res
	return ec.marshalOCedarConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPICedarConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminSettings_cedar(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "dbUrl":
				return ec.fieldContext_CedarConfig_dbUrl(ctx, field)
			case "dbName":
				return ec.fieldContext_CedarConfig_dbName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CedarConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_fws(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminSettings_fws(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FWS, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIFWSConfig)
	fc.Result = res
	return ec.marshalOFWSConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIFWSConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminSettings_fws(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "url":
				return ec.fieldContext_FWSConfig_url(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FWSConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_jira(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminSettings_jira(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Jira, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIJiraConfig)
	fc.Result = res
	return ec.marshalOJiraConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIJiraConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminSettings_jira(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "email":
				return ec.fieldContext_JiraConfig_email(ctx, field)
			case "host":
				return ec.fieldContext_JiraConfig_host(ctx, field)
			case "personalAccessToken":
				return ec.fieldContext_JiraConfig_personalAccessToken(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JiraConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_slack(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminSettings_slack(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Slack, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APISlackConfig)
	fc.Result = res
	return ec.marshalOSlackConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISlackConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminSettings_slack(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "options":
				return ec.fieldContext_SlackConfig_options(ctx, field)
			case "token":
				return ec.fieldContext_SlackConfig_token(ctx, field)
			case "level":
				return ec.fieldContext_SlackConfig_level(ctx, field)
			case "name":
				return ec.fieldContext_SlackConfig_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SlackConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_splunk(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminSettings_splunk(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Splunk, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APISplunkConfig)
	fc.Result = res
	return ec.marshalOSplunkConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISplunkConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminSettings_splunk(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "splunkConnectionInfo":
				return ec.fieldContext_SplunkConfig_splunkConnectionInfo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SplunkConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_runtimeEnvironments(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminSettings_runtimeEnvironments(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RuntimeEnvironments, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIRuntimeEnvironmentsConfig)
	fc.Result = res
	return ec.marshalORuntimeEnvironmentConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIRuntimeEnvironmentsConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminSettings_runtimeEnvironments(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "baseUrl":
				return ec.fieldContext_RuntimeEnvironmentConfig_baseUrl(ctx, field)
			case "apiKey":
				return ec.fieldContext_RuntimeEnvironmentConfig_apiKey(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RuntimeEnvironmentConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_testSelection(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminSettings_testSelection(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TestSelection, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APITestSelectionConfig)
	fc.Result = res
	return ec.marshalOTestSelectionConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITestSelectionConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminSettings_testSelection(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "url":
				return ec.fieldContext_TestSelectionConfig_url(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TestSelectionConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_serviceFlags(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminSettings_serviceFlags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceFlags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIServiceFlags)
	fc.Result = res
	return ec.marshalOServiceFlags2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIServiceFlags(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminSettings_serviceFlags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "taskDispatchDisabled":
				return ec.fieldContext_ServiceFlags_taskDispatchDisabled(ctx, field)
			case "hostInitDisabled":
				return ec.fieldContext_ServiceFlags_hostInitDisabled(ctx, field)
			case "podInitDisabled":
				return ec.fieldContext_ServiceFlags_podInitDisabled(ctx, field)
			case "largeParserProjectsDisabled":
				return ec.fieldContext_ServiceFlags_largeParserProjectsDisabled(ctx, field)
			case "monitorDisabled":
				return ec.fieldContext_ServiceFlags_monitorDisabled(ctx, field)
			case "alertsDisabled":
				return ec.fieldContext_ServiceFlags_alertsDisabled(ctx, field)
			case "agentStartDisabled":
				return ec.fieldContext_ServiceFlags_agentStartDisabled(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_ServiceFlags_repotrackerDisabled(ctx, field)
			case "schedulerDisabled":
				return ec.fieldContext_ServiceFlags_schedulerDisabled(ctx, field)
			case "checkBlockedTasksDisabled":
				return ec.fieldContext_ServiceFlags_checkBlockedTasksDisabled(ctx, field)
			case "githubPRTestingDisabled":
				return ec.fieldContext_ServiceFlags_githubPRTestingDisabled(ctx, field)
			case "cliUpdatesDisabled":
				return ec.fieldContext_ServiceFlags_cliUpdatesDisabled(ctx, field)
			case "backgroundStatsDisabled":
				return ec.fieldContext_ServiceFlags_backgroundStatsDisabled(ctx, field)
			case "taskLoggingDisabled":
				return ec.fieldContext_ServiceFlags_taskLoggingDisabled(ctx, field)
			case "cacheStatsJobDisabled":
				return ec.fieldContext_ServiceFlags_cacheStatsJobDisabled(ctx, field)
			case "cacheStatsEndpointDisabled":
				return ec.fieldContext_ServiceFlags_cacheStatsEndpointDisabled(ctx, field)
			case "taskReliabilityDisabled":
				return ec.fieldContext_ServiceFlags_taskReliabilityDisabled(ctx, field)
			case "hostAllocatorDisabled":
				return ec.fieldContext_ServiceFlags_hostAllocatorDisabled(ctx, field)
			case "podAllocatorDisabled":
				return ec.fieldContext_ServiceFlags_podAllocatorDisabled(ctx, field)
			case "unrecognizedPodCleanupDisabled":
				return ec.fieldContext_ServiceFlags_unrecognizedPodCleanupDisabled(ctx, field)
			case "backgroundReauthDisabled":
				return ec.fieldContext_ServiceFlags_backgroundReauthDisabled(ctx, field)
			case "cloudCleanupDisabled":
				return ec.fieldContext_ServiceFlags_cloudCleanupDisabled(ctx, field)
			case "sleepScheduleDisabled":
				return ec.fieldContext_ServiceFlags_sleepScheduleDisabled(ctx, field)
			case "staticAPIKeysDisabled":
				return ec.fieldContext_ServiceFlags_staticAPIKeysDisabled(ctx, field)
			case "jwtTokenForCLIDisabled":
				return ec.fieldContext_ServiceFlags_jwtTokenForCLIDisabled(ctx, field)
			case "systemFailedTaskRestartDisabled":
				return ec.fieldContext_ServiceFlags_systemFailedTaskRestartDisabled(ctx, field)
			case "degradedModeDisabled":
				return ec.fieldContext_ServiceFlags_degradedModeDisabled(ctx, field)
			case "elasticIPsDisabled":
				return ec.fieldContext_ServiceFlags_elasticIPsDisabled(ctx, field)
			case "releaseModeDisabled":
				return ec.fieldContext_ServiceFlags_releaseModeDisabled(ctx, field)
			case "adminParameterStoreDisabled":
				return ec.fieldContext_ServiceFlags_adminParameterStoreDisabled(ctx, field)
			case "eventProcessingDisabled":
				return ec.fieldContext_ServiceFlags_eventProcessingDisabled(ctx, field)
			case "jiraNotificationsDisabled":
				return ec.fieldContext_ServiceFlags_jiraNotificationsDisabled(ctx, field)
			case "slackNotificationsDisabled":
				return ec.fieldContext_ServiceFlags_slackNotificationsDisabled(ctx, field)
			case "emailNotificationsDisabled":
				return ec.fieldContext_ServiceFlags_emailNotificationsDisabled(ctx, field)
			case "webhookNotificationsDisabled":
				return ec.fieldContext_ServiceFlags_webhookNotificationsDisabled(ctx, field)
			case "githubStatusAPIDisabled":
				return ec.fieldContext_ServiceFlags_githubStatusAPIDisabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ServiceFlags", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_notify(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminSettings_notify(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Notify, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APINotifyConfig)
	fc.Result = res
	return ec.marshalONotifyConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPINotifyConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminSettings_notify(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ses":
				return ec.fieldContext_NotifyConfig_ses(ctx, field)
			case "bufferTargetPerInterval":
				return ec.fieldContext_NotifyConfig_bufferTargetPerInterval(ctx, field)
			case "bufferIntervalSeconds":
				return ec.fieldContext_NotifyConfig_bufferIntervalSeconds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NotifyConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_taskLimits(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminSettings_taskLimits(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskLimits, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APITaskLimitsConfig)
	fc.Result = res
	return ec.marshalOTaskLimitsConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskLimitsConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminSettings_taskLimits(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "maxTasksPerVersion":
				return ec.fieldContext_TaskLimitsConfig_maxTasksPerVersion(ctx, field)
			case "maxIncludesPerVersion":
				return ec.fieldContext_TaskLimitsConfig_maxIncludesPerVersion(ctx, field)
			case "maxHourlyPatchTasks":
				return ec.fieldContext_TaskLimitsConfig_maxHourlyPatchTasks(ctx, field)
			case "maxPendingGeneratedTasks":
				return ec.fieldContext_TaskLimitsConfig_maxPendingGeneratedTasks(ctx, field)
			case "maxGenerateTaskJSONSize":
				return ec.fieldContext_TaskLimitsConfig_maxGenerateTaskJSONSize(ctx, field)
			case "maxConcurrentLargeParserProjectTasks":
				return ec.fieldContext_TaskLimitsConfig_maxConcurrentLargeParserProjectTasks(ctx, field)
			case "maxDegradedModeConcurrentLargeParserProjectTasks":
				return ec.fieldContext_TaskLimitsConfig_maxDegradedModeConcurrentLargeParserProjectTasks(ctx, field)
			case "maxDegradedModeParserProjectSize":
				return ec.fieldContext_TaskLimitsConfig_maxDegradedModeParserProjectSize(ctx, field)
			case "maxParserProjectSize":
				return ec.fieldContext_TaskLimitsConfig_maxParserProjectSize(ctx, field)
			case "maxExecTimeoutSecs":
				return ec.fieldContext_TaskLimitsConfig_maxExecTimeoutSecs(ctx, field)
			case "maxTaskExecution":
				return ec.fieldContext_TaskLimitsConfig_maxTaskExecution(ctx, field)
			case "maxDailyAutomaticRestarts":
				return ec.fieldContext_TaskLimitsConfig_maxDailyAutomaticRestarts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskLimitsConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_hostInit(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminSettings_hostInit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostInit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIHostInitConfig)
	fc.Result = res
	return ec.marshalOHostInitConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHostInitConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminSettings_hostInit(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hostThrottle":
				return ec.fieldContext_HostInitConfig_hostThrottle(ctx, field)
			case "provisioningThrottle":
				return ec.fieldContext_HostInitConfig_provisioningThrottle(ctx, field)
			case "cloudStatusBatchSize":
				return ec.fieldContext_HostInitConfig_cloudStatusBatchSize(ctx, field)
			case "maxTotalDynamicHosts":
				return ec.fieldContext_HostInitConfig_maxTotalDynamicHosts(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HostInitConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_podLifecycle(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminSettings_podLifecycle(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PodLifecycle, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIPodLifecycleConfig)
	fc.Result = res
	return ec.marshalOPodLifecycleConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPodLifecycleConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminSettings_podLifecycle(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "maxParallelPodRequests":
				return ec.fieldContext_PodLifecycleConfig_maxParallelPodRequests(ctx, field)
			case "maxPodDefinitionCleanupRate":
				return ec.fieldContext_PodLifecycleConfig_maxPodDefinitionCleanupRate(ctx, field)
			case "maxSecretCleanupRate":
				return ec.fieldContext_PodLifecycleConfig_maxSecretCleanupRate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PodLifecycleConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_scheduler(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminSettings_scheduler(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Scheduler, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APISchedulerConfig)
	fc.Result = res
	return ec.marshalOSchedulerConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISchedulerConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminSettings_scheduler(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "taskFinder":
				return ec.fieldContext_SchedulerConfig_taskFinder(ctx, field)
			case "hostAllocator":
				return ec.fieldContext_SchedulerConfig_hostAllocator(ctx, field)
			case "hostAllocatorRoundingRule":
				return ec.fieldContext_SchedulerConfig_hostAllocatorRoundingRule(ctx, field)
			case "hostAllocatorFeedbackRule":
				return ec.fieldContext_SchedulerConfig_hostAllocatorFeedbackRule(ctx, field)
			case "hostsOverallocatedRule":
				return ec.fieldContext_SchedulerConfig_hostsOverallocatedRule(ctx, field)
			case "futureHostFraction":
				return ec.fieldContext_SchedulerConfig_futureHostFraction(ctx, field)
			case "cacheDurationSeconds":
				return ec.fieldContext_SchedulerConfig_cacheDurationSeconds(ctx, field)
			case "targetTimeSeconds":
				return ec.fieldContext_SchedulerConfig_targetTimeSeconds(ctx, field)
			case "acceptableHostIdleTimeSeconds":
				return ec.fieldContext_SchedulerConfig_acceptableHostIdleTimeSeconds(ctx, field)
			case "groupVersions":
				return ec.fieldContext_SchedulerConfig_groupVersions(ctx, field)
			case "patchFactor":
				return ec.fieldContext_SchedulerConfig_patchFactor(ctx, field)
			case "patchTimeInQueueFactor":
				return ec.fieldContext_SchedulerConfig_patchTimeInQueueFactor(ctx, field)
			case "commitQueueFactor":
				return ec.fieldContext_SchedulerConfig_commitQueueFactor(ctx, field)
			case "mainlineTimeInQueueFactor":
				return ec.fieldContext_SchedulerConfig_mainlineTimeInQueueFactor(ctx, field)
			case "expectedRuntimeFactor":
				return ec.fieldContext_SchedulerConfig_expectedRuntimeFactor(ctx, field)
			case "generateTaskFactor":
				return ec.fieldContext_SchedulerConfig_generateTaskFactor(ctx, field)
			case "numDependentsFactor":
				return ec.fieldContext_SchedulerConfig_numDependentsFactor(ctx, field)
			case "stepbackTaskFactor":
				return ec.fieldContext_SchedulerConfig_stepbackTaskFactor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SchedulerConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_repotracker(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminSettings_repotracker(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepoTracker, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIRepoTrackerConfig)
	fc.Result = res
	return ec.marshalORepotrackerConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIRepoTrackerConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminSettings_repotracker(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "numNewRepoRevisionsToFetch":
				return ec.fieldContext_RepotrackerConfig_numNewRepoRevisionsToFetch(ctx, field)
			case "maxRepoRevisionsToSearch":
				return ec.fieldContext_RepotrackerConfig_maxRepoRevisionsToSearch(ctx, field)
			case "maxConcurrentRequests":
				return ec.fieldContext_RepotrackerConfig_maxConcurrentRequests(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepotrackerConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_api(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminSettings_api(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Api, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIapiConfig)
	fc.Result = res
	return ec.marshalOAPIConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIapiConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminSettings_api(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "httpListenAddr":
				return ec.fieldContext_APIConfig_httpListenAddr(ctx, field)
			case "url":
				return ec.fieldContext_APIConfig_url(ctx, field)
			case "corpUrl":
				return ec.fieldContext_APIConfig_corpUrl(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type APIConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_ui(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminSettings_ui(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ui, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIUIConfig)
	fc.Result = res
	return ec.marshalOUIConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIUIConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminSettings_ui(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "betaFeatures":
				return ec.fieldContext_UIConfig_betaFeatures(ctx, field)
			case "url":
				return ec.fieldContext_UIConfig_url(ctx, field)
			case "helpUrl":
				return ec.fieldContext_UIConfig_helpUrl(ctx, field)
			case "uiv2Url":
				return ec.fieldContext_UIConfig_uiv2Url(ctx, field)
			case "parsleyUrl":
				return ec.fieldContext_UIConfig_parsleyUrl(ctx, field)
			case "httpListenAddr":
				return ec.fieldContext_UIConfig_httpListenAddr(ctx, field)
			case "secret":
				return ec.fieldContext_UIConfig_secret(ctx, field)
			case "defaultProject":
				return ec.fieldContext_UIConfig_defaultProject(ctx, field)
			case "corsOrigins":
				return ec.fieldContext_UIConfig_corsOrigins(ctx, field)
			case "fileStreamingContentTypes":
				return ec.fieldContext_UIConfig_fileStreamingContentTypes(ctx, field)
			case "loginDomain":
				return ec.fieldContext_UIConfig_loginDomain(ctx, field)
			case "userVoice":
				return ec.fieldContext_UIConfig_userVoice(ctx, field)
			case "csrfKey":
				return ec.fieldContext_UIConfig_csrfKey(ctx, field)
			case "cacheTemplates":
				return ec.fieldContext_UIConfig_cacheTemplates(ctx, field)
			case "stagingEnvironment":
				return ec.fieldContext_UIConfig_stagingEnvironment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UIConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_disabledGQLQueries(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminSettings_disabledGQLQueries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisabledGQLQueries, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminSettings_disabledGQLQueries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_loggerConfig(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminSettings_loggerConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LoggerConfig, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APILoggerConfig)
	fc.Result = res
	return ec.marshalOLoggerConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPILoggerConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminSettings_loggerConfig(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "buffer":
				return ec.fieldContext_LoggerConfig_buffer(ctx, field)
			case "defaultLevel":
				return ec.fieldContext_LoggerConfig_defaultLevel(ctx, field)
			case "thresholdLevel":
				return ec.fieldContext_LoggerConfig_thresholdLevel(ctx, field)
			case "logkeeperURL":
				return ec.fieldContext_LoggerConfig_logkeeperURL(ctx, field)
			case "redactKeys":
				return ec.fieldContext_LoggerConfig_redactKeys(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LoggerConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminSettings_triggers(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminSettings_triggers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Triggers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APITriggerConfig)
	fc.Result = res
	return ec.marshalOTriggerConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITriggerConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminSettings_triggers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "generateTaskDistro":
				return ec.fieldContext_TriggerConfig_generateTaskDistro(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TriggerConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AdminTasksToRestartPayload_tasksToRestart(ctx context.Context, field graphql.CollectedField, obj *AdminTasksToRestartPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AdminTasksToRestartPayload_tasksToRestart(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TasksToRestart, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APITask)
	fc.Result = res
	return ec.marshalNTask2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AdminTasksToRestartPayload_tasksToRestart(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AdminTasksToRestartPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyConfig_name(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AmboyConfig_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AmboyConfig_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyConfig_singleName(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AmboyConfig_singleName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SingleName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AmboyConfig_singleName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyConfig_poolSizeLocal(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AmboyConfig_poolSizeLocal(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PoolSizeLocal, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AmboyConfig_poolSizeLocal(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyConfig_poolSizeRemote(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AmboyConfig_poolSizeRemote(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PoolSizeRemote, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AmboyConfig_poolSizeRemote(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyConfig_localStorage(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AmboyConfig_localStorage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LocalStorage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AmboyConfig_localStorage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyConfig_groupDefaultWorkers(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AmboyConfig_groupDefaultWorkers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GroupDefaultWorkers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AmboyConfig_groupDefaultWorkers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyConfig_groupBackgroundCreateFrequencyMinutes(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AmboyConfig_groupBackgroundCreateFrequencyMinutes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GroupBackgroundCreateFrequencyMinutes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AmboyConfig_groupBackgroundCreateFrequencyMinutes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyConfig_groupPruneFrequencyMinutes(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AmboyConfig_groupPruneFrequencyMinutes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GroupPruneFrequencyMinutes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AmboyConfig_groupPruneFrequencyMinutes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyConfig_groupTTLMinutes(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AmboyConfig_groupTTLMinutes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GroupTTLMinutes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AmboyConfig_groupTTLMinutes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyConfig_lockTimeoutMinutes(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AmboyConfig_lockTimeoutMinutes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LockTimeoutMinutes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AmboyConfig_lockTimeoutMinutes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyConfig_sampleSize(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AmboyConfig_sampleSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SampleSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AmboyConfig_sampleSize(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyConfig_retry(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AmboyConfig_retry(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Retry, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.APIAmboyRetryConfig)
	fc.Result = res
	return ec.marshalOAmboyRetryConfig2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAmboyRetryConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AmboyConfig_retry(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "numWorkers":
				return ec.fieldContext_AmboyRetryConfig_numWorkers(ctx, field)
			case "maxCapacity":
				return ec.fieldContext_AmboyRetryConfig_maxCapacity(ctx, field)
			case "maxRetryAttempts":
				return ec.fieldContext_AmboyRetryConfig_maxRetryAttempts(ctx, field)
			case "maxRetryTimeSeconds":
				return ec.fieldContext_AmboyRetryConfig_maxRetryTimeSeconds(ctx, field)
			case "retryBackoffSeconds":
				return ec.fieldContext_AmboyRetryConfig_retryBackoffSeconds(ctx, field)
			case "staleRetryingMonitorIntervalSeconds":
				return ec.fieldContext_AmboyRetryConfig_staleRetryingMonitorIntervalSeconds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AmboyRetryConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyConfig_namedQueues(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AmboyConfig_namedQueues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NamedQueues, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APIAmboyNamedQueueConfig)
	fc.Result = res
	return ec.marshalNAmboyNamedQueueConfig2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAmboyNamedQueueConfigᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AmboyConfig_namedQueues(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_AmboyNamedQueueConfig_name(ctx, field)
			case "regexp":
				return ec.fieldContext_AmboyNamedQueueConfig_regexp(ctx, field)
			case "numWorkers":
				return ec.fieldContext_AmboyNamedQueueConfig_numWorkers(ctx, field)
			case "sampleSize":
				return ec.fieldContext_AmboyNamedQueueConfig_sampleSize(ctx, field)
			case "lockTimeoutSeconds":
				return ec.fieldContext_AmboyNamedQueueConfig_lockTimeoutSeconds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AmboyNamedQueueConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyDBConfig_url(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyDBConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AmboyDBConfig_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.URL, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.RequireAdmin == nil {
				var zeroVal *string
				return zeroVal, errors.New("directive requireAdmin is not implemented")
			}
			return ec.directives.RequireAdmin(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AmboyDBConfig_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyDBConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyDBConfig_database(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyDBConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AmboyDBConfig_database(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Database, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.RequireAdmin == nil {
				var zeroVal *string
				return zeroVal, errors.New("directive requireAdmin is not implemented")
			}
			return ec.directives.RequireAdmin(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AmboyDBConfig_database(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyDBConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyNamedQueueConfig_name(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyNamedQueueConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AmboyNamedQueueConfig_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AmboyNamedQueueConfig_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyNamedQueueConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyNamedQueueConfig_regexp(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyNamedQueueConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AmboyNamedQueueConfig_regexp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Regexp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AmboyNamedQueueConfig_regexp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyNamedQueueConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyNamedQueueConfig_numWorkers(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyNamedQueueConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AmboyNamedQueueConfig_numWorkers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumWorkers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AmboyNamedQueueConfig_numWorkers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyNamedQueueConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyNamedQueueConfig_sampleSize(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyNamedQueueConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AmboyNamedQueueConfig_sampleSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SampleSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AmboyNamedQueueConfig_sampleSize(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyNamedQueueConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyNamedQueueConfig_lockTimeoutSeconds(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyNamedQueueConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AmboyNamedQueueConfig_lockTimeoutSeconds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LockTimeoutSeconds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AmboyNamedQueueConfig_lockTimeoutSeconds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyNamedQueueConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyRetryConfig_numWorkers(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyRetryConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AmboyRetryConfig_numWorkers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumWorkers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AmboyRetryConfig_numWorkers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyRetryConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyRetryConfig_maxCapacity(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyRetryConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AmboyRetryConfig_maxCapacity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxCapacity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AmboyRetryConfig_maxCapacity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyRetryConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyRetryConfig_maxRetryAttempts(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyRetryConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AmboyRetryConfig_maxRetryAttempts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxRetryAttempts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AmboyRetryConfig_maxRetryAttempts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyRetryConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyRetryConfig_maxRetryTimeSeconds(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyRetryConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AmboyRetryConfig_maxRetryTimeSeconds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxRetryTimeSeconds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AmboyRetryConfig_maxRetryTimeSeconds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyRetryConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyRetryConfig_retryBackoffSeconds(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyRetryConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AmboyRetryConfig_retryBackoffSeconds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RetryBackoffSeconds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AmboyRetryConfig_retryBackoffSeconds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyRetryConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AmboyRetryConfig_staleRetryingMonitorIntervalSeconds(ctx context.Context, field graphql.CollectedField, obj *model.APIAmboyRetryConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AmboyRetryConfig_staleRetryingMonitorIntervalSeconds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StaleRetryingMonitorIntervalSeconds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AmboyRetryConfig_staleRetryingMonitorIntervalSeconds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AmboyRetryConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Annotation_id(ctx context.Context, field graphql.CollectedField, obj *model.APITaskAnnotation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Annotation_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Annotation_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Annotation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Annotation_createdIssues(ctx context.Context, field graphql.CollectedField, obj *model.APITaskAnnotation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Annotation_createdIssues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedIssues, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIIssueLink)
	fc.Result = res
	return ec.marshalOIssueLink2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIIssueLinkᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Annotation_createdIssues(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Annotation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "confidenceScore":
				return ec.fieldContext_IssueLink_confidenceScore(ctx, field)
			case "issueKey":
				return ec.fieldContext_IssueLink_issueKey(ctx, field)
			case "jiraTicket":
				return ec.fieldContext_IssueLink_jiraTicket(ctx, field)
			case "source":
				return ec.fieldContext_IssueLink_source(ctx, field)
			case "url":
				return ec.fieldContext_IssueLink_url(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IssueLink", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Annotation_issues(ctx context.Context, field graphql.CollectedField, obj *model.APITaskAnnotation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Annotation_issues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Issues, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIIssueLink)
	fc.Result = res
	return ec.marshalOIssueLink2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIIssueLinkᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Annotation_issues(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Annotation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "confidenceScore":
				return ec.fieldContext_IssueLink_confidenceScore(ctx, field)
			case "issueKey":
				return ec.fieldContext_IssueLink_issueKey(ctx, field)
			case "jiraTicket":
				return ec.fieldContext_IssueLink_jiraTicket(ctx, field)
			case "source":
				return ec.fieldContext_IssueLink_source(ctx, field)
			case "url":
				return ec.fieldContext_IssueLink_url(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IssueLink", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Annotation_note(ctx context.Context, field graphql.CollectedField, obj *model.APITaskAnnotation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Annotation_note(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Note, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APINote)
	fc.Result = res
	return ec.marshalONote2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPINote(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Annotation_note(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Annotation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "message":
				return ec.fieldContext_Note_message(ctx, field)
			case "source":
				return ec.fieldContext_Note_source(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Note", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Annotation_suspectedIssues(ctx context.Context, field graphql.CollectedField, obj *model.APITaskAnnotation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Annotation_suspectedIssues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SuspectedIssues, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIIssueLink)
	fc.Result = res
	return ec.marshalOIssueLink2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIIssueLinkᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Annotation_suspectedIssues(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Annotation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "confidenceScore":
				return ec.fieldContext_IssueLink_confidenceScore(ctx, field)
			case "issueKey":
				return ec.fieldContext_IssueLink_issueKey(ctx, field)
			case "jiraTicket":
				return ec.fieldContext_IssueLink_jiraTicket(ctx, field)
			case "source":
				return ec.fieldContext_IssueLink_source(ctx, field)
			case "url":
				return ec.fieldContext_IssueLink_url(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IssueLink", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Annotation_metadataLinks(ctx context.Context, field graphql.CollectedField, obj *model.APITaskAnnotation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Annotation_metadataLinks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MetadataLinks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIMetadataLink)
	fc.Result = res
	return ec.marshalOMetadataLink2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIMetadataLinkᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Annotation_metadataLinks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Annotation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "url":
				return ec.fieldContext_MetadataLink_url(ctx, field)
			case "text":
				return ec.fieldContext_MetadataLink_text(ctx, field)
			case "source":
				return ec.fieldContext_MetadataLink_source(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MetadataLink", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Annotation_taskId(ctx context.Context, field graphql.CollectedField, obj *model.APITaskAnnotation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Annotation_taskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Annotation_taskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Annotation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Annotation_taskExecution(ctx context.Context, field graphql.CollectedField, obj *model.APITaskAnnotation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Annotation_taskExecution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskExecution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalNInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Annotation_taskExecution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Annotation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Annotation_webhookConfigured(ctx context.Context, field graphql.CollectedField, obj *model.APITaskAnnotation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Annotation_webhookConfigured(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Annotation().WebhookConfigured(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Annotation_webhookConfigured(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Annotation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthConfig_okta(ctx context.Context, field graphql.CollectedField, obj *model.APIAuthConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthConfig_okta(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Okta, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.RequireAdmin == nil {
				var zeroVal *model.APIOktaConfig
				return zeroVal, errors.New("directive requireAdmin is not implemented")
			}
			return ec.directives.RequireAdmin(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.APIOktaConfig); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/evergreen-ci/evergreen/rest/model.APIOktaConfig`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIOktaConfig)
	fc.Result = res
	return ec.marshalOOktaConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIOktaConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthConfig_okta(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "clientId":
				return ec.fieldContext_OktaConfig_clientId(ctx, field)
			case "clientSecret":
				return ec.fieldContext_OktaConfig_clientSecret(ctx, field)
			case "issuer":
				return ec.fieldContext_OktaConfig_issuer(ctx, field)
			case "scopes":
				return ec.fieldContext_OktaConfig_scopes(ctx, field)
			case "userGroup":
				return ec.fieldContext_OktaConfig_userGroup(ctx, field)
			case "expireAfterMinutes":
				return ec.fieldContext_OktaConfig_expireAfterMinutes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OktaConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthConfig_naive(ctx context.Context, field graphql.CollectedField, obj *model.APIAuthConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthConfig_naive(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Naive, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.RequireAdmin == nil {
				var zeroVal *model.APINaiveAuthConfig
				return zeroVal, errors.New("directive requireAdmin is not implemented")
			}
			return ec.directives.RequireAdmin(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.APINaiveAuthConfig); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/evergreen-ci/evergreen/rest/model.APINaiveAuthConfig`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APINaiveAuthConfig)
	fc.Result = res
	return ec.marshalONaiveAuthConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPINaiveAuthConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthConfig_naive(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "users":
				return ec.fieldContext_NaiveAuthConfig_users(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NaiveAuthConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthConfig_github(ctx context.Context, field graphql.CollectedField, obj *model.APIAuthConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthConfig_github(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Github, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.RequireAdmin == nil {
				var zeroVal *model.APIGithubAuthConfig
				return zeroVal, errors.New("directive requireAdmin is not implemented")
			}
			return ec.directives.RequireAdmin(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.APIGithubAuthConfig); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/evergreen-ci/evergreen/rest/model.APIGithubAuthConfig`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIGithubAuthConfig)
	fc.Result = res
	return ec.marshalOGitHubAuthConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGithubAuthConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthConfig_github(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "appId":
				return ec.fieldContext_GitHubAuthConfig_appId(ctx, field)
			case "clientId":
				return ec.fieldContext_GitHubAuthConfig_clientId(ctx, field)
			case "clientSecret":
				return ec.fieldContext_GitHubAuthConfig_clientSecret(ctx, field)
			case "defaultOwner":
				return ec.fieldContext_GitHubAuthConfig_defaultOwner(ctx, field)
			case "defaultRepo":
				return ec.fieldContext_GitHubAuthConfig_defaultRepo(ctx, field)
			case "organization":
				return ec.fieldContext_GitHubAuthConfig_organization(ctx, field)
			case "users":
				return ec.fieldContext_GitHubAuthConfig_users(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GitHubAuthConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthConfig_multi(ctx context.Context, field graphql.CollectedField, obj *model.APIAuthConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthConfig_multi(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Multi, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.RequireAdmin == nil {
				var zeroVal *model.APIMultiAuthConfig
				return zeroVal, errors.New("directive requireAdmin is not implemented")
			}
			return ec.directives.RequireAdmin(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.APIMultiAuthConfig); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/evergreen-ci/evergreen/rest/model.APIMultiAuthConfig`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIMultiAuthConfig)
	fc.Result = res
	return ec.marshalOMultiAuthConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIMultiAuthConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthConfig_multi(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "readWrite":
				return ec.fieldContext_MultiAuthConfig_readWrite(ctx, field)
			case "readOnly":
				return ec.fieldContext_MultiAuthConfig_readOnly(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MultiAuthConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthConfig_kanopy(ctx context.Context, field graphql.CollectedField, obj *model.APIAuthConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthConfig_kanopy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Kanopy, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.RequireAdmin == nil {
				var zeroVal *model.APIKanopyAuthConfig
				return zeroVal, errors.New("directive requireAdmin is not implemented")
			}
			return ec.directives.RequireAdmin(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.APIKanopyAuthConfig); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/evergreen-ci/evergreen/rest/model.APIKanopyAuthConfig`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIKanopyAuthConfig)
	fc.Result = res
	return ec.marshalOKanopyAuthConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIKanopyAuthConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthConfig_kanopy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "headerName":
				return ec.fieldContext_KanopyAuthConfig_headerName(ctx, field)
			case "issuer":
				return ec.fieldContext_KanopyAuthConfig_issuer(ctx, field)
			case "keysetURL":
				return ec.fieldContext_KanopyAuthConfig_keysetURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type KanopyAuthConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthConfig_preferredType(ctx context.Context, field graphql.CollectedField, obj *model.APIAuthConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthConfig_preferredType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.PreferredType, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.RequireAdmin == nil {
				var zeroVal *string
				return zeroVal, errors.New("directive requireAdmin is not implemented")
			}
			return ec.directives.RequireAdmin(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOPreferredAuthType2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthConfig_preferredType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PreferredAuthType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthConfig_backgroundReauthMinutes(ctx context.Context, field graphql.CollectedField, obj *model.APIAuthConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthConfig_backgroundReauthMinutes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BackgroundReauthMinutes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthConfig_backgroundReauthMinutes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthConfig_allowServiceUsers(ctx context.Context, field graphql.CollectedField, obj *model.APIAuthConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthConfig_allowServiceUsers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AllowServiceUsers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthConfig_allowServiceUsers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthUser_username(ctx context.Context, field graphql.CollectedField, obj *model.APIAuthUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthUser_username(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Username, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthUser_username(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthUser_displayName(ctx context.Context, field graphql.CollectedField, obj *model.APIAuthUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthUser_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthUser_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthUser_password(ctx context.Context, field graphql.CollectedField, obj *model.APIAuthUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthUser_password(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Password, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthUser_password(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AuthUser_email(ctx context.Context, field graphql.CollectedField, obj *model.APIAuthUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AuthUser_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AuthUser_email(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AuthUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BetaFeatures_spruceWaterfallEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIBetaFeatures) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BetaFeatures_spruceWaterfallEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpruceWaterfallEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BetaFeatures_spruceWaterfallEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BetaFeatures",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_clientDir(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BootstrapSettings_clientDir(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientDir, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BootstrapSettings_clientDir(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_communication(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BootstrapSettings_communication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Communication, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNCommunicationMethod2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BootstrapSettings_communication(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CommunicationMethod does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_env(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BootstrapSettings_env(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Env, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APIEnvVar)
	fc.Result = res
	return ec.marshalNEnvVar2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIEnvVarᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BootstrapSettings_env(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_EnvVar_key(ctx, field)
			case "value":
				return ec.fieldContext_EnvVar_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EnvVar", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_jasperBinaryDir(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BootstrapSettings_jasperBinaryDir(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JasperBinaryDir, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BootstrapSettings_jasperBinaryDir(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_jasperCredentialsPath(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BootstrapSettings_jasperCredentialsPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JasperCredentialsPath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BootstrapSettings_jasperCredentialsPath(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_method(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BootstrapSettings_method(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Method, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNBootstrapMethod2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BootstrapSettings_method(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BootstrapMethod does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_preconditionScripts(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BootstrapSettings_preconditionScripts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreconditionScripts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APIPreconditionScript)
	fc.Result = res
	return ec.marshalNPreconditionScript2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPreconditionScriptᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BootstrapSettings_preconditionScripts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "path":
				return ec.fieldContext_PreconditionScript_path(ctx, field)
			case "script":
				return ec.fieldContext_PreconditionScript_script(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PreconditionScript", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_resourceLimits(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BootstrapSettings_resourceLimits(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceLimits, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIResourceLimits)
	fc.Result = res
	return ec.marshalNResourceLimits2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIResourceLimits(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BootstrapSettings_resourceLimits(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lockedMemoryKb":
				return ec.fieldContext_ResourceLimits_lockedMemoryKb(ctx, field)
			case "numFiles":
				return ec.fieldContext_ResourceLimits_numFiles(ctx, field)
			case "numProcesses":
				return ec.fieldContext_ResourceLimits_numProcesses(ctx, field)
			case "numTasks":
				return ec.fieldContext_ResourceLimits_numTasks(ctx, field)
			case "virtualMemoryKb":
				return ec.fieldContext_ResourceLimits_virtualMemoryKb(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceLimits", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_rootDir(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BootstrapSettings_rootDir(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RootDir, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BootstrapSettings_rootDir(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_serviceUser(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BootstrapSettings_serviceUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceUser, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BootstrapSettings_serviceUser(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_shellPath(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BootstrapSettings_shellPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShellPath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BootstrapSettings_shellPath(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_id(ctx context.Context, field graphql.CollectedField, obj *model.APIBuild) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_actualMakespan(ctx context.Context, field graphql.CollectedField, obj *model.APIBuild) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_actualMakespan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ActualMakespan, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIDuration)
	fc.Result = res
	return ec.marshalNDuration2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_actualMakespan(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_buildVariant(ctx context.Context, field graphql.CollectedField, obj *model.APIBuild) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_buildVariant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildVariant, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_buildVariant(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_predictedMakespan(ctx context.Context, field graphql.CollectedField, obj *model.APIBuild) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_predictedMakespan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PredictedMakespan, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIDuration)
	fc.Result = res
	return ec.marshalNDuration2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_predictedMakespan(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_status(ctx context.Context, field graphql.CollectedField, obj *model.APIBuild) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaron_bbTicketCreationDefined(ctx context.Context, field graphql.CollectedField, obj *BuildBaron) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildBaron_bbTicketCreationDefined(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BbTicketCreationDefined, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildBaron_bbTicketCreationDefined(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaron",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaron_buildBaronConfigured(ctx context.Context, field graphql.CollectedField, obj *BuildBaron) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildBaron_buildBaronConfigured(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildBaronConfigured, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildBaron_buildBaronConfigured(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaron",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaron_searchReturnInfo(ctx context.Context, field graphql.CollectedField, obj *BuildBaron) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildBaron_searchReturnInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SearchReturnInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*thirdparty.SearchReturnInfo)
	fc.Result = res
	return ec.marshalOSearchReturnInfo2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐSearchReturnInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildBaron_searchReturnInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaron",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "featuresURL":
				return ec.fieldContext_SearchReturnInfo_featuresURL(ctx, field)
			case "issues":
				return ec.fieldContext_SearchReturnInfo_issues(ctx, field)
			case "search":
				return ec.fieldContext_SearchReturnInfo_search(ctx, field)
			case "source":
				return ec.fieldContext_SearchReturnInfo_source(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SearchReturnInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaronSettings_bfSuggestionFeaturesURL(ctx context.Context, field graphql.CollectedField, obj *model.APIBuildBaronSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildBaronSettings_bfSuggestionFeaturesURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BFSuggestionFeaturesURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildBaronSettings_bfSuggestionFeaturesURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaronSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaronSettings_bfSuggestionPassword(ctx context.Context, field graphql.CollectedField, obj *model.APIBuildBaronSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildBaronSettings_bfSuggestionPassword(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BFSuggestionPassword, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildBaronSettings_bfSuggestionPassword(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaronSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaronSettings_bfSuggestionServer(ctx context.Context, field graphql.CollectedField, obj *model.APIBuildBaronSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildBaronSettings_bfSuggestionServer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BFSuggestionServer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildBaronSettings_bfSuggestionServer(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaronSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaronSettings_bfSuggestionTimeoutSecs(ctx context.Context, field graphql.CollectedField, obj *model.APIBuildBaronSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildBaronSettings_bfSuggestionTimeoutSecs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BFSuggestionTimeoutSecs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildBaronSettings_bfSuggestionTimeoutSecs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaronSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaronSettings_bfSuggestionUsername(ctx context.Context, field graphql.CollectedField, obj *model.APIBuildBaronSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildBaronSettings_bfSuggestionUsername(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BFSuggestionUsername, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildBaronSettings_bfSuggestionUsername(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaronSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaronSettings_ticketCreateProject(ctx context.Context, field graphql.CollectedField, obj *model.APIBuildBaronSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildBaronSettings_ticketCreateProject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TicketCreateProject, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildBaronSettings_ticketCreateProject(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaronSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaronSettings_ticketSearchProjects(ctx context.Context, field graphql.CollectedField, obj *model.APIBuildBaronSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildBaronSettings_ticketSearchProjects(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TicketSearchProjects, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2ᚕᚖstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildBaronSettings_ticketSearchProjects(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaronSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaronSettings_ticketCreateIssueType(ctx context.Context, field graphql.CollectedField, obj *model.APIBuildBaronSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildBaronSettings_ticketCreateIssueType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TicketCreateIssueType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildBaronSettings_ticketCreateIssueType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaronSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildVariantTuple_buildVariant(ctx context.Context, field graphql.CollectedField, obj *task.BuildVariantTuple) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildVariantTuple_buildVariant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildVariant, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildVariantTuple_buildVariant(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildVariantTuple",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildVariantTuple_displayName(ctx context.Context, field graphql.CollectedField, obj *task.BuildVariantTuple) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildVariantTuple_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildVariantTuple_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildVariantTuple",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CedarConfig_dbUrl(ctx context.Context, field graphql.CollectedField, obj *model.APICedarConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CedarConfig_dbUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.DBURL, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.RequireAdmin == nil {
				var zeroVal *string
				return zeroVal, errors.New("directive requireAdmin is not implemented")
			}
			return ec.directives.RequireAdmin(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CedarConfig_dbUrl(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CedarConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CedarConfig_dbName(ctx context.Context, field graphql.CollectedField, obj *model.APICedarConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CedarConfig_dbName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DBName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CedarConfig_dbName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CedarConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChildPatchAlias_alias(ctx context.Context, field graphql.CollectedField, obj *model.APIChildPatchAlias) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChildPatchAlias_alias(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Alias, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChildPatchAlias_alias(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChildPatchAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChildPatchAlias_patchId(ctx context.Context, field graphql.CollectedField, obj *model.APIChildPatchAlias) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChildPatchAlias_patchId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PatchID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChildPatchAlias_patchId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChildPatchAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ClientBinary_arch(ctx context.Context, field graphql.CollectedField, obj *model.APIClientBinary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ClientBinary_arch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Arch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ClientBinary_arch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ClientBinary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ClientBinary_displayName(ctx context.Context, field graphql.CollectedField, obj *model.APIClientBinary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ClientBinary_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ClientBinary_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ClientBinary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ClientBinary_os(ctx context.Context, field graphql.CollectedField, obj *model.APIClientBinary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ClientBinary_os(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OS, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ClientBinary_os(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ClientBinary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ClientBinary_url(ctx context.Context, field graphql.CollectedField, obj *model.APIClientBinary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ClientBinary_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ClientBinary_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ClientBinary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ClientConfig_clientBinaries(ctx context.Context, field graphql.CollectedField, obj *model.APIClientConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ClientConfig_clientBinaries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientBinaries, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIClientBinary)
	fc.Result = res
	return ec.marshalOClientBinary2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIClientBinaryᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ClientConfig_clientBinaries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ClientConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "arch":
				return ec.fieldContext_ClientBinary_arch(ctx, field)
			case "displayName":
				return ec.fieldContext_ClientBinary_displayName(ctx, field)
			case "os":
				return ec.fieldContext_ClientBinary_os(ctx, field)
			case "url":
				return ec.fieldContext_ClientBinary_url(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ClientBinary", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ClientConfig_latestRevision(ctx context.Context, field graphql.CollectedField, obj *model.APIClientConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ClientConfig_latestRevision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LatestRevision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ClientConfig_latestRevision(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ClientConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CloudProviderConfig_aws(ctx context.Context, field graphql.CollectedField, obj *model.APICloudProviders) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CloudProviderConfig_aws(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AWS, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIAWSConfig)
	fc.Result = res
	return ec.marshalOAWSConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAWSConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CloudProviderConfig_aws(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CloudProviderConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "maxVolumeSizePerUser":
				return ec.fieldContext_AWSConfig_maxVolumeSizePerUser(ctx, field)
			case "pod":
				return ec.fieldContext_AWSConfig_pod(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AWSConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CommitQueueParams_enabled(ctx context.Context, field graphql.CollectedField, obj *model.APICommitQueueParams) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CommitQueueParams_enabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CommitQueueParams_enabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CommitQueueParams",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CommitQueueParams_mergeMethod(ctx context.Context, field graphql.CollectedField, obj *model.APICommitQueueParams) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CommitQueueParams_mergeMethod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MergeMethod, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CommitQueueParams_mergeMethod(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CommitQueueParams",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CommitQueueParams_message(ctx context.Context, field graphql.CollectedField, obj *model.APICommitQueueParams) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CommitQueueParams_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CommitQueueParams_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CommitQueueParams",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerPool_id(ctx context.Context, field graphql.CollectedField, obj *model.APIContainerPool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerPool_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerPool_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerPool",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerPool_distro(ctx context.Context, field graphql.CollectedField, obj *model.APIContainerPool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerPool_distro(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distro, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerPool_distro(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerPool",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerPool_maxContainers(ctx context.Context, field graphql.CollectedField, obj *model.APIContainerPool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerPool_maxContainers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxContainers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerPool_maxContainers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerPool",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerPool_port(ctx context.Context, field graphql.CollectedField, obj *model.APIContainerPool) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerPool_port(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ContainerPool().Port(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerPool_port(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerPool",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerPoolsConfig_pools(ctx context.Context, field graphql.CollectedField, obj *model.APIContainerPoolsConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerPoolsConfig_pools(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pools, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APIContainerPool)
	fc.Result = res
	return ec.marshalNContainerPool2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIContainerPoolᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerPoolsConfig_pools(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerPoolsConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ContainerPool_id(ctx, field)
			case "distro":
				return ec.fieldContext_ContainerPool_distro(ctx, field)
			case "maxContainers":
				return ec.fieldContext_ContainerPool_maxContainers(ctx, field)
			case "port":
				return ec.fieldContext_ContainerPool_port(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContainerPool", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerResources_name(ctx context.Context, field graphql.CollectedField, obj *model.APIContainerResources) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerResources_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerResources_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerResources",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerResources_cpu(ctx context.Context, field graphql.CollectedField, obj *model.APIContainerResources) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerResources_cpu(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CPU, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalNInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerResources_cpu(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerResources",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerResources_memoryMb(ctx context.Context, field graphql.CollectedField, obj *model.APIContainerResources) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerResources_memoryMb(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MemoryMB, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalNInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerResources_memoryMb(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerResources",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteDistroPayload_deletedDistroId(ctx context.Context, field graphql.CollectedField, obj *DeleteDistroPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteDistroPayload_deletedDistroId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedDistroID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteDistroPayload_deletedDistroId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteDistroPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteGithubAppCredentialsPayload_oldAppId(ctx context.Context, field graphql.CollectedField, obj *DeleteGithubAppCredentialsPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteGithubAppCredentialsPayload_oldAppId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OldAppID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteGithubAppCredentialsPayload_oldAppId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteGithubAppCredentialsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dependency_buildVariant(ctx context.Context, field graphql.CollectedField, obj *Dependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dependency_buildVariant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildVariant, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dependency_buildVariant(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dependency_metStatus(ctx context.Context, field graphql.CollectedField, obj *Dependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dependency_metStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MetStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(MetStatus)
	fc.Result = res
	return ec.marshalNMetStatus2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐMetStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dependency_metStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MetStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dependency_name(ctx context.Context, field graphql.CollectedField, obj *Dependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dependency_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dependency_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dependency_requiredStatus(ctx context.Context, field graphql.CollectedField, obj *Dependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dependency_requiredStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequiredStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(RequiredStatus)
	fc.Result = res
	return ec.marshalNRequiredStatus2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐRequiredStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dependency_requiredStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RequiredStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dependency_taskId(ctx context.Context, field graphql.CollectedField, obj *Dependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dependency_taskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dependency_taskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DispatcherSettings_version(ctx context.Context, field graphql.CollectedField, obj *model.APIDispatcherSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DispatcherSettings_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNDispatcherVersion2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DispatcherSettings_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DispatcherSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DispatcherVersion does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_adminOnly(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_adminOnly(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdminOnly, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_adminOnly(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_aliases(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_aliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Aliases, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_aliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_arch(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_arch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Arch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNArch2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_arch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Arch does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_authorizedKeysFile(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_authorizedKeysFile(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthorizedKeysFile, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_authorizedKeysFile(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_availableRegions(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_availableRegions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Distro().AvailableRegions(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_availableRegions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_bootstrapSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_bootstrapSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BootstrapSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIBootstrapSettings)
	fc.Result = res
	return ec.marshalNBootstrapSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIBootstrapSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_bootstrapSettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "clientDir":
				return ec.fieldContext_BootstrapSettings_clientDir(ctx, field)
			case "communication":
				return ec.fieldContext_BootstrapSettings_communication(ctx, field)
			case "env":
				return ec.fieldContext_BootstrapSettings_env(ctx, field)
			case "jasperBinaryDir":
				return ec.fieldContext_BootstrapSettings_jasperBinaryDir(ctx, field)
			case "jasperCredentialsPath":
				return ec.fieldContext_BootstrapSettings_jasperCredentialsPath(ctx, field)
			case "method":
				return ec.fieldContext_BootstrapSettings_method(ctx, field)
			case "preconditionScripts":
				return ec.fieldContext_BootstrapSettings_preconditionScripts(ctx, field)
			case "resourceLimits":
				return ec.fieldContext_BootstrapSettings_resourceLimits(ctx, field)
			case "rootDir":
				return ec.fieldContext_BootstrapSettings_rootDir(ctx, field)
			case "serviceUser":
				return ec.fieldContext_BootstrapSettings_serviceUser(ctx, field)
			case "shellPath":
				return ec.fieldContext_BootstrapSettings_shellPath(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BootstrapSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_containerPool(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_containerPool(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContainerPool, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_containerPool(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_disabled(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_disabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Disabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_disabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_disableShallowClone(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_disableShallowClone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisableShallowClone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_disableShallowClone(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_dispatcherSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_dispatcherSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DispatcherSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIDispatcherSettings)
	fc.Result = res
	return ec.marshalNDispatcherSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDispatcherSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_dispatcherSettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "version":
				return ec.fieldContext_DispatcherSettings_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DispatcherSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_execUser(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_execUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExecUser, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_execUser(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_expansions(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_expansions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Expansions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APIExpansion)
	fc.Result = res
	return ec.marshalNExpansion2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIExpansionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_expansions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_Expansion_key(ctx, field)
			case "value":
				return ec.fieldContext_Expansion_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Expansion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_finderSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_finderSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FinderSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIFinderSettings)
	fc.Result = res
	return ec.marshalNFinderSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIFinderSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_finderSettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "version":
				return ec.fieldContext_FinderSettings_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FinderSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_homeVolumeSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_homeVolumeSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HomeVolumeSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIHomeVolumeSettings)
	fc.Result = res
	return ec.marshalNHomeVolumeSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHomeVolumeSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_homeVolumeSettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "formatCommand":
				return ec.fieldContext_HomeVolumeSettings_formatCommand(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HomeVolumeSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_hostAllocatorSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_hostAllocatorSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostAllocatorSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIHostAllocatorSettings)
	fc.Result = res
	return ec.marshalNHostAllocatorSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHostAllocatorSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_hostAllocatorSettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "acceptableHostIdleTime":
				return ec.fieldContext_HostAllocatorSettings_acceptableHostIdleTime(ctx, field)
			case "autoTuneMaximumHosts":
				return ec.fieldContext_HostAllocatorSettings_autoTuneMaximumHosts(ctx, field)
			case "feedbackRule":
				return ec.fieldContext_HostAllocatorSettings_feedbackRule(ctx, field)
			case "futureHostFraction":
				return ec.fieldContext_HostAllocatorSettings_futureHostFraction(ctx, field)
			case "hostsOverallocatedRule":
				return ec.fieldContext_HostAllocatorSettings_hostsOverallocatedRule(ctx, field)
			case "maximumHosts":
				return ec.fieldContext_HostAllocatorSettings_maximumHosts(ctx, field)
			case "minimumHosts":
				return ec.fieldContext_HostAllocatorSettings_minimumHosts(ctx, field)
			case "roundingRule":
				return ec.fieldContext_HostAllocatorSettings_roundingRule(ctx, field)
			case "version":
				return ec.fieldContext_HostAllocatorSettings_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HostAllocatorSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_iceCreamSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_iceCreamSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IcecreamSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIIceCreamSettings)
	fc.Result = res
	return ec.marshalNIceCreamSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIIceCreamSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_iceCreamSettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "configPath":
				return ec.fieldContext_IceCreamSettings_configPath(ctx, field)
			case "schedulerHost":
				return ec.fieldContext_IceCreamSettings_schedulerHost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IceCreamSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_imageId(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_imageId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ImageID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_imageId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_isCluster(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_isCluster(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsCluster, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_isCluster(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_isVirtualWorkStation(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_isVirtualWorkStation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsVirtualWorkstation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_isVirtualWorkStation(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_mountpoints(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_mountpoints(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Mountpoints, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_mountpoints(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_name(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_note(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_note(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Note, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_note(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_plannerSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_plannerSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PlannerSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIPlannerSettings)
	fc.Result = res
	return ec.marshalNPlannerSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPlannerSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_plannerSettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "commitQueueFactor":
				return ec.fieldContext_PlannerSettings_commitQueueFactor(ctx, field)
			case "expectedRuntimeFactor":
				return ec.fieldContext_PlannerSettings_expectedRuntimeFactor(ctx, field)
			case "generateTaskFactor":
				return ec.fieldContext_PlannerSettings_generateTaskFactor(ctx, field)
			case "numDependentsFactor":
				return ec.fieldContext_PlannerSettings_numDependentsFactor(ctx, field)
			case "groupVersions":
				return ec.fieldContext_PlannerSettings_groupVersions(ctx, field)
			case "mainlineTimeInQueueFactor":
				return ec.fieldContext_PlannerSettings_mainlineTimeInQueueFactor(ctx, field)
			case "patchFactor":
				return ec.fieldContext_PlannerSettings_patchFactor(ctx, field)
			case "patchTimeInQueueFactor":
				return ec.fieldContext_PlannerSettings_patchTimeInQueueFactor(ctx, field)
			case "targetTime":
				return ec.fieldContext_PlannerSettings_targetTime(ctx, field)
			case "version":
				return ec.fieldContext_PlannerSettings_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlannerSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_provider(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_provider(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Provider, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNProvider2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_provider(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Provider does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_providerAccount(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_providerAccount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProviderAccount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_providerAccount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_providerSettingsList(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_providerSettingsList(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Distro().ProviderSettingsList(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]map[string]any)
	fc.Result = res
	return ec.marshalNMap2ᚕmapᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_providerSettingsList(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_setup(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_setup(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Setup, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_setup(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_setupAsSudo(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_setupAsSudo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SetupAsSudo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_setupAsSudo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_singleTaskDistro(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_singleTaskDistro(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SingleTaskDistro, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_singleTaskDistro(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_sshOptions(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_sshOptions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SSHOptions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_sshOptions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_user(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_userSpawnAllowed(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_userSpawnAllowed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserSpawnAllowed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_userSpawnAllowed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_validProjects(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_validProjects(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ValidProjects, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalNString2ᚕᚖstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_validProjects(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_warningNote(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_warningNote(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WarningNote, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_warningNote(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_workDir(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_workDir(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkDir, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_workDir(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroEvent_after(ctx context.Context, field graphql.CollectedField, obj *DistroEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroEvent_after(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.After, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]any)
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroEvent_after(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroEvent_before(ctx context.Context, field graphql.CollectedField, obj *DistroEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroEvent_before(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Before, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]any)
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroEvent_before(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroEvent_data(ctx context.Context, field graphql.CollectedField, obj *DistroEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroEvent_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]any)
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroEvent_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroEvent_timestamp(ctx context.Context, field graphql.CollectedField, obj *DistroEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroEvent_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroEvent_timestamp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroEvent_user(ctx context.Context, field graphql.CollectedField, obj *DistroEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroEvent_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroEvent_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroEventsPayload_count(ctx context.Context, field graphql.CollectedField, obj *DistroEventsPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroEventsPayload_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroEventsPayload_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroEventsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroEventsPayload_eventLogEntries(ctx context.Context, field graphql.CollectedField, obj *DistroEventsPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroEventsPayload_eventLogEntries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventLogEntries, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*DistroEvent)
	fc.Result = res
	return ec.marshalNDistroEvent2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroEventᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroEventsPayload_eventLogEntries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroEventsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "after":
				return ec.fieldContext_DistroEvent_after(ctx, field)
			case "before":
				return ec.fieldContext_DistroEvent_before(ctx, field)
			case "data":
				return ec.fieldContext_DistroEvent_data(ctx, field)
			case "timestamp":
				return ec.fieldContext_DistroEvent_timestamp(ctx, field)
			case "user":
				return ec.fieldContext_DistroEvent_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DistroEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroInfo_id(ctx context.Context, field graphql.CollectedField, obj *model.DistroInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroInfo_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroInfo_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroInfo_bootstrapMethod(ctx context.Context, field graphql.CollectedField, obj *model.DistroInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroInfo_bootstrapMethod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BootstrapMethod, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroInfo_bootstrapMethod(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroInfo_isVirtualWorkStation(ctx context.Context, field graphql.CollectedField, obj *model.DistroInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroInfo_isVirtualWorkStation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsVirtualWorkstation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroInfo_isVirtualWorkStation(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroInfo_isWindows(ctx context.Context, field graphql.CollectedField, obj *model.DistroInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroInfo_isWindows(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsWindows, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroInfo_isWindows(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroInfo_user(ctx context.Context, field graphql.CollectedField, obj *model.DistroInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroInfo_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroInfo_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroInfo_workDir(ctx context.Context, field graphql.CollectedField, obj *model.DistroInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroInfo_workDir(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkDir, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroInfo_workDir(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroPermissions_admin(ctx context.Context, field graphql.CollectedField, obj *DistroPermissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroPermissions_admin(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Admin, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroPermissions_admin(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroPermissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroPermissions_edit(ctx context.Context, field graphql.CollectedField, obj *DistroPermissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroPermissions_edit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroPermissions_edit(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroPermissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroPermissions_view(ctx context.Context, field graphql.CollectedField, obj *DistroPermissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroPermissions_view(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.View, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroPermissions_view(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroPermissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ECSConfig_maxCPU(ctx context.Context, field graphql.CollectedField, obj *model.APIECSConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ECSConfig_maxCPU(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxCPU, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalNInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ECSConfig_maxCPU(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ECSConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ECSConfig_maxMemoryMb(ctx context.Context, field graphql.CollectedField, obj *model.APIECSConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ECSConfig_maxMemoryMb(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxMemoryMB, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalNInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ECSConfig_maxMemoryMb(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ECSConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EnvVar_key(ctx context.Context, field graphql.CollectedField, obj *model.APIEnvVar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EnvVar_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EnvVar_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EnvVar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EnvVar_value(ctx context.Context, field graphql.CollectedField, obj *model.APIEnvVar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EnvVar_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EnvVar_value(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EnvVar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Expansion_key(ctx context.Context, field graphql.CollectedField, obj *model.APIExpansion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Expansion_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Expansion_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Expansion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Expansion_value(ctx context.Context, field graphql.CollectedField, obj *model.APIExpansion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Expansion_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Expansion_value(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Expansion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExternalLink_displayName(ctx context.Context, field graphql.CollectedField, obj *model.APIExternalLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ExternalLink_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ExternalLink_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExternalLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExternalLink_requesters(ctx context.Context, field graphql.CollectedField, obj *model.APIExternalLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ExternalLink_requesters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Requesters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalNString2ᚕᚖstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ExternalLink_requesters(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExternalLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExternalLink_urlTemplate(ctx context.Context, field graphql.CollectedField, obj *model.APIExternalLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ExternalLink_urlTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URLTemplate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ExternalLink_urlTemplate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExternalLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExternalLinkForMetadata_url(ctx context.Context, field graphql.CollectedField, obj *ExternalLinkForMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ExternalLinkForMetadata_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ExternalLinkForMetadata_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExternalLinkForMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExternalLinkForMetadata_displayName(ctx context.Context, field graphql.CollectedField, obj *ExternalLinkForMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ExternalLinkForMetadata_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ExternalLinkForMetadata_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExternalLinkForMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FWSConfig_url(ctx context.Context, field graphql.CollectedField, obj *model.APIFWSConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FWSConfig_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FWSConfig_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FWSConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FailingCommand_fullDisplayName(ctx context.Context, field graphql.CollectedField, obj *model.APIFailingCommand) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FailingCommand_fullDisplayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FullDisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FailingCommand_fullDisplayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FailingCommand",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FailingCommand_failureMetadataTags(ctx context.Context, field graphql.CollectedField, obj *model.APIFailingCommand) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FailingCommand_failureMetadataTags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FailureMetadataTags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FailingCommand_failureMetadataTags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FailingCommand",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _File_link(ctx context.Context, field graphql.CollectedField, obj *model.APIFile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_File_link(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Link, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_File_link(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "File",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _File_name(ctx context.Context, field graphql.CollectedField, obj *model.APIFile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_File_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_File_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "File",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _File_urlParsley(ctx context.Context, field graphql.CollectedField, obj *model.APIFile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_File_urlParsley(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URLParsley, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_File_urlParsley(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "File",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _File_visibility(ctx context.Context, field graphql.CollectedField, obj *model.APIFile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_File_visibility(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Visibility, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_File_visibility(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "File",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDiff_additions(ctx context.Context, field graphql.CollectedField, obj *model.FileDiff) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDiff_additions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Additions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDiff_additions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDiff",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDiff_deletions(ctx context.Context, field graphql.CollectedField, obj *model.FileDiff) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDiff_deletions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Deletions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDiff_deletions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDiff",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDiff_description(ctx context.Context, field graphql.CollectedField, obj *model.FileDiff) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDiff_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDiff_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDiff",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDiff_diffLink(ctx context.Context, field graphql.CollectedField, obj *model.FileDiff) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDiff_diffLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DiffLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDiff_diffLink(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDiff",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDiff_fileName(ctx context.Context, field graphql.CollectedField, obj *model.FileDiff) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDiff_fileName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDiff_fileName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDiff",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FinderSettings_version(ctx context.Context, field graphql.CollectedField, obj *model.APIFinderSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FinderSettings_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNFinderVersion2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FinderSettings_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FinderSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FinderVersion does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneralSubscription_id(ctx context.Context, field graphql.CollectedField, obj *model.APISubscription) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GeneralSubscription_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GeneralSubscription_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneralSubscription",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneralSubscription_ownerType(ctx context.Context, field graphql.CollectedField, obj *model.APISubscription) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GeneralSubscription_ownerType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OwnerType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GeneralSubscription_ownerType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneralSubscription",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneralSubscription_regexSelectors(ctx context.Context, field graphql.CollectedField, obj *model.APISubscription) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GeneralSubscription_regexSelectors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RegexSelectors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APISelector)
	fc.Result = res
	return ec.marshalNSelector2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISelectorᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GeneralSubscription_regexSelectors(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneralSubscription",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_Selector_data(ctx, field)
			case "type":
				return ec.fieldContext_Selector_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Selector", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneralSubscription_resourceType(ctx context.Context, field graphql.CollectedField, obj *model.APISubscription) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GeneralSubscription_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GeneralSubscription_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneralSubscription",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneralSubscription_selectors(ctx context.Context, field graphql.CollectedField, obj *model.APISubscription) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GeneralSubscription_selectors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Selectors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APISelector)
	fc.Result = res
	return ec.marshalNSelector2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISelectorᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GeneralSubscription_selectors(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneralSubscription",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_Selector_data(ctx, field)
			case "type":
				return ec.fieldContext_Selector_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Selector", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneralSubscription_subscriber(ctx context.Context, field graphql.CollectedField, obj *model.APISubscription) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GeneralSubscription_subscriber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Subscriber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.APISubscriber)
	fc.Result = res
	return ec.marshalOSubscriberWrapper2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISubscriber(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GeneralSubscription_subscriber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneralSubscription",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "subscriber":
				return ec.fieldContext_SubscriberWrapper_subscriber(ctx, field)
			case "type":
				return ec.fieldContext_SubscriberWrapper_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SubscriberWrapper", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneralSubscription_trigger(ctx context.Context, field graphql.CollectedField, obj *model.APISubscription) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GeneralSubscription_trigger(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Trigger, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GeneralSubscription_trigger(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneralSubscription",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneralSubscription_triggerData(ctx context.Context, field graphql.CollectedField, obj *model.APISubscription) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GeneralSubscription_triggerData(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TriggerData, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]string)
	fc.Result = res
	return ec.marshalOStringMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GeneralSubscription_triggerData(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneralSubscription",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StringMap does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneratedTaskCountResults_buildVariantName(ctx context.Context, field graphql.CollectedField, obj *GeneratedTaskCountResults) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GeneratedTaskCountResults_buildVariantName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildVariantName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GeneratedTaskCountResults_buildVariantName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneratedTaskCountResults",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneratedTaskCountResults_taskName(ctx context.Context, field graphql.CollectedField, obj *GeneratedTaskCountResults) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GeneratedTaskCountResults_taskName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GeneratedTaskCountResults_taskName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneratedTaskCountResults",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneratedTaskCountResults_taskId(ctx context.Context, field graphql.CollectedField, obj *GeneratedTaskCountResults) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GeneratedTaskCountResults_taskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GeneratedTaskCountResults_taskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneratedTaskCountResults",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneratedTaskCountResults_estimatedTasks(ctx context.Context, field graphql.CollectedField, obj *GeneratedTaskCountResults) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GeneratedTaskCountResults_estimatedTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EstimatedTasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GeneratedTaskCountResults_estimatedTasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneratedTaskCountResults",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitHubAuthConfig_appId(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubAuthConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitHubAuthConfig_appId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.AppId, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.RequireAdmin == nil {
				var zeroVal int64
				return zeroVal, errors.New("directive requireAdmin is not implemented")
			}
			return ec.directives.RequireAdmin(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int64); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int64`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitHubAuthConfig_appId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitHubAuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitHubAuthConfig_clientId(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubAuthConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitHubAuthConfig_clientId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ClientId, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.RequireAdmin == nil {
				var zeroVal *string
				return zeroVal, errors.New("directive requireAdmin is not implemented")
			}
			return ec.directives.RequireAdmin(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitHubAuthConfig_clientId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitHubAuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitHubAuthConfig_clientSecret(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubAuthConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitHubAuthConfig_clientSecret(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ClientSecret, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.RequireAdmin == nil {
				var zeroVal *string
				return zeroVal, errors.New("directive requireAdmin is not implemented")
			}
			return ec.directives.RequireAdmin(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitHubAuthConfig_clientSecret(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitHubAuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitHubAuthConfig_defaultOwner(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubAuthConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitHubAuthConfig_defaultOwner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.DefaultOwner, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.RequireAdmin == nil {
				var zeroVal *string
				return zeroVal, errors.New("directive requireAdmin is not implemented")
			}
			return ec.directives.RequireAdmin(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitHubAuthConfig_defaultOwner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitHubAuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitHubAuthConfig_defaultRepo(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubAuthConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitHubAuthConfig_defaultRepo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.DefaultRepo, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.RequireAdmin == nil {
				var zeroVal *string
				return zeroVal, errors.New("directive requireAdmin is not implemented")
			}
			return ec.directives.RequireAdmin(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitHubAuthConfig_defaultRepo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitHubAuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitHubAuthConfig_organization(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubAuthConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitHubAuthConfig_organization(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Organization, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.RequireAdmin == nil {
				var zeroVal *string
				return zeroVal, errors.New("directive requireAdmin is not implemented")
			}
			return ec.directives.RequireAdmin(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitHubAuthConfig_organization(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitHubAuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitHubAuthConfig_users(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubAuthConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitHubAuthConfig_users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Users, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalNString2ᚕᚖstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitHubAuthConfig_users(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitHubAuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitHubDynamicTokenPermissionGroup_name(ctx context.Context, field graphql.CollectedField, obj *model.APIGitHubDynamicTokenPermissionGroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitHubDynamicTokenPermissionGroup_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitHubDynamicTokenPermissionGroup_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitHubDynamicTokenPermissionGroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitHubDynamicTokenPermissionGroup_permissions(ctx context.Context, field graphql.CollectedField, obj *model.APIGitHubDynamicTokenPermissionGroup) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitHubDynamicTokenPermissionGroup_permissions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Permissions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(map[string]string)
	fc.Result = res
	return ec.marshalNStringMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitHubDynamicTokenPermissionGroup_permissions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitHubDynamicTokenPermissionGroup",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StringMap does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitTag_tag(ctx context.Context, field graphql.CollectedField, obj *model.APIGitTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitTag_tag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tag, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitTag_tag(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitTag_pusher(ctx context.Context, field graphql.CollectedField, obj *model.APIGitTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitTag_pusher(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pusher, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitTag_pusher(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubAppAuth_appId(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubAppAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubAppAuth_appId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AppID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubAppAuth_appId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubAppAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubAppAuth_privateKey(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubAppAuth) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubAppAuth_privateKey(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrivateKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubAppAuth_privateKey(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubAppAuth",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubCheckSubscriber_owner(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubCheckSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubCheckSubscriber_owner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubCheckSubscriber_owner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubCheckSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubCheckSubscriber_ref(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubCheckSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubCheckSubscriber_ref(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ref, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubCheckSubscriber_ref(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubCheckSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubCheckSubscriber_repo(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubCheckSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubCheckSubscriber_repo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubCheckSubscriber_repo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubCheckSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubPRSubscriber_owner(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubPRSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubPRSubscriber_owner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubPRSubscriber_owner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubPRSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubPRSubscriber_prNumber(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubPRSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubPRSubscriber_prNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PRNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubPRSubscriber_prNumber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubPRSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubPRSubscriber_ref(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubPRSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubPRSubscriber_ref(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ref, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubPRSubscriber_ref(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubPRSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubPRSubscriber_repo(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubPRSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubPRSubscriber_repo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubPRSubscriber_repo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubPRSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubPatch_author(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubPatch_author(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Author, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubPatch_author(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubPatch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubPatch_baseOwner(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubPatch_baseOwner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BaseOwner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubPatch_baseOwner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubPatch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubPatch_baseRepo(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubPatch_baseRepo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BaseRepo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubPatch_baseRepo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubPatch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubPatch_headBranch(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubPatch_headBranch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HeadBranch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubPatch_headBranch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubPatch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubPatch_headHash(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubPatch_headHash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HeadHash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubPatch_headHash(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubPatch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubPatch_headOwner(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubPatch_headOwner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HeadOwner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubPatch_headOwner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubPatch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubPatch_headRepo(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubPatch_headRepo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HeadRepo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubPatch_headRepo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubPatch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubPatch_prNumber(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubPatch_prNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PRNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubPatch_prNumber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubPatch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubProjectConflicts_commitCheckIdentifiers(ctx context.Context, field graphql.CollectedField, obj *model1.GithubProjectConflicts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubProjectConflicts_commitCheckIdentifiers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CommitCheckIdentifiers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubProjectConflicts_commitCheckIdentifiers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubProjectConflicts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubProjectConflicts_commitQueueIdentifiers(ctx context.Context, field graphql.CollectedField, obj *model1.GithubProjectConflicts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubProjectConflicts_commitQueueIdentifiers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CommitQueueIdentifiers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubProjectConflicts_commitQueueIdentifiers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubProjectConflicts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubProjectConflicts_prTestingIdentifiers(ctx context.Context, field graphql.CollectedField, obj *model1.GithubProjectConflicts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubProjectConflicts_prTestingIdentifiers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PRTestingIdentifiers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubProjectConflicts_prTestingIdentifiers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubProjectConflicts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubUser_lastKnownAs(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubUser_lastKnownAs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastKnownAs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubUser_lastKnownAs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubUser_uid(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubUser_uid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubUser_uid(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedBuildVariant_displayName(ctx context.Context, field graphql.CollectedField, obj *GroupedBuildVariant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupedBuildVariant_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupedBuildVariant_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedBuildVariant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedBuildVariant_tasks(ctx context.Context, field graphql.CollectedField, obj *GroupedBuildVariant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupedBuildVariant_tasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.APITask)
	fc.Result = res
	return ec.marshalOTask2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupedBuildVariant_tasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedBuildVariant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedBuildVariant_variant(ctx context.Context, field graphql.CollectedField, obj *GroupedBuildVariant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupedBuildVariant_variant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Variant, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupedBuildVariant_variant(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedBuildVariant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedFiles_files(ctx context.Context, field graphql.CollectedField, obj *GroupedFiles) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupedFiles_files(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Files, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.APIFile)
	fc.Result = res
	return ec.marshalOFile2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIFileᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupedFiles_files(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedFiles",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "link":
				return ec.fieldContext_File_link(ctx, field)
			case "name":
				return ec.fieldContext_File_name(ctx, field)
			case "urlParsley":
				return ec.fieldContext_File_urlParsley(ctx, field)
			case "visibility":
				return ec.fieldContext_File_visibility(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type File", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedFiles_taskName(ctx context.Context, field graphql.CollectedField, obj *GroupedFiles) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupedFiles_taskName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupedFiles_taskName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedFiles",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedFiles_taskId(ctx context.Context, field graphql.CollectedField, obj *GroupedFiles) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupedFiles_taskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupedFiles_taskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedFiles",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedFiles_execution(ctx context.Context, field graphql.CollectedField, obj *GroupedFiles) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupedFiles_execution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Execution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupedFiles_execution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedFiles",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedProjects_groupDisplayName(ctx context.Context, field graphql.CollectedField, obj *GroupedProjects) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupedProjects_groupDisplayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GroupDisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupedProjects_groupDisplayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedProjects",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedProjects_projects(ctx context.Context, field graphql.CollectedField, obj *GroupedProjects) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupedProjects_projects(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Projects, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIProjectRef)
	fc.Result = res
	return ec.marshalNProject2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRefᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupedProjects_projects(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedProjects",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "githubPRTriggerAliases":
				return ec.fieldContext_Project_githubPRTriggerAliases(ctx, field)
			case "githubMQTriggerAliases":
				return ec.fieldContext_Project_githubMQTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedProjects_repo(ctx context.Context, field graphql.CollectedField, obj *GroupedProjects) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupedProjects_repo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectRef)
	fc.Result = res
	return ec.marshalORepoRef2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupedProjects_repo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedProjects",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RepoRef_id(ctx, field)
			case "admins":
				return ec.fieldContext_RepoRef_admins(ctx, field)
			case "batchTime":
				return ec.fieldContext_RepoRef_batchTime(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_RepoRef_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_RepoRef_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_RepoRef_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_RepoRef_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_RepoRef_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_RepoRef_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_RepoRef_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_RepoRef_enabled(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_RepoRef_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_RepoRef_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_RepoRef_githubPermissionGroupByRequester(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_RepoRef_githubTriggerAliases(ctx, field)
			case "githubPRTriggerAliases":
				return ec.fieldContext_RepoRef_githubPRTriggerAliases(ctx, field)
			case "githubMQTriggerAliases":
				return ec.fieldContext_RepoRef_githubMQTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_RepoRef_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_RepoRef_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_RepoRef_gitTagVersionsEnabled(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_RepoRef_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_RepoRef_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_RepoRef_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_RepoRef_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_RepoRef_parsleyFilters(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_RepoRef_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_RepoRef_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_RepoRef_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_RepoRef_periodicBuilds(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_RepoRef_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_RepoRef_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_RepoRef_repo(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_RepoRef_repotrackerDisabled(ctx, field)
			case "restricted":
				return ec.fieldContext_RepoRef_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_RepoRef_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_RepoRef_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_RepoRef_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_RepoRef_taskAnnotationSettings(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_RepoRef_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_RepoRef_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_RepoRef_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_RepoRef_workstationConfig(ctx, field)
			case "externalLinks":
				return ec.fieldContext_RepoRef_externalLinks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepoRef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedTaskStatusCount_displayName(ctx context.Context, field graphql.CollectedField, obj *task.GroupedTaskStatusCount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupedTaskStatusCount_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupedTaskStatusCount_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedTaskStatusCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedTaskStatusCount_statusCounts(ctx context.Context, field graphql.CollectedField, obj *task.GroupedTaskStatusCount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupedTaskStatusCount_statusCounts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StatusCounts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*task.StatusCount)
	fc.Result = res
	return ec.marshalNStatusCount2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋtaskᚐStatusCountᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupedTaskStatusCount_statusCounts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedTaskStatusCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_StatusCount_count(ctx, field)
			case "status":
				return ec.fieldContext_StatusCount_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StatusCount", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedTaskStatusCount_variant(ctx context.Context, field graphql.CollectedField, obj *task.GroupedTaskStatusCount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupedTaskStatusCount_variant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Variant, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupedTaskStatusCount_variant(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedTaskStatusCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HomeVolumeSettings_formatCommand(ctx context.Context, field graphql.CollectedField, obj *model.APIHomeVolumeSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HomeVolumeSettings_formatCommand(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FormatCommand, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HomeVolumeSettings_formatCommand(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HomeVolumeSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_id(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNID2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_availabilityZone(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_availabilityZone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvailabilityZone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_availabilityZone(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_ami(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_ami(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Host().Ami(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_ami(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_displayName(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_distro(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_distro(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distro, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.DistroInfo)
	fc.Result = res
	return ec.marshalODistroInfo2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐDistroInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_distro(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DistroInfo_id(ctx, field)
			case "bootstrapMethod":
				return ec.fieldContext_DistroInfo_bootstrapMethod(ctx, field)
			case "isVirtualWorkStation":
				return ec.fieldContext_DistroInfo_isVirtualWorkStation(ctx, field)
			case "isWindows":
				return ec.fieldContext_DistroInfo_isWindows(ctx, field)
			case "user":
				return ec.fieldContext_DistroInfo_user(ctx, field)
			case "workDir":
				return ec.fieldContext_DistroInfo_workDir(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DistroInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_distroId(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_distroId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Host().DistroID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_distroId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_elapsed(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_elapsed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Host().Elapsed(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_elapsed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_events(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Host().Events(rctx, obj, fc.Args["opts"].(HostEventsInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*HostEvents)
	fc.Result = res
	return ec.marshalNHostEvents2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐHostEvents(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_HostEvents_count(ctx, field)
			case "eventLogEntries":
				return ec.fieldContext_HostEvents_eventLogEntries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HostEvents", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Host_events_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Host_eventTypes(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_eventTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Host().EventTypes(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNHostEventType2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_eventTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type HostEventType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_expiration(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_expiration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Expiration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_expiration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_hostUrl(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_hostUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_hostUrl(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_homeVolume(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_homeVolume(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Host().HomeVolume(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIVolume)
	fc.Result = res
	return ec.marshalOVolume2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVolume(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_homeVolume(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Volume_id(ctx, field)
			case "availabilityZone":
				return ec.fieldContext_Volume_availabilityZone(ctx, field)
			case "createdBy":
				return ec.fieldContext_Volume_createdBy(ctx, field)
			case "creationTime":
				return ec.fieldContext_Volume_creationTime(ctx, field)
			case "deviceName":
				return ec.fieldContext_Volume_deviceName(ctx, field)
			case "displayName":
				return ec.fieldContext_Volume_displayName(ctx, field)
			case "expiration":
				return ec.fieldContext_Volume_expiration(ctx, field)
			case "homeVolume":
				return ec.fieldContext_Volume_homeVolume(ctx, field)
			case "host":
				return ec.fieldContext_Volume_host(ctx, field)
			case "hostID":
				return ec.fieldContext_Volume_hostID(ctx, field)
			case "migrating":
				return ec.fieldContext_Volume_migrating(ctx, field)
			case "noExpiration":
				return ec.fieldContext_Volume_noExpiration(ctx, field)
			case "size":
				return ec.fieldContext_Volume_size(ctx, field)
			case "type":
				return ec.fieldContext_Volume_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Volume", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_homeVolumeID(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_homeVolumeID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HomeVolumeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_homeVolumeID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_instanceType(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_instanceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InstanceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_instanceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_instanceTags(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_instanceTags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InstanceTags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]host.Tag)
	fc.Result = res
	return ec.marshalNInstanceTag2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋhostᚐTagᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_instanceTags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "canBeModified":
				return ec.fieldContext_InstanceTag_canBeModified(ctx, field)
			case "key":
				return ec.fieldContext_InstanceTag_key(ctx, field)
			case "value":
				return ec.fieldContext_InstanceTag_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InstanceTag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_lastCommunicationTime(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_lastCommunicationTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastCommunicationTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_lastCommunicationTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_noExpiration(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_noExpiration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NoExpiration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_noExpiration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_persistentDnsName(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_persistentDnsName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PersistentDNSName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_persistentDnsName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_provider(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_provider(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Provider, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_provider(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_runningTask(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_runningTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RunningTask, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.TaskInfo)
	fc.Result = res
	return ec.marshalOTaskInfo2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐTaskInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_runningTask(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TaskInfo_id(ctx, field)
			case "name":
				return ec.fieldContext_TaskInfo_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_sleepSchedule(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_sleepSchedule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Host().SleepSchedule(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*host.SleepScheduleInfo)
	fc.Result = res
	return ec.marshalOSleepSchedule2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋhostᚐSleepScheduleInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_sleepSchedule(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "dailyStartTime":
				return ec.fieldContext_SleepSchedule_dailyStartTime(ctx, field)
			case "dailyStopTime":
				return ec.fieldContext_SleepSchedule_dailyStopTime(ctx, field)
			case "nextStartTime":
				return ec.fieldContext_SleepSchedule_nextStartTime(ctx, field)
			case "nextStopTime":
				return ec.fieldContext_SleepSchedule_nextStopTime(ctx, field)
			case "permanentlyExempt":
				return ec.fieldContext_SleepSchedule_permanentlyExempt(ctx, field)
			case "shouldKeepOff":
				return ec.fieldContext_SleepSchedule_shouldKeepOff(ctx, field)
			case "timeZone":
				return ec.fieldContext_SleepSchedule_timeZone(ctx, field)
			case "temporarilyExemptUntil":
				return ec.fieldContext_SleepSchedule_temporarilyExemptUntil(ctx, field)
			case "wholeWeekdaysOff":
				return ec.fieldContext_SleepSchedule_wholeWeekdaysOff(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SleepSchedule", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_startedBy(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_startedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_startedBy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_status(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_tag(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_tag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tag, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_tag(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_totalIdleTime(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_totalIdleTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalIdleTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.APIDuration)
	fc.Result = res
	return ec.marshalODuration2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_totalIdleTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_uptime(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_uptime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Host().Uptime(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_uptime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_user(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_volumes(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_volumes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Host().Volumes(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIVolume)
	fc.Result = res
	return ec.marshalNVolume2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVolumeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_volumes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Volume_id(ctx, field)
			case "availabilityZone":
				return ec.fieldContext_Volume_availabilityZone(ctx, field)
			case "createdBy":
				return ec.fieldContext_Volume_createdBy(ctx, field)
			case "creationTime":
				return ec.fieldContext_Volume_creationTime(ctx, field)
			case "deviceName":
				return ec.fieldContext_Volume_deviceName(ctx, field)
			case "displayName":
				return ec.fieldContext_Volume_displayName(ctx, field)
			case "expiration":
				return ec.fieldContext_Volume_expiration(ctx, field)
			case "homeVolume":
				return ec.fieldContext_Volume_homeVolume(ctx, field)
			case "host":
				return ec.fieldContext_Volume_host(ctx, field)
			case "hostID":
				return ec.fieldContext_Volume_hostID(ctx, field)
			case "migrating":
				return ec.fieldContext_Volume_migrating(ctx, field)
			case "noExpiration":
				return ec.fieldContext_Volume_noExpiration(ctx, field)
			case "size":
				return ec.fieldContext_Volume_size(ctx, field)
			case "type":
				return ec.fieldContext_Volume_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Volume", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostAllocatorSettings_acceptableHostIdleTime(ctx context.Context, field graphql.CollectedField, obj *model.APIHostAllocatorSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostAllocatorSettings_acceptableHostIdleTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AcceptableHostIdleTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIDuration)
	fc.Result = res
	return ec.marshalNDuration2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostAllocatorSettings_acceptableHostIdleTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostAllocatorSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostAllocatorSettings_autoTuneMaximumHosts(ctx context.Context, field graphql.CollectedField, obj *model.APIHostAllocatorSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostAllocatorSettings_autoTuneMaximumHosts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AutoTuneMaximumHosts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostAllocatorSettings_autoTuneMaximumHosts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostAllocatorSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostAllocatorSettings_feedbackRule(ctx context.Context, field graphql.CollectedField, obj *model.APIHostAllocatorSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostAllocatorSettings_feedbackRule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedbackRule, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNFeedbackRule2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostAllocatorSettings_feedbackRule(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostAllocatorSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FeedbackRule does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostAllocatorSettings_futureHostFraction(ctx context.Context, field graphql.CollectedField, obj *model.APIHostAllocatorSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostAllocatorSettings_futureHostFraction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FutureHostFraction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostAllocatorSettings_futureHostFraction(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostAllocatorSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostAllocatorSettings_hostsOverallocatedRule(ctx context.Context, field graphql.CollectedField, obj *model.APIHostAllocatorSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostAllocatorSettings_hostsOverallocatedRule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostsOverallocatedRule, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNOverallocatedRule2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostAllocatorSettings_hostsOverallocatedRule(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostAllocatorSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type OverallocatedRule does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostAllocatorSettings_maximumHosts(ctx context.Context, field graphql.CollectedField, obj *model.APIHostAllocatorSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostAllocatorSettings_maximumHosts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaximumHosts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostAllocatorSettings_maximumHosts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostAllocatorSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostAllocatorSettings_minimumHosts(ctx context.Context, field graphql.CollectedField, obj *model.APIHostAllocatorSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostAllocatorSettings_minimumHosts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MinimumHosts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostAllocatorSettings_minimumHosts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostAllocatorSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostAllocatorSettings_roundingRule(ctx context.Context, field graphql.CollectedField, obj *model.APIHostAllocatorSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostAllocatorSettings_roundingRule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RoundingRule, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNRoundingRule2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostAllocatorSettings_roundingRule(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostAllocatorSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RoundingRule does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostAllocatorSettings_version(ctx context.Context, field graphql.CollectedField, obj *model.APIHostAllocatorSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostAllocatorSettings_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNHostAllocatorVersion2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostAllocatorSettings_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostAllocatorSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type HostAllocatorVersion does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_agentBuild(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_agentBuild(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentBuild, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_agentBuild(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_agentRevision(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_agentRevision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentRevision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_agentRevision(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_duration(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_duration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Duration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIDuration)
	fc.Result = res
	return ec.marshalNDuration2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_duration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_execution(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_execution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Execution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_execution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_hostname(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_hostname(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hostname, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_hostname(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_jasperRevision(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_jasperRevision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JasperRevision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_jasperRevision(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_logs(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_logs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Logs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_logs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_monitorOp(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_monitorOp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MonitorOp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_monitorOp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_newStatus(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_newStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_newStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_oldStatus(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_oldStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OldStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_oldStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_provisioningMethod(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_provisioningMethod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisioningMethod, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_provisioningMethod(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_successful(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_successful(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Successful, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_successful(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_taskId(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_taskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_taskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_taskPid(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_taskPid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskPid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_taskPid(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_taskStatus(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_taskStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_taskStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_user(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogEntry_data(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogEntry_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.HostAPIEventData)
	fc.Result = res
	return ec.marshalNHostEventLogData2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐHostAPIEventData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogEntry_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "agentBuild":
				return ec.fieldContext_HostEventLogData_agentBuild(ctx, field)
			case "agentRevision":
				return ec.fieldContext_HostEventLogData_agentRevision(ctx, field)
			case "duration":
				return ec.fieldContext_HostEventLogData_duration(ctx, field)
			case "execution":
				return ec.fieldContext_HostEventLogData_execution(ctx, field)
			case "hostname":
				return ec.fieldContext_HostEventLogData_hostname(ctx, field)
			case "jasperRevision":
				return ec.fieldContext_HostEventLogData_jasperRevision(ctx, field)
			case "logs":
				return ec.fieldContext_HostEventLogData_logs(ctx, field)
			case "monitorOp":
				return ec.fieldContext_HostEventLogData_monitorOp(ctx, field)
			case "newStatus":
				return ec.fieldContext_HostEventLogData_newStatus(ctx, field)
			case "oldStatus":
				return ec.fieldContext_HostEventLogData_oldStatus(ctx, field)
			case "provisioningMethod":
				return ec.fieldContext_HostEventLogData_provisioningMethod(ctx, field)
			case "successful":
				return ec.fieldContext_HostEventLogData_successful(ctx, field)
			case "taskId":
				return ec.fieldContext_HostEventLogData_taskId(ctx, field)
			case "taskPid":
				return ec.fieldContext_HostEventLogData_taskPid(ctx, field)
			case "taskStatus":
				return ec.fieldContext_HostEventLogData_taskStatus(ctx, field)
			case "user":
				return ec.fieldContext_HostEventLogData_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HostEventLogData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogEntry_eventType(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogEntry_eventType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOHostEventType2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogEntry_eventType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type HostEventType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogEntry_processedAt(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogEntry_processedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProcessedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogEntry_processedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogEntry_resourceId(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogEntry_resourceId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogEntry_resourceId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogEntry_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogEntry_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogEntry_timestamp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEvents_count(ctx context.Context, field graphql.CollectedField, obj *HostEvents) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEvents_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEvents_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEvents",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEvents_eventLogEntries(ctx context.Context, field graphql.CollectedField, obj *HostEvents) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEvents_eventLogEntries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventLogEntries, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.HostAPIEventLogEntry)
	fc.Result = res
	return ec.marshalNHostEventLogEntry2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐHostAPIEventLogEntryᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEvents_eventLogEntries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEvents",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_HostEventLogEntry_id(ctx, field)
			case "data":
				return ec.fieldContext_HostEventLogEntry_data(ctx, field)
			case "eventType":
				return ec.fieldContext_HostEventLogEntry_eventType(ctx, field)
			case "processedAt":
				return ec.fieldContext_HostEventLogEntry_processedAt(ctx, field)
			case "resourceId":
				return ec.fieldContext_HostEventLogEntry_resourceId(ctx, field)
			case "resourceType":
				return ec.fieldContext_HostEventLogEntry_resourceType(ctx, field)
			case "timestamp":
				return ec.fieldContext_HostEventLogEntry_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HostEventLogEntry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostInitConfig_hostThrottle(ctx context.Context, field graphql.CollectedField, obj *model.APIHostInitConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostInitConfig_hostThrottle(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostThrottle, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostInitConfig_hostThrottle(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostInitConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostInitConfig_provisioningThrottle(ctx context.Context, field graphql.CollectedField, obj *model.APIHostInitConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostInitConfig_provisioningThrottle(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisioningThrottle, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostInitConfig_provisioningThrottle(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostInitConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostInitConfig_cloudStatusBatchSize(ctx context.Context, field graphql.CollectedField, obj *model.APIHostInitConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostInitConfig_cloudStatusBatchSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CloudStatusBatchSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostInitConfig_cloudStatusBatchSize(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostInitConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostInitConfig_maxTotalDynamicHosts(ctx context.Context, field graphql.CollectedField, obj *model.APIHostInitConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostInitConfig_maxTotalDynamicHosts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxTotalDynamicHosts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostInitConfig_maxTotalDynamicHosts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostInitConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostsResponse_filteredHostsCount(ctx context.Context, field graphql.CollectedField, obj *HostsResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostsResponse_filteredHostsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FilteredHostsCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostsResponse_filteredHostsCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostsResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostsResponse_hosts(ctx context.Context, field graphql.CollectedField, obj *HostsResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostsResponse_hosts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hosts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIHost)
	fc.Result = res
	return ec.marshalNHost2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHostᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostsResponse_hosts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostsResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "availabilityZone":
				return ec.fieldContext_Host_availabilityZone(ctx, field)
			case "ami":
				return ec.fieldContext_Host_ami(ctx, field)
			case "displayName":
				return ec.fieldContext_Host_displayName(ctx, field)
			case "distro":
				return ec.fieldContext_Host_distro(ctx, field)
			case "distroId":
				return ec.fieldContext_Host_distroId(ctx, field)
			case "elapsed":
				return ec.fieldContext_Host_elapsed(ctx, field)
			case "events":
				return ec.fieldContext_Host_events(ctx, field)
			case "eventTypes":
				return ec.fieldContext_Host_eventTypes(ctx, field)
			case "expiration":
				return ec.fieldContext_Host_expiration(ctx, field)
			case "hostUrl":
				return ec.fieldContext_Host_hostUrl(ctx, field)
			case "homeVolume":
				return ec.fieldContext_Host_homeVolume(ctx, field)
			case "homeVolumeID":
				return ec.fieldContext_Host_homeVolumeID(ctx, field)
			case "instanceType":
				return ec.fieldContext_Host_instanceType(ctx, field)
			case "instanceTags":
				return ec.fieldContext_Host_instanceTags(ctx, field)
			case "lastCommunicationTime":
				return ec.fieldContext_Host_lastCommunicationTime(ctx, field)
			case "noExpiration":
				return ec.fieldContext_Host_noExpiration(ctx, field)
			case "persistentDnsName":
				return ec.fieldContext_Host_persistentDnsName(ctx, field)
			case "provider":
				return ec.fieldContext_Host_provider(ctx, field)
			case "runningTask":
				return ec.fieldContext_Host_runningTask(ctx, field)
			case "sleepSchedule":
				return ec.fieldContext_Host_sleepSchedule(ctx, field)
			case "startedBy":
				return ec.fieldContext_Host_startedBy(ctx, field)
			case "status":
				return ec.fieldContext_Host_status(ctx, field)
			case "tag":
				return ec.fieldContext_Host_tag(ctx, field)
			case "totalIdleTime":
				return ec.fieldContext_Host_totalIdleTime(ctx, field)
			case "uptime":
				return ec.fieldContext_Host_uptime(ctx, field)
			case "user":
				return ec.fieldContext_Host_user(ctx, field)
			case "volumes":
				return ec.fieldContext_Host_volumes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostsResponse_totalHostsCount(ctx context.Context, field graphql.CollectedField, obj *HostsResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostsResponse_totalHostsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalHostsCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostsResponse_totalHostsCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostsResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IceCreamSettings_configPath(ctx context.Context, field graphql.CollectedField, obj *model.APIIceCreamSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IceCreamSettings_configPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConfigPath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IceCreamSettings_configPath(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IceCreamSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IceCreamSettings_schedulerHost(ctx context.Context, field graphql.CollectedField, obj *model.APIIceCreamSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IceCreamSettings_schedulerHost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SchedulerHost, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IceCreamSettings_schedulerHost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IceCreamSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Image_id(ctx context.Context, field graphql.CollectedField, obj *model.APIImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Image_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Image_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Image_ami(ctx context.Context, field graphql.CollectedField, obj *model.APIImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Image_ami(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AMI, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Image_ami(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Image_distros(ctx context.Context, field graphql.CollectedField, obj *model.APIImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Image_distros(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Image().Distros(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIDistro)
	fc.Result = res
	return ec.marshalNDistro2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDistroᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Image_distros(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "adminOnly":
				return ec.fieldContext_Distro_adminOnly(ctx, field)
			case "aliases":
				return ec.fieldContext_Distro_aliases(ctx, field)
			case "arch":
				return ec.fieldContext_Distro_arch(ctx, field)
			case "authorizedKeysFile":
				return ec.fieldContext_Distro_authorizedKeysFile(ctx, field)
			case "availableRegions":
				return ec.fieldContext_Distro_availableRegions(ctx, field)
			case "bootstrapSettings":
				return ec.fieldContext_Distro_bootstrapSettings(ctx, field)
			case "containerPool":
				return ec.fieldContext_Distro_containerPool(ctx, field)
			case "disabled":
				return ec.fieldContext_Distro_disabled(ctx, field)
			case "disableShallowClone":
				return ec.fieldContext_Distro_disableShallowClone(ctx, field)
			case "dispatcherSettings":
				return ec.fieldContext_Distro_dispatcherSettings(ctx, field)
			case "execUser":
				return ec.fieldContext_Distro_execUser(ctx, field)
			case "expansions":
				return ec.fieldContext_Distro_expansions(ctx, field)
			case "finderSettings":
				return ec.fieldContext_Distro_finderSettings(ctx, field)
			case "homeVolumeSettings":
				return ec.fieldContext_Distro_homeVolumeSettings(ctx, field)
			case "hostAllocatorSettings":
				return ec.fieldContext_Distro_hostAllocatorSettings(ctx, field)
			case "iceCreamSettings":
				return ec.fieldContext_Distro_iceCreamSettings(ctx, field)
			case "imageId":
				return ec.fieldContext_Distro_imageId(ctx, field)
			case "isCluster":
				return ec.fieldContext_Distro_isCluster(ctx, field)
			case "isVirtualWorkStation":
				return ec.fieldContext_Distro_isVirtualWorkStation(ctx, field)
			case "mountpoints":
				return ec.fieldContext_Distro_mountpoints(ctx, field)
			case "name":
				return ec.fieldContext_Distro_name(ctx, field)
			case "note":
				return ec.fieldContext_Distro_note(ctx, field)
			case "plannerSettings":
				return ec.fieldContext_Distro_plannerSettings(ctx, field)
			case "provider":
				return ec.fieldContext_Distro_provider(ctx, field)
			case "providerAccount":
				return ec.fieldContext_Distro_providerAccount(ctx, field)
			case "providerSettingsList":
				return ec.fieldContext_Distro_providerSettingsList(ctx, field)
			case "setup":
				return ec.fieldContext_Distro_setup(ctx, field)
			case "setupAsSudo":
				return ec.fieldContext_Distro_setupAsSudo(ctx, field)
			case "singleTaskDistro":
				return ec.fieldContext_Distro_singleTaskDistro(ctx, field)
			case "sshOptions":
				return ec.fieldContext_Distro_sshOptions(ctx, field)
			case "user":
				return ec.fieldContext_Distro_user(ctx, field)
			case "userSpawnAllowed":
				return ec.fieldContext_Distro_userSpawnAllowed(ctx, field)
			case "validProjects":
				return ec.fieldContext_Distro_validProjects(ctx, field)
			case "warningNote":
				return ec.fieldContext_Distro_warningNote(ctx, field)
			case "workDir":
				return ec.fieldContext_Distro_workDir(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Distro", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Image_events(ctx context.Context, field graphql.CollectedField, obj *model.APIImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Image_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Image().Events(rctx, obj, fc.Args["limit"].(int), fc.Args["page"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ImageEventsPayload)
	fc.Result = res
	return ec.marshalNImageEventsPayload2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐImageEventsPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Image_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_ImageEventsPayload_count(ctx, field)
			case "eventLogEntries":
				return ec.fieldContext_ImageEventsPayload_eventLogEntries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImageEventsPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Image_events_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Image_lastDeployed(ctx context.Context, field graphql.CollectedField, obj *model.APIImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Image_lastDeployed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastDeployed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Image_lastDeployed(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Image_latestTask(ctx context.Context, field graphql.CollectedField, obj *model.APIImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Image_latestTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Image().LatestTask(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APITask)
	fc.Result = res
	return ec.marshalOTask2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Image_latestTask(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Image_operatingSystem(ctx context.Context, field graphql.CollectedField, obj *model.APIImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Image_operatingSystem(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Image().OperatingSystem(rctx, obj, fc.Args["opts"].(thirdparty.OSInfoFilterOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ImageOperatingSystemPayload)
	fc.Result = res
	return ec.marshalNImageOperatingSystemPayload2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐImageOperatingSystemPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Image_operatingSystem(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_ImageOperatingSystemPayload_data(ctx, field)
			case "filteredCount":
				return ec.fieldContext_ImageOperatingSystemPayload_filteredCount(ctx, field)
			case "totalCount":
				return ec.fieldContext_ImageOperatingSystemPayload_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImageOperatingSystemPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Image_operatingSystem_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Image_packages(ctx context.Context, field graphql.CollectedField, obj *model.APIImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Image_packages(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Image().Packages(rctx, obj, fc.Args["opts"].(thirdparty.PackageFilterOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ImagePackagesPayload)
	fc.Result = res
	return ec.marshalNImagePackagesPayload2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐImagePackagesPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Image_packages(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_ImagePackagesPayload_data(ctx, field)
			case "filteredCount":
				return ec.fieldContext_ImagePackagesPayload_filteredCount(ctx, field)
			case "totalCount":
				return ec.fieldContext_ImagePackagesPayload_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImagePackagesPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Image_packages_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Image_toolchains(ctx context.Context, field graphql.CollectedField, obj *model.APIImage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Image_toolchains(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Image().Toolchains(rctx, obj, fc.Args["opts"].(thirdparty.ToolchainFilterOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ImageToolchainsPayload)
	fc.Result = res
	return ec.marshalNImageToolchainsPayload2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐImageToolchainsPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Image_toolchains(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Image",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_ImageToolchainsPayload_data(ctx, field)
			case "filteredCount":
				return ec.fieldContext_ImageToolchainsPayload_filteredCount(ctx, field)
			case "totalCount":
				return ec.fieldContext_ImageToolchainsPayload_totalCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImageToolchainsPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Image_toolchains_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _ImageEvent_entries(ctx context.Context, field graphql.CollectedField, obj *model.APIImageEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageEvent_entries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Entries, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APIImageEventEntry)
	fc.Result = res
	return ec.marshalNImageEventEntry2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIImageEventEntryᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageEvent_entries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ImageEventEntry_name(ctx, field)
			case "after":
				return ec.fieldContext_ImageEventEntry_after(ctx, field)
			case "before":
				return ec.fieldContext_ImageEventEntry_before(ctx, field)
			case "type":
				return ec.fieldContext_ImageEventEntry_type(ctx, field)
			case "action":
				return ec.fieldContext_ImageEventEntry_action(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImageEventEntry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageEvent_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.APIImageEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageEvent_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageEvent_timestamp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageEvent_amiBefore(ctx context.Context, field graphql.CollectedField, obj *model.APIImageEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageEvent_amiBefore(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AMIBefore, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageEvent_amiBefore(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageEvent_amiAfter(ctx context.Context, field graphql.CollectedField, obj *model.APIImageEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageEvent_amiAfter(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AMIAfter, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageEvent_amiAfter(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageEventEntry_name(ctx context.Context, field graphql.CollectedField, obj *model.APIImageEventEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageEventEntry_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageEventEntry_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageEventEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageEventEntry_after(ctx context.Context, field graphql.CollectedField, obj *model.APIImageEventEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageEventEntry_after(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.After, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageEventEntry_after(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageEventEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageEventEntry_before(ctx context.Context, field graphql.CollectedField, obj *model.APIImageEventEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageEventEntry_before(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Before, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageEventEntry_before(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageEventEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageEventEntry_type(ctx context.Context, field graphql.CollectedField, obj *model.APIImageEventEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageEventEntry_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(thirdparty.ImageEventType)
	fc.Result = res
	return ec.marshalNImageEventType2githubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐImageEventType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageEventEntry_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageEventEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ImageEventType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageEventEntry_action(ctx context.Context, field graphql.CollectedField, obj *model.APIImageEventEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageEventEntry_action(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Action, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(thirdparty.ImageEventEntryAction)
	fc.Result = res
	return ec.marshalNImageEventEntryAction2githubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐImageEventEntryAction(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageEventEntry_action(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageEventEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ImageEventEntryAction does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageEventsPayload_count(ctx context.Context, field graphql.CollectedField, obj *ImageEventsPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageEventsPayload_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageEventsPayload_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageEventsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageEventsPayload_eventLogEntries(ctx context.Context, field graphql.CollectedField, obj *ImageEventsPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageEventsPayload_eventLogEntries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventLogEntries, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIImageEvent)
	fc.Result = res
	return ec.marshalNImageEvent2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIImageEventᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageEventsPayload_eventLogEntries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageEventsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "entries":
				return ec.fieldContext_ImageEvent_entries(ctx, field)
			case "timestamp":
				return ec.fieldContext_ImageEvent_timestamp(ctx, field)
			case "amiBefore":
				return ec.fieldContext_ImageEvent_amiBefore(ctx, field)
			case "amiAfter":
				return ec.fieldContext_ImageEvent_amiAfter(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ImageEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageOperatingSystemPayload_data(ctx context.Context, field graphql.CollectedField, obj *ImageOperatingSystemPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageOperatingSystemPayload_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIOSInfo)
	fc.Result = res
	return ec.marshalNOSInfo2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIOSInfoᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageOperatingSystemPayload_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageOperatingSystemPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_OSInfo_name(ctx, field)
			case "version":
				return ec.fieldContext_OSInfo_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OSInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageOperatingSystemPayload_filteredCount(ctx context.Context, field graphql.CollectedField, obj *ImageOperatingSystemPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageOperatingSystemPayload_filteredCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FilteredCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageOperatingSystemPayload_filteredCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageOperatingSystemPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageOperatingSystemPayload_totalCount(ctx context.Context, field graphql.CollectedField, obj *ImageOperatingSystemPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageOperatingSystemPayload_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageOperatingSystemPayload_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageOperatingSystemPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImagePackagesPayload_data(ctx context.Context, field graphql.CollectedField, obj *ImagePackagesPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImagePackagesPayload_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIPackage)
	fc.Result = res
	return ec.marshalNPackage2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPackageᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImagePackagesPayload_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImagePackagesPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Package_name(ctx, field)
			case "manager":
				return ec.fieldContext_Package_manager(ctx, field)
			case "version":
				return ec.fieldContext_Package_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Package", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImagePackagesPayload_filteredCount(ctx context.Context, field graphql.CollectedField, obj *ImagePackagesPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImagePackagesPayload_filteredCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FilteredCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImagePackagesPayload_filteredCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImagePackagesPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImagePackagesPayload_totalCount(ctx context.Context, field graphql.CollectedField, obj *ImagePackagesPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImagePackagesPayload_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImagePackagesPayload_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImagePackagesPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageToolchainsPayload_data(ctx context.Context, field graphql.CollectedField, obj *ImageToolchainsPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageToolchainsPayload_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIToolchain)
	fc.Result = res
	return ec.marshalNToolchain2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIToolchainᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageToolchainsPayload_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageToolchainsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_Toolchain_name(ctx, field)
			case "path":
				return ec.fieldContext_Toolchain_path(ctx, field)
			case "version":
				return ec.fieldContext_Toolchain_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Toolchain", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageToolchainsPayload_filteredCount(ctx context.Context, field graphql.CollectedField, obj *ImageToolchainsPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageToolchainsPayload_filteredCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FilteredCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageToolchainsPayload_filteredCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageToolchainsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ImageToolchainsPayload_totalCount(ctx context.Context, field graphql.CollectedField, obj *ImageToolchainsPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ImageToolchainsPayload_totalCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ImageToolchainsPayload_totalCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ImageToolchainsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InstanceTag_canBeModified(ctx context.Context, field graphql.CollectedField, obj *host.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InstanceTag_canBeModified(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CanBeModified, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InstanceTag_canBeModified(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InstanceTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InstanceTag_key(ctx context.Context, field graphql.CollectedField, obj *host.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InstanceTag_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InstanceTag_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InstanceTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InstanceTag_value(ctx context.Context, field graphql.CollectedField, obj *host.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InstanceTag_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InstanceTag_value(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InstanceTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IssueLink_confidenceScore(ctx context.Context, field graphql.CollectedField, obj *model.APIIssueLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IssueLink_confidenceScore(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConfidenceScore, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2ᚖfloat64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IssueLink_confidenceScore(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IssueLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IssueLink_issueKey(ctx context.Context, field graphql.CollectedField, obj *model.APIIssueLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IssueLink_issueKey(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IssueKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IssueLink_issueKey(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IssueLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IssueLink_jiraTicket(ctx context.Context, field graphql.CollectedField, obj *model.APIIssueLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IssueLink_jiraTicket(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.IssueLink().JiraTicket(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*thirdparty.JiraTicket)
	fc.Result = res
	return ec.marshalOJiraTicket2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐJiraTicket(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IssueLink_jiraTicket(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IssueLink",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "fields":
				return ec.fieldContext_JiraTicket_fields(ctx, field)
			case "key":
				return ec.fieldContext_JiraTicket_key(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JiraTicket", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IssueLink_source(ctx context.Context, field graphql.CollectedField, obj *model.APIIssueLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IssueLink_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APISource)
	fc.Result = res
	return ec.marshalOSource2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IssueLink_source(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IssueLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "author":
				return ec.fieldContext_Source_author(ctx, field)
			case "requester":
				return ec.fieldContext_Source_requester(ctx, field)
			case "time":
				return ec.fieldContext_Source_time(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Source", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IssueLink_url(ctx context.Context, field graphql.CollectedField, obj *model.APIIssueLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IssueLink_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IssueLink_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IssueLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraConfig_email(ctx context.Context, field graphql.CollectedField, obj *model.APIJiraConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JiraConfig_email(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Email, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JiraConfig_email(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraConfig_host(ctx context.Context, field graphql.CollectedField, obj *model.APIJiraConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JiraConfig_host(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Host, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JiraConfig_host(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraConfig_personalAccessToken(ctx context.Context, field graphql.CollectedField, obj *model.APIJiraConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JiraConfig_personalAccessToken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.PersonalAccessToken, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.RequireAdmin == nil {
				var zeroVal *string
				return zeroVal, errors.New("directive requireAdmin is not implemented")
			}
			return ec.directives.RequireAdmin(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JiraConfig_personalAccessToken(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraIssueSubscriber_issueType(ctx context.Context, field graphql.CollectedField, obj *model.APIJIRAIssueSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JiraIssueSubscriber_issueType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IssueType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JiraIssueSubscriber_issueType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraIssueSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraIssueSubscriber_project(ctx context.Context, field graphql.CollectedField, obj *model.APIJIRAIssueSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JiraIssueSubscriber_project(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Project, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JiraIssueSubscriber_project(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraIssueSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraStatus_id(ctx context.Context, field graphql.CollectedField, obj *thirdparty.JiraStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JiraStatus_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JiraStatus_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraStatus_name(ctx context.Context, field graphql.CollectedField, obj *thirdparty.JiraStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JiraStatus_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JiraStatus_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraTicket_fields(ctx context.Context, field graphql.CollectedField, obj *thirdparty.JiraTicket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JiraTicket_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*thirdparty.TicketFields)
	fc.Result = res
	return ec.marshalNTicketFields2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐTicketFields(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JiraTicket_fields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraTicket",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "assignedTeam":
				return ec.fieldContext_TicketFields_assignedTeam(ctx, field)
			case "assigneeDisplayName":
				return ec.fieldContext_TicketFields_assigneeDisplayName(ctx, field)
			case "created":
				return ec.fieldContext_TicketFields_created(ctx, field)
			case "resolutionName":
				return ec.fieldContext_TicketFields_resolutionName(ctx, field)
			case "status":
				return ec.fieldContext_TicketFields_status(ctx, field)
			case "summary":
				return ec.fieldContext_TicketFields_summary(ctx, field)
			case "updated":
				return ec.fieldContext_TicketFields_updated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TicketFields", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraTicket_key(ctx context.Context, field graphql.CollectedField, obj *thirdparty.JiraTicket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JiraTicket_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JiraTicket_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraTicket",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KanopyAuthConfig_headerName(ctx context.Context, field graphql.CollectedField, obj *model.APIKanopyAuthConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KanopyAuthConfig_headerName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.HeaderName, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.RequireAdmin == nil {
				var zeroVal *string
				return zeroVal, errors.New("directive requireAdmin is not implemented")
			}
			return ec.directives.RequireAdmin(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KanopyAuthConfig_headerName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KanopyAuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KanopyAuthConfig_issuer(ctx context.Context, field graphql.CollectedField, obj *model.APIKanopyAuthConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KanopyAuthConfig_issuer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Issuer, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.RequireAdmin == nil {
				var zeroVal *string
				return zeroVal, errors.New("directive requireAdmin is not implemented")
			}
			return ec.directives.RequireAdmin(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KanopyAuthConfig_issuer(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KanopyAuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _KanopyAuthConfig_keysetURL(ctx context.Context, field graphql.CollectedField, obj *model.APIKanopyAuthConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_KanopyAuthConfig_keysetURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.KeysetURL, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.RequireAdmin == nil {
				var zeroVal *string
				return zeroVal, errors.New("directive requireAdmin is not implemented")
			}
			return ec.directives.RequireAdmin(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_KanopyAuthConfig_keysetURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "KanopyAuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogBuffering_useAsync(ctx context.Context, field graphql.CollectedField, obj *model.APILogBuffering) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogBuffering_useAsync(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UseAsync, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogBuffering_useAsync(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogBuffering",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogBuffering_durationSeconds(ctx context.Context, field graphql.CollectedField, obj *model.APILogBuffering) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogBuffering_durationSeconds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DurationSeconds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogBuffering_durationSeconds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogBuffering",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogBuffering_count(ctx context.Context, field graphql.CollectedField, obj *model.APILogBuffering) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogBuffering_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogBuffering_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogBuffering",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogBuffering_incomingBufferFactor(ctx context.Context, field graphql.CollectedField, obj *model.APILogBuffering) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogBuffering_incomingBufferFactor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IncomingBufferFactor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogBuffering_incomingBufferFactor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogBuffering",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogMessage_message(ctx context.Context, field graphql.CollectedField, obj *apimodels.LogMessage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogMessage_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogMessage_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogMessage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogMessage_severity(ctx context.Context, field graphql.CollectedField, obj *apimodels.LogMessage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogMessage_severity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Severity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogMessage_severity(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogMessage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogMessage_timestamp(ctx context.Context, field graphql.CollectedField, obj *apimodels.LogMessage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogMessage_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogMessage_timestamp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogMessage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogMessage_type(ctx context.Context, field graphql.CollectedField, obj *apimodels.LogMessage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogMessage_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogMessage_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogMessage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogMessage_version(ctx context.Context, field graphql.CollectedField, obj *apimodels.LogMessage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogMessage_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogMessage_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogMessage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoggerConfig_buffer(ctx context.Context, field graphql.CollectedField, obj *model.APILoggerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoggerConfig_buffer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Buffer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APILogBuffering)
	fc.Result = res
	return ec.marshalOLogBuffering2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPILogBuffering(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoggerConfig_buffer(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoggerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "useAsync":
				return ec.fieldContext_LogBuffering_useAsync(ctx, field)
			case "durationSeconds":
				return ec.fieldContext_LogBuffering_durationSeconds(ctx, field)
			case "count":
				return ec.fieldContext_LogBuffering_count(ctx, field)
			case "incomingBufferFactor":
				return ec.fieldContext_LogBuffering_incomingBufferFactor(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LogBuffering", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoggerConfig_defaultLevel(ctx context.Context, field graphql.CollectedField, obj *model.APILoggerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoggerConfig_defaultLevel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultLevel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOPriorityLevel2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoggerConfig_defaultLevel(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoggerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PriorityLevel does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoggerConfig_thresholdLevel(ctx context.Context, field graphql.CollectedField, obj *model.APILoggerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoggerConfig_thresholdLevel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ThresholdLevel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOPriorityLevel2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoggerConfig_thresholdLevel(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoggerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PriorityLevel does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoggerConfig_logkeeperURL(ctx context.Context, field graphql.CollectedField, obj *model.APILoggerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoggerConfig_logkeeperURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LogkeeperURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoggerConfig_logkeeperURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoggerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LoggerConfig_redactKeys(ctx context.Context, field graphql.CollectedField, obj *model.APILoggerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LoggerConfig_redactKeys(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RedactKeys, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalNString2ᚕᚖstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LoggerConfig_redactKeys(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LoggerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperBuild_id(ctx context.Context, field graphql.CollectedField, obj *plank.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperBuild_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperBuild_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperBuild_builder(ctx context.Context, field graphql.CollectedField, obj *plank.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperBuild_builder(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Builder, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperBuild_builder(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperBuild_buildNum(ctx context.Context, field graphql.CollectedField, obj *plank.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperBuild_buildNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperBuild_buildNum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperBuild_taskId(ctx context.Context, field graphql.CollectedField, obj *plank.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperBuild_taskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperBuild_taskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperBuild_taskExecution(ctx context.Context, field graphql.CollectedField, obj *plank.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperBuild_taskExecution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskExecution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperBuild_taskExecution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperBuild_tests(ctx context.Context, field graphql.CollectedField, obj *plank.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperBuild_tests(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tests, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]plank.Test)
	fc.Result = res
	return ec.marshalNLogkeeperTest2ᚕgithubᚗcomᚋevergreenᚑciᚋplankᚐTestᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperBuild_tests(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LogkeeperTest_id(ctx, field)
			case "name":
				return ec.fieldContext_LogkeeperTest_name(ctx, field)
			case "buildId":
				return ec.fieldContext_LogkeeperTest_buildId(ctx, field)
			case "taskId":
				return ec.fieldContext_LogkeeperTest_taskId(ctx, field)
			case "taskExecution":
				return ec.fieldContext_LogkeeperTest_taskExecution(ctx, field)
			case "phase":
				return ec.fieldContext_LogkeeperTest_phase(ctx, field)
			case "command":
				return ec.fieldContext_LogkeeperTest_command(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LogkeeperTest", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperBuild_task(ctx context.Context, field graphql.CollectedField, obj *plank.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperBuild_task(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.LogkeeperBuild().Task(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APITask)
	fc.Result = res
	return ec.marshalNTask2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperBuild_task(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperBuild",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperTest_id(ctx context.Context, field graphql.CollectedField, obj *plank.Test) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperTest_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperTest_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperTest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperTest_name(ctx context.Context, field graphql.CollectedField, obj *plank.Test) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperTest_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperTest_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperTest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperTest_buildId(ctx context.Context, field graphql.CollectedField, obj *plank.Test) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperTest_buildId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperTest_buildId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperTest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperTest_taskId(ctx context.Context, field graphql.CollectedField, obj *plank.Test) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperTest_taskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperTest_taskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperTest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperTest_taskExecution(ctx context.Context, field graphql.CollectedField, obj *plank.Test) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperTest_taskExecution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskExecution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperTest_taskExecution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperTest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperTest_phase(ctx context.Context, field graphql.CollectedField, obj *plank.Test) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperTest_phase(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Phase, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperTest_phase(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperTest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperTest_command(ctx context.Context, field graphql.CollectedField, obj *plank.Test) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperTest_command(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Command, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperTest_command(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperTest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MainlineCommitVersion_rolledUpVersions(ctx context.Context, field graphql.CollectedField, obj *MainlineCommitVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MainlineCommitVersion_rolledUpVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RolledUpVersions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.APIVersion)
	fc.Result = res
	return ec.marshalOVersion2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVersionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MainlineCommitVersion_rolledUpVersions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MainlineCommitVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "authorEmail":
				return ec.fieldContext_Version_authorEmail(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Version_generatedTaskCounts(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "ignored":
				return ec.fieldContext_Version_ignored(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			case "waterfallBuilds":
				return ec.fieldContext_Version_waterfallBuilds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MainlineCommitVersion_version(ctx context.Context, field graphql.CollectedField, obj *MainlineCommitVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MainlineCommitVersion_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIVersion)
	fc.Result = res
	return ec.marshalOVersion2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MainlineCommitVersion_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MainlineCommitVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "authorEmail":
				return ec.fieldContext_Version_authorEmail(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Version_generatedTaskCounts(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "ignored":
				return ec.fieldContext_Version_ignored(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			case "waterfallBuilds":
				return ec.fieldContext_Version_waterfallBuilds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MainlineCommits_nextPageOrderNumber(ctx context.Context, field graphql.CollectedField, obj *MainlineCommits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MainlineCommits_nextPageOrderNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextPageOrderNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MainlineCommits_nextPageOrderNumber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MainlineCommits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MainlineCommits_prevPageOrderNumber(ctx context.Context, field graphql.CollectedField, obj *MainlineCommits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MainlineCommits_prevPageOrderNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrevPageOrderNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MainlineCommits_prevPageOrderNumber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MainlineCommits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MainlineCommits_versions(ctx context.Context, field graphql.CollectedField, obj *MainlineCommits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MainlineCommits_versions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Versions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*MainlineCommitVersion)
	fc.Result = res
	return ec.marshalNMainlineCommitVersion2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐMainlineCommitVersionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MainlineCommits_versions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MainlineCommits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "rolledUpVersions":
				return ec.fieldContext_MainlineCommitVersion_rolledUpVersions(ctx, field)
			case "version":
				return ec.fieldContext_MainlineCommitVersion_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MainlineCommitVersion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Manifest_id(ctx context.Context, field graphql.CollectedField, obj *Manifest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Manifest_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Manifest_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Manifest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Manifest_branch(ctx context.Context, field graphql.CollectedField, obj *Manifest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Manifest_branch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Branch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Manifest_branch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Manifest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Manifest_isBase(ctx context.Context, field graphql.CollectedField, obj *Manifest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Manifest_isBase(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsBase, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Manifest_isBase(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Manifest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Manifest_moduleOverrides(ctx context.Context, field graphql.CollectedField, obj *Manifest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Manifest_moduleOverrides(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModuleOverrides, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]string)
	fc.Result = res
	return ec.marshalOStringMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Manifest_moduleOverrides(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Manifest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StringMap does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Manifest_modules(ctx context.Context, field graphql.CollectedField, obj *Manifest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Manifest_modules(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Modules, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]any)
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Manifest_modules(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Manifest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Manifest_project(ctx context.Context, field graphql.CollectedField, obj *Manifest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Manifest_project(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Project, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Manifest_project(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Manifest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Manifest_revision(ctx context.Context, field graphql.CollectedField, obj *Manifest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Manifest_revision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Manifest_revision(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Manifest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MetadataLink_url(ctx context.Context, field graphql.CollectedField, obj *model.APIMetadataLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MetadataLink_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MetadataLink_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MetadataLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MetadataLink_text(ctx context.Context, field graphql.CollectedField, obj *model.APIMetadataLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MetadataLink_text(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Text, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MetadataLink_text(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MetadataLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MetadataLink_source(ctx context.Context, field graphql.CollectedField, obj *model.APIMetadataLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MetadataLink_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APISource)
	fc.Result = res
	return ec.marshalOSource2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MetadataLink_source(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MetadataLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "author":
				return ec.fieldContext_Source_author(ctx, field)
			case "requester":
				return ec.fieldContext_Source_requester(ctx, field)
			case "time":
				return ec.fieldContext_Source_time(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Source", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModuleCodeChange_branchName(ctx context.Context, field graphql.CollectedField, obj *model.APIModulePatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModuleCodeChange_branchName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BranchName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModuleCodeChange_branchName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModuleCodeChange",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModuleCodeChange_fileDiffs(ctx context.Context, field graphql.CollectedField, obj *model.APIModulePatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModuleCodeChange_fileDiffs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileDiffs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.FileDiff)
	fc.Result = res
	return ec.marshalNFileDiff2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐFileDiffᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModuleCodeChange_fileDiffs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModuleCodeChange",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "additions":
				return ec.fieldContext_FileDiff_additions(ctx, field)
			case "deletions":
				return ec.fieldContext_FileDiff_deletions(ctx, field)
			case "description":
				return ec.fieldContext_FileDiff_description(ctx, field)
			case "diffLink":
				return ec.fieldContext_FileDiff_diffLink(ctx, field)
			case "fileName":
				return ec.fieldContext_FileDiff_fileName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FileDiff", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModuleCodeChange_htmlLink(ctx context.Context, field graphql.CollectedField, obj *model.APIModulePatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModuleCodeChange_htmlLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HTMLLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModuleCodeChange_htmlLink(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModuleCodeChange",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModuleCodeChange_rawLink(ctx context.Context, field graphql.CollectedField, obj *model.APIModulePatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModuleCodeChange_rawLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RawLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModuleCodeChange_rawLink(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModuleCodeChange",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MultiAuthConfig_readWrite(ctx context.Context, field graphql.CollectedField, obj *model.APIMultiAuthConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MultiAuthConfig_readWrite(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReadWrite, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MultiAuthConfig_readWrite(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MultiAuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MultiAuthConfig_readOnly(ctx context.Context, field graphql.CollectedField, obj *model.APIMultiAuthConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MultiAuthConfig_readOnly(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReadOnly, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MultiAuthConfig_readOnly(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MultiAuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_bbCreateTicket(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_bbCreateTicket(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().BbCreateTicket(rctx, fc.Args["taskId"].(string), fc.Args["execution"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_bbCreateTicket(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_bbCreateTicket_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addAnnotationIssue(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addAnnotationIssue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddAnnotationIssue(rctx, fc.Args["taskId"].(string), fc.Args["execution"].(int), fc.Args["apiIssue"].(model.APIIssueLink), fc.Args["isIssue"].(bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addAnnotationIssue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addAnnotationIssue_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_editAnnotationNote(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_editAnnotationNote(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().EditAnnotationNote(rctx, fc.Args["taskId"].(string), fc.Args["execution"].(int), fc.Args["originalMessage"].(string), fc.Args["newMessage"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_editAnnotationNote(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_editAnnotationNote_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_moveAnnotationIssue(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_moveAnnotationIssue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().MoveAnnotationIssue(rctx, fc.Args["taskId"].(string), fc.Args["execution"].(int), fc.Args["apiIssue"].(model.APIIssueLink), fc.Args["isIssue"].(bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_moveAnnotationIssue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_moveAnnotationIssue_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_removeAnnotationIssue(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_removeAnnotationIssue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RemoveAnnotationIssue(rctx, fc.Args["taskId"].(string), fc.Args["execution"].(int), fc.Args["apiIssue"].(model.APIIssueLink), fc.Args["isIssue"].(bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_removeAnnotationIssue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_removeAnnotationIssue_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setAnnotationMetadataLinks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_setAnnotationMetadataLinks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SetAnnotationMetadataLinks(rctx, fc.Args["taskId"].(string), fc.Args["execution"].(int), fc.Args["metadataLinks"].([]*model.APIMetadataLink))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_setAnnotationMetadataLinks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setAnnotationMetadataLinks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_saveAdminSettings(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_saveAdminSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().SaveAdminSettings(rctx, fc.Args["adminSettings"].(model.APIAdminSettings))
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.RequireAdmin == nil {
				var zeroVal *model.APIAdminSettings
				return zeroVal, errors.New("directive requireAdmin is not implemented")
			}
			return ec.directives.RequireAdmin(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.APIAdminSettings); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/evergreen-ci/evergreen/rest/model.APIAdminSettings`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIAdminSettings)
	fc.Result = res
	return ec.marshalNAdminSettings2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAdminSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_saveAdminSettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "amboy":
				return ec.fieldContext_AdminSettings_amboy(ctx, field)
			case "amboyDB":
				return ec.fieldContext_AdminSettings_amboyDB(ctx, field)
			case "authConfig":
				return ec.fieldContext_AdminSettings_authConfig(ctx, field)
			case "banner":
				return ec.fieldContext_AdminSettings_banner(ctx, field)
			case "bannerTheme":
				return ec.fieldContext_AdminSettings_bannerTheme(ctx, field)
			case "cedar":
				return ec.fieldContext_AdminSettings_cedar(ctx, field)
			case "fws":
				return ec.fieldContext_AdminSettings_fws(ctx, field)
			case "jira":
				return ec.fieldContext_AdminSettings_jira(ctx, field)
			case "slack":
				return ec.fieldContext_AdminSettings_slack(ctx, field)
			case "splunk":
				return ec.fieldContext_AdminSettings_splunk(ctx, field)
			case "runtimeEnvironments":
				return ec.fieldContext_AdminSettings_runtimeEnvironments(ctx, field)
			case "testSelection":
				return ec.fieldContext_AdminSettings_testSelection(ctx, field)
			case "serviceFlags":
				return ec.fieldContext_AdminSettings_serviceFlags(ctx, field)
			case "notify":
				return ec.fieldContext_AdminSettings_notify(ctx, field)
			case "taskLimits":
				return ec.fieldContext_AdminSettings_taskLimits(ctx, field)
			case "hostInit":
				return ec.fieldContext_AdminSettings_hostInit(ctx, field)
			case "podLifecycle":
				return ec.fieldContext_AdminSettings_podLifecycle(ctx, field)
			case "scheduler":
				return ec.fieldContext_AdminSettings_scheduler(ctx, field)
			case "repotracker":
				return ec.fieldContext_AdminSettings_repotracker(ctx, field)
			case "api":
				return ec.fieldContext_AdminSettings_api(ctx, field)
			case "ui":
				return ec.fieldContext_AdminSettings_ui(ctx, field)
			case "disabledGQLQueries":
				return ec.fieldContext_AdminSettings_disabledGQLQueries(ctx, field)
			case "loggerConfig":
				return ec.fieldContext_AdminSettings_loggerConfig(ctx, field)
			case "triggers":
				return ec.fieldContext_AdminSettings_triggers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdminSettings", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_saveAdminSettings_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_restartAdminTasks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_restartAdminTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Mutation().RestartAdminTasks(rctx, fc.Args["opts"].(model1.RestartOptions))
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.RequireAdmin == nil {
				var zeroVal *RestartAdminTasksPayload
				return zeroVal, errors.New("directive requireAdmin is not implemented")
			}
			return ec.directives.RequireAdmin(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*RestartAdminTasksPayload); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/evergreen-ci/evergreen/graphql.RestartAdminTasksPayload`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*RestartAdminTasksPayload)
	fc.Result = res
	return ec.marshalNRestartAdminTasksPayload2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐRestartAdminTasksPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_restartAdminTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "numRestartedTasks":
				return ec.fieldContext_RestartAdminTasksPayload_numRestartedTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RestartAdminTasksPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_restartAdminTasks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteDistro(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteDistro(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteDistro(rctx, fc.Args["opts"].(DeleteDistroInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*DeleteDistroPayload)
	fc.Result = res
	return ec.marshalNDeleteDistroPayload2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDeleteDistroPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteDistro(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "deletedDistroId":
				return ec.fieldContext_DeleteDistroPayload_deletedDistroId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeleteDistroPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteDistro_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_copyDistro(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_copyDistro(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CopyDistro(rctx, fc.Args["opts"].(model.CopyDistroOpts))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*NewDistroPayload)
	fc.Result = res
	return ec.marshalNNewDistroPayload2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐNewDistroPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_copyDistro(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "newDistroId":
				return ec.fieldContext_NewDistroPayload_newDistroId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NewDistroPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_copyDistro_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createDistro(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createDistro(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateDistro(rctx, fc.Args["opts"].(CreateDistroInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*NewDistroPayload)
	fc.Result = res
	return ec.marshalNNewDistroPayload2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐNewDistroPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createDistro(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "newDistroId":
				return ec.fieldContext_NewDistroPayload_newDistroId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NewDistroPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createDistro_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_saveDistro(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_saveDistro(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SaveDistro(rctx, fc.Args["opts"].(SaveDistroInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*SaveDistroPayload)
	fc.Result = res
	return ec.marshalNSaveDistroPayload2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSaveDistroPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_saveDistro(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "distro":
				return ec.fieldContext_SaveDistroPayload_distro(ctx, field)
			case "hostCount":
				return ec.fieldContext_SaveDistroPayload_hostCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SaveDistroPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_saveDistro_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_reprovisionToNew(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_reprovisionToNew(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ReprovisionToNew(rctx, fc.Args["hostIds"].([]string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_reprovisionToNew(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_reprovisionToNew_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_restartJasper(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_restartJasper(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RestartJasper(rctx, fc.Args["hostIds"].([]string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_restartJasper(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_restartJasper_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateHostStatus(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateHostStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateHostStatus(rctx, fc.Args["hostIds"].([]string), fc.Args["status"].(string), fc.Args["notes"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateHostStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateHostStatus_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setPatchVisibility(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_setPatchVisibility(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SetPatchVisibility(rctx, fc.Args["patchIds"].([]string), fc.Args["hidden"].(bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIPatch)
	fc.Result = res
	return ec.marshalNPatch2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatchᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_setPatchVisibility(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Patch_id(ctx, field)
			case "activated":
				return ec.fieldContext_Patch_activated(ctx, field)
			case "alias":
				return ec.fieldContext_Patch_alias(ctx, field)
			case "author":
				return ec.fieldContext_Patch_author(ctx, field)
			case "authorDisplayName":
				return ec.fieldContext_Patch_authorDisplayName(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Patch_baseTaskStatuses(ctx, field)
			case "builds":
				return ec.fieldContext_Patch_builds(ctx, field)
			case "childPatchAliases":
				return ec.fieldContext_Patch_childPatchAliases(ctx, field)
			case "childPatches":
				return ec.fieldContext_Patch_childPatches(ctx, field)
			case "createTime":
				return ec.fieldContext_Patch_createTime(ctx, field)
			case "description":
				return ec.fieldContext_Patch_description(ctx, field)
			case "duration":
				return ec.fieldContext_Patch_duration(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Patch_generatedTaskCounts(ctx, field)
			case "githash":
				return ec.fieldContext_Patch_githash(ctx, field)
			case "githubPatchData":
				return ec.fieldContext_Patch_githubPatchData(ctx, field)
			case "hidden":
				return ec.fieldContext_Patch_hidden(ctx, field)
			case "moduleCodeChanges":
				return ec.fieldContext_Patch_moduleCodeChanges(ctx, field)
			case "parameters":
				return ec.fieldContext_Patch_parameters(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Patch_patchNumber(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Patch_patchTriggerAliases(ctx, field)
			case "project":
				return ec.fieldContext_Patch_project(ctx, field)
			case "projectID":
				return ec.fieldContext_Patch_projectID(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Patch_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Patch_projectMetadata(ctx, field)
			case "status":
				return ec.fieldContext_Patch_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Patch_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Patch_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Patch_taskStatuses(ctx, field)
			case "time":
				return ec.fieldContext_Patch_time(ctx, field)
			case "variants":
				return ec.fieldContext_Patch_variants(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_Patch_variantsTasks(ctx, field)
			case "versionFull":
				return ec.fieldContext_Patch_versionFull(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Patch", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setPatchVisibility_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_schedulePatch(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_schedulePatch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SchedulePatch(rctx, fc.Args["patchId"].(string), fc.Args["configure"].(PatchConfigure))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIPatch)
	fc.Result = res
	return ec.marshalNPatch2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_schedulePatch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Patch_id(ctx, field)
			case "activated":
				return ec.fieldContext_Patch_activated(ctx, field)
			case "alias":
				return ec.fieldContext_Patch_alias(ctx, field)
			case "author":
				return ec.fieldContext_Patch_author(ctx, field)
			case "authorDisplayName":
				return ec.fieldContext_Patch_authorDisplayName(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Patch_baseTaskStatuses(ctx, field)
			case "builds":
				return ec.fieldContext_Patch_builds(ctx, field)
			case "childPatchAliases":
				return ec.fieldContext_Patch_childPatchAliases(ctx, field)
			case "childPatches":
				return ec.fieldContext_Patch_childPatches(ctx, field)
			case "createTime":
				return ec.fieldContext_Patch_createTime(ctx, field)
			case "description":
				return ec.fieldContext_Patch_description(ctx, field)
			case "duration":
				return ec.fieldContext_Patch_duration(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Patch_generatedTaskCounts(ctx, field)
			case "githash":
				return ec.fieldContext_Patch_githash(ctx, field)
			case "githubPatchData":
				return ec.fieldContext_Patch_githubPatchData(ctx, field)
			case "hidden":
				return ec.fieldContext_Patch_hidden(ctx, field)
			case "moduleCodeChanges":
				return ec.fieldContext_Patch_moduleCodeChanges(ctx, field)
			case "parameters":
				return ec.fieldContext_Patch_parameters(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Patch_patchNumber(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Patch_patchTriggerAliases(ctx, field)
			case "project":
				return ec.fieldContext_Patch_project(ctx, field)
			case "projectID":
				return ec.fieldContext_Patch_projectID(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Patch_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Patch_projectMetadata(ctx, field)
			case "status":
				return ec.fieldContext_Patch_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Patch_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Patch_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Patch_taskStatuses(ctx, field)
			case "time":
				return ec.fieldContext_Patch_time(ctx, field)
			case "variants":
				return ec.fieldContext_Patch_variants(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_Patch_variantsTasks(ctx, field)
			case "versionFull":
				return ec.fieldContext_Patch_versionFull(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Patch", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_schedulePatch_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_attachProjectToNewRepo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_attachProjectToNewRepo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AttachProjectToNewRepo(rctx, fc.Args["project"].(MoveProjectInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectRef)
	fc.Result = res
	return ec.marshalNProject2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_attachProjectToNewRepo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "githubPRTriggerAliases":
				return ec.fieldContext_Project_githubPRTriggerAliases(ctx, field)
			case "githubMQTriggerAliases":
				return ec.fieldContext_Project_githubMQTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_attachProjectToNewRepo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_attachProjectToRepo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_attachProjectToRepo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AttachProjectToRepo(rctx, fc.Args["projectId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectRef)
	fc.Result = res
	return ec.marshalNProject2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_attachProjectToRepo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "githubPRTriggerAliases":
				return ec.fieldContext_Project_githubPRTriggerAliases(ctx, field)
			case "githubMQTriggerAliases":
				return ec.fieldContext_Project_githubMQTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_attachProjectToRepo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createProject(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createProject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateProject(rctx, fc.Args["project"].(model.APIProjectRef), fc.Args["requestS3Creds"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectRef)
	fc.Result = res
	return ec.marshalNProject2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createProject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "githubPRTriggerAliases":
				return ec.fieldContext_Project_githubPRTriggerAliases(ctx, field)
			case "githubMQTriggerAliases":
				return ec.fieldContext_Project_githubMQTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createProject_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_copyProject(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_copyProject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CopyProject(rctx, fc.Args["project"].(model.CopyProjectOpts), fc.Args["requestS3Creds"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectRef)
	fc.Result = res
	return ec.marshalNProject2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_copyProject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "githubPRTriggerAliases":
				return ec.fieldContext_Project_githubPRTriggerAliases(ctx, field)
			case "githubMQTriggerAliases":
				return ec.fieldContext_Project_githubMQTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_copyProject_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deactivateStepbackTask(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deactivateStepbackTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeactivateStepbackTask(rctx, fc.Args["opts"].(DeactivateStepbackTaskInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deactivateStepbackTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deactivateStepbackTask_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_defaultSectionToRepo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_defaultSectionToRepo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DefaultSectionToRepo(rctx, fc.Args["opts"].(DefaultSectionToRepoInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_defaultSectionToRepo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_defaultSectionToRepo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteGithubAppCredentials(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteGithubAppCredentials(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteGithubAppCredentials(rctx, fc.Args["opts"].(DeleteGithubAppCredentialsInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*DeleteGithubAppCredentialsPayload)
	fc.Result = res
	return ec.marshalODeleteGithubAppCredentialsPayload2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDeleteGithubAppCredentialsPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteGithubAppCredentials(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "oldAppId":
				return ec.fieldContext_DeleteGithubAppCredentialsPayload_oldAppId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeleteGithubAppCredentialsPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteGithubAppCredentials_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteProject(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteProject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteProject(rctx, fc.Args["projectId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteProject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteProject_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_detachProjectFromRepo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_detachProjectFromRepo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DetachProjectFromRepo(rctx, fc.Args["projectId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectRef)
	fc.Result = res
	return ec.marshalNProject2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_detachProjectFromRepo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "githubPRTriggerAliases":
				return ec.fieldContext_Project_githubPRTriggerAliases(ctx, field)
			case "githubMQTriggerAliases":
				return ec.fieldContext_Project_githubMQTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_detachProjectFromRepo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_forceRepotrackerRun(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_forceRepotrackerRun(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ForceRepotrackerRun(rctx, fc.Args["projectId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_forceRepotrackerRun(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_forceRepotrackerRun_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_promoteVarsToRepo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_promoteVarsToRepo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().PromoteVarsToRepo(rctx, fc.Args["opts"].(PromoteVarsToRepoInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_promoteVarsToRepo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_promoteVarsToRepo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_saveProjectSettingsForSection(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_saveProjectSettingsForSection(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SaveProjectSettingsForSection(rctx, fc.Args["projectSettings"].(*model.APIProjectSettings), fc.Args["section"].(ProjectSettingsSection))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectSettings)
	fc.Result = res
	return ec.marshalNProjectSettings2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_saveProjectSettingsForSection(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aliases":
				return ec.fieldContext_ProjectSettings_aliases(ctx, field)
			case "githubAppAuth":
				return ec.fieldContext_ProjectSettings_githubAppAuth(ctx, field)
			case "githubWebhooksEnabled":
				return ec.fieldContext_ProjectSettings_githubWebhooksEnabled(ctx, field)
			case "projectRef":
				return ec.fieldContext_ProjectSettings_projectRef(ctx, field)
			case "subscriptions":
				return ec.fieldContext_ProjectSettings_subscriptions(ctx, field)
			case "vars":
				return ec.fieldContext_ProjectSettings_vars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectSettings", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_saveProjectSettingsForSection_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_saveRepoSettingsForSection(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_saveRepoSettingsForSection(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SaveRepoSettingsForSection(rctx, fc.Args["repoSettings"].(*model.APIProjectSettings), fc.Args["section"].(ProjectSettingsSection))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectSettings)
	fc.Result = res
	return ec.marshalNRepoSettings2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_saveRepoSettingsForSection(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aliases":
				return ec.fieldContext_RepoSettings_aliases(ctx, field)
			case "githubAppAuth":
				return ec.fieldContext_RepoSettings_githubAppAuth(ctx, field)
			case "githubWebhooksEnabled":
				return ec.fieldContext_RepoSettings_githubWebhooksEnabled(ctx, field)
			case "projectRef":
				return ec.fieldContext_RepoSettings_projectRef(ctx, field)
			case "subscriptions":
				return ec.fieldContext_RepoSettings_subscriptions(ctx, field)
			case "vars":
				return ec.fieldContext_RepoSettings_vars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepoSettings", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_saveRepoSettingsForSection_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setLastRevision(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_setLastRevision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SetLastRevision(rctx, fc.Args["opts"].(SetLastRevisionInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*SetLastRevisionPayload)
	fc.Result = res
	return ec.marshalNSetLastRevisionPayload2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSetLastRevisionPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_setLastRevision(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "mergeBaseRevision":
				return ec.fieldContext_SetLastRevisionPayload_mergeBaseRevision(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SetLastRevisionPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setLastRevision_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_attachVolumeToHost(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_attachVolumeToHost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AttachVolumeToHost(rctx, fc.Args["volumeAndHost"].(VolumeHost))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_attachVolumeToHost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_attachVolumeToHost_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_detachVolumeFromHost(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_detachVolumeFromHost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DetachVolumeFromHost(rctx, fc.Args["volumeId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_detachVolumeFromHost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_detachVolumeFromHost_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_editSpawnHost(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_editSpawnHost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().EditSpawnHost(rctx, fc.Args["spawnHost"].(*EditSpawnHostInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIHost)
	fc.Result = res
	return ec.marshalNHost2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_editSpawnHost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "availabilityZone":
				return ec.fieldContext_Host_availabilityZone(ctx, field)
			case "ami":
				return ec.fieldContext_Host_ami(ctx, field)
			case "displayName":
				return ec.fieldContext_Host_displayName(ctx, field)
			case "distro":
				return ec.fieldContext_Host_distro(ctx, field)
			case "distroId":
				return ec.fieldContext_Host_distroId(ctx, field)
			case "elapsed":
				return ec.fieldContext_Host_elapsed(ctx, field)
			case "events":
				return ec.fieldContext_Host_events(ctx, field)
			case "eventTypes":
				return ec.fieldContext_Host_eventTypes(ctx, field)
			case "expiration":
				return ec.fieldContext_Host_expiration(ctx, field)
			case "hostUrl":
				return ec.fieldContext_Host_hostUrl(ctx, field)
			case "homeVolume":
				return ec.fieldContext_Host_homeVolume(ctx, field)
			case "homeVolumeID":
				return ec.fieldContext_Host_homeVolumeID(ctx, field)
			case "instanceType":
				return ec.fieldContext_Host_instanceType(ctx, field)
			case "instanceTags":
				return ec.fieldContext_Host_instanceTags(ctx, field)
			case "lastCommunicationTime":
				return ec.fieldContext_Host_lastCommunicationTime(ctx, field)
			case "noExpiration":
				return ec.fieldContext_Host_noExpiration(ctx, field)
			case "persistentDnsName":
				return ec.fieldContext_Host_persistentDnsName(ctx, field)
			case "provider":
				return ec.fieldContext_Host_provider(ctx, field)
			case "runningTask":
				return ec.fieldContext_Host_runningTask(ctx, field)
			case "sleepSchedule":
				return ec.fieldContext_Host_sleepSchedule(ctx, field)
			case "startedBy":
				return ec.fieldContext_Host_startedBy(ctx, field)
			case "status":
				return ec.fieldContext_Host_status(ctx, field)
			case "tag":
				return ec.fieldContext_Host_tag(ctx, field)
			case "totalIdleTime":
				return ec.fieldContext_Host_totalIdleTime(ctx, field)
			case "uptime":
				return ec.fieldContext_Host_uptime(ctx, field)
			case "user":
				return ec.fieldContext_Host_user(ctx, field)
			case "volumes":
				return ec.fieldContext_Host_volumes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_editSpawnHost_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_migrateVolume(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_migrateVolume(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().MigrateVolume(rctx, fc.Args["volumeId"].(string), fc.Args["spawnHostInput"].(*SpawnHostInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_migrateVolume(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_migrateVolume_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_spawnHost(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_spawnHost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SpawnHost(rctx, fc.Args["spawnHostInput"].(*SpawnHostInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIHost)
	fc.Result = res
	return ec.marshalNHost2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_spawnHost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "availabilityZone":
				return ec.fieldContext_Host_availabilityZone(ctx, field)
			case "ami":
				return ec.fieldContext_Host_ami(ctx, field)
			case "displayName":
				return ec.fieldContext_Host_displayName(ctx, field)
			case "distro":
				return ec.fieldContext_Host_distro(ctx, field)
			case "distroId":
				return ec.fieldContext_Host_distroId(ctx, field)
			case "elapsed":
				return ec.fieldContext_Host_elapsed(ctx, field)
			case "events":
				return ec.fieldContext_Host_events(ctx, field)
			case "eventTypes":
				return ec.fieldContext_Host_eventTypes(ctx, field)
			case "expiration":
				return ec.fieldContext_Host_expiration(ctx, field)
			case "hostUrl":
				return ec.fieldContext_Host_hostUrl(ctx, field)
			case "homeVolume":
				return ec.fieldContext_Host_homeVolume(ctx, field)
			case "homeVolumeID":
				return ec.fieldContext_Host_homeVolumeID(ctx, field)
			case "instanceType":
				return ec.fieldContext_Host_instanceType(ctx, field)
			case "instanceTags":
				return ec.fieldContext_Host_instanceTags(ctx, field)
			case "lastCommunicationTime":
				return ec.fieldContext_Host_lastCommunicationTime(ctx, field)
			case "noExpiration":
				return ec.fieldContext_Host_noExpiration(ctx, field)
			case "persistentDnsName":
				return ec.fieldContext_Host_persistentDnsName(ctx, field)
			case "provider":
				return ec.fieldContext_Host_provider(ctx, field)
			case "runningTask":
				return ec.fieldContext_Host_runningTask(ctx, field)
			case "sleepSchedule":
				return ec.fieldContext_Host_sleepSchedule(ctx, field)
			case "startedBy":
				return ec.fieldContext_Host_startedBy(ctx, field)
			case "status":
				return ec.fieldContext_Host_status(ctx, field)
			case "tag":
				return ec.fieldContext_Host_tag(ctx, field)
			case "totalIdleTime":
				return ec.fieldContext_Host_totalIdleTime(ctx, field)
			case "uptime":
				return ec.fieldContext_Host_uptime(ctx, field)
			case "user":
				return ec.fieldContext_Host_user(ctx, field)
			case "volumes":
				return ec.fieldContext_Host_volumes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_spawnHost_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_spawnVolume(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_spawnVolume(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SpawnVolume(rctx, fc.Args["spawnVolumeInput"].(SpawnVolumeInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_spawnVolume(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_spawnVolume_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_removeVolume(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_removeVolume(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RemoveVolume(rctx, fc.Args["volumeId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_removeVolume(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_removeVolume_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateSpawnHostStatus(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateSpawnHostStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateSpawnHostStatus(rctx, fc.Args["updateSpawnHostStatusInput"].(UpdateSpawnHostStatusInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIHost)
	fc.Result = res
	return ec.marshalNHost2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateSpawnHostStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "availabilityZone":
				return ec.fieldContext_Host_availabilityZone(ctx, field)
			case "ami":
				return ec.fieldContext_Host_ami(ctx, field)
			case "displayName":
				return ec.fieldContext_Host_displayName(ctx, field)
			case "distro":
				return ec.fieldContext_Host_distro(ctx, field)
			case "distroId":
				return ec.fieldContext_Host_distroId(ctx, field)
			case "elapsed":
				return ec.fieldContext_Host_elapsed(ctx, field)
			case "events":
				return ec.fieldContext_Host_events(ctx, field)
			case "eventTypes":
				return ec.fieldContext_Host_eventTypes(ctx, field)
			case "expiration":
				return ec.fieldContext_Host_expiration(ctx, field)
			case "hostUrl":
				return ec.fieldContext_Host_hostUrl(ctx, field)
			case "homeVolume":
				return ec.fieldContext_Host_homeVolume(ctx, field)
			case "homeVolumeID":
				return ec.fieldContext_Host_homeVolumeID(ctx, field)
			case "instanceType":
				return ec.fieldContext_Host_instanceType(ctx, field)
			case "instanceTags":
				return ec.fieldContext_Host_instanceTags(ctx, field)
			case "lastCommunicationTime":
				return ec.fieldContext_Host_lastCommunicationTime(ctx, field)
			case "noExpiration":
				return ec.fieldContext_Host_noExpiration(ctx, field)
			case "persistentDnsName":
				return ec.fieldContext_Host_persistentDnsName(ctx, field)
			case "provider":
				return ec.fieldContext_Host_provider(ctx, field)
			case "runningTask":
				return ec.fieldContext_Host_runningTask(ctx, field)
			case "sleepSchedule":
				return ec.fieldContext_Host_sleepSchedule(ctx, field)
			case "startedBy":
				return ec.fieldContext_Host_startedBy(ctx, field)
			case "status":
				return ec.fieldContext_Host_status(ctx, field)
			case "tag":
				return ec.fieldContext_Host_tag(ctx, field)
			case "totalIdleTime":
				return ec.fieldContext_Host_totalIdleTime(ctx, field)
			case "uptime":
				return ec.fieldContext_Host_uptime(ctx, field)
			case "user":
				return ec.fieldContext_Host_user(ctx, field)
			case "volumes":
				return ec.fieldContext_Host_volumes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateSpawnHostStatus_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateVolume(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateVolume(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateVolume(rctx, fc.Args["updateVolumeInput"].(UpdateVolumeInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateVolume(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateVolume_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_abortTask(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_abortTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AbortTask(rctx, fc.Args["taskId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APITask)
	fc.Result = res
	return ec.marshalNTask2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_abortTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_abortTask_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_overrideTaskDependencies(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_overrideTaskDependencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().OverrideTaskDependencies(rctx, fc.Args["taskId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APITask)
	fc.Result = res
	return ec.marshalNTask2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_overrideTaskDependencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_overrideTaskDependencies_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_restartTask(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_restartTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RestartTask(rctx, fc.Args["taskId"].(string), fc.Args["failedOnly"].(bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APITask)
	fc.Result = res
	return ec.marshalNTask2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_restartTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_restartTask_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_scheduleTasks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_scheduleTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ScheduleTasks(rctx, fc.Args["versionId"].(string), fc.Args["taskIds"].([]string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APITask)
	fc.Result = res
	return ec.marshalNTask2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_scheduleTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_scheduleTasks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setTaskPriority(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_setTaskPriority(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SetTaskPriority(rctx, fc.Args["taskId"].(string), fc.Args["priority"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APITask)
	fc.Result = res
	return ec.marshalNTask2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_setTaskPriority(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setTaskPriority_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setTaskPriorities(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_setTaskPriorities(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SetTaskPriorities(rctx, fc.Args["taskPriorities"].([]*TaskPriority))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APITask)
	fc.Result = res
	return ec.marshalNTask2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_setTaskPriorities(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setTaskPriorities_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_unscheduleTask(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_unscheduleTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UnscheduleTask(rctx, fc.Args["taskId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APITask)
	fc.Result = res
	return ec.marshalNTask2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_unscheduleTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_unscheduleTask_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addFavoriteProject(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addFavoriteProject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddFavoriteProject(rctx, fc.Args["opts"].(AddFavoriteProjectInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectRef)
	fc.Result = res
	return ec.marshalNProject2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addFavoriteProject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "githubPRTriggerAliases":
				return ec.fieldContext_Project_githubPRTriggerAliases(ctx, field)
			case "githubMQTriggerAliases":
				return ec.fieldContext_Project_githubMQTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addFavoriteProject_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_clearMySubscriptions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_clearMySubscriptions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ClearMySubscriptions(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_clearMySubscriptions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createPublicKey(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createPublicKey(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreatePublicKey(rctx, fc.Args["publicKeyInput"].(PublicKeyInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIPubKey)
	fc.Result = res
	return ec.marshalNPublicKey2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPubKeyᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createPublicKey(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_PublicKey_key(ctx, field)
			case "name":
				return ec.fieldContext_PublicKey_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PublicKey", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createPublicKey_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteSubscriptions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteSubscriptions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteSubscriptions(rctx, fc.Args["subscriptionIds"].([]string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteSubscriptions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteSubscriptions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_removeFavoriteProject(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_removeFavoriteProject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RemoveFavoriteProject(rctx, fc.Args["opts"].(RemoveFavoriteProjectInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectRef)
	fc.Result = res
	return ec.marshalNProject2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_removeFavoriteProject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "githubPRTriggerAliases":
				return ec.fieldContext_Project_githubPRTriggerAliases(ctx, field)
			case "githubMQTriggerAliases":
				return ec.fieldContext_Project_githubMQTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_removeFavoriteProject_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_removePublicKey(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_removePublicKey(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RemovePublicKey(rctx, fc.Args["keyName"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIPubKey)
	fc.Result = res
	return ec.marshalNPublicKey2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPubKeyᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_removePublicKey(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_PublicKey_key(ctx, field)
			case "name":
				return ec.fieldContext_PublicKey_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PublicKey", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_removePublicKey_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_saveSubscription(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_saveSubscription(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SaveSubscription(rctx, fc.Args["subscription"].(model.APISubscription))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_saveSubscription(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_saveSubscription_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateBetaFeatures(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateBetaFeatures(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateBetaFeatures(rctx, fc.Args["opts"].(UpdateBetaFeaturesInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*UpdateBetaFeaturesPayload)
	fc.Result = res
	return ec.marshalOUpdateBetaFeaturesPayload2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐUpdateBetaFeaturesPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateBetaFeatures(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "betaFeatures":
				return ec.fieldContext_UpdateBetaFeaturesPayload_betaFeatures(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateBetaFeaturesPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateBetaFeatures_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateParsleySettings(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateParsleySettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateParsleySettings(rctx, fc.Args["opts"].(UpdateParsleySettingsInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*UpdateParsleySettingsPayload)
	fc.Result = res
	return ec.marshalOUpdateParsleySettingsPayload2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐUpdateParsleySettingsPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateParsleySettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "parsleySettings":
				return ec.fieldContext_UpdateParsleySettingsPayload_parsleySettings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpdateParsleySettingsPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateParsleySettings_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updatePublicKey(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updatePublicKey(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdatePublicKey(rctx, fc.Args["targetKeyName"].(string), fc.Args["updateInfo"].(PublicKeyInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIPubKey)
	fc.Result = res
	return ec.marshalNPublicKey2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPubKeyᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updatePublicKey(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_PublicKey_key(ctx, field)
			case "name":
				return ec.fieldContext_PublicKey_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PublicKey", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updatePublicKey_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateUserSettings(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateUserSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateUserSettings(rctx, fc.Args["userSettings"].(*model.APIUserSettings))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateUserSettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateUserSettings_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_restartVersions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_restartVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RestartVersions(rctx, fc.Args["versionId"].(string), fc.Args["abort"].(bool), fc.Args["versionsToRestart"].([]*model1.VersionToRestart))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.APIVersion)
	fc.Result = res
	return ec.marshalOVersion2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVersionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_restartVersions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "authorEmail":
				return ec.fieldContext_Version_authorEmail(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Version_generatedTaskCounts(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "ignored":
				return ec.fieldContext_Version_ignored(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			case "waterfallBuilds":
				return ec.fieldContext_Version_waterfallBuilds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_restartVersions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_scheduleUndispatchedBaseTasks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_scheduleUndispatchedBaseTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ScheduleUndispatchedBaseTasks(rctx, fc.Args["versionId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.APITask)
	fc.Result = res
	return ec.marshalOTask2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_scheduleUndispatchedBaseTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_scheduleUndispatchedBaseTasks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setVersionPriority(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_setVersionPriority(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SetVersionPriority(rctx, fc.Args["versionId"].(string), fc.Args["priority"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_setVersionPriority(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setVersionPriority_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_unscheduleVersionTasks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_unscheduleVersionTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UnscheduleVersionTasks(rctx, fc.Args["versionId"].(string), fc.Args["abort"].(bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_unscheduleVersionTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_unscheduleVersionTasks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _NaiveAuthConfig_users(ctx context.Context, field graphql.CollectedField, obj *model.APINaiveAuthConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NaiveAuthConfig_users(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Users, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APIAuthUser)
	fc.Result = res
	return ec.marshalNAuthUser2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAuthUserᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NaiveAuthConfig_users(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NaiveAuthConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "username":
				return ec.fieldContext_AuthUser_username(ctx, field)
			case "displayName":
				return ec.fieldContext_AuthUser_displayName(ctx, field)
			case "password":
				return ec.fieldContext_AuthUser_password(ctx, field)
			case "email":
				return ec.fieldContext_AuthUser_email(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AuthUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NewDistroPayload_newDistroId(ctx context.Context, field graphql.CollectedField, obj *NewDistroPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NewDistroPayload_newDistroId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewDistroID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NewDistroPayload_newDistroId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NewDistroPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Note_message(ctx context.Context, field graphql.CollectedField, obj *model.APINote) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Note_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Note_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Note",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Note_source(ctx context.Context, field graphql.CollectedField, obj *model.APINote) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Note_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APISource)
	fc.Result = res
	return ec.marshalNSource2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Note_source(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Note",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "author":
				return ec.fieldContext_Source_author(ctx, field)
			case "requester":
				return ec.fieldContext_Source_requester(ctx, field)
			case "time":
				return ec.fieldContext_Source_time(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Source", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_buildBreak(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notifications_buildBreak(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildBreak, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notifications_buildBreak(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_buildBreakId(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notifications_buildBreakId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildBreakID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notifications_buildBreakId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_patchFinish(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notifications_patchFinish(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PatchFinish, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notifications_patchFinish(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_patchFinishId(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notifications_patchFinishId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PatchFinishID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notifications_patchFinishId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_patchFirstFailure(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notifications_patchFirstFailure(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PatchFirstFailure, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notifications_patchFirstFailure(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_patchFirstFailureId(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notifications_patchFirstFailureId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PatchFirstFailureID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notifications_patchFirstFailureId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_spawnHostExpiration(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notifications_spawnHostExpiration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpawnHostExpiration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notifications_spawnHostExpiration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_spawnHostExpirationId(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notifications_spawnHostExpirationId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpawnHostExpirationID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notifications_spawnHostExpirationId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_spawnHostOutcome(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notifications_spawnHostOutcome(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpawnHostOutcome, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notifications_spawnHostOutcome(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_spawnHostOutcomeId(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notifications_spawnHostOutcomeId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpawnHostOutcomeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notifications_spawnHostOutcomeId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotifyConfig_ses(ctx context.Context, field graphql.CollectedField, obj *model.APINotifyConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotifyConfig_ses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.SES, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.RequireAdmin == nil {
				var zeroVal model.APISESConfig
				return zeroVal, errors.New("directive requireAdmin is not implemented")
			}
			return ec.directives.RequireAdmin(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.APISESConfig); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/rest/model.APISESConfig`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.APISESConfig)
	fc.Result = res
	return ec.marshalOSESConfig2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISESConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotifyConfig_ses(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotifyConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "senderAddress":
				return ec.fieldContext_SESConfig_senderAddress(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SESConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotifyConfig_bufferTargetPerInterval(ctx context.Context, field graphql.CollectedField, obj *model.APINotifyConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotifyConfig_bufferTargetPerInterval(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BufferTargetPerInterval, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotifyConfig_bufferTargetPerInterval(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotifyConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _NotifyConfig_bufferIntervalSeconds(ctx context.Context, field graphql.CollectedField, obj *model.APINotifyConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NotifyConfig_bufferIntervalSeconds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BufferIntervalSeconds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NotifyConfig_bufferIntervalSeconds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NotifyConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OSInfo_name(ctx context.Context, field graphql.CollectedField, obj *model.APIOSInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OSInfo_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OSInfo_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OSInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OSInfo_version(ctx context.Context, field graphql.CollectedField, obj *model.APIOSInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OSInfo_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OSInfo_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OSInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OktaConfig_clientId(ctx context.Context, field graphql.CollectedField, obj *model.APIOktaConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OktaConfig_clientId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ClientID, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.RequireAdmin == nil {
				var zeroVal *string
				return zeroVal, errors.New("directive requireAdmin is not implemented")
			}
			return ec.directives.RequireAdmin(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OktaConfig_clientId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OktaConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OktaConfig_clientSecret(ctx context.Context, field graphql.CollectedField, obj *model.APIOktaConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OktaConfig_clientSecret(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ClientSecret, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.RequireAdmin == nil {
				var zeroVal *string
				return zeroVal, errors.New("directive requireAdmin is not implemented")
			}
			return ec.directives.RequireAdmin(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OktaConfig_clientSecret(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OktaConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OktaConfig_issuer(ctx context.Context, field graphql.CollectedField, obj *model.APIOktaConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OktaConfig_issuer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Issuer, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.RequireAdmin == nil {
				var zeroVal *string
				return zeroVal, errors.New("directive requireAdmin is not implemented")
			}
			return ec.directives.RequireAdmin(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OktaConfig_issuer(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OktaConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OktaConfig_scopes(ctx context.Context, field graphql.CollectedField, obj *model.APIOktaConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OktaConfig_scopes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Scopes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OktaConfig_scopes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OktaConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OktaConfig_userGroup(ctx context.Context, field graphql.CollectedField, obj *model.APIOktaConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OktaConfig_userGroup(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserGroup, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OktaConfig_userGroup(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OktaConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OktaConfig_expireAfterMinutes(ctx context.Context, field graphql.CollectedField, obj *model.APIOktaConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OktaConfig_expireAfterMinutes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpireAfterMinutes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OktaConfig_expireAfterMinutes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OktaConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OomTrackerInfo_detected(ctx context.Context, field graphql.CollectedField, obj *model.APIOomTrackerInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OomTrackerInfo_detected(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Detected, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OomTrackerInfo_detected(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OomTrackerInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OomTrackerInfo_pids(ctx context.Context, field graphql.CollectedField, obj *model.APIOomTrackerInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OomTrackerInfo_pids(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pids, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]int)
	fc.Result = res
	return ec.marshalOInt2ᚕintᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OomTrackerInfo_pids(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OomTrackerInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Package_name(ctx context.Context, field graphql.CollectedField, obj *model.APIPackage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Package_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Package_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Package",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Package_manager(ctx context.Context, field graphql.CollectedField, obj *model.APIPackage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Package_manager(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Manager, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Package_manager(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Package",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Package_version(ctx context.Context, field graphql.CollectedField, obj *model.APIPackage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Package_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Package_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Package",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Parameter_key(ctx context.Context, field graphql.CollectedField, obj *model.APIParameter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Parameter_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Parameter_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Parameter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Parameter_value(ctx context.Context, field graphql.CollectedField, obj *model.APIParameter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Parameter_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Parameter_value(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Parameter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ParsleyFilter_caseSensitive(ctx context.Context, field graphql.CollectedField, obj *model.APIParsleyFilter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ParsleyFilter_caseSensitive(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CaseSensitive, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ParsleyFilter_caseSensitive(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ParsleyFilter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ParsleyFilter_description(ctx context.Context, field graphql.CollectedField, obj *model.APIParsleyFilter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ParsleyFilter_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ParsleyFilter_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ParsleyFilter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ParsleyFilter_exactMatch(ctx context.Context, field graphql.CollectedField, obj *model.APIParsleyFilter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ParsleyFilter_exactMatch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExactMatch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ParsleyFilter_exactMatch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ParsleyFilter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ParsleyFilter_expression(ctx context.Context, field graphql.CollectedField, obj *model.APIParsleyFilter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ParsleyFilter_expression(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Expression, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ParsleyFilter_expression(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ParsleyFilter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ParsleySettings_sectionsEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIParsleySettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ParsleySettings_sectionsEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SectionsEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ParsleySettings_sectionsEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ParsleySettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ParsleySettings_jumpToFailingLineEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIParsleySettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ParsleySettings_jumpToFailingLineEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JumpToFailingLineEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ParsleySettings_jumpToFailingLineEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ParsleySettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_id(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNID2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_activated(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_activated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Activated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_activated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_alias(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_alias(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Alias, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_alias(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_author(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_author(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Author, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_author(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_authorDisplayName(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_authorDisplayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Patch().AuthorDisplayName(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_authorDisplayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_baseTaskStatuses(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_baseTaskStatuses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Patch().BaseTaskStatuses(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_baseTaskStatuses(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_builds(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_builds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Patch().Builds(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIBuild)
	fc.Result = res
	return ec.marshalNBuild2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIBuildᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_builds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "actualMakespan":
				return ec.fieldContext_Build_actualMakespan(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Build_buildVariant(ctx, field)
			case "predictedMakespan":
				return ec.fieldContext_Build_predictedMakespan(ctx, field)
			case "status":
				return ec.fieldContext_Build_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_childPatchAliases(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_childPatchAliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChildPatchAliases, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIChildPatchAlias)
	fc.Result = res
	return ec.marshalOChildPatchAlias2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIChildPatchAliasᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_childPatchAliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "alias":
				return ec.fieldContext_ChildPatchAlias_alias(ctx, field)
			case "patchId":
				return ec.fieldContext_ChildPatchAlias_patchId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChildPatchAlias", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_childPatches(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_childPatches(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChildPatches, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIPatch)
	fc.Result = res
	return ec.marshalOPatch2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatchᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_childPatches(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Patch_id(ctx, field)
			case "activated":
				return ec.fieldContext_Patch_activated(ctx, field)
			case "alias":
				return ec.fieldContext_Patch_alias(ctx, field)
			case "author":
				return ec.fieldContext_Patch_author(ctx, field)
			case "authorDisplayName":
				return ec.fieldContext_Patch_authorDisplayName(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Patch_baseTaskStatuses(ctx, field)
			case "builds":
				return ec.fieldContext_Patch_builds(ctx, field)
			case "childPatchAliases":
				return ec.fieldContext_Patch_childPatchAliases(ctx, field)
			case "childPatches":
				return ec.fieldContext_Patch_childPatches(ctx, field)
			case "createTime":
				return ec.fieldContext_Patch_createTime(ctx, field)
			case "description":
				return ec.fieldContext_Patch_description(ctx, field)
			case "duration":
				return ec.fieldContext_Patch_duration(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Patch_generatedTaskCounts(ctx, field)
			case "githash":
				return ec.fieldContext_Patch_githash(ctx, field)
			case "githubPatchData":
				return ec.fieldContext_Patch_githubPatchData(ctx, field)
			case "hidden":
				return ec.fieldContext_Patch_hidden(ctx, field)
			case "moduleCodeChanges":
				return ec.fieldContext_Patch_moduleCodeChanges(ctx, field)
			case "parameters":
				return ec.fieldContext_Patch_parameters(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Patch_patchNumber(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Patch_patchTriggerAliases(ctx, field)
			case "project":
				return ec.fieldContext_Patch_project(ctx, field)
			case "projectID":
				return ec.fieldContext_Patch_projectID(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Patch_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Patch_projectMetadata(ctx, field)
			case "status":
				return ec.fieldContext_Patch_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Patch_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Patch_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Patch_taskStatuses(ctx, field)
			case "time":
				return ec.fieldContext_Patch_time(ctx, field)
			case "variants":
				return ec.fieldContext_Patch_variants(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_Patch_variantsTasks(ctx, field)
			case "versionFull":
				return ec.fieldContext_Patch_versionFull(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Patch", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_createTime(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_createTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreateTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_createTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_description(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_duration(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_duration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Patch().Duration(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*PatchDuration)
	fc.Result = res
	return ec.marshalOPatchDuration2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPatchDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_duration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "makespan":
				return ec.fieldContext_PatchDuration_makespan(ctx, field)
			case "time":
				return ec.fieldContext_PatchDuration_time(ctx, field)
			case "timeTaken":
				return ec.fieldContext_PatchDuration_timeTaken(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PatchDuration", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_generatedTaskCounts(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_generatedTaskCounts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Patch().GeneratedTaskCounts(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*GeneratedTaskCountResults)
	fc.Result = res
	return ec.marshalNGeneratedTaskCountResults2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐGeneratedTaskCountResultsᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_generatedTaskCounts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "buildVariantName":
				return ec.fieldContext_GeneratedTaskCountResults_buildVariantName(ctx, field)
			case "taskName":
				return ec.fieldContext_GeneratedTaskCountResults_taskName(ctx, field)
			case "taskId":
				return ec.fieldContext_GeneratedTaskCountResults_taskId(ctx, field)
			case "estimatedTasks":
				return ec.fieldContext_GeneratedTaskCountResults_estimatedTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GeneratedTaskCountResults", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_githash(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_githash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Githash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_githash(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_githubPatchData(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_githubPatchData(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GithubPatchData, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.APIGithubPatch)
	fc.Result = res
	return ec.marshalOGithubPatch2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGithubPatch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_githubPatchData(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "author":
				return ec.fieldContext_GithubPatch_author(ctx, field)
			case "baseOwner":
				return ec.fieldContext_GithubPatch_baseOwner(ctx, field)
			case "baseRepo":
				return ec.fieldContext_GithubPatch_baseRepo(ctx, field)
			case "headBranch":
				return ec.fieldContext_GithubPatch_headBranch(ctx, field)
			case "headHash":
				return ec.fieldContext_GithubPatch_headHash(ctx, field)
			case "headOwner":
				return ec.fieldContext_GithubPatch_headOwner(ctx, field)
			case "headRepo":
				return ec.fieldContext_GithubPatch_headRepo(ctx, field)
			case "prNumber":
				return ec.fieldContext_GithubPatch_prNumber(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubPatch", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_hidden(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_hidden(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hidden, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_hidden(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_moduleCodeChanges(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_moduleCodeChanges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModuleCodeChanges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APIModulePatch)
	fc.Result = res
	return ec.marshalNModuleCodeChange2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIModulePatchᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_moduleCodeChanges(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "branchName":
				return ec.fieldContext_ModuleCodeChange_branchName(ctx, field)
			case "fileDiffs":
				return ec.fieldContext_ModuleCodeChange_fileDiffs(ctx, field)
			case "htmlLink":
				return ec.fieldContext_ModuleCodeChange_htmlLink(ctx, field)
			case "rawLink":
				return ec.fieldContext_ModuleCodeChange_rawLink(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ModuleCodeChange", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_parameters(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_parameters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Parameters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APIParameter)
	fc.Result = res
	return ec.marshalNParameter2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParameterᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_parameters(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_Parameter_key(ctx, field)
			case "value":
				return ec.fieldContext_Parameter_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Parameter", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_patchNumber(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_patchNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PatchNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_patchNumber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_patchTriggerAliases(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_patchTriggerAliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Patch().PatchTriggerAliases(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIPatchTriggerDefinition)
	fc.Result = res
	return ec.marshalNPatchTriggerAlias2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatchTriggerDefinitionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_patchTriggerAliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "alias":
				return ec.fieldContext_PatchTriggerAlias_alias(ctx, field)
			case "childProjectId":
				return ec.fieldContext_PatchTriggerAlias_childProjectId(ctx, field)
			case "childProjectIdentifier":
				return ec.fieldContext_PatchTriggerAlias_childProjectIdentifier(ctx, field)
			case "parentAsModule":
				return ec.fieldContext_PatchTriggerAlias_parentAsModule(ctx, field)
			case "status":
				return ec.fieldContext_PatchTriggerAlias_status(ctx, field)
			case "downstreamRevision":
				return ec.fieldContext_PatchTriggerAlias_downstreamRevision(ctx, field)
			case "taskSpecifiers":
				return ec.fieldContext_PatchTriggerAlias_taskSpecifiers(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_PatchTriggerAlias_variantsTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PatchTriggerAlias", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_project(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_project(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Patch().Project(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*PatchProject)
	fc.Result = res
	return ec.marshalOPatchProject2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPatchProject(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_project(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "variants":
				return ec.fieldContext_PatchProject_variants(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PatchProject", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_projectID(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_projectID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_projectID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_projectIdentifier(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_projectIdentifier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Patch().ProjectIdentifier(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_projectIdentifier(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_projectMetadata(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_projectMetadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Patch().ProjectMetadata(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectRef)
	fc.Result = res
	return ec.marshalOProject2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_projectMetadata(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "githubPRTriggerAliases":
				return ec.fieldContext_Project_githubPRTriggerAliases(ctx, field)
			case "githubMQTriggerAliases":
				return ec.fieldContext_Project_githubMQTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_status(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_taskCount(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_taskCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Patch().TaskCount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_taskCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_tasks(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_tasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalNString2ᚕᚖstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_tasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_taskStatuses(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_taskStatuses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Patch().TaskStatuses(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_taskStatuses(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_time(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Patch().Time(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*PatchTime)
	fc.Result = res
	return ec.marshalOPatchTime2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPatchTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "finished":
				return ec.fieldContext_PatchTime_finished(ctx, field)
			case "started":
				return ec.fieldContext_PatchTime_started(ctx, field)
			case "submittedAt":
				return ec.fieldContext_PatchTime_submittedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PatchTime", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_variants(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_variants(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Variants, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalNString2ᚕᚖstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_variants(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_variantsTasks(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_variantsTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VariantsTasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.VariantTask)
	fc.Result = res
	return ec.marshalNVariantTask2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐVariantTaskᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_variantsTasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_VariantTask_name(ctx, field)
			case "tasks":
				return ec.fieldContext_VariantTask_tasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VariantTask", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_versionFull(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_versionFull(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Patch().VersionFull(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIVersion)
	fc.Result = res
	return ec.marshalOVersion2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_versionFull(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "authorEmail":
				return ec.fieldContext_Version_authorEmail(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Version_generatedTaskCounts(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "ignored":
				return ec.fieldContext_Version_ignored(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			case "waterfallBuilds":
				return ec.fieldContext_Version_waterfallBuilds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchDuration_makespan(ctx context.Context, field graphql.CollectedField, obj *PatchDuration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchDuration_makespan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Makespan, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchDuration_makespan(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchDuration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchDuration_time(ctx context.Context, field graphql.CollectedField, obj *PatchDuration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchDuration_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Time, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*PatchTime)
	fc.Result = res
	return ec.marshalOPatchTime2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPatchTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchDuration_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchDuration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "finished":
				return ec.fieldContext_PatchTime_finished(ctx, field)
			case "started":
				return ec.fieldContext_PatchTime_started(ctx, field)
			case "submittedAt":
				return ec.fieldContext_PatchTime_submittedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PatchTime", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchDuration_timeTaken(ctx context.Context, field graphql.CollectedField, obj *PatchDuration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchDuration_timeTaken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimeTaken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchDuration_timeTaken(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchDuration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchProject_variants(ctx context.Context, field graphql.CollectedField, obj *PatchProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchProject_variants(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Variants, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ProjectBuildVariant)
	fc.Result = res
	return ec.marshalNProjectBuildVariant2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectBuildVariantᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchProject_variants(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "displayName":
				return ec.fieldContext_ProjectBuildVariant_displayName(ctx, field)
			case "name":
				return ec.fieldContext_ProjectBuildVariant_name(ctx, field)
			case "tasks":
				return ec.fieldContext_ProjectBuildVariant_tasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectBuildVariant", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTime_finished(ctx context.Context, field graphql.CollectedField, obj *PatchTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchTime_finished(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Finished, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchTime_finished(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTime_started(ctx context.Context, field graphql.CollectedField, obj *PatchTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchTime_started(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Started, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchTime_started(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTime_submittedAt(ctx context.Context, field graphql.CollectedField, obj *PatchTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchTime_submittedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubmittedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchTime_submittedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTriggerAlias_alias(ctx context.Context, field graphql.CollectedField, obj *model.APIPatchTriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchTriggerAlias_alias(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Alias, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchTriggerAlias_alias(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTriggerAlias_childProjectId(ctx context.Context, field graphql.CollectedField, obj *model.APIPatchTriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchTriggerAlias_childProjectId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChildProjectId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchTriggerAlias_childProjectId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTriggerAlias_childProjectIdentifier(ctx context.Context, field graphql.CollectedField, obj *model.APIPatchTriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchTriggerAlias_childProjectIdentifier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChildProjectIdentifier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchTriggerAlias_childProjectIdentifier(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTriggerAlias_parentAsModule(ctx context.Context, field graphql.CollectedField, obj *model.APIPatchTriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchTriggerAlias_parentAsModule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParentAsModule, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchTriggerAlias_parentAsModule(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTriggerAlias_status(ctx context.Context, field graphql.CollectedField, obj *model.APIPatchTriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchTriggerAlias_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchTriggerAlias_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTriggerAlias_downstreamRevision(ctx context.Context, field graphql.CollectedField, obj *model.APIPatchTriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchTriggerAlias_downstreamRevision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DownstreamRevision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchTriggerAlias_downstreamRevision(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTriggerAlias_taskSpecifiers(ctx context.Context, field graphql.CollectedField, obj *model.APIPatchTriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchTriggerAlias_taskSpecifiers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskSpecifiers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APITaskSpecifier)
	fc.Result = res
	return ec.marshalOTaskSpecifier2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskSpecifierᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchTriggerAlias_taskSpecifiers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "patchAlias":
				return ec.fieldContext_TaskSpecifier_patchAlias(ctx, field)
			case "taskRegex":
				return ec.fieldContext_TaskSpecifier_taskRegex(ctx, field)
			case "variantRegex":
				return ec.fieldContext_TaskSpecifier_variantRegex(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskSpecifier", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTriggerAlias_variantsTasks(ctx context.Context, field graphql.CollectedField, obj *model.APIPatchTriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchTriggerAlias_variantsTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VariantsTasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.VariantTask)
	fc.Result = res
	return ec.marshalNVariantTask2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐVariantTaskᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchTriggerAlias_variantsTasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_VariantTask_name(ctx, field)
			case "tasks":
				return ec.fieldContext_VariantTask_tasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VariantTask", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patches_filteredPatchCount(ctx context.Context, field graphql.CollectedField, obj *Patches) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patches_filteredPatchCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FilteredPatchCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patches_filteredPatchCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patches",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patches_patches(ctx context.Context, field graphql.CollectedField, obj *Patches) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patches_patches(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Patches, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIPatch)
	fc.Result = res
	return ec.marshalNPatch2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatchᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patches_patches(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patches",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Patch_id(ctx, field)
			case "activated":
				return ec.fieldContext_Patch_activated(ctx, field)
			case "alias":
				return ec.fieldContext_Patch_alias(ctx, field)
			case "author":
				return ec.fieldContext_Patch_author(ctx, field)
			case "authorDisplayName":
				return ec.fieldContext_Patch_authorDisplayName(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Patch_baseTaskStatuses(ctx, field)
			case "builds":
				return ec.fieldContext_Patch_builds(ctx, field)
			case "childPatchAliases":
				return ec.fieldContext_Patch_childPatchAliases(ctx, field)
			case "childPatches":
				return ec.fieldContext_Patch_childPatches(ctx, field)
			case "createTime":
				return ec.fieldContext_Patch_createTime(ctx, field)
			case "description":
				return ec.fieldContext_Patch_description(ctx, field)
			case "duration":
				return ec.fieldContext_Patch_duration(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Patch_generatedTaskCounts(ctx, field)
			case "githash":
				return ec.fieldContext_Patch_githash(ctx, field)
			case "githubPatchData":
				return ec.fieldContext_Patch_githubPatchData(ctx, field)
			case "hidden":
				return ec.fieldContext_Patch_hidden(ctx, field)
			case "moduleCodeChanges":
				return ec.fieldContext_Patch_moduleCodeChanges(ctx, field)
			case "parameters":
				return ec.fieldContext_Patch_parameters(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Patch_patchNumber(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Patch_patchTriggerAliases(ctx, field)
			case "project":
				return ec.fieldContext_Patch_project(ctx, field)
			case "projectID":
				return ec.fieldContext_Patch_projectID(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Patch_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Patch_projectMetadata(ctx, field)
			case "status":
				return ec.fieldContext_Patch_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Patch_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Patch_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Patch_taskStatuses(ctx, field)
			case "time":
				return ec.fieldContext_Patch_time(ctx, field)
			case "variants":
				return ec.fieldContext_Patch_variants(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_Patch_variantsTasks(ctx, field)
			case "versionFull":
				return ec.fieldContext_Patch_versionFull(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Patch", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PeriodicBuild_id(ctx context.Context, field graphql.CollectedField, obj *model.APIPeriodicBuildDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PeriodicBuild_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PeriodicBuild_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PeriodicBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PeriodicBuild_alias(ctx context.Context, field graphql.CollectedField, obj *model.APIPeriodicBuildDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PeriodicBuild_alias(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Alias, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PeriodicBuild_alias(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PeriodicBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PeriodicBuild_configFile(ctx context.Context, field graphql.CollectedField, obj *model.APIPeriodicBuildDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PeriodicBuild_configFile(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConfigFile, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PeriodicBuild_configFile(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PeriodicBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PeriodicBuild_intervalHours(ctx context.Context, field graphql.CollectedField, obj *model.APIPeriodicBuildDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PeriodicBuild_intervalHours(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IntervalHours, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalNInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PeriodicBuild_intervalHours(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PeriodicBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PeriodicBuild_cron(ctx context.Context, field graphql.CollectedField, obj *model.APIPeriodicBuildDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PeriodicBuild_cron(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cron, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PeriodicBuild_cron(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PeriodicBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PeriodicBuild_message(ctx context.Context, field graphql.CollectedField, obj *model.APIPeriodicBuildDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PeriodicBuild_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PeriodicBuild_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PeriodicBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PeriodicBuild_nextRunTime(ctx context.Context, field graphql.CollectedField, obj *model.APIPeriodicBuildDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PeriodicBuild_nextRunTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextRunTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PeriodicBuild_nextRunTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PeriodicBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_canCreateDistro(ctx context.Context, field graphql.CollectedField, obj *Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_canCreateDistro(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Permissions().CanCreateDistro(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_canCreateDistro(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_canCreateProject(ctx context.Context, field graphql.CollectedField, obj *Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_canCreateProject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Permissions().CanCreateProject(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_canCreateProject(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_canEditAdminSettings(ctx context.Context, field graphql.CollectedField, obj *Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_canEditAdminSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Permissions().CanEditAdminSettings(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_canEditAdminSettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_distroPermissions(ctx context.Context, field graphql.CollectedField, obj *Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_distroPermissions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Permissions().DistroPermissions(rctx, obj, fc.Args["options"].(DistroPermissionsOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*DistroPermissions)
	fc.Result = res
	return ec.marshalNDistroPermissions2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroPermissions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_distroPermissions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "admin":
				return ec.fieldContext_DistroPermissions_admin(ctx, field)
			case "edit":
				return ec.fieldContext_DistroPermissions_edit(ctx, field)
			case "view":
				return ec.fieldContext_DistroPermissions_view(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DistroPermissions", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Permissions_distroPermissions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_projectPermissions(ctx context.Context, field graphql.CollectedField, obj *Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_projectPermissions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Permissions().ProjectPermissions(rctx, obj, fc.Args["options"].(ProjectPermissionsOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ProjectPermissions)
	fc.Result = res
	return ec.marshalNProjectPermissions2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermissions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_projectPermissions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edit":
				return ec.fieldContext_ProjectPermissions_edit(ctx, field)
			case "view":
				return ec.fieldContext_ProjectPermissions_view(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectPermissions", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Permissions_projectPermissions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_repoPermissions(ctx context.Context, field graphql.CollectedField, obj *Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_repoPermissions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Permissions().RepoPermissions(rctx, obj, fc.Args["options"].(RepoPermissionsOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*RepoPermissions)
	fc.Result = res
	return ec.marshalNRepoPermissions2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐRepoPermissions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_repoPermissions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "edit":
				return ec.fieldContext_RepoPermissions_edit(ctx, field)
			case "view":
				return ec.fieldContext_RepoPermissions_view(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepoPermissions", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Permissions_repoPermissions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_userId(ctx context.Context, field graphql.CollectedField, obj *Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_userId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannerSettings_commitQueueFactor(ctx context.Context, field graphql.CollectedField, obj *model.APIPlannerSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannerSettings_commitQueueFactor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CommitQueueFactor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannerSettings_commitQueueFactor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannerSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannerSettings_expectedRuntimeFactor(ctx context.Context, field graphql.CollectedField, obj *model.APIPlannerSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannerSettings_expectedRuntimeFactor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpectedRuntimeFactor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannerSettings_expectedRuntimeFactor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannerSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannerSettings_generateTaskFactor(ctx context.Context, field graphql.CollectedField, obj *model.APIPlannerSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannerSettings_generateTaskFactor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GenerateTaskFactor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannerSettings_generateTaskFactor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannerSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannerSettings_numDependentsFactor(ctx context.Context, field graphql.CollectedField, obj *model.APIPlannerSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannerSettings_numDependentsFactor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumDependentsFactor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannerSettings_numDependentsFactor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannerSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannerSettings_groupVersions(ctx context.Context, field graphql.CollectedField, obj *model.APIPlannerSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannerSettings_groupVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GroupVersions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannerSettings_groupVersions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannerSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannerSettings_mainlineTimeInQueueFactor(ctx context.Context, field graphql.CollectedField, obj *model.APIPlannerSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannerSettings_mainlineTimeInQueueFactor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MainlineTimeInQueueFactor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannerSettings_mainlineTimeInQueueFactor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannerSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannerSettings_patchFactor(ctx context.Context, field graphql.CollectedField, obj *model.APIPlannerSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannerSettings_patchFactor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PatchFactor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannerSettings_patchFactor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannerSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannerSettings_patchTimeInQueueFactor(ctx context.Context, field graphql.CollectedField, obj *model.APIPlannerSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannerSettings_patchTimeInQueueFactor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PatchTimeInQueueFactor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannerSettings_patchTimeInQueueFactor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannerSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannerSettings_targetTime(ctx context.Context, field graphql.CollectedField, obj *model.APIPlannerSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannerSettings_targetTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIDuration)
	fc.Result = res
	return ec.marshalNDuration2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannerSettings_targetTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannerSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannerSettings_version(ctx context.Context, field graphql.CollectedField, obj *model.APIPlannerSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannerSettings_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNPlannerVersion2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannerSettings_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannerSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PlannerVersion does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pod_events(ctx context.Context, field graphql.CollectedField, obj *model.APIPod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pod_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Pod().Events(rctx, obj, fc.Args["limit"].(*int), fc.Args["page"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PodEvents)
	fc.Result = res
	return ec.marshalNPodEvents2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPodEvents(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pod_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pod",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_PodEvents_count(ctx, field)
			case "eventLogEntries":
				return ec.fieldContext_PodEvents_eventLogEntries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PodEvents", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Pod_events_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Pod_id(ctx context.Context, field graphql.CollectedField, obj *model.APIPod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pod_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pod_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pod_status(ctx context.Context, field graphql.CollectedField, obj *model.APIPod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pod_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Pod().Status(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pod_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pod",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pod_task(ctx context.Context, field graphql.CollectedField, obj *model.APIPod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pod_task(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Pod().Task(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APITask)
	fc.Result = res
	return ec.marshalOTask2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pod_task(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pod",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pod_taskContainerCreationOpts(ctx context.Context, field graphql.CollectedField, obj *model.APIPod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pod_taskContainerCreationOpts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskContainerCreationOpts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIPodTaskContainerCreationOptions)
	fc.Result = res
	return ec.marshalNTaskContainerCreationOpts2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPodTaskContainerCreationOptions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pod_taskContainerCreationOpts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "image":
				return ec.fieldContext_TaskContainerCreationOpts_image(ctx, field)
			case "memoryMB":
				return ec.fieldContext_TaskContainerCreationOpts_memoryMB(ctx, field)
			case "cpu":
				return ec.fieldContext_TaskContainerCreationOpts_cpu(ctx, field)
			case "os":
				return ec.fieldContext_TaskContainerCreationOpts_os(ctx, field)
			case "arch":
				return ec.fieldContext_TaskContainerCreationOpts_arch(ctx, field)
			case "workingDir":
				return ec.fieldContext_TaskContainerCreationOpts_workingDir(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskContainerCreationOpts", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pod_type(ctx context.Context, field graphql.CollectedField, obj *model.APIPod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pod_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Pod().Type(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pod_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pod",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogData_oldStatus(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogData_oldStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OldStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogData_oldStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogData_newStatus(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogData_newStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogData_newStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogData_reason(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogData_reason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogData_reason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogData_taskID(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogData_taskID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogData_taskID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogData_taskExecution(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogData_taskExecution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskExecution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogData_taskExecution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogData_taskStatus(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogData_taskStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogData_taskStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogData_task(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogData_task(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PodEventLogData().Task(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APITask)
	fc.Result = res
	return ec.marshalOTask2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogData_task(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogData",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogEntry_data(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogEntry_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PodAPIEventData)
	fc.Result = res
	return ec.marshalNPodEventLogData2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐPodAPIEventData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogEntry_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "oldStatus":
				return ec.fieldContext_PodEventLogData_oldStatus(ctx, field)
			case "newStatus":
				return ec.fieldContext_PodEventLogData_newStatus(ctx, field)
			case "reason":
				return ec.fieldContext_PodEventLogData_reason(ctx, field)
			case "taskID":
				return ec.fieldContext_PodEventLogData_taskID(ctx, field)
			case "taskExecution":
				return ec.fieldContext_PodEventLogData_taskExecution(ctx, field)
			case "taskStatus":
				return ec.fieldContext_PodEventLogData_taskStatus(ctx, field)
			case "task":
				return ec.fieldContext_PodEventLogData_task(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PodEventLogData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogEntry_eventType(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogEntry_eventType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogEntry_eventType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogEntry_processedAt(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogEntry_processedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProcessedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogEntry_processedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogEntry_resourceId(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogEntry_resourceId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogEntry_resourceId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogEntry_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogEntry_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogEntry_timestamp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEvents_count(ctx context.Context, field graphql.CollectedField, obj *PodEvents) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEvents_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEvents_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEvents",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEvents_eventLogEntries(ctx context.Context, field graphql.CollectedField, obj *PodEvents) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEvents_eventLogEntries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventLogEntries, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.PodAPIEventLogEntry)
	fc.Result = res
	return ec.marshalNPodEventLogEntry2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐPodAPIEventLogEntryᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEvents_eventLogEntries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEvents",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_PodEventLogEntry_id(ctx, field)
			case "data":
				return ec.fieldContext_PodEventLogEntry_data(ctx, field)
			case "eventType":
				return ec.fieldContext_PodEventLogEntry_eventType(ctx, field)
			case "processedAt":
				return ec.fieldContext_PodEventLogEntry_processedAt(ctx, field)
			case "resourceId":
				return ec.fieldContext_PodEventLogEntry_resourceId(ctx, field)
			case "resourceType":
				return ec.fieldContext_PodEventLogEntry_resourceType(ctx, field)
			case "timestamp":
				return ec.fieldContext_PodEventLogEntry_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PodEventLogEntry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodLifecycleConfig_maxParallelPodRequests(ctx context.Context, field graphql.CollectedField, obj *model.APIPodLifecycleConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodLifecycleConfig_maxParallelPodRequests(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxParallelPodRequests, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodLifecycleConfig_maxParallelPodRequests(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodLifecycleConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodLifecycleConfig_maxPodDefinitionCleanupRate(ctx context.Context, field graphql.CollectedField, obj *model.APIPodLifecycleConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodLifecycleConfig_maxPodDefinitionCleanupRate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxPodDefinitionCleanupRate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodLifecycleConfig_maxPodDefinitionCleanupRate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodLifecycleConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodLifecycleConfig_maxSecretCleanupRate(ctx context.Context, field graphql.CollectedField, obj *model.APIPodLifecycleConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodLifecycleConfig_maxSecretCleanupRate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxSecretCleanupRate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodLifecycleConfig_maxSecretCleanupRate(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodLifecycleConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreconditionScript_path(ctx context.Context, field graphql.CollectedField, obj *model.APIPreconditionScript) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PreconditionScript_path(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PreconditionScript_path(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreconditionScript",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreconditionScript_script(ctx context.Context, field graphql.CollectedField, obj *model.APIPreconditionScript) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PreconditionScript_script(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Script, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PreconditionScript_script(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreconditionScript",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_id(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_admins(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_admins(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Admins, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2ᚕᚖstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_admins(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_banner(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_banner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Banner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.APIProjectBanner)
	fc.Result = res
	return ec.marshalOProjectBanner2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectBanner(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_banner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "text":
				return ec.fieldContext_ProjectBanner_text(ctx, field)
			case "theme":
				return ec.fieldContext_ProjectBanner_theme(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectBanner", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_batchTime(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_batchTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BatchTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_batchTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_branch(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_branch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Branch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_branch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_buildBaronSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_buildBaronSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildBaronSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIBuildBaronSettings)
	fc.Result = res
	return ec.marshalNBuildBaronSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIBuildBaronSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_buildBaronSettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "bfSuggestionFeaturesURL":
				return ec.fieldContext_BuildBaronSettings_bfSuggestionFeaturesURL(ctx, field)
			case "bfSuggestionPassword":
				return ec.fieldContext_BuildBaronSettings_bfSuggestionPassword(ctx, field)
			case "bfSuggestionServer":
				return ec.fieldContext_BuildBaronSettings_bfSuggestionServer(ctx, field)
			case "bfSuggestionTimeoutSecs":
				return ec.fieldContext_BuildBaronSettings_bfSuggestionTimeoutSecs(ctx, field)
			case "bfSuggestionUsername":
				return ec.fieldContext_BuildBaronSettings_bfSuggestionUsername(ctx, field)
			case "ticketCreateProject":
				return ec.fieldContext_BuildBaronSettings_ticketCreateProject(ctx, field)
			case "ticketSearchProjects":
				return ec.fieldContext_BuildBaronSettings_ticketSearchProjects(ctx, field)
			case "ticketCreateIssueType":
				return ec.fieldContext_BuildBaronSettings_ticketCreateIssueType(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BuildBaronSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_commitQueue(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_commitQueue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CommitQueue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APICommitQueueParams)
	fc.Result = res
	return ec.marshalNCommitQueueParams2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPICommitQueueParams(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_commitQueue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "enabled":
				return ec.fieldContext_CommitQueueParams_enabled(ctx, field)
			case "mergeMethod":
				return ec.fieldContext_CommitQueueParams_mergeMethod(ctx, field)
			case "message":
				return ec.fieldContext_CommitQueueParams_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CommitQueueParams", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_containerSizeDefinitions(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContainerSizeDefinitions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIContainerResources)
	fc.Result = res
	return ec.marshalOContainerResources2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIContainerResourcesᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_containerSizeDefinitions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ContainerResources_name(ctx, field)
			case "cpu":
				return ec.fieldContext_ContainerResources_cpu(ctx, field)
			case "memoryMb":
				return ec.fieldContext_ContainerResources_memoryMb(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContainerResources", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_deactivatePrevious(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_deactivatePrevious(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeactivatePrevious, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_deactivatePrevious(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_disabledStatsCache(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_disabledStatsCache(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisabledStatsCache, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_disabledStatsCache(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_dispatchingDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_dispatchingDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DispatchingDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_dispatchingDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_displayName(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_enabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_enabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_enabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_externalLinks(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_externalLinks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExternalLinks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIExternalLink)
	fc.Result = res
	return ec.marshalOExternalLink2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIExternalLinkᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_externalLinks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "displayName":
				return ec.fieldContext_ExternalLink_displayName(ctx, field)
			case "requesters":
				return ec.fieldContext_ExternalLink_requesters(ctx, field)
			case "urlTemplate":
				return ec.fieldContext_ExternalLink_urlTemplate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ExternalLink", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_githubChecksEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_githubChecksEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GithubChecksEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_githubChecksEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_githubDynamicTokenPermissionGroups(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GitHubDynamicTokenPermissionGroups, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APIGitHubDynamicTokenPermissionGroup)
	fc.Result = res
	return ec.marshalNGitHubDynamicTokenPermissionGroup2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGitHubDynamicTokenPermissionGroupᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_githubDynamicTokenPermissionGroups(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_GitHubDynamicTokenPermissionGroup_name(ctx, field)
			case "permissions":
				return ec.fieldContext_GitHubDynamicTokenPermissionGroup_permissions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GitHubDynamicTokenPermissionGroup", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_githubPermissionGroupByRequester(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GitHubPermissionGroupByRequester, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]string)
	fc.Result = res
	return ec.marshalOStringMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_githubPermissionGroupByRequester(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StringMap does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_githubTriggerAliases(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_githubTriggerAliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Project().GithubTriggerAliases(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_githubTriggerAliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_githubPRTriggerAliases(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_githubPRTriggerAliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GithubPRTriggerAliases, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2ᚕᚖstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_githubPRTriggerAliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_githubMQTriggerAliases(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_githubMQTriggerAliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GithubMQTriggerAliases, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2ᚕᚖstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_githubMQTriggerAliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_gitTagAuthorizedTeams(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GitTagAuthorizedTeams, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2ᚕᚖstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_gitTagAuthorizedTeams(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_gitTagAuthorizedUsers(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GitTagAuthorizedUsers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2ᚕᚖstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_gitTagAuthorizedUsers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_gitTagVersionsEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GitTagVersionsEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_gitTagVersionsEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_hidden(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_hidden(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hidden, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_hidden(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_identifier(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_identifier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Identifier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_identifier(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_isFavorite(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_isFavorite(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Project().IsFavorite(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_isFavorite(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_manualPrTestingEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ManualPRTestingEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_manualPrTestingEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_notifyOnBuildFailure(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NotifyOnBuildFailure, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_notifyOnBuildFailure(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_oldestAllowedMergeBase(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OldestAllowedMergeBase, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_oldestAllowedMergeBase(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_owner(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_owner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_owner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_parsleyFilters(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_parsleyFilters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParsleyFilters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIParsleyFilter)
	fc.Result = res
	return ec.marshalOParsleyFilter2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParsleyFilterᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_parsleyFilters(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "caseSensitive":
				return ec.fieldContext_ParsleyFilter_caseSensitive(ctx, field)
			case "description":
				return ec.fieldContext_ParsleyFilter_description(ctx, field)
			case "exactMatch":
				return ec.fieldContext_ParsleyFilter_exactMatch(ctx, field)
			case "expression":
				return ec.fieldContext_ParsleyFilter_expression(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ParsleyFilter", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_patches(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_patches(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Project().Patches(rctx, obj, fc.Args["patchesInput"].(PatchesInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Patches)
	fc.Result = res
	return ec.marshalNPatches2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPatches(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_patches(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "filteredPatchCount":
				return ec.fieldContext_Patches_filteredPatchCount(ctx, field)
			case "patches":
				return ec.fieldContext_Patches_patches(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Patches", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Project_patches_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Project_patchingDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_patchingDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PatchingDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_patchingDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_patchTriggerAliases(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_patchTriggerAliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PatchTriggerAliases, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIPatchTriggerDefinition)
	fc.Result = res
	return ec.marshalOPatchTriggerAlias2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatchTriggerDefinitionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_patchTriggerAliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "alias":
				return ec.fieldContext_PatchTriggerAlias_alias(ctx, field)
			case "childProjectId":
				return ec.fieldContext_PatchTriggerAlias_childProjectId(ctx, field)
			case "childProjectIdentifier":
				return ec.fieldContext_PatchTriggerAlias_childProjectIdentifier(ctx, field)
			case "parentAsModule":
				return ec.fieldContext_PatchTriggerAlias_parentAsModule(ctx, field)
			case "status":
				return ec.fieldContext_PatchTriggerAlias_status(ctx, field)
			case "downstreamRevision":
				return ec.fieldContext_PatchTriggerAlias_downstreamRevision(ctx, field)
			case "taskSpecifiers":
				return ec.fieldContext_PatchTriggerAlias_taskSpecifiers(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_PatchTriggerAlias_variantsTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PatchTriggerAlias", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_perfEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_perfEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PerfEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_perfEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_periodicBuilds(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_periodicBuilds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PeriodicBuilds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIPeriodicBuildDefinition)
	fc.Result = res
	return ec.marshalOPeriodicBuild2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPeriodicBuildDefinitionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_periodicBuilds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_PeriodicBuild_id(ctx, field)
			case "alias":
				return ec.fieldContext_PeriodicBuild_alias(ctx, field)
			case "configFile":
				return ec.fieldContext_PeriodicBuild_configFile(ctx, field)
			case "intervalHours":
				return ec.fieldContext_PeriodicBuild_intervalHours(ctx, field)
			case "cron":
				return ec.fieldContext_PeriodicBuild_cron(ctx, field)
			case "message":
				return ec.fieldContext_PeriodicBuild_message(ctx, field)
			case "nextRunTime":
				return ec.fieldContext_PeriodicBuild_nextRunTime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PeriodicBuild", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_projectHealthView(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_projectHealthView(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectHealthView, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model1.ProjectHealthView)
	fc.Result = res
	return ec.marshalNProjectHealthView2githubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐProjectHealthView(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_projectHealthView(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ProjectHealthView does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_prTestingEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_prTestingEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PRTestingEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_prTestingEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_remotePath(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_remotePath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RemotePath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_remotePath(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_repo(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_repo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_repo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_repoRefId(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_repoRefId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepoRefId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_repoRefId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_repotrackerDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_repotrackerDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepotrackerDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_repotrackerDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_repotrackerError(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_repotrackerError(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepotrackerError, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIRepositoryErrorDetails)
	fc.Result = res
	return ec.marshalORepotrackerError2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIRepositoryErrorDetails(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_repotrackerError(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "exists":
				return ec.fieldContext_RepotrackerError_exists(ctx, field)
			case "invalidRevision":
				return ec.fieldContext_RepotrackerError_invalidRevision(ctx, field)
			case "mergeBaseRevision":
				return ec.fieldContext_RepotrackerError_mergeBaseRevision(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepotrackerError", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_restricted(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_restricted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Restricted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_restricted(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_spawnHostScriptPath(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpawnHostScriptPath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_spawnHostScriptPath(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_stepbackDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_stepbackDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StepbackDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_stepbackDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_stepbackBisect(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_stepbackBisect(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StepbackBisect, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_stepbackBisect(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_taskAnnotationSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskAnnotationSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APITaskAnnotationSettings)
	fc.Result = res
	return ec.marshalNTaskAnnotationSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskAnnotationSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_taskAnnotationSettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "fileTicketWebhook":
				return ec.fieldContext_TaskAnnotationSettings_fileTicketWebhook(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskAnnotationSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_tracksPushEvents(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_tracksPushEvents(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TracksPushEvents, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_tracksPushEvents(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_triggers(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_triggers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Triggers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APITriggerDefinition)
	fc.Result = res
	return ec.marshalOTriggerAlias2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITriggerDefinitionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_triggers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "alias":
				return ec.fieldContext_TriggerAlias_alias(ctx, field)
			case "buildVariantRegex":
				return ec.fieldContext_TriggerAlias_buildVariantRegex(ctx, field)
			case "configFile":
				return ec.fieldContext_TriggerAlias_configFile(ctx, field)
			case "dateCutoff":
				return ec.fieldContext_TriggerAlias_dateCutoff(ctx, field)
			case "level":
				return ec.fieldContext_TriggerAlias_level(ctx, field)
			case "project":
				return ec.fieldContext_TriggerAlias_project(ctx, field)
			case "status":
				return ec.fieldContext_TriggerAlias_status(ctx, field)
			case "taskRegex":
				return ec.fieldContext_TriggerAlias_taskRegex(ctx, field)
			case "unscheduleDownstreamVersions":
				return ec.fieldContext_TriggerAlias_unscheduleDownstreamVersions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TriggerAlias", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_versionControlEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_versionControlEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VersionControlEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_versionControlEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_workstationConfig(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_workstationConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkstationConfig, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIWorkstationConfig)
	fc.Result = res
	return ec.marshalNWorkstationConfig2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWorkstationConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_workstationConfig(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "gitClone":
				return ec.fieldContext_WorkstationConfig_gitClone(ctx, field)
			case "setupCommands":
				return ec.fieldContext_WorkstationConfig_setupCommands(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkstationConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAlias_id(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectAlias) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectAlias_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectAlias_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAlias_alias(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectAlias) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectAlias_alias(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Alias, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectAlias_alias(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAlias_description(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectAlias) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectAlias_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectAlias_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAlias_gitTag(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectAlias) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectAlias_gitTag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GitTag, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectAlias_gitTag(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAlias_remotePath(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectAlias) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectAlias_remotePath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RemotePath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectAlias_remotePath(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAlias_task(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectAlias) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectAlias_task(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Task, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectAlias_task(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAlias_taskTags(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectAlias) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectAlias_taskTags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskTags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalNString2ᚕᚖstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectAlias_taskTags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAlias_variant(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectAlias) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectAlias_variant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Variant, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectAlias_variant(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAlias_variantTags(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectAlias) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectAlias_variantTags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VariantTags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalNString2ᚕᚖstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectAlias_variantTags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAlias_parameters(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectAlias) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectAlias_parameters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Parameters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIParameter)
	fc.Result = res
	return ec.marshalNParameter2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParameterᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectAlias_parameters(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_Parameter_key(ctx, field)
			case "value":
				return ec.fieldContext_Parameter_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Parameter", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectBanner_text(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectBanner) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectBanner_text(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Text, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectBanner_text(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectBanner",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectBanner_theme(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectBanner) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectBanner_theme(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Theme, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(evergreen.BannerTheme)
	fc.Result = res
	return ec.marshalNBannerTheme2githubᚗcomᚋevergreenᚑciᚋevergreenᚐBannerTheme(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectBanner_theme(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectBanner",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BannerTheme does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectBuildVariant_displayName(ctx context.Context, field graphql.CollectedField, obj *ProjectBuildVariant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectBuildVariant_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectBuildVariant_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectBuildVariant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectBuildVariant_name(ctx context.Context, field graphql.CollectedField, obj *ProjectBuildVariant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectBuildVariant_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectBuildVariant_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectBuildVariant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectBuildVariant_tasks(ctx context.Context, field graphql.CollectedField, obj *ProjectBuildVariant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectBuildVariant_tasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectBuildVariant_tasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectBuildVariant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEventLogEntry_after(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectEventLogEntry_after(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.After, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.APIProjectEventSettings)
	fc.Result = res
	return ec.marshalOProjectEventSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectEventSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectEventLogEntry_after(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aliases":
				return ec.fieldContext_ProjectEventSettings_aliases(ctx, field)
			case "githubAppAuth":
				return ec.fieldContext_ProjectEventSettings_githubAppAuth(ctx, field)
			case "githubWebhooksEnabled":
				return ec.fieldContext_ProjectEventSettings_githubWebhooksEnabled(ctx, field)
			case "projectRef":
				return ec.fieldContext_ProjectEventSettings_projectRef(ctx, field)
			case "subscriptions":
				return ec.fieldContext_ProjectEventSettings_subscriptions(ctx, field)
			case "vars":
				return ec.fieldContext_ProjectEventSettings_vars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectEventSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEventLogEntry_before(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectEventLogEntry_before(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Before, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.APIProjectEventSettings)
	fc.Result = res
	return ec.marshalOProjectEventSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectEventSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectEventLogEntry_before(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aliases":
				return ec.fieldContext_ProjectEventSettings_aliases(ctx, field)
			case "githubAppAuth":
				return ec.fieldContext_ProjectEventSettings_githubAppAuth(ctx, field)
			case "githubWebhooksEnabled":
				return ec.fieldContext_ProjectEventSettings_githubWebhooksEnabled(ctx, field)
			case "projectRef":
				return ec.fieldContext_ProjectEventSettings_projectRef(ctx, field)
			case "subscriptions":
				return ec.fieldContext_ProjectEventSettings_subscriptions(ctx, field)
			case "vars":
				return ec.fieldContext_ProjectEventSettings_vars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectEventSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEventLogEntry_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectEventLogEntry_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectEventLogEntry_timestamp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEventLogEntry_user(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectEventLogEntry_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectEventLogEntry_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEventSettings_aliases(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectEventSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectEventSettings_aliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Aliases, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIProjectAlias)
	fc.Result = res
	return ec.marshalOProjectAlias2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectAliasᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectEventSettings_aliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEventSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProjectAlias_id(ctx, field)
			case "alias":
				return ec.fieldContext_ProjectAlias_alias(ctx, field)
			case "description":
				return ec.fieldContext_ProjectAlias_description(ctx, field)
			case "gitTag":
				return ec.fieldContext_ProjectAlias_gitTag(ctx, field)
			case "remotePath":
				return ec.fieldContext_ProjectAlias_remotePath(ctx, field)
			case "task":
				return ec.fieldContext_ProjectAlias_task(ctx, field)
			case "taskTags":
				return ec.fieldContext_ProjectAlias_taskTags(ctx, field)
			case "variant":
				return ec.fieldContext_ProjectAlias_variant(ctx, field)
			case "variantTags":
				return ec.fieldContext_ProjectAlias_variantTags(ctx, field)
			case "parameters":
				return ec.fieldContext_ProjectAlias_parameters(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectAlias", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEventSettings_githubAppAuth(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectEventSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectEventSettings_githubAppAuth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GithubAppAuth, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.APIGithubAppAuth)
	fc.Result = res
	return ec.marshalOGithubAppAuth2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGithubAppAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectEventSettings_githubAppAuth(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEventSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "appId":
				return ec.fieldContext_GithubAppAuth_appId(ctx, field)
			case "privateKey":
				return ec.fieldContext_GithubAppAuth_privateKey(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubAppAuth", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEventSettings_githubWebhooksEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectEventSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectEventSettings_githubWebhooksEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GithubWebhooksEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectEventSettings_githubWebhooksEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEventSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEventSettings_projectRef(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectEventSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectEventSettings_projectRef(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectRef, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.APIProjectRef)
	fc.Result = res
	return ec.marshalOProject2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectEventSettings_projectRef(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEventSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "githubPRTriggerAliases":
				return ec.fieldContext_Project_githubPRTriggerAliases(ctx, field)
			case "githubMQTriggerAliases":
				return ec.fieldContext_Project_githubMQTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEventSettings_subscriptions(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectEventSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectEventSettings_subscriptions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Subscriptions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APISubscription)
	fc.Result = res
	return ec.marshalOGeneralSubscription2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISubscriptionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectEventSettings_subscriptions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEventSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GeneralSubscription_id(ctx, field)
			case "ownerType":
				return ec.fieldContext_GeneralSubscription_ownerType(ctx, field)
			case "regexSelectors":
				return ec.fieldContext_GeneralSubscription_regexSelectors(ctx, field)
			case "resourceType":
				return ec.fieldContext_GeneralSubscription_resourceType(ctx, field)
			case "selectors":
				return ec.fieldContext_GeneralSubscription_selectors(ctx, field)
			case "subscriber":
				return ec.fieldContext_GeneralSubscription_subscriber(ctx, field)
			case "trigger":
				return ec.fieldContext_GeneralSubscription_trigger(ctx, field)
			case "triggerData":
				return ec.fieldContext_GeneralSubscription_triggerData(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GeneralSubscription", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEventSettings_vars(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectEventSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectEventSettings_vars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Vars, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.APIProjectVars)
	fc.Result = res
	return ec.marshalOProjectVars2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectVars(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectEventSettings_vars(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEventSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "adminOnlyVars":
				return ec.fieldContext_ProjectVars_adminOnlyVars(ctx, field)
			case "privateVars":
				return ec.fieldContext_ProjectVars_privateVars(ctx, field)
			case "vars":
				return ec.fieldContext_ProjectVars_vars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectVars", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEvents_count(ctx context.Context, field graphql.CollectedField, obj *ProjectEvents) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectEvents_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectEvents_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEvents",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEvents_eventLogEntries(ctx context.Context, field graphql.CollectedField, obj *ProjectEvents) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectEvents_eventLogEntries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventLogEntries, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIProjectEvent)
	fc.Result = res
	return ec.marshalNProjectEventLogEntry2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectEventᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectEvents_eventLogEntries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEvents",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "after":
				return ec.fieldContext_ProjectEventLogEntry_after(ctx, field)
			case "before":
				return ec.fieldContext_ProjectEventLogEntry_before(ctx, field)
			case "timestamp":
				return ec.fieldContext_ProjectEventLogEntry_timestamp(ctx, field)
			case "user":
				return ec.fieldContext_ProjectEventLogEntry_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectEventLogEntry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectPermissions_edit(ctx context.Context, field graphql.CollectedField, obj *ProjectPermissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectPermissions_edit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectPermissions_edit(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectPermissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectPermissions_view(ctx context.Context, field graphql.CollectedField, obj *ProjectPermissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectPermissions_view(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.View, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectPermissions_view(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectPermissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectSettings_aliases(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectSettings_aliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProjectSettings().Aliases(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.APIProjectAlias)
	fc.Result = res
	return ec.marshalOProjectAlias2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectAliasᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectSettings_aliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProjectAlias_id(ctx, field)
			case "alias":
				return ec.fieldContext_ProjectAlias_alias(ctx, field)
			case "description":
				return ec.fieldContext_ProjectAlias_description(ctx, field)
			case "gitTag":
				return ec.fieldContext_ProjectAlias_gitTag(ctx, field)
			case "remotePath":
				return ec.fieldContext_ProjectAlias_remotePath(ctx, field)
			case "task":
				return ec.fieldContext_ProjectAlias_task(ctx, field)
			case "taskTags":
				return ec.fieldContext_ProjectAlias_taskTags(ctx, field)
			case "variant":
				return ec.fieldContext_ProjectAlias_variant(ctx, field)
			case "variantTags":
				return ec.fieldContext_ProjectAlias_variantTags(ctx, field)
			case "parameters":
				return ec.fieldContext_ProjectAlias_parameters(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectAlias", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectSettings_githubAppAuth(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectSettings_githubAppAuth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProjectSettings().GithubAppAuth(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIGithubAppAuth)
	fc.Result = res
	return ec.marshalOGithubAppAuth2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGithubAppAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectSettings_githubAppAuth(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "appId":
				return ec.fieldContext_GithubAppAuth_appId(ctx, field)
			case "privateKey":
				return ec.fieldContext_GithubAppAuth_privateKey(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubAppAuth", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectSettings_githubWebhooksEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectSettings_githubWebhooksEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProjectSettings().GithubWebhooksEnabled(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectSettings_githubWebhooksEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectSettings_projectRef(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectSettings_projectRef(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ProjectRef, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.RequireProjectSettingsAccess == nil {
				var zeroVal model.APIProjectRef
				return zeroVal, errors.New("directive requireProjectSettingsAccess is not implemented")
			}
			return ec.directives.RequireProjectSettingsAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.APIProjectRef); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/rest/model.APIProjectRef`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.APIProjectRef)
	fc.Result = res
	return ec.marshalOProject2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectSettings_projectRef(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "githubPRTriggerAliases":
				return ec.fieldContext_Project_githubPRTriggerAliases(ctx, field)
			case "githubMQTriggerAliases":
				return ec.fieldContext_Project_githubMQTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectSettings_subscriptions(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectSettings_subscriptions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProjectSettings().Subscriptions(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.APISubscription)
	fc.Result = res
	return ec.marshalOGeneralSubscription2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISubscriptionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectSettings_subscriptions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GeneralSubscription_id(ctx, field)
			case "ownerType":
				return ec.fieldContext_GeneralSubscription_ownerType(ctx, field)
			case "regexSelectors":
				return ec.fieldContext_GeneralSubscription_regexSelectors(ctx, field)
			case "resourceType":
				return ec.fieldContext_GeneralSubscription_resourceType(ctx, field)
			case "selectors":
				return ec.fieldContext_GeneralSubscription_selectors(ctx, field)
			case "subscriber":
				return ec.fieldContext_GeneralSubscription_subscriber(ctx, field)
			case "trigger":
				return ec.fieldContext_GeneralSubscription_trigger(ctx, field)
			case "triggerData":
				return ec.fieldContext_GeneralSubscription_triggerData(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GeneralSubscription", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectSettings_vars(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectSettings_vars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProjectSettings().Vars(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectVars)
	fc.Result = res
	return ec.marshalOProjectVars2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectVars(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectSettings_vars(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "adminOnlyVars":
				return ec.fieldContext_ProjectVars_adminOnlyVars(ctx, field)
			case "privateVars":
				return ec.fieldContext_ProjectVars_privateVars(ctx, field)
			case "vars":
				return ec.fieldContext_ProjectVars_vars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectVars", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectTasksPair_projectId(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectTasksPair) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectTasksPair_projectId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectTasksPair_projectId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectTasksPair",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectTasksPair_allowedTasks(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectTasksPair) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectTasksPair_allowedTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AllowedTasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectTasksPair_allowedTasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectTasksPair",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectTasksPair_allowedBVs(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectTasksPair) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectTasksPair_allowedBVs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AllowedBVs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectTasksPair_allowedBVs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectTasksPair",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectVars_adminOnlyVars(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectVars) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectVars_adminOnlyVars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProjectVars().AdminOnlyVars(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectVars_adminOnlyVars(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectVars",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectVars_privateVars(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectVars) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectVars_privateVars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProjectVars().PrivateVars(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectVars_privateVars(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectVars",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectVars_vars(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectVars) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectVars_vars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Vars, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]string)
	fc.Result = res
	return ec.marshalOStringMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectVars_vars(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectVars",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StringMap does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PublicKey_key(ctx context.Context, field graphql.CollectedField, obj *model.APIPubKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PublicKey_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PublicKey_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PublicKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PublicKey_name(ctx context.Context, field graphql.CollectedField, obj *model.APIPubKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PublicKey_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PublicKey_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PublicKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_bbGetCreatedTickets(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_bbGetCreatedTickets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().BbGetCreatedTickets(rctx, fc.Args["taskId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*thirdparty.JiraTicket)
	fc.Result = res
	return ec.marshalNJiraTicket2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐJiraTicketᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_bbGetCreatedTickets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "fields":
				return ec.fieldContext_JiraTicket_fields(ctx, field)
			case "key":
				return ec.fieldContext_JiraTicket_key(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JiraTicket", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_bbGetCreatedTickets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_buildBaron(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_buildBaron(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().BuildBaron(rctx, fc.Args["taskId"].(string), fc.Args["execution"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*BuildBaron)
	fc.Result = res
	return ec.marshalNBuildBaron2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐBuildBaron(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_buildBaron(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "bbTicketCreationDefined":
				return ec.fieldContext_BuildBaron_bbTicketCreationDefined(ctx, field)
			case "buildBaronConfigured":
				return ec.fieldContext_BuildBaron_buildBaronConfigured(ctx, field)
			case "searchReturnInfo":
				return ec.fieldContext_BuildBaron_searchReturnInfo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BuildBaron", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_buildBaron_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_adminEvents(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_adminEvents(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().AdminEvents(rctx, fc.Args["opts"].(AdminEventsInput))
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.RequireAdmin == nil {
				var zeroVal *AdminEventsPayload
				return zeroVal, errors.New("directive requireAdmin is not implemented")
			}
			return ec.directives.RequireAdmin(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*AdminEventsPayload); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/evergreen-ci/evergreen/graphql.AdminEventsPayload`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*AdminEventsPayload)
	fc.Result = res
	return ec.marshalNAdminEventsPayload2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAdminEventsPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_adminEvents(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_AdminEventsPayload_count(ctx, field)
			case "eventLogEntries":
				return ec.fieldContext_AdminEventsPayload_eventLogEntries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdminEventsPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_adminEvents_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_adminSettings(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_adminSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().AdminSettings(rctx)
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.RequireAdmin == nil {
				var zeroVal *model.APIAdminSettings
				return zeroVal, errors.New("directive requireAdmin is not implemented")
			}
			return ec.directives.RequireAdmin(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*model.APIAdminSettings); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/evergreen-ci/evergreen/rest/model.APIAdminSettings`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIAdminSettings)
	fc.Result = res
	return ec.marshalOAdminSettings2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAdminSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_adminSettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "amboy":
				return ec.fieldContext_AdminSettings_amboy(ctx, field)
			case "amboyDB":
				return ec.fieldContext_AdminSettings_amboyDB(ctx, field)
			case "authConfig":
				return ec.fieldContext_AdminSettings_authConfig(ctx, field)
			case "banner":
				return ec.fieldContext_AdminSettings_banner(ctx, field)
			case "bannerTheme":
				return ec.fieldContext_AdminSettings_bannerTheme(ctx, field)
			case "cedar":
				return ec.fieldContext_AdminSettings_cedar(ctx, field)
			case "fws":
				return ec.fieldContext_AdminSettings_fws(ctx, field)
			case "jira":
				return ec.fieldContext_AdminSettings_jira(ctx, field)
			case "slack":
				return ec.fieldContext_AdminSettings_slack(ctx, field)
			case "splunk":
				return ec.fieldContext_AdminSettings_splunk(ctx, field)
			case "runtimeEnvironments":
				return ec.fieldContext_AdminSettings_runtimeEnvironments(ctx, field)
			case "testSelection":
				return ec.fieldContext_AdminSettings_testSelection(ctx, field)
			case "serviceFlags":
				return ec.fieldContext_AdminSettings_serviceFlags(ctx, field)
			case "notify":
				return ec.fieldContext_AdminSettings_notify(ctx, field)
			case "taskLimits":
				return ec.fieldContext_AdminSettings_taskLimits(ctx, field)
			case "hostInit":
				return ec.fieldContext_AdminSettings_hostInit(ctx, field)
			case "podLifecycle":
				return ec.fieldContext_AdminSettings_podLifecycle(ctx, field)
			case "scheduler":
				return ec.fieldContext_AdminSettings_scheduler(ctx, field)
			case "repotracker":
				return ec.fieldContext_AdminSettings_repotracker(ctx, field)
			case "api":
				return ec.fieldContext_AdminSettings_api(ctx, field)
			case "ui":
				return ec.fieldContext_AdminSettings_ui(ctx, field)
			case "disabledGQLQueries":
				return ec.fieldContext_AdminSettings_disabledGQLQueries(ctx, field)
			case "loggerConfig":
				return ec.fieldContext_AdminSettings_loggerConfig(ctx, field)
			case "triggers":
				return ec.fieldContext_AdminSettings_triggers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdminSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_adminTasksToRestart(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_adminTasksToRestart(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return ec.resolvers.Query().AdminTasksToRestart(rctx, fc.Args["opts"].(model1.RestartOptions))
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.RequireAdmin == nil {
				var zeroVal *AdminTasksToRestartPayload
				return zeroVal, errors.New("directive requireAdmin is not implemented")
			}
			return ec.directives.RequireAdmin(ctx, nil, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*AdminTasksToRestartPayload); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *github.com/evergreen-ci/evergreen/graphql.AdminTasksToRestartPayload`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*AdminTasksToRestartPayload)
	fc.Result = res
	return ec.marshalNAdminTasksToRestartPayload2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAdminTasksToRestartPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_adminTasksToRestart(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tasksToRestart":
				return ec.fieldContext_AdminTasksToRestartPayload_tasksToRestart(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AdminTasksToRestartPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_adminTasksToRestart_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_awsRegions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_awsRegions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AWSRegions(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_awsRegions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_clientConfig(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_clientConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ClientConfig(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIClientConfig)
	fc.Result = res
	return ec.marshalOClientConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIClientConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_clientConfig(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "clientBinaries":
				return ec.fieldContext_ClientConfig_clientBinaries(ctx, field)
			case "latestRevision":
				return ec.fieldContext_ClientConfig_latestRevision(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ClientConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_instanceTypes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_instanceTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().InstanceTypes(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_instanceTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_spruceConfig(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_spruceConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().SpruceConfig(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIAdminSettings)
	fc.Result = res
	return ec.marshalOSpruceConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAdminSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_spruceConfig(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "banner":
				return ec.fieldContext_SpruceConfig_banner(ctx, field)
			case "bannerTheme":
				return ec.fieldContext_SpruceConfig_bannerTheme(ctx, field)
			case "containerPools":
				return ec.fieldContext_SpruceConfig_containerPools(ctx, field)
			case "githubOrgs":
				return ec.fieldContext_SpruceConfig_githubOrgs(ctx, field)
			case "jira":
				return ec.fieldContext_SpruceConfig_jira(ctx, field)
			case "providers":
				return ec.fieldContext_SpruceConfig_providers(ctx, field)
			case "secretFields":
				return ec.fieldContext_SpruceConfig_secretFields(ctx, field)
			case "singleTaskDistro":
				return ec.fieldContext_SpruceConfig_singleTaskDistro(ctx, field)
			case "slack":
				return ec.fieldContext_SpruceConfig_slack(ctx, field)
			case "spawnHost":
				return ec.fieldContext_SpruceConfig_spawnHost(ctx, field)
			case "ui":
				return ec.fieldContext_SpruceConfig_ui(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SpruceConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_subnetAvailabilityZones(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_subnetAvailabilityZones(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().SubnetAvailabilityZones(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_subnetAvailabilityZones(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_distro(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_distro(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Distro(rctx, fc.Args["distroId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIDistro)
	fc.Result = res
	return ec.marshalODistro2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDistro(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_distro(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "adminOnly":
				return ec.fieldContext_Distro_adminOnly(ctx, field)
			case "aliases":
				return ec.fieldContext_Distro_aliases(ctx, field)
			case "arch":
				return ec.fieldContext_Distro_arch(ctx, field)
			case "authorizedKeysFile":
				return ec.fieldContext_Distro_authorizedKeysFile(ctx, field)
			case "availableRegions":
				return ec.fieldContext_Distro_availableRegions(ctx, field)
			case "bootstrapSettings":
				return ec.fieldContext_Distro_bootstrapSettings(ctx, field)
			case "containerPool":
				return ec.fieldContext_Distro_containerPool(ctx, field)
			case "disabled":
				return ec.fieldContext_Distro_disabled(ctx, field)
			case "disableShallowClone":
				return ec.fieldContext_Distro_disableShallowClone(ctx, field)
			case "dispatcherSettings":
				return ec.fieldContext_Distro_dispatcherSettings(ctx, field)
			case "execUser":
				return ec.fieldContext_Distro_execUser(ctx, field)
			case "expansions":
				return ec.fieldContext_Distro_expansions(ctx, field)
			case "finderSettings":
				return ec.fieldContext_Distro_finderSettings(ctx, field)
			case "homeVolumeSettings":
				return ec.fieldContext_Distro_homeVolumeSettings(ctx, field)
			case "hostAllocatorSettings":
				return ec.fieldContext_Distro_hostAllocatorSettings(ctx, field)
			case "iceCreamSettings":
				return ec.fieldContext_Distro_iceCreamSettings(ctx, field)
			case "imageId":
				return ec.fieldContext_Distro_imageId(ctx, field)
			case "isCluster":
				return ec.fieldContext_Distro_isCluster(ctx, field)
			case "isVirtualWorkStation":
				return ec.fieldContext_Distro_isVirtualWorkStation(ctx, field)
			case "mountpoints":
				return ec.fieldContext_Distro_mountpoints(ctx, field)
			case "name":
				return ec.fieldContext_Distro_name(ctx, field)
			case "note":
				return ec.fieldContext_Distro_note(ctx, field)
			case "plannerSettings":
				return ec.fieldContext_Distro_plannerSettings(ctx, field)
			case "provider":
				return ec.fieldContext_Distro_provider(ctx, field)
			case "providerAccount":
				return ec.fieldContext_Distro_providerAccount(ctx, field)
			case "providerSettingsList":
				return ec.fieldContext_Distro_providerSettingsList(ctx, field)
			case "setup":
				return ec.fieldContext_Distro_setup(ctx, field)
			case "setupAsSudo":
				return ec.fieldContext_Distro_setupAsSudo(ctx, field)
			case "singleTaskDistro":
				return ec.fieldContext_Distro_singleTaskDistro(ctx, field)
			case "sshOptions":
				return ec.fieldContext_Distro_sshOptions(ctx, field)
			case "user":
				return ec.fieldContext_Distro_user(ctx, field)
			case "userSpawnAllowed":
				return ec.fieldContext_Distro_userSpawnAllowed(ctx, field)
			case "validProjects":
				return ec.fieldContext_Distro_validProjects(ctx, field)
			case "warningNote":
				return ec.fieldContext_Distro_warningNote(ctx, field)
			case "workDir":
				return ec.fieldContext_Distro_workDir(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Distro", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_distro_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_distroEvents(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_distroEvents(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().DistroEvents(rctx, fc.Args["opts"].(DistroEventsInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*DistroEventsPayload)
	fc.Result = res
	return ec.marshalNDistroEventsPayload2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroEventsPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_distroEvents(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_DistroEventsPayload_count(ctx, field)
			case "eventLogEntries":
				return ec.fieldContext_DistroEventsPayload_eventLogEntries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DistroEventsPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_distroEvents_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_distros(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_distros(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Distros(rctx, fc.Args["onlySpawnable"].(bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIDistro)
	fc.Result = res
	return ec.marshalNDistro2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDistroᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_distros(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "adminOnly":
				return ec.fieldContext_Distro_adminOnly(ctx, field)
			case "aliases":
				return ec.fieldContext_Distro_aliases(ctx, field)
			case "arch":
				return ec.fieldContext_Distro_arch(ctx, field)
			case "authorizedKeysFile":
				return ec.fieldContext_Distro_authorizedKeysFile(ctx, field)
			case "availableRegions":
				return ec.fieldContext_Distro_availableRegions(ctx, field)
			case "bootstrapSettings":
				return ec.fieldContext_Distro_bootstrapSettings(ctx, field)
			case "containerPool":
				return ec.fieldContext_Distro_containerPool(ctx, field)
			case "disabled":
				return ec.fieldContext_Distro_disabled(ctx, field)
			case "disableShallowClone":
				return ec.fieldContext_Distro_disableShallowClone(ctx, field)
			case "dispatcherSettings":
				return ec.fieldContext_Distro_dispatcherSettings(ctx, field)
			case "execUser":
				return ec.fieldContext_Distro_execUser(ctx, field)
			case "expansions":
				return ec.fieldContext_Distro_expansions(ctx, field)
			case "finderSettings":
				return ec.fieldContext_Distro_finderSettings(ctx, field)
			case "homeVolumeSettings":
				return ec.fieldContext_Distro_homeVolumeSettings(ctx, field)
			case "hostAllocatorSettings":
				return ec.fieldContext_Distro_hostAllocatorSettings(ctx, field)
			case "iceCreamSettings":
				return ec.fieldContext_Distro_iceCreamSettings(ctx, field)
			case "imageId":
				return ec.fieldContext_Distro_imageId(ctx, field)
			case "isCluster":
				return ec.fieldContext_Distro_isCluster(ctx, field)
			case "isVirtualWorkStation":
				return ec.fieldContext_Distro_isVirtualWorkStation(ctx, field)
			case "mountpoints":
				return ec.fieldContext_Distro_mountpoints(ctx, field)
			case "name":
				return ec.fieldContext_Distro_name(ctx, field)
			case "note":
				return ec.fieldContext_Distro_note(ctx, field)
			case "plannerSettings":
				return ec.fieldContext_Distro_plannerSettings(ctx, field)
			case "provider":
				return ec.fieldContext_Distro_provider(ctx, field)
			case "providerAccount":
				return ec.fieldContext_Distro_providerAccount(ctx, field)
			case "providerSettingsList":
				return ec.fieldContext_Distro_providerSettingsList(ctx, field)
			case "setup":
				return ec.fieldContext_Distro_setup(ctx, field)
			case "setupAsSudo":
				return ec.fieldContext_Distro_setupAsSudo(ctx, field)
			case "singleTaskDistro":
				return ec.fieldContext_Distro_singleTaskDistro(ctx, field)
			case "sshOptions":
				return ec.fieldContext_Distro_sshOptions(ctx, field)
			case "user":
				return ec.fieldContext_Distro_user(ctx, field)
			case "userSpawnAllowed":
				return ec.fieldContext_Distro_userSpawnAllowed(ctx, field)
			case "validProjects":
				return ec.fieldContext_Distro_validProjects(ctx, field)
			case "warningNote":
				return ec.fieldContext_Distro_warningNote(ctx, field)
			case "workDir":
				return ec.fieldContext_Distro_workDir(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Distro", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_distros_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_distroTaskQueue(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_distroTaskQueue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().DistroTaskQueue(rctx, fc.Args["distroId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APITaskQueueItem)
	fc.Result = res
	return ec.marshalNTaskQueueItem2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskQueueItemᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_distroTaskQueue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TaskQueueItem_id(ctx, field)
			case "buildVariant":
				return ec.fieldContext_TaskQueueItem_buildVariant(ctx, field)
			case "displayName":
				return ec.fieldContext_TaskQueueItem_displayName(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_TaskQueueItem_expectedDuration(ctx, field)
			case "priority":
				return ec.fieldContext_TaskQueueItem_priority(ctx, field)
			case "project":
				return ec.fieldContext_TaskQueueItem_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_TaskQueueItem_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_TaskQueueItem_requester(ctx, field)
			case "activatedBy":
				return ec.fieldContext_TaskQueueItem_activatedBy(ctx, field)
			case "revision":
				return ec.fieldContext_TaskQueueItem_revision(ctx, field)
			case "version":
				return ec.fieldContext_TaskQueueItem_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskQueueItem", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_distroTaskQueue_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_host(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_host(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Host(rctx, fc.Args["hostId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIHost)
	fc.Result = res
	return ec.marshalOHost2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_host(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "availabilityZone":
				return ec.fieldContext_Host_availabilityZone(ctx, field)
			case "ami":
				return ec.fieldContext_Host_ami(ctx, field)
			case "displayName":
				return ec.fieldContext_Host_displayName(ctx, field)
			case "distro":
				return ec.fieldContext_Host_distro(ctx, field)
			case "distroId":
				return ec.fieldContext_Host_distroId(ctx, field)
			case "elapsed":
				return ec.fieldContext_Host_elapsed(ctx, field)
			case "events":
				return ec.fieldContext_Host_events(ctx, field)
			case "eventTypes":
				return ec.fieldContext_Host_eventTypes(ctx, field)
			case "expiration":
				return ec.fieldContext_Host_expiration(ctx, field)
			case "hostUrl":
				return ec.fieldContext_Host_hostUrl(ctx, field)
			case "homeVolume":
				return ec.fieldContext_Host_homeVolume(ctx, field)
			case "homeVolumeID":
				return ec.fieldContext_Host_homeVolumeID(ctx, field)
			case "instanceType":
				return ec.fieldContext_Host_instanceType(ctx, field)
			case "instanceTags":
				return ec.fieldContext_Host_instanceTags(ctx, field)
			case "lastCommunicationTime":
				return ec.fieldContext_Host_lastCommunicationTime(ctx, field)
			case "noExpiration":
				return ec.fieldContext_Host_noExpiration(ctx, field)
			case "persistentDnsName":
				return ec.fieldContext_Host_persistentDnsName(ctx, field)
			case "provider":
				return ec.fieldContext_Host_provider(ctx, field)
			case "runningTask":
				return ec.fieldContext_Host_runningTask(ctx, field)
			case "sleepSchedule":
				return ec.fieldContext_Host_sleepSchedule(ctx, field)
			case "startedBy":
				return ec.fieldContext_Host_startedBy(ctx, field)
			case "status":
				return ec.fieldContext_Host_status(ctx, field)
			case "tag":
				return ec.fieldContext_Host_tag(ctx, field)
			case "totalIdleTime":
				return ec.fieldContext_Host_totalIdleTime(ctx, field)
			case "uptime":
				return ec.fieldContext_Host_uptime(ctx, field)
			case "user":
				return ec.fieldContext_Host_user(ctx, field)
			case "volumes":
				return ec.fieldContext_Host_volumes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_host_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_hostEvents(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_hostEvents(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().HostEvents(rctx, fc.Args["hostId"].(string), fc.Args["hostTag"].(*string), fc.Args["limit"].(*int), fc.Args["page"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*HostEvents)
	fc.Result = res
	return ec.marshalNHostEvents2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐHostEvents(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_hostEvents(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_HostEvents_count(ctx, field)
			case "eventLogEntries":
				return ec.fieldContext_HostEvents_eventLogEntries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HostEvents", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_hostEvents_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_hosts(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_hosts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Hosts(rctx, fc.Args["hostId"].(*string), fc.Args["distroId"].(*string), fc.Args["currentTaskId"].(*string), fc.Args["statuses"].([]string), fc.Args["startedBy"].(*string), fc.Args["sortBy"].(*HostSortBy), fc.Args["sortDir"].(*SortDirection), fc.Args["page"].(*int), fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*HostsResponse)
	fc.Result = res
	return ec.marshalNHostsResponse2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐHostsResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_hosts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "filteredHostsCount":
				return ec.fieldContext_HostsResponse_filteredHostsCount(ctx, field)
			case "hosts":
				return ec.fieldContext_HostsResponse_hosts(ctx, field)
			case "totalHostsCount":
				return ec.fieldContext_HostsResponse_totalHostsCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HostsResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_hosts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_taskQueueDistros(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_taskQueueDistros(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().TaskQueueDistros(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*TaskQueueDistro)
	fc.Result = res
	return ec.marshalNTaskQueueDistro2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskQueueDistroᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_taskQueueDistros(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TaskQueueDistro_id(ctx, field)
			case "hostCount":
				return ec.fieldContext_TaskQueueDistro_hostCount(ctx, field)
			case "taskCount":
				return ec.fieldContext_TaskQueueDistro_taskCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskQueueDistro", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_pod(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_pod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Pod(rctx, fc.Args["podId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIPod)
	fc.Result = res
	return ec.marshalNPod2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_pod(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "events":
				return ec.fieldContext_Pod_events(ctx, field)
			case "id":
				return ec.fieldContext_Pod_id(ctx, field)
			case "status":
				return ec.fieldContext_Pod_status(ctx, field)
			case "task":
				return ec.fieldContext_Pod_task(ctx, field)
			case "taskContainerCreationOpts":
				return ec.fieldContext_Pod_taskContainerCreationOpts(ctx, field)
			case "type":
				return ec.fieldContext_Pod_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Pod", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_pod_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_patch(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_patch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Patch(rctx, fc.Args["patchId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIPatch)
	fc.Result = res
	return ec.marshalNPatch2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_patch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Patch_id(ctx, field)
			case "activated":
				return ec.fieldContext_Patch_activated(ctx, field)
			case "alias":
				return ec.fieldContext_Patch_alias(ctx, field)
			case "author":
				return ec.fieldContext_Patch_author(ctx, field)
			case "authorDisplayName":
				return ec.fieldContext_Patch_authorDisplayName(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Patch_baseTaskStatuses(ctx, field)
			case "builds":
				return ec.fieldContext_Patch_builds(ctx, field)
			case "childPatchAliases":
				return ec.fieldContext_Patch_childPatchAliases(ctx, field)
			case "childPatches":
				return ec.fieldContext_Patch_childPatches(ctx, field)
			case "createTime":
				return ec.fieldContext_Patch_createTime(ctx, field)
			case "description":
				return ec.fieldContext_Patch_description(ctx, field)
			case "duration":
				return ec.fieldContext_Patch_duration(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Patch_generatedTaskCounts(ctx, field)
			case "githash":
				return ec.fieldContext_Patch_githash(ctx, field)
			case "githubPatchData":
				return ec.fieldContext_Patch_githubPatchData(ctx, field)
			case "hidden":
				return ec.fieldContext_Patch_hidden(ctx, field)
			case "moduleCodeChanges":
				return ec.fieldContext_Patch_moduleCodeChanges(ctx, field)
			case "parameters":
				return ec.fieldContext_Patch_parameters(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Patch_patchNumber(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Patch_patchTriggerAliases(ctx, field)
			case "project":
				return ec.fieldContext_Patch_project(ctx, field)
			case "projectID":
				return ec.fieldContext_Patch_projectID(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Patch_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Patch_projectMetadata(ctx, field)
			case "status":
				return ec.fieldContext_Patch_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Patch_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Patch_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Patch_taskStatuses(ctx, field)
			case "time":
				return ec.fieldContext_Patch_time(ctx, field)
			case "variants":
				return ec.fieldContext_Patch_variants(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_Patch_variantsTasks(ctx, field)
			case "versionFull":
				return ec.fieldContext_Patch_versionFull(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Patch", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_patch_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_githubProjectConflicts(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_githubProjectConflicts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GithubProjectConflicts(rctx, fc.Args["projectId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model1.GithubProjectConflicts)
	fc.Result = res
	return ec.marshalNGithubProjectConflicts2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐGithubProjectConflicts(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_githubProjectConflicts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "commitCheckIdentifiers":
				return ec.fieldContext_GithubProjectConflicts_commitCheckIdentifiers(ctx, field)
			case "commitQueueIdentifiers":
				return ec.fieldContext_GithubProjectConflicts_commitQueueIdentifiers(ctx, field)
			case "prTestingIdentifiers":
				return ec.fieldContext_GithubProjectConflicts_prTestingIdentifiers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubProjectConflicts", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_githubProjectConflicts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_project(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_project(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Project(rctx, fc.Args["projectIdentifier"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectRef)
	fc.Result = res
	return ec.marshalNProject2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_project(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "githubPRTriggerAliases":
				return ec.fieldContext_Project_githubPRTriggerAliases(ctx, field)
			case "githubMQTriggerAliases":
				return ec.fieldContext_Project_githubMQTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_project_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_projects(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_projects(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Projects(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*GroupedProjects)
	fc.Result = res
	return ec.marshalNGroupedProjects2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐGroupedProjectsᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_projects(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "groupDisplayName":
				return ec.fieldContext_GroupedProjects_groupDisplayName(ctx, field)
			case "projects":
				return ec.fieldContext_GroupedProjects_projects(ctx, field)
			case "repo":
				return ec.fieldContext_GroupedProjects_repo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupedProjects", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_projectEvents(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_projectEvents(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ProjectEvents(rctx, fc.Args["projectIdentifier"].(string), fc.Args["limit"].(*int), fc.Args["before"].(*time.Time))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ProjectEvents)
	fc.Result = res
	return ec.marshalNProjectEvents2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectEvents(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_projectEvents(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_ProjectEvents_count(ctx, field)
			case "eventLogEntries":
				return ec.fieldContext_ProjectEvents_eventLogEntries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectEvents", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_projectEvents_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_projectSettings(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_projectSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ProjectSettings(rctx, fc.Args["projectIdentifier"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectSettings)
	fc.Result = res
	return ec.marshalNProjectSettings2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_projectSettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aliases":
				return ec.fieldContext_ProjectSettings_aliases(ctx, field)
			case "githubAppAuth":
				return ec.fieldContext_ProjectSettings_githubAppAuth(ctx, field)
			case "githubWebhooksEnabled":
				return ec.fieldContext_ProjectSettings_githubWebhooksEnabled(ctx, field)
			case "projectRef":
				return ec.fieldContext_ProjectSettings_projectRef(ctx, field)
			case "subscriptions":
				return ec.fieldContext_ProjectSettings_subscriptions(ctx, field)
			case "vars":
				return ec.fieldContext_ProjectSettings_vars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectSettings", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_projectSettings_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_repoEvents(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_repoEvents(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().RepoEvents(rctx, fc.Args["repoId"].(string), fc.Args["limit"].(*int), fc.Args["before"].(*time.Time))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ProjectEvents)
	fc.Result = res
	return ec.marshalNProjectEvents2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectEvents(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_repoEvents(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_ProjectEvents_count(ctx, field)
			case "eventLogEntries":
				return ec.fieldContext_ProjectEvents_eventLogEntries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectEvents", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_repoEvents_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_repoSettings(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_repoSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().RepoSettings(rctx, fc.Args["repoId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectSettings)
	fc.Result = res
	return ec.marshalNRepoSettings2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_repoSettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aliases":
				return ec.fieldContext_RepoSettings_aliases(ctx, field)
			case "githubAppAuth":
				return ec.fieldContext_RepoSettings_githubAppAuth(ctx, field)
			case "githubWebhooksEnabled":
				return ec.fieldContext_RepoSettings_githubWebhooksEnabled(ctx, field)
			case "projectRef":
				return ec.fieldContext_RepoSettings_projectRef(ctx, field)
			case "subscriptions":
				return ec.fieldContext_RepoSettings_subscriptions(ctx, field)
			case "vars":
				return ec.fieldContext_RepoSettings_vars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepoSettings", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_repoSettings_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_viewableProjectRefs(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_viewableProjectRefs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ViewableProjectRefs(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*GroupedProjects)
	fc.Result = res
	return ec.marshalNGroupedProjects2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐGroupedProjectsᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_viewableProjectRefs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "groupDisplayName":
				return ec.fieldContext_GroupedProjects_groupDisplayName(ctx, field)
			case "projects":
				return ec.fieldContext_GroupedProjects_projects(ctx, field)
			case "repo":
				return ec.fieldContext_GroupedProjects_repo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupedProjects", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_isRepo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_isRepo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().IsRepo(rctx, fc.Args["projectOrRepoId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_isRepo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_isRepo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_myHosts(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_myHosts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MyHosts(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIHost)
	fc.Result = res
	return ec.marshalNHost2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHostᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_myHosts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "availabilityZone":
				return ec.fieldContext_Host_availabilityZone(ctx, field)
			case "ami":
				return ec.fieldContext_Host_ami(ctx, field)
			case "displayName":
				return ec.fieldContext_Host_displayName(ctx, field)
			case "distro":
				return ec.fieldContext_Host_distro(ctx, field)
			case "distroId":
				return ec.fieldContext_Host_distroId(ctx, field)
			case "elapsed":
				return ec.fieldContext_Host_elapsed(ctx, field)
			case "events":
				return ec.fieldContext_Host_events(ctx, field)
			case "eventTypes":
				return ec.fieldContext_Host_eventTypes(ctx, field)
			case "expiration":
				return ec.fieldContext_Host_expiration(ctx, field)
			case "hostUrl":
				return ec.fieldContext_Host_hostUrl(ctx, field)
			case "homeVolume":
				return ec.fieldContext_Host_homeVolume(ctx, field)
			case "homeVolumeID":
				return ec.fieldContext_Host_homeVolumeID(ctx, field)
			case "instanceType":
				return ec.fieldContext_Host_instanceType(ctx, field)
			case "instanceTags":
				return ec.fieldContext_Host_instanceTags(ctx, field)
			case "lastCommunicationTime":
				return ec.fieldContext_Host_lastCommunicationTime(ctx, field)
			case "noExpiration":
				return ec.fieldContext_Host_noExpiration(ctx, field)
			case "persistentDnsName":
				return ec.fieldContext_Host_persistentDnsName(ctx, field)
			case "provider":
				return ec.fieldContext_Host_provider(ctx, field)
			case "runningTask":
				return ec.fieldContext_Host_runningTask(ctx, field)
			case "sleepSchedule":
				return ec.fieldContext_Host_sleepSchedule(ctx, field)
			case "startedBy":
				return ec.fieldContext_Host_startedBy(ctx, field)
			case "status":
				return ec.fieldContext_Host_status(ctx, field)
			case "tag":
				return ec.fieldContext_Host_tag(ctx, field)
			case "totalIdleTime":
				return ec.fieldContext_Host_totalIdleTime(ctx, field)
			case "uptime":
				return ec.fieldContext_Host_uptime(ctx, field)
			case "user":
				return ec.fieldContext_Host_user(ctx, field)
			case "volumes":
				return ec.fieldContext_Host_volumes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_myVolumes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_myVolumes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MyVolumes(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIVolume)
	fc.Result = res
	return ec.marshalNVolume2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVolumeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_myVolumes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Volume_id(ctx, field)
			case "availabilityZone":
				return ec.fieldContext_Volume_availabilityZone(ctx, field)
			case "createdBy":
				return ec.fieldContext_Volume_createdBy(ctx, field)
			case "creationTime":
				return ec.fieldContext_Volume_creationTime(ctx, field)
			case "deviceName":
				return ec.fieldContext_Volume_deviceName(ctx, field)
			case "displayName":
				return ec.fieldContext_Volume_displayName(ctx, field)
			case "expiration":
				return ec.fieldContext_Volume_expiration(ctx, field)
			case "homeVolume":
				return ec.fieldContext_Volume_homeVolume(ctx, field)
			case "host":
				return ec.fieldContext_Volume_host(ctx, field)
			case "hostID":
				return ec.fieldContext_Volume_hostID(ctx, field)
			case "migrating":
				return ec.fieldContext_Volume_migrating(ctx, field)
			case "noExpiration":
				return ec.fieldContext_Volume_noExpiration(ctx, field)
			case "size":
				return ec.fieldContext_Volume_size(ctx, field)
			case "type":
				return ec.fieldContext_Volume_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Volume", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_logkeeperBuildMetadata(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_logkeeperBuildMetadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().LogkeeperBuildMetadata(rctx, fc.Args["buildId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*plank.Build)
	fc.Result = res
	return ec.marshalNLogkeeperBuild2ᚖgithubᚗcomᚋevergreenᚑciᚋplankᚐBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_logkeeperBuildMetadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LogkeeperBuild_id(ctx, field)
			case "builder":
				return ec.fieldContext_LogkeeperBuild_builder(ctx, field)
			case "buildNum":
				return ec.fieldContext_LogkeeperBuild_buildNum(ctx, field)
			case "taskId":
				return ec.fieldContext_LogkeeperBuild_taskId(ctx, field)
			case "taskExecution":
				return ec.fieldContext_LogkeeperBuild_taskExecution(ctx, field)
			case "tests":
				return ec.fieldContext_LogkeeperBuild_tests(ctx, field)
			case "task":
				return ec.fieldContext_LogkeeperBuild_task(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LogkeeperBuild", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_logkeeperBuildMetadata_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_task(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_task(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Task(rctx, fc.Args["taskId"].(string), fc.Args["execution"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APITask)
	fc.Result = res
	return ec.marshalOTask2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_task(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_task_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_taskAllExecutions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_taskAllExecutions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().TaskAllExecutions(rctx, fc.Args["taskId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APITask)
	fc.Result = res
	return ec.marshalNTask2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_taskAllExecutions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_taskAllExecutions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_taskTestSample(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_taskTestSample(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().TaskTestSample(rctx, fc.Args["versionId"].(string), fc.Args["taskIds"].([]string), fc.Args["filters"].([]*TestFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*TaskTestResultSample)
	fc.Result = res
	return ec.marshalOTaskTestResultSample2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskTestResultSampleᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_taskTestSample(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "execution":
				return ec.fieldContext_TaskTestResultSample_execution(ctx, field)
			case "matchingFailedTestNames":
				return ec.fieldContext_TaskTestResultSample_matchingFailedTestNames(ctx, field)
			case "taskId":
				return ec.fieldContext_TaskTestResultSample_taskId(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_TaskTestResultSample_totalTestCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskTestResultSample", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_taskTestSample_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_myPublicKeys(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_myPublicKeys(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MyPublicKeys(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIPubKey)
	fc.Result = res
	return ec.marshalNPublicKey2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPubKeyᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_myPublicKeys(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_PublicKey_key(ctx, field)
			case "name":
				return ec.fieldContext_PublicKey_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PublicKey", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_user(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().User(rctx, fc.Args["userId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIDBUser)
	fc.Result = res
	return ec.marshalNUser2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDBUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "betaFeatures":
				return ec.fieldContext_User_betaFeatures(ctx, field)
			case "displayName":
				return ec.fieldContext_User_displayName(ctx, field)
			case "emailAddress":
				return ec.fieldContext_User_emailAddress(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_User_parsleyFilters(ctx, field)
			case "parsleySettings":
				return ec.fieldContext_User_parsleySettings(ctx, field)
			case "patches":
				return ec.fieldContext_User_patches(ctx, field)
			case "permissions":
				return ec.fieldContext_User_permissions(ctx, field)
			case "settings":
				return ec.fieldContext_User_settings(ctx, field)
			case "subscriptions":
				return ec.fieldContext_User_subscriptions(ctx, field)
			case "userId":
				return ec.fieldContext_User_userId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_user_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_userConfig(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserConfig(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*UserConfig)
	fc.Result = res
	return ec.marshalOUserConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐUserConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userConfig(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "api_key":
				return ec.fieldContext_UserConfig_api_key(ctx, field)
			case "api_server_host":
				return ec.fieldContext_UserConfig_api_server_host(ctx, field)
			case "ui_server_host":
				return ec.fieldContext_UserConfig_ui_server_host(ctx, field)
			case "user":
				return ec.fieldContext_UserConfig_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_buildVariantsForTaskName(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_buildVariantsForTaskName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().BuildVariantsForTaskName(rctx, fc.Args["projectIdentifier"].(string), fc.Args["taskName"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*task.BuildVariantTuple)
	fc.Result = res
	return ec.marshalOBuildVariantTuple2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋtaskᚐBuildVariantTupleᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_buildVariantsForTaskName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "buildVariant":
				return ec.fieldContext_BuildVariantTuple_buildVariant(ctx, field)
			case "displayName":
				return ec.fieldContext_BuildVariantTuple_displayName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BuildVariantTuple", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_buildVariantsForTaskName_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_mainlineCommits(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_mainlineCommits(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MainlineCommits(rctx, fc.Args["options"].(MainlineCommitsOptions), fc.Args["buildVariantOptions"].(*BuildVariantOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*MainlineCommits)
	fc.Result = res
	return ec.marshalOMainlineCommits2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐMainlineCommits(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_mainlineCommits(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nextPageOrderNumber":
				return ec.fieldContext_MainlineCommits_nextPageOrderNumber(ctx, field)
			case "prevPageOrderNumber":
				return ec.fieldContext_MainlineCommits_prevPageOrderNumber(ctx, field)
			case "versions":
				return ec.fieldContext_MainlineCommits_versions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MainlineCommits", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_mainlineCommits_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_taskNamesForBuildVariant(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_taskNamesForBuildVariant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().TaskNamesForBuildVariant(rctx, fc.Args["projectIdentifier"].(string), fc.Args["buildVariant"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_taskNamesForBuildVariant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_taskNamesForBuildVariant_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_waterfall(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_waterfall(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Waterfall(rctx, fc.Args["options"].(WaterfallOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Waterfall)
	fc.Result = res
	return ec.marshalNWaterfall2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐWaterfall(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_waterfall(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "flattenedVersions":
				return ec.fieldContext_Waterfall_flattenedVersions(ctx, field)
			case "pagination":
				return ec.fieldContext_Waterfall_pagination(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Waterfall", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_waterfall_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_taskHistory(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_taskHistory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().TaskHistory(rctx, fc.Args["options"].(TaskHistoryOpts))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*TaskHistory)
	fc.Result = res
	return ec.marshalNTaskHistory2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskHistory(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_taskHistory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tasks":
				return ec.fieldContext_TaskHistory_tasks(ctx, field)
			case "pagination":
				return ec.fieldContext_TaskHistory_pagination(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskHistory", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_taskHistory_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_hasVersion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_hasVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().HasVersion(rctx, fc.Args["patchId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_hasVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_hasVersion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_version(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Version(rctx, fc.Args["versionId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIVersion)
	fc.Result = res
	return ec.marshalNVersion2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "authorEmail":
				return ec.fieldContext_Version_authorEmail(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Version_generatedTaskCounts(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "ignored":
				return ec.fieldContext_Version_ignored(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			case "waterfallBuilds":
				return ec.fieldContext_Version_waterfallBuilds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_version_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_image(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_image(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Image(rctx, fc.Args["imageId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIImage)
	fc.Result = res
	return ec.marshalOImage2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIImage(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_image(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Image_id(ctx, field)
			case "ami":
				return ec.fieldContext_Image_ami(ctx, field)
			case "distros":
				return ec.fieldContext_Image_distros(ctx, field)
			case "events":
				return ec.fieldContext_Image_events(ctx, field)
			case "lastDeployed":
				return ec.fieldContext_Image_lastDeployed(ctx, field)
			case "latestTask":
				return ec.fieldContext_Image_latestTask(ctx, field)
			case "operatingSystem":
				return ec.fieldContext_Image_operatingSystem(ctx, field)
			case "packages":
				return ec.fieldContext_Image_packages(ctx, field)
			case "toolchains":
				return ec.fieldContext_Image_toolchains(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Image", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_image_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query_images(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_images(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Images(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_images(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoCommitQueueParams_enabled(ctx context.Context, field graphql.CollectedField, obj *model.APICommitQueueParams) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoCommitQueueParams_enabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoCommitQueueParams_enabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoCommitQueueParams",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoCommitQueueParams_mergeMethod(ctx context.Context, field graphql.CollectedField, obj *model.APICommitQueueParams) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoCommitQueueParams_mergeMethod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MergeMethod, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoCommitQueueParams_mergeMethod(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoCommitQueueParams",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoCommitQueueParams_message(ctx context.Context, field graphql.CollectedField, obj *model.APICommitQueueParams) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoCommitQueueParams_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoCommitQueueParams_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoCommitQueueParams",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoPermissions_edit(ctx context.Context, field graphql.CollectedField, obj *RepoPermissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoPermissions_edit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoPermissions_edit(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoPermissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoPermissions_view(ctx context.Context, field graphql.CollectedField, obj *RepoPermissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoPermissions_view(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.View, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoPermissions_view(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoPermissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_id(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_admins(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_admins(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Admins, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalNString2ᚕᚖstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_admins(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_batchTime(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_batchTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BatchTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_batchTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_buildBaronSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_buildBaronSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildBaronSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIBuildBaronSettings)
	fc.Result = res
	return ec.marshalNBuildBaronSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIBuildBaronSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_buildBaronSettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "bfSuggestionFeaturesURL":
				return ec.fieldContext_BuildBaronSettings_bfSuggestionFeaturesURL(ctx, field)
			case "bfSuggestionPassword":
				return ec.fieldContext_BuildBaronSettings_bfSuggestionPassword(ctx, field)
			case "bfSuggestionServer":
				return ec.fieldContext_BuildBaronSettings_bfSuggestionServer(ctx, field)
			case "bfSuggestionTimeoutSecs":
				return ec.fieldContext_BuildBaronSettings_bfSuggestionTimeoutSecs(ctx, field)
			case "bfSuggestionUsername":
				return ec.fieldContext_BuildBaronSettings_bfSuggestionUsername(ctx, field)
			case "ticketCreateProject":
				return ec.fieldContext_BuildBaronSettings_ticketCreateProject(ctx, field)
			case "ticketSearchProjects":
				return ec.fieldContext_BuildBaronSettings_ticketSearchProjects(ctx, field)
			case "ticketCreateIssueType":
				return ec.fieldContext_BuildBaronSettings_ticketCreateIssueType(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BuildBaronSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_commitQueue(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_commitQueue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CommitQueue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APICommitQueueParams)
	fc.Result = res
	return ec.marshalNRepoCommitQueueParams2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPICommitQueueParams(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_commitQueue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "enabled":
				return ec.fieldContext_RepoCommitQueueParams_enabled(ctx, field)
			case "mergeMethod":
				return ec.fieldContext_RepoCommitQueueParams_mergeMethod(ctx, field)
			case "message":
				return ec.fieldContext_RepoCommitQueueParams_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepoCommitQueueParams", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_containerSizeDefinitions(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_containerSizeDefinitions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContainerSizeDefinitions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIContainerResources)
	fc.Result = res
	return ec.marshalOContainerResources2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIContainerResourcesᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_containerSizeDefinitions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ContainerResources_name(ctx, field)
			case "cpu":
				return ec.fieldContext_ContainerResources_cpu(ctx, field)
			case "memoryMb":
				return ec.fieldContext_ContainerResources_memoryMb(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContainerResources", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_deactivatePrevious(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_deactivatePrevious(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeactivatePrevious, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_deactivatePrevious(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_disabledStatsCache(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_disabledStatsCache(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisabledStatsCache, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_disabledStatsCache(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_dispatchingDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_dispatchingDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DispatchingDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_dispatchingDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_displayName(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_enabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_enabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_enabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_githubChecksEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_githubChecksEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GithubChecksEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_githubChecksEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_githubDynamicTokenPermissionGroups(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_githubDynamicTokenPermissionGroups(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GitHubDynamicTokenPermissionGroups, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APIGitHubDynamicTokenPermissionGroup)
	fc.Result = res
	return ec.marshalNGitHubDynamicTokenPermissionGroup2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGitHubDynamicTokenPermissionGroupᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_githubDynamicTokenPermissionGroups(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_GitHubDynamicTokenPermissionGroup_name(ctx, field)
			case "permissions":
				return ec.fieldContext_GitHubDynamicTokenPermissionGroup_permissions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GitHubDynamicTokenPermissionGroup", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_githubPermissionGroupByRequester(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_githubPermissionGroupByRequester(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GitHubPermissionGroupByRequester, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]string)
	fc.Result = res
	return ec.marshalOStringMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_githubPermissionGroupByRequester(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StringMap does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_githubTriggerAliases(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_githubTriggerAliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RepoRef().GithubTriggerAliases(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_githubTriggerAliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_githubPRTriggerAliases(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_githubPRTriggerAliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GithubPRTriggerAliases, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2ᚕᚖstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_githubPRTriggerAliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_githubMQTriggerAliases(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_githubMQTriggerAliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GithubMQTriggerAliases, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2ᚕᚖstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_githubMQTriggerAliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_gitTagAuthorizedTeams(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_gitTagAuthorizedTeams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GitTagAuthorizedTeams, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2ᚕᚖstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_gitTagAuthorizedTeams(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_gitTagAuthorizedUsers(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_gitTagAuthorizedUsers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GitTagAuthorizedUsers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2ᚕᚖstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_gitTagAuthorizedUsers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_gitTagVersionsEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_gitTagVersionsEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GitTagVersionsEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_gitTagVersionsEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_manualPrTestingEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_manualPrTestingEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ManualPRTestingEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_manualPrTestingEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_notifyOnBuildFailure(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_notifyOnBuildFailure(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NotifyOnBuildFailure, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_notifyOnBuildFailure(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_oldestAllowedMergeBase(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_oldestAllowedMergeBase(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OldestAllowedMergeBase, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_oldestAllowedMergeBase(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_owner(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_owner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_owner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_parsleyFilters(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_parsleyFilters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParsleyFilters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIParsleyFilter)
	fc.Result = res
	return ec.marshalOParsleyFilter2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParsleyFilterᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_parsleyFilters(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "caseSensitive":
				return ec.fieldContext_ParsleyFilter_caseSensitive(ctx, field)
			case "description":
				return ec.fieldContext_ParsleyFilter_description(ctx, field)
			case "exactMatch":
				return ec.fieldContext_ParsleyFilter_exactMatch(ctx, field)
			case "expression":
				return ec.fieldContext_ParsleyFilter_expression(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ParsleyFilter", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_patchingDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_patchingDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PatchingDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_patchingDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_patchTriggerAliases(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_patchTriggerAliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PatchTriggerAliases, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIPatchTriggerDefinition)
	fc.Result = res
	return ec.marshalOPatchTriggerAlias2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatchTriggerDefinitionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_patchTriggerAliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "alias":
				return ec.fieldContext_PatchTriggerAlias_alias(ctx, field)
			case "childProjectId":
				return ec.fieldContext_PatchTriggerAlias_childProjectId(ctx, field)
			case "childProjectIdentifier":
				return ec.fieldContext_PatchTriggerAlias_childProjectIdentifier(ctx, field)
			case "parentAsModule":
				return ec.fieldContext_PatchTriggerAlias_parentAsModule(ctx, field)
			case "status":
				return ec.fieldContext_PatchTriggerAlias_status(ctx, field)
			case "downstreamRevision":
				return ec.fieldContext_PatchTriggerAlias_downstreamRevision(ctx, field)
			case "taskSpecifiers":
				return ec.fieldContext_PatchTriggerAlias_taskSpecifiers(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_PatchTriggerAlias_variantsTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PatchTriggerAlias", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_perfEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_perfEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PerfEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_perfEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_periodicBuilds(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_periodicBuilds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PeriodicBuilds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIPeriodicBuildDefinition)
	fc.Result = res
	return ec.marshalOPeriodicBuild2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPeriodicBuildDefinitionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_periodicBuilds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_PeriodicBuild_id(ctx, field)
			case "alias":
				return ec.fieldContext_PeriodicBuild_alias(ctx, field)
			case "configFile":
				return ec.fieldContext_PeriodicBuild_configFile(ctx, field)
			case "intervalHours":
				return ec.fieldContext_PeriodicBuild_intervalHours(ctx, field)
			case "cron":
				return ec.fieldContext_PeriodicBuild_cron(ctx, field)
			case "message":
				return ec.fieldContext_PeriodicBuild_message(ctx, field)
			case "nextRunTime":
				return ec.fieldContext_PeriodicBuild_nextRunTime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PeriodicBuild", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_prTestingEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_prTestingEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PRTestingEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_prTestingEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_remotePath(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_remotePath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RemotePath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_remotePath(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_repo(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_repo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_repo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_repotrackerDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_repotrackerDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepotrackerDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_repotrackerDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_restricted(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_restricted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Restricted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_restricted(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_spawnHostScriptPath(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_spawnHostScriptPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpawnHostScriptPath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_spawnHostScriptPath(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_stepbackDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_stepbackDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StepbackDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_stepbackDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_stepbackBisect(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_stepbackBisect(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StepbackBisect, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_stepbackBisect(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_taskAnnotationSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_taskAnnotationSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskAnnotationSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APITaskAnnotationSettings)
	fc.Result = res
	return ec.marshalNTaskAnnotationSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskAnnotationSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_taskAnnotationSettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "fileTicketWebhook":
				return ec.fieldContext_TaskAnnotationSettings_fileTicketWebhook(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskAnnotationSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_tracksPushEvents(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_tracksPushEvents(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TracksPushEvents, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_tracksPushEvents(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_triggers(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_triggers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Triggers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APITriggerDefinition)
	fc.Result = res
	return ec.marshalNTriggerAlias2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITriggerDefinitionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_triggers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "alias":
				return ec.fieldContext_TriggerAlias_alias(ctx, field)
			case "buildVariantRegex":
				return ec.fieldContext_TriggerAlias_buildVariantRegex(ctx, field)
			case "configFile":
				return ec.fieldContext_TriggerAlias_configFile(ctx, field)
			case "dateCutoff":
				return ec.fieldContext_TriggerAlias_dateCutoff(ctx, field)
			case "level":
				return ec.fieldContext_TriggerAlias_level(ctx, field)
			case "project":
				return ec.fieldContext_TriggerAlias_project(ctx, field)
			case "status":
				return ec.fieldContext_TriggerAlias_status(ctx, field)
			case "taskRegex":
				return ec.fieldContext_TriggerAlias_taskRegex(ctx, field)
			case "unscheduleDownstreamVersions":
				return ec.fieldContext_TriggerAlias_unscheduleDownstreamVersions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TriggerAlias", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_versionControlEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_versionControlEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VersionControlEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_versionControlEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_workstationConfig(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_workstationConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkstationConfig, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIWorkstationConfig)
	fc.Result = res
	return ec.marshalNRepoWorkstationConfig2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWorkstationConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_workstationConfig(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "gitClone":
				return ec.fieldContext_RepoWorkstationConfig_gitClone(ctx, field)
			case "setupCommands":
				return ec.fieldContext_RepoWorkstationConfig_setupCommands(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepoWorkstationConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_externalLinks(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_externalLinks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExternalLinks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIExternalLink)
	fc.Result = res
	return ec.marshalOExternalLink2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIExternalLinkᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_externalLinks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "displayName":
				return ec.fieldContext_ExternalLink_displayName(ctx, field)
			case "requesters":
				return ec.fieldContext_ExternalLink_requesters(ctx, field)
			case "urlTemplate":
				return ec.fieldContext_ExternalLink_urlTemplate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ExternalLink", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoSettings_aliases(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoSettings_aliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RepoSettings().Aliases(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.APIProjectAlias)
	fc.Result = res
	return ec.marshalOProjectAlias2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectAliasᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoSettings_aliases(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProjectAlias_id(ctx, field)
			case "alias":
				return ec.fieldContext_ProjectAlias_alias(ctx, field)
			case "description":
				return ec.fieldContext_ProjectAlias_description(ctx, field)
			case "gitTag":
				return ec.fieldContext_ProjectAlias_gitTag(ctx, field)
			case "remotePath":
				return ec.fieldContext_ProjectAlias_remotePath(ctx, field)
			case "task":
				return ec.fieldContext_ProjectAlias_task(ctx, field)
			case "taskTags":
				return ec.fieldContext_ProjectAlias_taskTags(ctx, field)
			case "variant":
				return ec.fieldContext_ProjectAlias_variant(ctx, field)
			case "variantTags":
				return ec.fieldContext_ProjectAlias_variantTags(ctx, field)
			case "parameters":
				return ec.fieldContext_ProjectAlias_parameters(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectAlias", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoSettings_githubAppAuth(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoSettings_githubAppAuth(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RepoSettings().GithubAppAuth(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIGithubAppAuth)
	fc.Result = res
	return ec.marshalOGithubAppAuth2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGithubAppAuth(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoSettings_githubAppAuth(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "appId":
				return ec.fieldContext_GithubAppAuth_appId(ctx, field)
			case "privateKey":
				return ec.fieldContext_GithubAppAuth_privateKey(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubAppAuth", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoSettings_githubWebhooksEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoSettings_githubWebhooksEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RepoSettings().GithubWebhooksEnabled(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoSettings_githubWebhooksEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoSettings_projectRef(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoSettings_projectRef(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ProjectRef, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.RequireProjectSettingsAccess == nil {
				var zeroVal model.APIProjectRef
				return zeroVal, errors.New("directive requireProjectSettingsAccess is not implemented")
			}
			return ec.directives.RequireProjectSettingsAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.APIProjectRef); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/rest/model.APIProjectRef`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.APIProjectRef)
	fc.Result = res
	return ec.marshalORepoRef2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoSettings_projectRef(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RepoRef_id(ctx, field)
			case "admins":
				return ec.fieldContext_RepoRef_admins(ctx, field)
			case "batchTime":
				return ec.fieldContext_RepoRef_batchTime(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_RepoRef_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_RepoRef_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_RepoRef_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_RepoRef_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_RepoRef_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_RepoRef_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_RepoRef_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_RepoRef_enabled(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_RepoRef_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_RepoRef_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_RepoRef_githubPermissionGroupByRequester(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_RepoRef_githubTriggerAliases(ctx, field)
			case "githubPRTriggerAliases":
				return ec.fieldContext_RepoRef_githubPRTriggerAliases(ctx, field)
			case "githubMQTriggerAliases":
				return ec.fieldContext_RepoRef_githubMQTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_RepoRef_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_RepoRef_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_RepoRef_gitTagVersionsEnabled(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_RepoRef_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_RepoRef_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_RepoRef_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_RepoRef_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_RepoRef_parsleyFilters(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_RepoRef_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_RepoRef_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_RepoRef_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_RepoRef_periodicBuilds(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_RepoRef_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_RepoRef_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_RepoRef_repo(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_RepoRef_repotrackerDisabled(ctx, field)
			case "restricted":
				return ec.fieldContext_RepoRef_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_RepoRef_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_RepoRef_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_RepoRef_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_RepoRef_taskAnnotationSettings(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_RepoRef_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_RepoRef_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_RepoRef_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_RepoRef_workstationConfig(ctx, field)
			case "externalLinks":
				return ec.fieldContext_RepoRef_externalLinks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepoRef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoSettings_subscriptions(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoSettings_subscriptions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RepoSettings().Subscriptions(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.APISubscription)
	fc.Result = res
	return ec.marshalOGeneralSubscription2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISubscriptionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoSettings_subscriptions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GeneralSubscription_id(ctx, field)
			case "ownerType":
				return ec.fieldContext_GeneralSubscription_ownerType(ctx, field)
			case "regexSelectors":
				return ec.fieldContext_GeneralSubscription_regexSelectors(ctx, field)
			case "resourceType":
				return ec.fieldContext_GeneralSubscription_resourceType(ctx, field)
			case "selectors":
				return ec.fieldContext_GeneralSubscription_selectors(ctx, field)
			case "subscriber":
				return ec.fieldContext_GeneralSubscription_subscriber(ctx, field)
			case "trigger":
				return ec.fieldContext_GeneralSubscription_trigger(ctx, field)
			case "triggerData":
				return ec.fieldContext_GeneralSubscription_triggerData(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GeneralSubscription", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoSettings_vars(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoSettings_vars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RepoSettings().Vars(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectVars)
	fc.Result = res
	return ec.marshalOProjectVars2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectVars(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoSettings_vars(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "adminOnlyVars":
				return ec.fieldContext_ProjectVars_adminOnlyVars(ctx, field)
			case "privateVars":
				return ec.fieldContext_ProjectVars_privateVars(ctx, field)
			case "vars":
				return ec.fieldContext_ProjectVars_vars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectVars", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoWorkstationConfig_gitClone(ctx context.Context, field graphql.CollectedField, obj *model.APIWorkstationConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoWorkstationConfig_gitClone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GitClone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoWorkstationConfig_gitClone(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoWorkstationConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoWorkstationConfig_setupCommands(ctx context.Context, field graphql.CollectedField, obj *model.APIWorkstationConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoWorkstationConfig_setupCommands(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SetupCommands, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIWorkstationSetupCommand)
	fc.Result = res
	return ec.marshalOWorkstationSetupCommand2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWorkstationSetupCommandᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoWorkstationConfig_setupCommands(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoWorkstationConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "command":
				return ec.fieldContext_WorkstationSetupCommand_command(ctx, field)
			case "directory":
				return ec.fieldContext_WorkstationSetupCommand_directory(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkstationSetupCommand", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepotrackerConfig_numNewRepoRevisionsToFetch(ctx context.Context, field graphql.CollectedField, obj *model.APIRepoTrackerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepotrackerConfig_numNewRepoRevisionsToFetch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumNewRepoRevisionsToFetch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepotrackerConfig_numNewRepoRevisionsToFetch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepotrackerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepotrackerConfig_maxRepoRevisionsToSearch(ctx context.Context, field graphql.CollectedField, obj *model.APIRepoTrackerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepotrackerConfig_maxRepoRevisionsToSearch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxRepoRevisionsToSearch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepotrackerConfig_maxRepoRevisionsToSearch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepotrackerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepotrackerConfig_maxConcurrentRequests(ctx context.Context, field graphql.CollectedField, obj *model.APIRepoTrackerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepotrackerConfig_maxConcurrentRequests(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxConcurrentRequests, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepotrackerConfig_maxConcurrentRequests(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepotrackerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepotrackerError_exists(ctx context.Context, field graphql.CollectedField, obj *model.APIRepositoryErrorDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepotrackerError_exists(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Exists, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepotrackerError_exists(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepotrackerError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepotrackerError_invalidRevision(ctx context.Context, field graphql.CollectedField, obj *model.APIRepositoryErrorDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepotrackerError_invalidRevision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InvalidRevision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepotrackerError_invalidRevision(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepotrackerError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepotrackerError_mergeBaseRevision(ctx context.Context, field graphql.CollectedField, obj *model.APIRepositoryErrorDetails) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepotrackerError_mergeBaseRevision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MergeBaseRevision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepotrackerError_mergeBaseRevision(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepotrackerError",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceLimits_lockedMemoryKb(ctx context.Context, field graphql.CollectedField, obj *model.APIResourceLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceLimits_lockedMemoryKb(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LockedMemoryKB, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceLimits_lockedMemoryKb(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceLimits_numFiles(ctx context.Context, field graphql.CollectedField, obj *model.APIResourceLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceLimits_numFiles(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumFiles, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceLimits_numFiles(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceLimits_numProcesses(ctx context.Context, field graphql.CollectedField, obj *model.APIResourceLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceLimits_numProcesses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumProcesses, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceLimits_numProcesses(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceLimits_numTasks(ctx context.Context, field graphql.CollectedField, obj *model.APIResourceLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceLimits_numTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumTasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceLimits_numTasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceLimits_virtualMemoryKb(ctx context.Context, field graphql.CollectedField, obj *model.APIResourceLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceLimits_virtualMemoryKb(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VirtualMemoryKB, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceLimits_virtualMemoryKb(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RestartAdminTasksPayload_numRestartedTasks(ctx context.Context, field graphql.CollectedField, obj *RestartAdminTasksPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RestartAdminTasksPayload_numRestartedTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumRestartedTasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RestartAdminTasksPayload_numRestartedTasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RestartAdminTasksPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeEnvironmentConfig_baseUrl(ctx context.Context, field graphql.CollectedField, obj *model.APIRuntimeEnvironmentsConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeEnvironmentConfig_baseUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BaseURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeEnvironmentConfig_baseUrl(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeEnvironmentConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RuntimeEnvironmentConfig_apiKey(ctx context.Context, field graphql.CollectedField, obj *model.APIRuntimeEnvironmentsConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RuntimeEnvironmentConfig_apiKey(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.APIKey, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.RequireAdmin == nil {
				var zeroVal *string
				return zeroVal, errors.New("directive requireAdmin is not implemented")
			}
			return ec.directives.RequireAdmin(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RuntimeEnvironmentConfig_apiKey(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RuntimeEnvironmentConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SESConfig_senderAddress(ctx context.Context, field graphql.CollectedField, obj *model.APISESConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SESConfig_senderAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.SenderAddress, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.RequireAdmin == nil {
				var zeroVal *string
				return zeroVal, errors.New("directive requireAdmin is not implemented")
			}
			return ec.directives.RequireAdmin(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SESConfig_senderAddress(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SESConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SaveDistroPayload_distro(ctx context.Context, field graphql.CollectedField, obj *SaveDistroPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SaveDistroPayload_distro(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distro, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIDistro)
	fc.Result = res
	return ec.marshalNDistro2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDistro(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SaveDistroPayload_distro(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SaveDistroPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "adminOnly":
				return ec.fieldContext_Distro_adminOnly(ctx, field)
			case "aliases":
				return ec.fieldContext_Distro_aliases(ctx, field)
			case "arch":
				return ec.fieldContext_Distro_arch(ctx, field)
			case "authorizedKeysFile":
				return ec.fieldContext_Distro_authorizedKeysFile(ctx, field)
			case "availableRegions":
				return ec.fieldContext_Distro_availableRegions(ctx, field)
			case "bootstrapSettings":
				return ec.fieldContext_Distro_bootstrapSettings(ctx, field)
			case "containerPool":
				return ec.fieldContext_Distro_containerPool(ctx, field)
			case "disabled":
				return ec.fieldContext_Distro_disabled(ctx, field)
			case "disableShallowClone":
				return ec.fieldContext_Distro_disableShallowClone(ctx, field)
			case "dispatcherSettings":
				return ec.fieldContext_Distro_dispatcherSettings(ctx, field)
			case "execUser":
				return ec.fieldContext_Distro_execUser(ctx, field)
			case "expansions":
				return ec.fieldContext_Distro_expansions(ctx, field)
			case "finderSettings":
				return ec.fieldContext_Distro_finderSettings(ctx, field)
			case "homeVolumeSettings":
				return ec.fieldContext_Distro_homeVolumeSettings(ctx, field)
			case "hostAllocatorSettings":
				return ec.fieldContext_Distro_hostAllocatorSettings(ctx, field)
			case "iceCreamSettings":
				return ec.fieldContext_Distro_iceCreamSettings(ctx, field)
			case "imageId":
				return ec.fieldContext_Distro_imageId(ctx, field)
			case "isCluster":
				return ec.fieldContext_Distro_isCluster(ctx, field)
			case "isVirtualWorkStation":
				return ec.fieldContext_Distro_isVirtualWorkStation(ctx, field)
			case "mountpoints":
				return ec.fieldContext_Distro_mountpoints(ctx, field)
			case "name":
				return ec.fieldContext_Distro_name(ctx, field)
			case "note":
				return ec.fieldContext_Distro_note(ctx, field)
			case "plannerSettings":
				return ec.fieldContext_Distro_plannerSettings(ctx, field)
			case "provider":
				return ec.fieldContext_Distro_provider(ctx, field)
			case "providerAccount":
				return ec.fieldContext_Distro_providerAccount(ctx, field)
			case "providerSettingsList":
				return ec.fieldContext_Distro_providerSettingsList(ctx, field)
			case "setup":
				return ec.fieldContext_Distro_setup(ctx, field)
			case "setupAsSudo":
				return ec.fieldContext_Distro_setupAsSudo(ctx, field)
			case "singleTaskDistro":
				return ec.fieldContext_Distro_singleTaskDistro(ctx, field)
			case "sshOptions":
				return ec.fieldContext_Distro_sshOptions(ctx, field)
			case "user":
				return ec.fieldContext_Distro_user(ctx, field)
			case "userSpawnAllowed":
				return ec.fieldContext_Distro_userSpawnAllowed(ctx, field)
			case "validProjects":
				return ec.fieldContext_Distro_validProjects(ctx, field)
			case "warningNote":
				return ec.fieldContext_Distro_warningNote(ctx, field)
			case "workDir":
				return ec.fieldContext_Distro_workDir(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Distro", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SaveDistroPayload_hostCount(ctx context.Context, field graphql.CollectedField, obj *SaveDistroPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SaveDistroPayload_hostCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SaveDistroPayload_hostCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SaveDistroPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SchedulerConfig_taskFinder(ctx context.Context, field graphql.CollectedField, obj *model.APISchedulerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SchedulerConfig_taskFinder(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskFinder, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOFinderVersion2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SchedulerConfig_taskFinder(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SchedulerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FinderVersion does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SchedulerConfig_hostAllocator(ctx context.Context, field graphql.CollectedField, obj *model.APISchedulerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SchedulerConfig_hostAllocator(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostAllocator, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOHostAllocatorVersion2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SchedulerConfig_hostAllocator(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SchedulerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type HostAllocatorVersion does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SchedulerConfig_hostAllocatorRoundingRule(ctx context.Context, field graphql.CollectedField, obj *model.APISchedulerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SchedulerConfig_hostAllocatorRoundingRule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostAllocatorRoundingRule, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalORoundingRule2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SchedulerConfig_hostAllocatorRoundingRule(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SchedulerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RoundingRule does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SchedulerConfig_hostAllocatorFeedbackRule(ctx context.Context, field graphql.CollectedField, obj *model.APISchedulerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SchedulerConfig_hostAllocatorFeedbackRule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostAllocatorFeedbackRule, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOFeedbackRule2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SchedulerConfig_hostAllocatorFeedbackRule(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SchedulerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FeedbackRule does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SchedulerConfig_hostsOverallocatedRule(ctx context.Context, field graphql.CollectedField, obj *model.APISchedulerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SchedulerConfig_hostsOverallocatedRule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostsOverallocatedRule, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOOverallocatedRule2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SchedulerConfig_hostsOverallocatedRule(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SchedulerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type OverallocatedRule does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SchedulerConfig_futureHostFraction(ctx context.Context, field graphql.CollectedField, obj *model.APISchedulerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SchedulerConfig_futureHostFraction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FutureHostFraction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SchedulerConfig_futureHostFraction(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SchedulerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SchedulerConfig_cacheDurationSeconds(ctx context.Context, field graphql.CollectedField, obj *model.APISchedulerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SchedulerConfig_cacheDurationSeconds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CacheDurationSeconds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SchedulerConfig_cacheDurationSeconds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SchedulerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SchedulerConfig_targetTimeSeconds(ctx context.Context, field graphql.CollectedField, obj *model.APISchedulerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SchedulerConfig_targetTimeSeconds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetTimeSeconds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SchedulerConfig_targetTimeSeconds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SchedulerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SchedulerConfig_acceptableHostIdleTimeSeconds(ctx context.Context, field graphql.CollectedField, obj *model.APISchedulerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SchedulerConfig_acceptableHostIdleTimeSeconds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AcceptableHostIdleTimeSeconds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SchedulerConfig_acceptableHostIdleTimeSeconds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SchedulerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SchedulerConfig_groupVersions(ctx context.Context, field graphql.CollectedField, obj *model.APISchedulerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SchedulerConfig_groupVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GroupVersions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SchedulerConfig_groupVersions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SchedulerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SchedulerConfig_patchFactor(ctx context.Context, field graphql.CollectedField, obj *model.APISchedulerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SchedulerConfig_patchFactor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PatchFactor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SchedulerConfig_patchFactor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SchedulerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SchedulerConfig_patchTimeInQueueFactor(ctx context.Context, field graphql.CollectedField, obj *model.APISchedulerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SchedulerConfig_patchTimeInQueueFactor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PatchTimeInQueueFactor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SchedulerConfig_patchTimeInQueueFactor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SchedulerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SchedulerConfig_commitQueueFactor(ctx context.Context, field graphql.CollectedField, obj *model.APISchedulerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SchedulerConfig_commitQueueFactor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CommitQueueFactor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SchedulerConfig_commitQueueFactor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SchedulerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SchedulerConfig_mainlineTimeInQueueFactor(ctx context.Context, field graphql.CollectedField, obj *model.APISchedulerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SchedulerConfig_mainlineTimeInQueueFactor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MainlineTimeInQueueFactor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SchedulerConfig_mainlineTimeInQueueFactor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SchedulerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SchedulerConfig_expectedRuntimeFactor(ctx context.Context, field graphql.CollectedField, obj *model.APISchedulerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SchedulerConfig_expectedRuntimeFactor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpectedRuntimeFactor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SchedulerConfig_expectedRuntimeFactor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SchedulerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SchedulerConfig_generateTaskFactor(ctx context.Context, field graphql.CollectedField, obj *model.APISchedulerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SchedulerConfig_generateTaskFactor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GenerateTaskFactor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SchedulerConfig_generateTaskFactor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SchedulerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SchedulerConfig_numDependentsFactor(ctx context.Context, field graphql.CollectedField, obj *model.APISchedulerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SchedulerConfig_numDependentsFactor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumDependentsFactor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SchedulerConfig_numDependentsFactor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SchedulerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SchedulerConfig_stepbackTaskFactor(ctx context.Context, field graphql.CollectedField, obj *model.APISchedulerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SchedulerConfig_stepbackTaskFactor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StepbackTaskFactor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SchedulerConfig_stepbackTaskFactor(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SchedulerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchReturnInfo_featuresURL(ctx context.Context, field graphql.CollectedField, obj *thirdparty.SearchReturnInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchReturnInfo_featuresURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeaturesURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchReturnInfo_featuresURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchReturnInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchReturnInfo_issues(ctx context.Context, field graphql.CollectedField, obj *thirdparty.SearchReturnInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchReturnInfo_issues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Issues, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]thirdparty.JiraTicket)
	fc.Result = res
	return ec.marshalNJiraTicket2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐJiraTicketᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchReturnInfo_issues(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchReturnInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "fields":
				return ec.fieldContext_JiraTicket_fields(ctx, field)
			case "key":
				return ec.fieldContext_JiraTicket_key(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JiraTicket", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchReturnInfo_search(ctx context.Context, field graphql.CollectedField, obj *thirdparty.SearchReturnInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchReturnInfo_search(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Search, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchReturnInfo_search(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchReturnInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchReturnInfo_source(ctx context.Context, field graphql.CollectedField, obj *thirdparty.SearchReturnInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchReturnInfo_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchReturnInfo_source(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchReturnInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Selector_data(ctx context.Context, field graphql.CollectedField, obj *model.APISelector) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Selector_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Selector_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Selector",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Selector_type(ctx context.Context, field graphql.CollectedField, obj *model.APISelector) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Selector_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Selector_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Selector",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_taskDispatchDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceFlags_taskDispatchDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskDispatchDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceFlags_taskDispatchDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_hostInitDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceFlags_hostInitDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostInitDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceFlags_hostInitDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_podInitDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceFlags_podInitDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PodInitDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceFlags_podInitDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_largeParserProjectsDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceFlags_largeParserProjectsDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LargeParserProjectsDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceFlags_largeParserProjectsDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_monitorDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceFlags_monitorDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MonitorDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceFlags_monitorDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_alertsDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceFlags_alertsDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AlertsDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceFlags_alertsDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_agentStartDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceFlags_agentStartDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentStartDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceFlags_agentStartDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_repotrackerDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceFlags_repotrackerDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepotrackerDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceFlags_repotrackerDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_schedulerDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceFlags_schedulerDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SchedulerDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceFlags_schedulerDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_checkBlockedTasksDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceFlags_checkBlockedTasksDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CheckBlockedTasksDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceFlags_checkBlockedTasksDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_githubPRTestingDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceFlags_githubPRTestingDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GithubPRTestingDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceFlags_githubPRTestingDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_cliUpdatesDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceFlags_cliUpdatesDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CLIUpdatesDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceFlags_cliUpdatesDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_backgroundStatsDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceFlags_backgroundStatsDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BackgroundStatsDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceFlags_backgroundStatsDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_taskLoggingDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceFlags_taskLoggingDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskLoggingDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceFlags_taskLoggingDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_cacheStatsJobDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceFlags_cacheStatsJobDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CacheStatsJobDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceFlags_cacheStatsJobDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_cacheStatsEndpointDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceFlags_cacheStatsEndpointDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CacheStatsEndpointDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceFlags_cacheStatsEndpointDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_taskReliabilityDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceFlags_taskReliabilityDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskReliabilityDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceFlags_taskReliabilityDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_hostAllocatorDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceFlags_hostAllocatorDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostAllocatorDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceFlags_hostAllocatorDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_podAllocatorDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceFlags_podAllocatorDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PodAllocatorDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceFlags_podAllocatorDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_unrecognizedPodCleanupDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceFlags_unrecognizedPodCleanupDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UnrecognizedPodCleanupDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceFlags_unrecognizedPodCleanupDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_backgroundReauthDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceFlags_backgroundReauthDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BackgroundReauthDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceFlags_backgroundReauthDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_cloudCleanupDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceFlags_cloudCleanupDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CloudCleanupDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceFlags_cloudCleanupDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_sleepScheduleDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceFlags_sleepScheduleDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SleepScheduleDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceFlags_sleepScheduleDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_staticAPIKeysDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceFlags_staticAPIKeysDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StaticAPIKeysDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceFlags_staticAPIKeysDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_jwtTokenForCLIDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceFlags_jwtTokenForCLIDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JWTTokenForCLIDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceFlags_jwtTokenForCLIDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_systemFailedTaskRestartDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceFlags_systemFailedTaskRestartDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SystemFailedTaskRestartDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceFlags_systemFailedTaskRestartDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_degradedModeDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceFlags_degradedModeDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DegradedModeDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceFlags_degradedModeDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_elasticIPsDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceFlags_elasticIPsDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ElasticIPsDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceFlags_elasticIPsDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_releaseModeDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceFlags_releaseModeDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ReleaseModeDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceFlags_releaseModeDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_adminParameterStoreDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceFlags_adminParameterStoreDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AdminParameterStoreDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceFlags_adminParameterStoreDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_eventProcessingDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceFlags_eventProcessingDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventProcessingDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceFlags_eventProcessingDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_jiraNotificationsDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceFlags_jiraNotificationsDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JIRANotificationsDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceFlags_jiraNotificationsDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_slackNotificationsDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceFlags_slackNotificationsDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SlackNotificationsDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceFlags_slackNotificationsDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_emailNotificationsDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceFlags_emailNotificationsDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EmailNotificationsDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceFlags_emailNotificationsDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_webhookNotificationsDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceFlags_webhookNotificationsDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WebhookNotificationsDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceFlags_webhookNotificationsDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ServiceFlags_githubStatusAPIDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIServiceFlags) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ServiceFlags_githubStatusAPIDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GithubStatusAPIDisabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ServiceFlags_githubStatusAPIDisabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ServiceFlags",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SetLastRevisionPayload_mergeBaseRevision(ctx context.Context, field graphql.CollectedField, obj *SetLastRevisionPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SetLastRevisionPayload_mergeBaseRevision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MergeBaseRevision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SetLastRevisionPayload_mergeBaseRevision(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SetLastRevisionPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SingleTaskDistroConfig_projectTasksPairs(ctx context.Context, field graphql.CollectedField, obj *model.APISingleTaskDistroConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SingleTaskDistroConfig_projectTasksPairs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectTasksPairs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APIProjectTasksPair)
	fc.Result = res
	return ec.marshalNProjectTasksPair2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectTasksPairᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SingleTaskDistroConfig_projectTasksPairs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SingleTaskDistroConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "projectId":
				return ec.fieldContext_ProjectTasksPair_projectId(ctx, field)
			case "allowedTasks":
				return ec.fieldContext_ProjectTasksPair_allowedTasks(ctx, field)
			case "allowedBVs":
				return ec.fieldContext_ProjectTasksPair_allowedBVs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectTasksPair", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlackConfig_options(ctx context.Context, field graphql.CollectedField, obj *model.APISlackConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SlackConfig_options(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Options, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APISlackOptions)
	fc.Result = res
	return ec.marshalOSlackOptions2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISlackOptions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SlackConfig_options(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlackConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "channel":
				return ec.fieldContext_SlackOptions_channel(ctx, field)
			case "hostname":
				return ec.fieldContext_SlackOptions_hostname(ctx, field)
			case "name":
				return ec.fieldContext_SlackOptions_name(ctx, field)
			case "username":
				return ec.fieldContext_SlackOptions_username(ctx, field)
			case "basicMetadata":
				return ec.fieldContext_SlackOptions_basicMetadata(ctx, field)
			case "fields":
				return ec.fieldContext_SlackOptions_fields(ctx, field)
			case "allFields":
				return ec.fieldContext_SlackOptions_allFields(ctx, field)
			case "fieldsSet":
				return ec.fieldContext_SlackOptions_fieldsSet(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SlackOptions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlackConfig_token(ctx context.Context, field graphql.CollectedField, obj *model.APISlackConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SlackConfig_token(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Token, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.RequireAdmin == nil {
				var zeroVal *string
				return zeroVal, errors.New("directive requireAdmin is not implemented")
			}
			return ec.directives.RequireAdmin(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SlackConfig_token(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlackConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlackConfig_level(ctx context.Context, field graphql.CollectedField, obj *model.APISlackConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SlackConfig_level(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Level, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOPriorityLevel2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SlackConfig_level(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlackConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PriorityLevel does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlackConfig_name(ctx context.Context, field graphql.CollectedField, obj *model.APISlackConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SlackConfig_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SlackConfig_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlackConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlackOptions_channel(ctx context.Context, field graphql.CollectedField, obj *model.APISlackOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SlackOptions_channel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Channel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SlackOptions_channel(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlackOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlackOptions_hostname(ctx context.Context, field graphql.CollectedField, obj *model.APISlackOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SlackOptions_hostname(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hostname, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SlackOptions_hostname(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlackOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlackOptions_name(ctx context.Context, field graphql.CollectedField, obj *model.APISlackOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SlackOptions_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SlackOptions_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlackOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlackOptions_username(ctx context.Context, field graphql.CollectedField, obj *model.APISlackOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SlackOptions_username(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Username, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SlackOptions_username(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlackOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlackOptions_basicMetadata(ctx context.Context, field graphql.CollectedField, obj *model.APISlackOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SlackOptions_basicMetadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BasicMetadata, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SlackOptions_basicMetadata(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlackOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlackOptions_fields(ctx context.Context, field graphql.CollectedField, obj *model.APISlackOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SlackOptions_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SlackOptions_fields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlackOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlackOptions_allFields(ctx context.Context, field graphql.CollectedField, obj *model.APISlackOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SlackOptions_allFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AllFields, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SlackOptions_allFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlackOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlackOptions_fieldsSet(ctx context.Context, field graphql.CollectedField, obj *model.APISlackOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SlackOptions_fieldsSet(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FieldsSet, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]bool)
	fc.Result = res
	return ec.marshalOBooleanMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SlackOptions_fieldsSet(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlackOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BooleanMap does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SleepSchedule_dailyStartTime(ctx context.Context, field graphql.CollectedField, obj *host.SleepScheduleInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SleepSchedule_dailyStartTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DailyStartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SleepSchedule_dailyStartTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SleepSchedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SleepSchedule_dailyStopTime(ctx context.Context, field graphql.CollectedField, obj *host.SleepScheduleInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SleepSchedule_dailyStopTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DailyStopTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SleepSchedule_dailyStopTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SleepSchedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SleepSchedule_nextStartTime(ctx context.Context, field graphql.CollectedField, obj *host.SleepScheduleInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SleepSchedule_nextStartTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextStartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SleepSchedule_nextStartTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SleepSchedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SleepSchedule_nextStopTime(ctx context.Context, field graphql.CollectedField, obj *host.SleepScheduleInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SleepSchedule_nextStopTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextStopTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SleepSchedule_nextStopTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SleepSchedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SleepSchedule_permanentlyExempt(ctx context.Context, field graphql.CollectedField, obj *host.SleepScheduleInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SleepSchedule_permanentlyExempt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PermanentlyExempt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SleepSchedule_permanentlyExempt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SleepSchedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SleepSchedule_shouldKeepOff(ctx context.Context, field graphql.CollectedField, obj *host.SleepScheduleInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SleepSchedule_shouldKeepOff(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShouldKeepOff, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SleepSchedule_shouldKeepOff(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SleepSchedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SleepSchedule_timeZone(ctx context.Context, field graphql.CollectedField, obj *host.SleepScheduleInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SleepSchedule_timeZone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimeZone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SleepSchedule_timeZone(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SleepSchedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SleepSchedule_temporarilyExemptUntil(ctx context.Context, field graphql.CollectedField, obj *host.SleepScheduleInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SleepSchedule_temporarilyExemptUntil(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TemporarilyExemptUntil, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SleepSchedule_temporarilyExemptUntil(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SleepSchedule",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SleepSchedule_wholeWeekdaysOff(ctx context.Context, field graphql.CollectedField, obj *host.SleepScheduleInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SleepSchedule_wholeWeekdaysOff(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SleepSchedule().WholeWeekdaysOff(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]int)
	fc.Result = res
	return ec.marshalNInt2ᚕintᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SleepSchedule_wholeWeekdaysOff(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SleepSchedule",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Source_author(ctx context.Context, field graphql.CollectedField, obj *model.APISource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Source_author(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Author, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Source_author(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Source",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Source_requester(ctx context.Context, field graphql.CollectedField, obj *model.APISource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Source_requester(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Requester, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Source_requester(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Source",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Source_time(ctx context.Context, field graphql.CollectedField, obj *model.APISource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Source_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Time, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Source_time(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Source",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpawnHostConfig_spawnHostsPerUser(ctx context.Context, field graphql.CollectedField, obj *model.APISpawnHostConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpawnHostConfig_spawnHostsPerUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpawnHostsPerUser, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalNInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpawnHostConfig_spawnHostsPerUser(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpawnHostConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpawnHostConfig_unexpirableHostsPerUser(ctx context.Context, field graphql.CollectedField, obj *model.APISpawnHostConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpawnHostConfig_unexpirableHostsPerUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UnexpirableHostsPerUser, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalNInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpawnHostConfig_unexpirableHostsPerUser(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpawnHostConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpawnHostConfig_unexpirableVolumesPerUser(ctx context.Context, field graphql.CollectedField, obj *model.APISpawnHostConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpawnHostConfig_unexpirableVolumesPerUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UnexpirableVolumesPerUser, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalNInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpawnHostConfig_unexpirableVolumesPerUser(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpawnHostConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SplunkConfig_splunkConnectionInfo(ctx context.Context, field graphql.CollectedField, obj *model.APISplunkConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SplunkConfig_splunkConnectionInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SplunkConnectionInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APISplunkConnectionInfo)
	fc.Result = res
	return ec.marshalNSplunkConnectionInfo2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISplunkConnectionInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SplunkConfig_splunkConnectionInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplunkConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "serverUrl":
				return ec.fieldContext_SplunkConnectionInfo_serverUrl(ctx, field)
			case "token":
				return ec.fieldContext_SplunkConnectionInfo_token(ctx, field)
			case "channel":
				return ec.fieldContext_SplunkConnectionInfo_channel(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SplunkConnectionInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SplunkConnectionInfo_serverUrl(ctx context.Context, field graphql.CollectedField, obj *model.APISplunkConnectionInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SplunkConnectionInfo_serverUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServerURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SplunkConnectionInfo_serverUrl(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplunkConnectionInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SplunkConnectionInfo_token(ctx context.Context, field graphql.CollectedField, obj *model.APISplunkConnectionInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SplunkConnectionInfo_token(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Token, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.RequireAdmin == nil {
				var zeroVal *string
				return zeroVal, errors.New("directive requireAdmin is not implemented")
			}
			return ec.directives.RequireAdmin(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SplunkConnectionInfo_token(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplunkConnectionInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SplunkConnectionInfo_channel(ctx context.Context, field graphql.CollectedField, obj *model.APISplunkConnectionInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SplunkConnectionInfo_channel(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Channel, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SplunkConnectionInfo_channel(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SplunkConnectionInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_banner(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpruceConfig_banner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Banner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpruceConfig_banner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_bannerTheme(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpruceConfig_bannerTheme(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BannerTheme, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpruceConfig_bannerTheme(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_containerPools(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpruceConfig_containerPools(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContainerPools, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIContainerPoolsConfig)
	fc.Result = res
	return ec.marshalOContainerPoolsConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIContainerPoolsConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpruceConfig_containerPools(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "pools":
				return ec.fieldContext_ContainerPoolsConfig_pools(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContainerPoolsConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_githubOrgs(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpruceConfig_githubOrgs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GithubOrgs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpruceConfig_githubOrgs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_jira(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpruceConfig_jira(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Jira, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIJiraConfig)
	fc.Result = res
	return ec.marshalOJiraConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIJiraConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpruceConfig_jira(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "email":
				return ec.fieldContext_JiraConfig_email(ctx, field)
			case "host":
				return ec.fieldContext_JiraConfig_host(ctx, field)
			case "personalAccessToken":
				return ec.fieldContext_JiraConfig_personalAccessToken(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JiraConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_providers(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpruceConfig_providers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Providers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APICloudProviders)
	fc.Result = res
	return ec.marshalOCloudProviderConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPICloudProviders(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpruceConfig_providers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aws":
				return ec.fieldContext_CloudProviderConfig_aws(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CloudProviderConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_secretFields(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpruceConfig_secretFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SpruceConfig().SecretFields(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpruceConfig_secretFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_singleTaskDistro(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpruceConfig_singleTaskDistro(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SingleTaskDistro, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APISingleTaskDistroConfig)
	fc.Result = res
	return ec.marshalOSingleTaskDistroConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISingleTaskDistroConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpruceConfig_singleTaskDistro(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "projectTasksPairs":
				return ec.fieldContext_SingleTaskDistroConfig_projectTasksPairs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SingleTaskDistroConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_slack(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpruceConfig_slack(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Slack, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APISlackConfig)
	fc.Result = res
	return ec.marshalOSlackConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISlackConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpruceConfig_slack(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "options":
				return ec.fieldContext_SlackConfig_options(ctx, field)
			case "token":
				return ec.fieldContext_SlackConfig_token(ctx, field)
			case "level":
				return ec.fieldContext_SlackConfig_level(ctx, field)
			case "name":
				return ec.fieldContext_SlackConfig_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SlackConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_spawnHost(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpruceConfig_spawnHost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Spawnhost, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APISpawnHostConfig)
	fc.Result = res
	return ec.marshalNSpawnHostConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISpawnHostConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpruceConfig_spawnHost(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "spawnHostsPerUser":
				return ec.fieldContext_SpawnHostConfig_spawnHostsPerUser(ctx, field)
			case "unexpirableHostsPerUser":
				return ec.fieldContext_SpawnHostConfig_unexpirableHostsPerUser(ctx, field)
			case "unexpirableVolumesPerUser":
				return ec.fieldContext_SpawnHostConfig_unexpirableVolumesPerUser(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SpawnHostConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_ui(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpruceConfig_ui(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ui, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIUIConfig)
	fc.Result = res
	return ec.marshalNUIConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIUIConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpruceConfig_ui(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "betaFeatures":
				return ec.fieldContext_UIConfig_betaFeatures(ctx, field)
			case "url":
				return ec.fieldContext_UIConfig_url(ctx, field)
			case "helpUrl":
				return ec.fieldContext_UIConfig_helpUrl(ctx, field)
			case "uiv2Url":
				return ec.fieldContext_UIConfig_uiv2Url(ctx, field)
			case "parsleyUrl":
				return ec.fieldContext_UIConfig_parsleyUrl(ctx, field)
			case "httpListenAddr":
				return ec.fieldContext_UIConfig_httpListenAddr(ctx, field)
			case "secret":
				return ec.fieldContext_UIConfig_secret(ctx, field)
			case "defaultProject":
				return ec.fieldContext_UIConfig_defaultProject(ctx, field)
			case "corsOrigins":
				return ec.fieldContext_UIConfig_corsOrigins(ctx, field)
			case "fileStreamingContentTypes":
				return ec.fieldContext_UIConfig_fileStreamingContentTypes(ctx, field)
			case "loginDomain":
				return ec.fieldContext_UIConfig_loginDomain(ctx, field)
			case "userVoice":
				return ec.fieldContext_UIConfig_userVoice(ctx, field)
			case "csrfKey":
				return ec.fieldContext_UIConfig_csrfKey(ctx, field)
			case "cacheTemplates":
				return ec.fieldContext_UIConfig_cacheTemplates(ctx, field)
			case "stagingEnvironment":
				return ec.fieldContext_UIConfig_stagingEnvironment(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UIConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _StatusCount_count(ctx context.Context, field graphql.CollectedField, obj *task.StatusCount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StatusCount_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StatusCount_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StatusCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StatusCount_status(ctx context.Context, field graphql.CollectedField, obj *task.StatusCount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StatusCount_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StatusCount_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StatusCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StepbackInfo_lastFailingStepbackTaskId(ctx context.Context, field graphql.CollectedField, obj *model.APIStepbackInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StepbackInfo_lastFailingStepbackTaskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastFailingStepbackTaskId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StepbackInfo_lastFailingStepbackTaskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StepbackInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StepbackInfo_lastPassingStepbackTaskId(ctx context.Context, field graphql.CollectedField, obj *model.APIStepbackInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StepbackInfo_lastPassingStepbackTaskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastPassingStepbackTaskId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StepbackInfo_lastPassingStepbackTaskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StepbackInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StepbackInfo_nextStepbackTaskId(ctx context.Context, field graphql.CollectedField, obj *model.APIStepbackInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StepbackInfo_nextStepbackTaskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextStepbackTaskId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StepbackInfo_nextStepbackTaskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StepbackInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StepbackInfo_previousStepbackTaskId(ctx context.Context, field graphql.CollectedField, obj *model.APIStepbackInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StepbackInfo_previousStepbackTaskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreviousStepbackTaskId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StepbackInfo_previousStepbackTaskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StepbackInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscriber_emailSubscriber(ctx context.Context, field graphql.CollectedField, obj *Subscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscriber_emailSubscriber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EmailSubscriber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Subscriber_emailSubscriber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscriber_githubCheckSubscriber(ctx context.Context, field graphql.CollectedField, obj *Subscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscriber_githubCheckSubscriber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GithubCheckSubscriber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIGithubCheckSubscriber)
	fc.Result = res
	return ec.marshalOGithubCheckSubscriber2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGithubCheckSubscriber(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Subscriber_githubCheckSubscriber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "owner":
				return ec.fieldContext_GithubCheckSubscriber_owner(ctx, field)
			case "ref":
				return ec.fieldContext_GithubCheckSubscriber_ref(ctx, field)
			case "repo":
				return ec.fieldContext_GithubCheckSubscriber_repo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubCheckSubscriber", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscriber_githubPRSubscriber(ctx context.Context, field graphql.CollectedField, obj *Subscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscriber_githubPRSubscriber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GithubPRSubscriber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIGithubPRSubscriber)
	fc.Result = res
	return ec.marshalOGithubPRSubscriber2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGithubPRSubscriber(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Subscriber_githubPRSubscriber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "owner":
				return ec.fieldContext_GithubPRSubscriber_owner(ctx, field)
			case "prNumber":
				return ec.fieldContext_GithubPRSubscriber_prNumber(ctx, field)
			case "ref":
				return ec.fieldContext_GithubPRSubscriber_ref(ctx, field)
			case "repo":
				return ec.fieldContext_GithubPRSubscriber_repo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubPRSubscriber", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscriber_jiraCommentSubscriber(ctx context.Context, field graphql.CollectedField, obj *Subscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscriber_jiraCommentSubscriber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JiraCommentSubscriber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Subscriber_jiraCommentSubscriber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscriber_jiraIssueSubscriber(ctx context.Context, field graphql.CollectedField, obj *Subscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscriber_jiraIssueSubscriber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JiraIssueSubscriber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIJIRAIssueSubscriber)
	fc.Result = res
	return ec.marshalOJiraIssueSubscriber2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIJIRAIssueSubscriber(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Subscriber_jiraIssueSubscriber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "issueType":
				return ec.fieldContext_JiraIssueSubscriber_issueType(ctx, field)
			case "project":
				return ec.fieldContext_JiraIssueSubscriber_project(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JiraIssueSubscriber", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscriber_slackSubscriber(ctx context.Context, field graphql.CollectedField, obj *Subscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscriber_slackSubscriber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SlackSubscriber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Subscriber_slackSubscriber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscriber_webhookSubscriber(ctx context.Context, field graphql.CollectedField, obj *Subscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscriber_webhookSubscriber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WebhookSubscriber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIWebhookSubscriber)
	fc.Result = res
	return ec.marshalOWebhookSubscriber2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWebhookSubscriber(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Subscriber_webhookSubscriber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "headers":
				return ec.fieldContext_WebhookSubscriber_headers(ctx, field)
			case "secret":
				return ec.fieldContext_WebhookSubscriber_secret(ctx, field)
			case "url":
				return ec.fieldContext_WebhookSubscriber_url(ctx, field)
			case "retries":
				return ec.fieldContext_WebhookSubscriber_retries(ctx, field)
			case "minDelayMs":
				return ec.fieldContext_WebhookSubscriber_minDelayMs(ctx, field)
			case "timeoutMs":
				return ec.fieldContext_WebhookSubscriber_timeoutMs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WebhookSubscriber", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SubscriberWrapper_subscriber(ctx context.Context, field graphql.CollectedField, obj *model.APISubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SubscriberWrapper_subscriber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SubscriberWrapper().Subscriber(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Subscriber)
	fc.Result = res
	return ec.marshalNSubscriber2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSubscriber(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SubscriberWrapper_subscriber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SubscriberWrapper",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "emailSubscriber":
				return ec.fieldContext_Subscriber_emailSubscriber(ctx, field)
			case "githubCheckSubscriber":
				return ec.fieldContext_Subscriber_githubCheckSubscriber(ctx, field)
			case "githubPRSubscriber":
				return ec.fieldContext_Subscriber_githubPRSubscriber(ctx, field)
			case "jiraCommentSubscriber":
				return ec.fieldContext_Subscriber_jiraCommentSubscriber(ctx, field)
			case "jiraIssueSubscriber":
				return ec.fieldContext_Subscriber_jiraIssueSubscriber(ctx, field)
			case "slackSubscriber":
				return ec.fieldContext_Subscriber_slackSubscriber(ctx, field)
			case "webhookSubscriber":
				return ec.fieldContext_Subscriber_webhookSubscriber(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Subscriber", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SubscriberWrapper_type(ctx context.Context, field graphql.CollectedField, obj *model.APISubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SubscriberWrapper_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SubscriberWrapper_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SubscriberWrapper",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_aborted(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_aborted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Aborted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_aborted(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_abortInfo(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_abortInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().AbortInfo(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AbortInfo)
	fc.Result = res
	return ec.marshalOAbortInfo2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAbortInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_abortInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "buildVariantDisplayName":
				return ec.fieldContext_AbortInfo_buildVariantDisplayName(ctx, field)
			case "newVersion":
				return ec.fieldContext_AbortInfo_newVersion(ctx, field)
			case "prClosed":
				return ec.fieldContext_AbortInfo_prClosed(ctx, field)
			case "taskDisplayName":
				return ec.fieldContext_AbortInfo_taskDisplayName(ctx, field)
			case "taskID":
				return ec.fieldContext_AbortInfo_taskID(ctx, field)
			case "user":
				return ec.fieldContext_AbortInfo_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AbortInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_activated(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_activated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Activated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_activated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_activatedBy(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_activatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ActivatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_activatedBy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_activatedTime(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_activatedTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ActivatedTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_activatedTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_ami(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_ami(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().Ami(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_ami(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_annotation(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_annotation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().Annotation(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APITaskAnnotation)
	fc.Result = res
	return ec.marshalOAnnotation2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskAnnotation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_annotation(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Annotation_id(ctx, field)
			case "createdIssues":
				return ec.fieldContext_Annotation_createdIssues(ctx, field)
			case "issues":
				return ec.fieldContext_Annotation_issues(ctx, field)
			case "note":
				return ec.fieldContext_Annotation_note(ctx, field)
			case "suspectedIssues":
				return ec.fieldContext_Annotation_suspectedIssues(ctx, field)
			case "metadataLinks":
				return ec.fieldContext_Annotation_metadataLinks(ctx, field)
			case "taskId":
				return ec.fieldContext_Annotation_taskId(ctx, field)
			case "taskExecution":
				return ec.fieldContext_Annotation_taskExecution(ctx, field)
			case "webhookConfigured":
				return ec.fieldContext_Annotation_webhookConfigured(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Annotation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_id(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_baseStatus(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_baseStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().BaseStatus(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_baseStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_baseTask(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_baseTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().BaseTask(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APITask)
	fc.Result = res
	return ec.marshalOTask2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_baseTask(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_blocked(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_blocked(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Blocked, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_blocked(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_buildId(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_buildId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_buildId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_buildVariant(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_buildVariant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildVariant, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_buildVariant(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_buildVariantDisplayName(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().BuildVariantDisplayName(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_buildVariantDisplayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_canAbort(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_canAbort(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().CanAbort(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_canAbort(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_canDisable(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_canDisable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().CanDisable(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_canDisable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_canModifyAnnotation(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_canModifyAnnotation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().CanModifyAnnotation(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_canModifyAnnotation(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_canOverrideDependencies(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_canOverrideDependencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().CanOverrideDependencies(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_canOverrideDependencies(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_canRestart(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_canRestart(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().CanRestart(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_canRestart(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_canSchedule(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_canSchedule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().CanSchedule(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_canSchedule(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_canSetPriority(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_canSetPriority(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().CanSetPriority(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_canSetPriority(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_canUnschedule(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_canUnschedule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().CanUnschedule(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_canUnschedule(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_containerAllocatedTime(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_containerAllocatedTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContainerAllocatedTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_containerAllocatedTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_createTime(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_createTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreateTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_createTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_dependsOn(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_dependsOn(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().DependsOn(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Dependency)
	fc.Result = res
	return ec.marshalODependency2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDependencyᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_dependsOn(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "buildVariant":
				return ec.fieldContext_Dependency_buildVariant(ctx, field)
			case "metStatus":
				return ec.fieldContext_Dependency_metStatus(ctx, field)
			case "name":
				return ec.fieldContext_Dependency_name(ctx, field)
			case "requiredStatus":
				return ec.fieldContext_Dependency_requiredStatus(ctx, field)
			case "taskId":
				return ec.fieldContext_Dependency_taskId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Dependency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_details(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_details(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Details, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.ApiTaskEndDetail)
	fc.Result = res
	return ec.marshalOTaskEndDetail2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐApiTaskEndDetail(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_details(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext_TaskEndDetail_description(ctx, field)
			case "diskDevices":
				return ec.fieldContext_TaskEndDetail_diskDevices(ctx, field)
			case "failingCommand":
				return ec.fieldContext_TaskEndDetail_failingCommand(ctx, field)
			case "failureMetadataTags":
				return ec.fieldContext_TaskEndDetail_failureMetadataTags(ctx, field)
			case "oomTracker":
				return ec.fieldContext_TaskEndDetail_oomTracker(ctx, field)
			case "otherFailingCommands":
				return ec.fieldContext_TaskEndDetail_otherFailingCommands(ctx, field)
			case "status":
				return ec.fieldContext_TaskEndDetail_status(ctx, field)
			case "timedOut":
				return ec.fieldContext_TaskEndDetail_timedOut(ctx, field)
			case "timeoutType":
				return ec.fieldContext_TaskEndDetail_timeoutType(ctx, field)
			case "traceID":
				return ec.fieldContext_TaskEndDetail_traceID(ctx, field)
			case "type":
				return ec.fieldContext_TaskEndDetail_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskEndDetail", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_dispatchTime(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_dispatchTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DispatchTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_dispatchTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_displayName(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_displayOnly(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_displayOnly(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayOnly, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_displayOnly(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_displayStatus(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_displayStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_displayStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_displayTask(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_displayTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().DisplayTask(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APITask)
	fc.Result = res
	return ec.marshalOTask2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_displayTask(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_distroId(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_distroId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DistroId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_distroId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_estimatedStart(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_estimatedStart(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().EstimatedStart(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIDuration)
	fc.Result = res
	return ec.marshalODuration2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_estimatedStart(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_execution(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_execution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Execution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_execution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_executionTasks(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_executionTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExecutionTasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2ᚕᚖstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_executionTasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_executionTasksFull(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_executionTasksFull(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().ExecutionTasksFull(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.APITask)
	fc.Result = res
	return ec.marshalOTask2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_executionTasksFull(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_expectedDuration(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_expectedDuration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpectedDuration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.APIDuration)
	fc.Result = res
	return ec.marshalODuration2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_expectedDuration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_failedTestCount(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_failedTestCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().FailedTestCount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_failedTestCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_files(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_files(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().Files(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*TaskFiles)
	fc.Result = res
	return ec.marshalNTaskFiles2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskFiles(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_files(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "fileCount":
				return ec.fieldContext_TaskFiles_fileCount(ctx, field)
			case "groupedFiles":
				return ec.fieldContext_TaskFiles_groupedFiles(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskFiles", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_finishTime(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_finishTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FinishTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_finishTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_generatedBy(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_generatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GeneratedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_generatedBy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_generatedByName(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_generatedByName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().GeneratedByName(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_generatedByName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_generateTask(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_generateTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GenerateTask, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_generateTask(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_hasTestResults(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_hasTestResults(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasTestResults, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_hasTestResults(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_hostId(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_hostId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_hostId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_imageId(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_imageId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().ImageID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_imageId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_ingestTime(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_ingestTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IngestTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_ingestTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_isPerfPluginEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().IsPerfPluginEnabled(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_isPerfPluginEnabled(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_latestExecution(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_latestExecution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().LatestExecution(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_latestExecution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_logs(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_logs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Logs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.LogLinks)
	fc.Result = res
	return ec.marshalNTaskLogLinks2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐLogLinks(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_logs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "agentLogLink":
				return ec.fieldContext_TaskLogLinks_agentLogLink(ctx, field)
			case "allLogLink":
				return ec.fieldContext_TaskLogLinks_allLogLink(ctx, field)
			case "eventLogLink":
				return ec.fieldContext_TaskLogLinks_eventLogLink(ctx, field)
			case "systemLogLink":
				return ec.fieldContext_TaskLogLinks_systemLogLink(ctx, field)
			case "taskLogLink":
				return ec.fieldContext_TaskLogLinks_taskLogLink(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskLogLinks", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_minQueuePosition(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_minQueuePosition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().MinQueuePosition(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_minQueuePosition(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_order(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_order(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Order, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_order(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_patch(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_patch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().Patch(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIPatch)
	fc.Result = res
	return ec.marshalOPatch2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_patch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Patch_id(ctx, field)
			case "activated":
				return ec.fieldContext_Patch_activated(ctx, field)
			case "alias":
				return ec.fieldContext_Patch_alias(ctx, field)
			case "author":
				return ec.fieldContext_Patch_author(ctx, field)
			case "authorDisplayName":
				return ec.fieldContext_Patch_authorDisplayName(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Patch_baseTaskStatuses(ctx, field)
			case "builds":
				return ec.fieldContext_Patch_builds(ctx, field)
			case "childPatchAliases":
				return ec.fieldContext_Patch_childPatchAliases(ctx, field)
			case "childPatches":
				return ec.fieldContext_Patch_childPatches(ctx, field)
			case "createTime":
				return ec.fieldContext_Patch_createTime(ctx, field)
			case "description":
				return ec.fieldContext_Patch_description(ctx, field)
			case "duration":
				return ec.fieldContext_Patch_duration(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Patch_generatedTaskCounts(ctx, field)
			case "githash":
				return ec.fieldContext_Patch_githash(ctx, field)
			case "githubPatchData":
				return ec.fieldContext_Patch_githubPatchData(ctx, field)
			case "hidden":
				return ec.fieldContext_Patch_hidden(ctx, field)
			case "moduleCodeChanges":
				return ec.fieldContext_Patch_moduleCodeChanges(ctx, field)
			case "parameters":
				return ec.fieldContext_Patch_parameters(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Patch_patchNumber(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Patch_patchTriggerAliases(ctx, field)
			case "project":
				return ec.fieldContext_Patch_project(ctx, field)
			case "projectID":
				return ec.fieldContext_Patch_projectID(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Patch_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Patch_projectMetadata(ctx, field)
			case "status":
				return ec.fieldContext_Patch_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Patch_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Patch_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Patch_taskStatuses(ctx, field)
			case "time":
				return ec.fieldContext_Patch_time(ctx, field)
			case "variants":
				return ec.fieldContext_Patch_variants(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_Patch_variantsTasks(ctx, field)
			case "versionFull":
				return ec.fieldContext_Patch_versionFull(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Patch", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_patchNumber(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_patchNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().PatchNumber(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_patchNumber(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_pod(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_pod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().Pod(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIPod)
	fc.Result = res
	return ec.marshalOPod2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_pod(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "events":
				return ec.fieldContext_Pod_events(ctx, field)
			case "id":
				return ec.fieldContext_Pod_id(ctx, field)
			case "status":
				return ec.fieldContext_Pod_status(ctx, field)
			case "task":
				return ec.fieldContext_Pod_task(ctx, field)
			case "taskContainerCreationOpts":
				return ec.fieldContext_Pod_taskContainerCreationOpts(ctx, field)
			case "type":
				return ec.fieldContext_Pod_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Pod", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_priority(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_priority(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Priority, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_priority(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_project(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_project(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().Project(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectRef)
	fc.Result = res
	return ec.marshalOProject2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_project(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "githubPRTriggerAliases":
				return ec.fieldContext_Project_githubPRTriggerAliases(ctx, field)
			case "githubMQTriggerAliases":
				return ec.fieldContext_Project_githubMQTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_projectId(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_projectId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_projectId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_projectIdentifier(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_projectIdentifier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().ProjectIdentifier(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_projectIdentifier(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_requester(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_requester(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Requester, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_requester(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_resetWhenFinished(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_resetWhenFinished(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResetWhenFinished, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_resetWhenFinished(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_revision(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_revision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_revision(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_scheduledTime(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_scheduledTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ScheduledTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_scheduledTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_spawnHostLink(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_spawnHostLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().SpawnHostLink(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_spawnHostLink(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_startTime(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_startTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_startTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_status(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_tags(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_tags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalNString2ᚕᚖstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_tags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_taskGroup(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_taskGroup(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskGroup, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_taskGroup(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_taskGroupMaxHosts(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskGroupMaxHosts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_taskGroupMaxHosts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_stepbackInfo(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_stepbackInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StepbackInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIStepbackInfo)
	fc.Result = res
	return ec.marshalOStepbackInfo2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIStepbackInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_stepbackInfo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lastFailingStepbackTaskId":
				return ec.fieldContext_StepbackInfo_lastFailingStepbackTaskId(ctx, field)
			case "lastPassingStepbackTaskId":
				return ec.fieldContext_StepbackInfo_lastPassingStepbackTaskId(ctx, field)
			case "nextStepbackTaskId":
				return ec.fieldContext_StepbackInfo_nextStepbackTaskId(ctx, field)
			case "previousStepbackTaskId":
				return ec.fieldContext_StepbackInfo_previousStepbackTaskId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StepbackInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_taskLogs(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_taskLogs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().TaskLogs(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*TaskLogs)
	fc.Result = res
	return ec.marshalNTaskLogs2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskLogs(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_taskLogs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "agentLogs":
				return ec.fieldContext_TaskLogs_agentLogs(ctx, field)
			case "allLogs":
				return ec.fieldContext_TaskLogs_allLogs(ctx, field)
			case "eventLogs":
				return ec.fieldContext_TaskLogs_eventLogs(ctx, field)
			case "execution":
				return ec.fieldContext_TaskLogs_execution(ctx, field)
			case "systemLogs":
				return ec.fieldContext_TaskLogs_systemLogs(ctx, field)
			case "taskId":
				return ec.fieldContext_TaskLogs_taskId(ctx, field)
			case "taskLogs":
				return ec.fieldContext_TaskLogs_taskLogs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskLogs", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_taskOwnerTeam(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_taskOwnerTeam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().TaskOwnerTeam(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*TaskOwnerTeam)
	fc.Result = res
	return ec.marshalOTaskOwnerTeam2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskOwnerTeam(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_taskOwnerTeam(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "assignmentType":
				return ec.fieldContext_TaskOwnerTeam_assignmentType(ctx, field)
			case "messages":
				return ec.fieldContext_TaskOwnerTeam_messages(ctx, field)
			case "teamName":
				return ec.fieldContext_TaskOwnerTeam_teamName(ctx, field)
			case "jiraProject":
				return ec.fieldContext_TaskOwnerTeam_jiraProject(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskOwnerTeam", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_tests(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_tests(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().Tests(rctx, obj, fc.Args["opts"].(*TestFilterOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*TaskTestResult)
	fc.Result = res
	return ec.marshalNTaskTestResult2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskTestResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_tests(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "testResults":
				return ec.fieldContext_TaskTestResult_testResults(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_TaskTestResult_totalTestCount(ctx, field)
			case "filteredTestCount":
				return ec.fieldContext_TaskTestResult_filteredTestCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskTestResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Task_tests_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Task_timeTaken(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_timeTaken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimeTaken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.APIDuration)
	fc.Result = res
	return ec.marshalODuration2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_timeTaken(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_totalTestCount(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_totalTestCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().TotalTestCount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_totalTestCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_versionMetadata(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_versionMetadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().VersionMetadata(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIVersion)
	fc.Result = res
	return ec.marshalNVersion2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_versionMetadata(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "authorEmail":
				return ec.fieldContext_Version_authorEmail(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Version_generatedTaskCounts(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "ignored":
				return ec.fieldContext_Version_ignored(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			case "waterfallBuilds":
				return ec.fieldContext_Version_waterfallBuilds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskAnnotationSettings_fileTicketWebhook(ctx context.Context, field graphql.CollectedField, obj *model.APITaskAnnotationSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskAnnotationSettings_fileTicketWebhook(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileTicketWebhook, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIWebHook)
	fc.Result = res
	return ec.marshalNWebhook2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWebHook(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskAnnotationSettings_fileTicketWebhook(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskAnnotationSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "endpoint":
				return ec.fieldContext_Webhook_endpoint(ctx, field)
			case "secret":
				return ec.fieldContext_Webhook_secret(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Webhook", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskContainerCreationOpts_image(ctx context.Context, field graphql.CollectedField, obj *model.APIPodTaskContainerCreationOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskContainerCreationOpts_image(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Image, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskContainerCreationOpts_image(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskContainerCreationOpts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskContainerCreationOpts_memoryMB(ctx context.Context, field graphql.CollectedField, obj *model.APIPodTaskContainerCreationOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskContainerCreationOpts_memoryMB(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MemoryMB, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalNInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskContainerCreationOpts_memoryMB(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskContainerCreationOpts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskContainerCreationOpts_cpu(ctx context.Context, field graphql.CollectedField, obj *model.APIPodTaskContainerCreationOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskContainerCreationOpts_cpu(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CPU, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalNInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskContainerCreationOpts_cpu(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskContainerCreationOpts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskContainerCreationOpts_os(ctx context.Context, field graphql.CollectedField, obj *model.APIPodTaskContainerCreationOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskContainerCreationOpts_os(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TaskContainerCreationOpts().Os(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskContainerCreationOpts_os(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskContainerCreationOpts",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskContainerCreationOpts_arch(ctx context.Context, field graphql.CollectedField, obj *model.APIPodTaskContainerCreationOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskContainerCreationOpts_arch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TaskContainerCreationOpts().Arch(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskContainerCreationOpts_arch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskContainerCreationOpts",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskContainerCreationOpts_workingDir(ctx context.Context, field graphql.CollectedField, obj *model.APIPodTaskContainerCreationOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskContainerCreationOpts_workingDir(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkingDir, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskContainerCreationOpts_workingDir(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskContainerCreationOpts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEndDetail_description(ctx context.Context, field graphql.CollectedField, obj *model.ApiTaskEndDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEndDetail_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEndDetail_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEndDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEndDetail_diskDevices(ctx context.Context, field graphql.CollectedField, obj *model.ApiTaskEndDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEndDetail_diskDevices(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DiskDevices, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEndDetail_diskDevices(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEndDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEndDetail_failingCommand(ctx context.Context, field graphql.CollectedField, obj *model.ApiTaskEndDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEndDetail_failingCommand(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FailingCommand, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEndDetail_failingCommand(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEndDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEndDetail_failureMetadataTags(ctx context.Context, field graphql.CollectedField, obj *model.ApiTaskEndDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEndDetail_failureMetadataTags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FailureMetadataTags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEndDetail_failureMetadataTags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEndDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEndDetail_oomTracker(ctx context.Context, field graphql.CollectedField, obj *model.ApiTaskEndDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEndDetail_oomTracker(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OOMTracker, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIOomTrackerInfo)
	fc.Result = res
	return ec.marshalNOomTrackerInfo2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIOomTrackerInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEndDetail_oomTracker(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEndDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "detected":
				return ec.fieldContext_OomTrackerInfo_detected(ctx, field)
			case "pids":
				return ec.fieldContext_OomTrackerInfo_pids(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OomTrackerInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEndDetail_otherFailingCommands(ctx context.Context, field graphql.CollectedField, obj *model.ApiTaskEndDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEndDetail_otherFailingCommands(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OtherFailingCommands, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APIFailingCommand)
	fc.Result = res
	return ec.marshalNFailingCommand2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIFailingCommandᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEndDetail_otherFailingCommands(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEndDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "fullDisplayName":
				return ec.fieldContext_FailingCommand_fullDisplayName(ctx, field)
			case "failureMetadataTags":
				return ec.fieldContext_FailingCommand_failureMetadataTags(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FailingCommand", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEndDetail_status(ctx context.Context, field graphql.CollectedField, obj *model.ApiTaskEndDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEndDetail_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEndDetail_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEndDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEndDetail_timedOut(ctx context.Context, field graphql.CollectedField, obj *model.ApiTaskEndDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEndDetail_timedOut(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimedOut, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEndDetail_timedOut(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEndDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEndDetail_timeoutType(ctx context.Context, field graphql.CollectedField, obj *model.ApiTaskEndDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEndDetail_timeoutType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimeoutType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEndDetail_timeoutType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEndDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEndDetail_traceID(ctx context.Context, field graphql.CollectedField, obj *model.ApiTaskEndDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEndDetail_traceID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TraceID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEndDetail_traceID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEndDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEndDetail_type(ctx context.Context, field graphql.CollectedField, obj *model.ApiTaskEndDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEndDetail_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEndDetail_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEndDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogData_hostId(ctx context.Context, field graphql.CollectedField, obj *model.TaskEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogData_hostId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogData_hostId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogData_podId(ctx context.Context, field graphql.CollectedField, obj *model.TaskEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogData_podId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PodId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogData_podId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogData_jiraIssue(ctx context.Context, field graphql.CollectedField, obj *model.TaskEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogData_jiraIssue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JiraIssue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogData_jiraIssue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogData_jiraLink(ctx context.Context, field graphql.CollectedField, obj *model.TaskEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogData_jiraLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JiraLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogData_jiraLink(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogData_priority(ctx context.Context, field graphql.CollectedField, obj *model.TaskEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogData_priority(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Priority, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogData_priority(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogData_status(ctx context.Context, field graphql.CollectedField, obj *model.TaskEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogData_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogData_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogData_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.TaskEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogData_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogData_timestamp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogData_userId(ctx context.Context, field graphql.CollectedField, obj *model.TaskEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogData_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogData_userId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogData_blockedOn(ctx context.Context, field graphql.CollectedField, obj *model.TaskEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogData_blockedOn(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BlockedOn, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogData_blockedOn(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *model.TaskAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogEntry_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogEntry_data(ctx context.Context, field graphql.CollectedField, obj *model.TaskAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogEntry_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.TaskEventData)
	fc.Result = res
	return ec.marshalNTaskEventLogData2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐTaskEventData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogEntry_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hostId":
				return ec.fieldContext_TaskEventLogData_hostId(ctx, field)
			case "podId":
				return ec.fieldContext_TaskEventLogData_podId(ctx, field)
			case "jiraIssue":
				return ec.fieldContext_TaskEventLogData_jiraIssue(ctx, field)
			case "jiraLink":
				return ec.fieldContext_TaskEventLogData_jiraLink(ctx, field)
			case "priority":
				return ec.fieldContext_TaskEventLogData_priority(ctx, field)
			case "status":
				return ec.fieldContext_TaskEventLogData_status(ctx, field)
			case "timestamp":
				return ec.fieldContext_TaskEventLogData_timestamp(ctx, field)
			case "userId":
				return ec.fieldContext_TaskEventLogData_userId(ctx, field)
			case "blockedOn":
				return ec.fieldContext_TaskEventLogData_blockedOn(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskEventLogData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogEntry_eventType(ctx context.Context, field graphql.CollectedField, obj *model.TaskAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogEntry_eventType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogEntry_eventType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogEntry_processedAt(ctx context.Context, field graphql.CollectedField, obj *model.TaskAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogEntry_processedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProcessedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogEntry_processedAt(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogEntry_resourceId(ctx context.Context, field graphql.CollectedField, obj *model.TaskAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogEntry_resourceId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogEntry_resourceId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *model.TaskAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogEntry_resourceType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogEntry_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.TaskAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogEntry_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogEntry_timestamp(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskFiles_fileCount(ctx context.Context, field graphql.CollectedField, obj *TaskFiles) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskFiles_fileCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskFiles_fileCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskFiles",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskFiles_groupedFiles(ctx context.Context, field graphql.CollectedField, obj *TaskFiles) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskFiles_groupedFiles(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GroupedFiles, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*GroupedFiles)
	fc.Result = res
	return ec.marshalNGroupedFiles2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐGroupedFilesᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskFiles_groupedFiles(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskFiles",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "files":
				return ec.fieldContext_GroupedFiles_files(ctx, field)
			case "taskName":
				return ec.fieldContext_GroupedFiles_taskName(ctx, field)
			case "taskId":
				return ec.fieldContext_GroupedFiles_taskId(ctx, field)
			case "execution":
				return ec.fieldContext_GroupedFiles_execution(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupedFiles", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskHistory_tasks(ctx context.Context, field graphql.CollectedField, obj *TaskHistory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskHistory_tasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APITask)
	fc.Result = res
	return ec.marshalNTask2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskHistory_tasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskHistory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskHistory_pagination(ctx context.Context, field graphql.CollectedField, obj *TaskHistory) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskHistory_pagination(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pagination, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*TaskHistoryPagination)
	fc.Result = res
	return ec.marshalNTaskHistoryPagination2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskHistoryPagination(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskHistory_pagination(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskHistory",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "mostRecentTaskOrder":
				return ec.fieldContext_TaskHistoryPagination_mostRecentTaskOrder(ctx, field)
			case "oldestTaskOrder":
				return ec.fieldContext_TaskHistoryPagination_oldestTaskOrder(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskHistoryPagination", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskHistoryPagination_mostRecentTaskOrder(ctx context.Context, field graphql.CollectedField, obj *TaskHistoryPagination) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskHistoryPagination_mostRecentTaskOrder(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MostRecentTaskOrder, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskHistoryPagination_mostRecentTaskOrder(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskHistoryPagination",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskHistoryPagination_oldestTaskOrder(ctx context.Context, field graphql.CollectedField, obj *TaskHistoryPagination) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskHistoryPagination_oldestTaskOrder(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OldestTaskOrder, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskHistoryPagination_oldestTaskOrder(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskHistoryPagination",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskInfo_id(ctx context.Context, field graphql.CollectedField, obj *model.TaskInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskInfo_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskInfo_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskInfo_name(ctx context.Context, field graphql.CollectedField, obj *model.TaskInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskInfo_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskInfo_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLimitsConfig_maxTasksPerVersion(ctx context.Context, field graphql.CollectedField, obj *model.APITaskLimitsConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLimitsConfig_maxTasksPerVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxTasksPerVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLimitsConfig_maxTasksPerVersion(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLimitsConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLimitsConfig_maxIncludesPerVersion(ctx context.Context, field graphql.CollectedField, obj *model.APITaskLimitsConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLimitsConfig_maxIncludesPerVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxIncludesPerVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLimitsConfig_maxIncludesPerVersion(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLimitsConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLimitsConfig_maxHourlyPatchTasks(ctx context.Context, field graphql.CollectedField, obj *model.APITaskLimitsConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLimitsConfig_maxHourlyPatchTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxHourlyPatchTasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLimitsConfig_maxHourlyPatchTasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLimitsConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLimitsConfig_maxPendingGeneratedTasks(ctx context.Context, field graphql.CollectedField, obj *model.APITaskLimitsConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLimitsConfig_maxPendingGeneratedTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxPendingGeneratedTasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLimitsConfig_maxPendingGeneratedTasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLimitsConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLimitsConfig_maxGenerateTaskJSONSize(ctx context.Context, field graphql.CollectedField, obj *model.APITaskLimitsConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLimitsConfig_maxGenerateTaskJSONSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxGenerateTaskJSONSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLimitsConfig_maxGenerateTaskJSONSize(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLimitsConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLimitsConfig_maxConcurrentLargeParserProjectTasks(ctx context.Context, field graphql.CollectedField, obj *model.APITaskLimitsConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLimitsConfig_maxConcurrentLargeParserProjectTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxConcurrentLargeParserProjectTasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLimitsConfig_maxConcurrentLargeParserProjectTasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLimitsConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLimitsConfig_maxDegradedModeConcurrentLargeParserProjectTasks(ctx context.Context, field graphql.CollectedField, obj *model.APITaskLimitsConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLimitsConfig_maxDegradedModeConcurrentLargeParserProjectTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxDegradedModeConcurrentLargeParserProjectTasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLimitsConfig_maxDegradedModeConcurrentLargeParserProjectTasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLimitsConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLimitsConfig_maxDegradedModeParserProjectSize(ctx context.Context, field graphql.CollectedField, obj *model.APITaskLimitsConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLimitsConfig_maxDegradedModeParserProjectSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxDegradedModeParserProjectSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLimitsConfig_maxDegradedModeParserProjectSize(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLimitsConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLimitsConfig_maxParserProjectSize(ctx context.Context, field graphql.CollectedField, obj *model.APITaskLimitsConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLimitsConfig_maxParserProjectSize(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxParserProjectSize, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLimitsConfig_maxParserProjectSize(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLimitsConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLimitsConfig_maxExecTimeoutSecs(ctx context.Context, field graphql.CollectedField, obj *model.APITaskLimitsConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLimitsConfig_maxExecTimeoutSecs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxExecTimeoutSecs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLimitsConfig_maxExecTimeoutSecs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLimitsConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLimitsConfig_maxTaskExecution(ctx context.Context, field graphql.CollectedField, obj *model.APITaskLimitsConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLimitsConfig_maxTaskExecution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxTaskExecution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLimitsConfig_maxTaskExecution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLimitsConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLimitsConfig_maxDailyAutomaticRestarts(ctx context.Context, field graphql.CollectedField, obj *model.APITaskLimitsConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLimitsConfig_maxDailyAutomaticRestarts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxDailyAutomaticRestarts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLimitsConfig_maxDailyAutomaticRestarts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLimitsConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogLinks_agentLogLink(ctx context.Context, field graphql.CollectedField, obj *model.LogLinks) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLogLinks_agentLogLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentLogLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLogLinks_agentLogLink(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogLinks",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogLinks_allLogLink(ctx context.Context, field graphql.CollectedField, obj *model.LogLinks) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLogLinks_allLogLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AllLogLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLogLinks_allLogLink(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogLinks",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogLinks_eventLogLink(ctx context.Context, field graphql.CollectedField, obj *model.LogLinks) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLogLinks_eventLogLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventLogLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLogLinks_eventLogLink(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogLinks",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogLinks_systemLogLink(ctx context.Context, field graphql.CollectedField, obj *model.LogLinks) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLogLinks_systemLogLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SystemLogLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLogLinks_systemLogLink(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogLinks",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogLinks_taskLogLink(ctx context.Context, field graphql.CollectedField, obj *model.LogLinks) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLogLinks_taskLogLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskLogLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLogLinks_taskLogLink(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogLinks",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogs_agentLogs(ctx context.Context, field graphql.CollectedField, obj *TaskLogs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLogs_agentLogs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TaskLogs().AgentLogs(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*apimodels.LogMessage)
	fc.Result = res
	return ec.marshalNLogMessage2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋapimodelsᚐLogMessageᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLogs_agentLogs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogs",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "message":
				return ec.fieldContext_LogMessage_message(ctx, field)
			case "severity":
				return ec.fieldContext_LogMessage_severity(ctx, field)
			case "timestamp":
				return ec.fieldContext_LogMessage_timestamp(ctx, field)
			case "type":
				return ec.fieldContext_LogMessage_type(ctx, field)
			case "version":
				return ec.fieldContext_LogMessage_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LogMessage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogs_allLogs(ctx context.Context, field graphql.CollectedField, obj *TaskLogs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLogs_allLogs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TaskLogs().AllLogs(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*apimodels.LogMessage)
	fc.Result = res
	return ec.marshalNLogMessage2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋapimodelsᚐLogMessageᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLogs_allLogs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogs",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "message":
				return ec.fieldContext_LogMessage_message(ctx, field)
			case "severity":
				return ec.fieldContext_LogMessage_severity(ctx, field)
			case "timestamp":
				return ec.fieldContext_LogMessage_timestamp(ctx, field)
			case "type":
				return ec.fieldContext_LogMessage_type(ctx, field)
			case "version":
				return ec.fieldContext_LogMessage_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LogMessage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogs_eventLogs(ctx context.Context, field graphql.CollectedField, obj *TaskLogs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLogs_eventLogs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TaskLogs().EventLogs(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.TaskAPIEventLogEntry)
	fc.Result = res
	return ec.marshalNTaskEventLogEntry2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐTaskAPIEventLogEntryᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLogs_eventLogs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogs",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TaskEventLogEntry_id(ctx, field)
			case "data":
				return ec.fieldContext_TaskEventLogEntry_data(ctx, field)
			case "eventType":
				return ec.fieldContext_TaskEventLogEntry_eventType(ctx, field)
			case "processedAt":
				return ec.fieldContext_TaskEventLogEntry_processedAt(ctx, field)
			case "resourceId":
				return ec.fieldContext_TaskEventLogEntry_resourceId(ctx, field)
			case "resourceType":
				return ec.fieldContext_TaskEventLogEntry_resourceType(ctx, field)
			case "timestamp":
				return ec.fieldContext_TaskEventLogEntry_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskEventLogEntry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogs_execution(ctx context.Context, field graphql.CollectedField, obj *TaskLogs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLogs_execution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Execution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLogs_execution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogs",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogs_systemLogs(ctx context.Context, field graphql.CollectedField, obj *TaskLogs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLogs_systemLogs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TaskLogs().SystemLogs(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*apimodels.LogMessage)
	fc.Result = res
	return ec.marshalNLogMessage2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋapimodelsᚐLogMessageᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLogs_systemLogs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogs",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "message":
				return ec.fieldContext_LogMessage_message(ctx, field)
			case "severity":
				return ec.fieldContext_LogMessage_severity(ctx, field)
			case "timestamp":
				return ec.fieldContext_LogMessage_timestamp(ctx, field)
			case "type":
				return ec.fieldContext_LogMessage_type(ctx, field)
			case "version":
				return ec.fieldContext_LogMessage_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LogMessage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogs_taskId(ctx context.Context, field graphql.CollectedField, obj *TaskLogs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLogs_taskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLogs_taskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogs",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogs_taskLogs(ctx context.Context, field graphql.CollectedField, obj *TaskLogs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLogs_taskLogs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TaskLogs().TaskLogs(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*apimodels.LogMessage)
	fc.Result = res
	return ec.marshalNLogMessage2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋapimodelsᚐLogMessageᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLogs_taskLogs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogs",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "message":
				return ec.fieldContext_LogMessage_message(ctx, field)
			case "severity":
				return ec.fieldContext_LogMessage_severity(ctx, field)
			case "timestamp":
				return ec.fieldContext_LogMessage_timestamp(ctx, field)
			case "type":
				return ec.fieldContext_LogMessage_type(ctx, field)
			case "version":
				return ec.fieldContext_LogMessage_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LogMessage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskOwnerTeam_assignmentType(ctx context.Context, field graphql.CollectedField, obj *TaskOwnerTeam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskOwnerTeam_assignmentType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AssignmentType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskOwnerTeam_assignmentType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskOwnerTeam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskOwnerTeam_messages(ctx context.Context, field graphql.CollectedField, obj *TaskOwnerTeam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskOwnerTeam_messages(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Messages, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskOwnerTeam_messages(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskOwnerTeam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskOwnerTeam_teamName(ctx context.Context, field graphql.CollectedField, obj *TaskOwnerTeam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskOwnerTeam_teamName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TeamName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskOwnerTeam_teamName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskOwnerTeam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskOwnerTeam_jiraProject(ctx context.Context, field graphql.CollectedField, obj *TaskOwnerTeam) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskOwnerTeam_jiraProject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JiraProject, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskOwnerTeam_jiraProject(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskOwnerTeam",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueDistro_id(ctx context.Context, field graphql.CollectedField, obj *TaskQueueDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskQueueDistro_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskQueueDistro_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueDistro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueDistro_hostCount(ctx context.Context, field graphql.CollectedField, obj *TaskQueueDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskQueueDistro_hostCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskQueueDistro_hostCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueDistro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueDistro_taskCount(ctx context.Context, field graphql.CollectedField, obj *TaskQueueDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskQueueDistro_taskCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskQueueDistro_taskCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueDistro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_id(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskQueueItem_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNID2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskQueueItem_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_buildVariant(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskQueueItem_buildVariant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildVariant, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskQueueItem_buildVariant(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_displayName(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskQueueItem_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskQueueItem_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_expectedDuration(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskQueueItem_expectedDuration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpectedDuration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIDuration)
	fc.Result = res
	return ec.marshalNDuration2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskQueueItem_expectedDuration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_priority(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskQueueItem_priority(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Priority, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskQueueItem_priority(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_project(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskQueueItem_project(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Project, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskQueueItem_project(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_projectIdentifier(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskQueueItem_projectIdentifier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectIdentifier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskQueueItem_projectIdentifier(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_requester(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskQueueItem_requester(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TaskQueueItem().Requester(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(TaskQueueItemType)
	fc.Result = res
	return ec.marshalNTaskQueueItemType2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskQueueItemType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskQueueItem_requester(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TaskQueueItemType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_activatedBy(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskQueueItem_activatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ActivatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskQueueItem_activatedBy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_revision(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskQueueItem_revision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskQueueItem_revision(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_version(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskQueueItem_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskQueueItem_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskSpecifier_patchAlias(ctx context.Context, field graphql.CollectedField, obj *model.APITaskSpecifier) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskSpecifier_patchAlias(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PatchAlias, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskSpecifier_patchAlias(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskSpecifier",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskSpecifier_taskRegex(ctx context.Context, field graphql.CollectedField, obj *model.APITaskSpecifier) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskSpecifier_taskRegex(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskRegex, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskSpecifier_taskRegex(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskSpecifier",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskSpecifier_variantRegex(ctx context.Context, field graphql.CollectedField, obj *model.APITaskSpecifier) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskSpecifier_variantRegex(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VariantRegex, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskSpecifier_variantRegex(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskSpecifier",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskStats_counts(ctx context.Context, field graphql.CollectedField, obj *task.TaskStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskStats_counts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Counts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]task.StatusCount)
	fc.Result = res
	return ec.marshalOStatusCount2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋtaskᚐStatusCountᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskStats_counts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_StatusCount_count(ctx, field)
			case "status":
				return ec.fieldContext_StatusCount_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StatusCount", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskStats_eta(ctx context.Context, field graphql.CollectedField, obj *task.TaskStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskStats_eta(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ETA, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskStats_eta(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskTestResult_testResults(ctx context.Context, field graphql.CollectedField, obj *TaskTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskTestResult_testResults(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TestResults, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APITest)
	fc.Result = res
	return ec.marshalNTestResult2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITestᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskTestResult_testResults(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TestResult_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_TestResult_baseStatus(ctx, field)
			case "duration":
				return ec.fieldContext_TestResult_duration(ctx, field)
			case "endTime":
				return ec.fieldContext_TestResult_endTime(ctx, field)
			case "execution":
				return ec.fieldContext_TestResult_execution(ctx, field)
			case "exitCode":
				return ec.fieldContext_TestResult_exitCode(ctx, field)
			case "groupID":
				return ec.fieldContext_TestResult_groupID(ctx, field)
			case "logs":
				return ec.fieldContext_TestResult_logs(ctx, field)
			case "startTime":
				return ec.fieldContext_TestResult_startTime(ctx, field)
			case "status":
				return ec.fieldContext_TestResult_status(ctx, field)
			case "taskId":
				return ec.fieldContext_TestResult_taskId(ctx, field)
			case "testFile":
				return ec.fieldContext_TestResult_testFile(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TestResult", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskTestResult_totalTestCount(ctx context.Context, field graphql.CollectedField, obj *TaskTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskTestResult_totalTestCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalTestCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskTestResult_totalTestCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskTestResult_filteredTestCount(ctx context.Context, field graphql.CollectedField, obj *TaskTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskTestResult_filteredTestCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FilteredTestCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskTestResult_filteredTestCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskTestResultSample_execution(ctx context.Context, field graphql.CollectedField, obj *TaskTestResultSample) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskTestResultSample_execution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Execution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskTestResultSample_execution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskTestResultSample",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskTestResultSample_matchingFailedTestNames(ctx context.Context, field graphql.CollectedField, obj *TaskTestResultSample) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskTestResultSample_matchingFailedTestNames(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MatchingFailedTestNames, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskTestResultSample_matchingFailedTestNames(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskTestResultSample",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskTestResultSample_taskId(ctx context.Context, field graphql.CollectedField, obj *TaskTestResultSample) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskTestResultSample_taskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskTestResultSample_taskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskTestResultSample",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskTestResultSample_totalTestCount(ctx context.Context, field graphql.CollectedField, obj *TaskTestResultSample) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskTestResultSample_totalTestCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalTestCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskTestResultSample_totalTestCount(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskTestResultSample",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestLog_lineNum(ctx context.Context, field graphql.CollectedField, obj *model.TestLogs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestLog_lineNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LineNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestLog_lineNum(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestLog_url(ctx context.Context, field graphql.CollectedField, obj *model.TestLogs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestLog_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestLog_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestLog_urlParsley(ctx context.Context, field graphql.CollectedField, obj *model.TestLogs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestLog_urlParsley(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URLParsley, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestLog_urlParsley(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestLog_urlRaw(ctx context.Context, field graphql.CollectedField, obj *model.TestLogs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestLog_urlRaw(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URLRaw, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestLog_urlRaw(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestLog_renderingType(ctx context.Context, field graphql.CollectedField, obj *model.TestLogs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestLog_renderingType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RenderingType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestLog_renderingType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestLog_version(ctx context.Context, field graphql.CollectedField, obj *model.TestLogs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestLog_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int32)
	fc.Result = res
	return ec.marshalOInt2int32(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestLog_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_id(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestResult_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestResult_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_baseStatus(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestResult_baseStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BaseStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestResult_baseStatus(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_duration(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestResult_duration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Duration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestResult_duration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_endTime(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestResult_endTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestResult_endTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_execution(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestResult_execution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Execution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestResult_execution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_exitCode(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestResult_exitCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExitCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestResult_exitCode(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_groupID(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestResult_groupID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GroupID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestResult_groupID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_logs(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestResult_logs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Logs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.TestLogs)
	fc.Result = res
	return ec.marshalNTestLog2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐTestLogs(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestResult_logs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lineNum":
				return ec.fieldContext_TestLog_lineNum(ctx, field)
			case "url":
				return ec.fieldContext_TestLog_url(ctx, field)
			case "urlParsley":
				return ec.fieldContext_TestLog_urlParsley(ctx, field)
			case "urlRaw":
				return ec.fieldContext_TestLog_urlRaw(ctx, field)
			case "renderingType":
				return ec.fieldContext_TestLog_renderingType(ctx, field)
			case "version":
				return ec.fieldContext_TestLog_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TestLog", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_startTime(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestResult_startTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestResult_startTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_status(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestResult_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestResult_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_taskId(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestResult_taskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestResult_taskId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_testFile(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestResult_testFile(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TestFile, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestResult_testFile(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestSelectionConfig_url(ctx context.Context, field graphql.CollectedField, obj *model.APITestSelectionConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestSelectionConfig_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestSelectionConfig_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestSelectionConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TicketFields_assignedTeam(ctx context.Context, field graphql.CollectedField, obj *thirdparty.TicketFields) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TicketFields_assignedTeam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TicketFields().AssignedTeam(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TicketFields_assignedTeam(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TicketFields",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TicketFields_assigneeDisplayName(ctx context.Context, field graphql.CollectedField, obj *thirdparty.TicketFields) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TicketFields_assigneeDisplayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TicketFields().AssigneeDisplayName(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TicketFields_assigneeDisplayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TicketFields",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TicketFields_created(ctx context.Context, field graphql.CollectedField, obj *thirdparty.TicketFields) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TicketFields_created(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Created, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TicketFields_created(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TicketFields",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TicketFields_resolutionName(ctx context.Context, field graphql.CollectedField, obj *thirdparty.TicketFields) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TicketFields_resolutionName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TicketFields().ResolutionName(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TicketFields_resolutionName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TicketFields",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TicketFields_status(ctx context.Context, field graphql.CollectedField, obj *thirdparty.TicketFields) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TicketFields_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*thirdparty.JiraStatus)
	fc.Result = res
	return ec.marshalNJiraStatus2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐJiraStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TicketFields_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TicketFields",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_JiraStatus_id(ctx, field)
			case "name":
				return ec.fieldContext_JiraStatus_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JiraStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TicketFields_summary(ctx context.Context, field graphql.CollectedField, obj *thirdparty.TicketFields) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TicketFields_summary(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Summary, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TicketFields_summary(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TicketFields",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TicketFields_updated(ctx context.Context, field graphql.CollectedField, obj *thirdparty.TicketFields) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TicketFields_updated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Updated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TicketFields_updated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TicketFields",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Toolchain_name(ctx context.Context, field graphql.CollectedField, obj *model.APIToolchain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Toolchain_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Toolchain_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Toolchain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Toolchain_path(ctx context.Context, field graphql.CollectedField, obj *model.APIToolchain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Toolchain_path(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Toolchain_path(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Toolchain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Toolchain_version(ctx context.Context, field graphql.CollectedField, obj *model.APIToolchain) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Toolchain_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Toolchain_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Toolchain",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TriggerAlias_alias(ctx context.Context, field graphql.CollectedField, obj *model.APITriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TriggerAlias_alias(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Alias, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TriggerAlias_alias(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TriggerAlias_buildVariantRegex(ctx context.Context, field graphql.CollectedField, obj *model.APITriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TriggerAlias_buildVariantRegex(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildVariantRegex, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TriggerAlias_buildVariantRegex(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TriggerAlias_configFile(ctx context.Context, field graphql.CollectedField, obj *model.APITriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TriggerAlias_configFile(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConfigFile, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TriggerAlias_configFile(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TriggerAlias_dateCutoff(ctx context.Context, field graphql.CollectedField, obj *model.APITriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TriggerAlias_dateCutoff(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DateCutoff, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TriggerAlias_dateCutoff(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TriggerAlias_level(ctx context.Context, field graphql.CollectedField, obj *model.APITriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TriggerAlias_level(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Level, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TriggerAlias_level(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TriggerAlias_project(ctx context.Context, field graphql.CollectedField, obj *model.APITriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TriggerAlias_project(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Project, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TriggerAlias_project(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TriggerAlias_status(ctx context.Context, field graphql.CollectedField, obj *model.APITriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TriggerAlias_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TriggerAlias_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TriggerAlias_taskRegex(ctx context.Context, field graphql.CollectedField, obj *model.APITriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TriggerAlias_taskRegex(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskRegex, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TriggerAlias_taskRegex(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TriggerAlias_unscheduleDownstreamVersions(ctx context.Context, field graphql.CollectedField, obj *model.APITriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TriggerAlias_unscheduleDownstreamVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UnscheduleDownstreamVersions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TriggerAlias_unscheduleDownstreamVersions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TriggerConfig_generateTaskDistro(ctx context.Context, field graphql.CollectedField, obj *model.APITriggerConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TriggerConfig_generateTaskDistro(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GenerateTaskDistro, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TriggerConfig_generateTaskDistro(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TriggerConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UIConfig_betaFeatures(ctx context.Context, field graphql.CollectedField, obj *model.APIUIConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UIConfig_betaFeatures(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BetaFeatures, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIBetaFeatures)
	fc.Result = res
	return ec.marshalNBetaFeatures2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIBetaFeatures(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UIConfig_betaFeatures(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "spruceWaterfallEnabled":
				return ec.fieldContext_BetaFeatures_spruceWaterfallEnabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BetaFeatures", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UIConfig_url(ctx context.Context, field graphql.CollectedField, obj *model.APIUIConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UIConfig_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Url, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UIConfig_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UIConfig_helpUrl(ctx context.Context, field graphql.CollectedField, obj *model.APIUIConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UIConfig_helpUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HelpUrl, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UIConfig_helpUrl(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UIConfig_uiv2Url(ctx context.Context, field graphql.CollectedField, obj *model.APIUIConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UIConfig_uiv2Url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UIv2Url, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UIConfig_uiv2Url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UIConfig_parsleyUrl(ctx context.Context, field graphql.CollectedField, obj *model.APIUIConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UIConfig_parsleyUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParsleyUrl, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UIConfig_parsleyUrl(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UIConfig_httpListenAddr(ctx context.Context, field graphql.CollectedField, obj *model.APIUIConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UIConfig_httpListenAddr(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HttpListenAddr, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UIConfig_httpListenAddr(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UIConfig_secret(ctx context.Context, field graphql.CollectedField, obj *model.APIUIConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UIConfig_secret(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Secret, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.RequireAdmin == nil {
				var zeroVal *string
				return zeroVal, errors.New("directive requireAdmin is not implemented")
			}
			return ec.directives.RequireAdmin(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UIConfig_secret(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UIConfig_defaultProject(ctx context.Context, field graphql.CollectedField, obj *model.APIUIConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UIConfig_defaultProject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultProject, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UIConfig_defaultProject(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UIConfig_corsOrigins(ctx context.Context, field graphql.CollectedField, obj *model.APIUIConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UIConfig_corsOrigins(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CORSOrigins, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UIConfig_corsOrigins(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UIConfig_fileStreamingContentTypes(ctx context.Context, field graphql.CollectedField, obj *model.APIUIConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UIConfig_fileStreamingContentTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileStreamingContentTypes, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UIConfig_fileStreamingContentTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UIConfig_loginDomain(ctx context.Context, field graphql.CollectedField, obj *model.APIUIConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UIConfig_loginDomain(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LoginDomain, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UIConfig_loginDomain(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UIConfig_userVoice(ctx context.Context, field graphql.CollectedField, obj *model.APIUIConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UIConfig_userVoice(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserVoice, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UIConfig_userVoice(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UIConfig_csrfKey(ctx context.Context, field graphql.CollectedField, obj *model.APIUIConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UIConfig_csrfKey(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		directive0 := func(rctx context.Context) (any, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CsrfKey, nil
		}

		directive1 := func(ctx context.Context) (any, error) {
			if ec.directives.RequireAdmin == nil {
				var zeroVal *string
				return zeroVal, errors.New("directive requireAdmin is not implemented")
			}
			return ec.directives.RequireAdmin(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UIConfig_csrfKey(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UIConfig_cacheTemplates(ctx context.Context, field graphql.CollectedField, obj *model.APIUIConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UIConfig_cacheTemplates(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CacheTemplates, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UIConfig_cacheTemplates(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UIConfig_stagingEnvironment(ctx context.Context, field graphql.CollectedField, obj *model.APIUIConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UIConfig_stagingEnvironment(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StagingEnvironment, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UIConfig_stagingEnvironment(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateBetaFeaturesPayload_betaFeatures(ctx context.Context, field graphql.CollectedField, obj *UpdateBetaFeaturesPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateBetaFeaturesPayload_betaFeatures(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BetaFeatures, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIBetaFeatures)
	fc.Result = res
	return ec.marshalOBetaFeatures2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIBetaFeatures(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateBetaFeaturesPayload_betaFeatures(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateBetaFeaturesPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "spruceWaterfallEnabled":
				return ec.fieldContext_BetaFeatures_spruceWaterfallEnabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BetaFeatures", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpdateParsleySettingsPayload_parsleySettings(ctx context.Context, field graphql.CollectedField, obj *UpdateParsleySettingsPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpdateParsleySettingsPayload_parsleySettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParsleySettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIParsleySettings)
	fc.Result = res
	return ec.marshalOParsleySettings2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParsleySettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpdateParsleySettingsPayload_parsleySettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpdateParsleySettingsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "sectionsEnabled":
				return ec.fieldContext_ParsleySettings_sectionsEnabled(ctx, field)
			case "jumpToFailingLineEnabled":
				return ec.fieldContext_ParsleySettings_jumpToFailingLineEnabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ParsleySettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpstreamProject_owner(ctx context.Context, field graphql.CollectedField, obj *UpstreamProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpstreamProject_owner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpstreamProject_owner(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpstreamProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpstreamProject_project(ctx context.Context, field graphql.CollectedField, obj *UpstreamProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpstreamProject_project(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Project, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpstreamProject_project(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpstreamProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpstreamProject_repo(ctx context.Context, field graphql.CollectedField, obj *UpstreamProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpstreamProject_repo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpstreamProject_repo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpstreamProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpstreamProject_resourceID(ctx context.Context, field graphql.CollectedField, obj *UpstreamProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpstreamProject_resourceID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpstreamProject_resourceID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpstreamProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpstreamProject_revision(ctx context.Context, field graphql.CollectedField, obj *UpstreamProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpstreamProject_revision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpstreamProject_revision(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpstreamProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpstreamProject_task(ctx context.Context, field graphql.CollectedField, obj *UpstreamProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpstreamProject_task(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Task, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APITask)
	fc.Result = res
	return ec.marshalOTask2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpstreamProject_task(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpstreamProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpstreamProject_triggerID(ctx context.Context, field graphql.CollectedField, obj *UpstreamProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpstreamProject_triggerID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TriggerID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpstreamProject_triggerID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpstreamProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpstreamProject_triggerType(ctx context.Context, field graphql.CollectedField, obj *UpstreamProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpstreamProject_triggerType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TriggerType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpstreamProject_triggerType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpstreamProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpstreamProject_version(ctx context.Context, field graphql.CollectedField, obj *UpstreamProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpstreamProject_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIVersion)
	fc.Result = res
	return ec.marshalOVersion2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpstreamProject_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpstreamProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "authorEmail":
				return ec.fieldContext_Version_authorEmail(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Version_generatedTaskCounts(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "ignored":
				return ec.fieldContext_Version_ignored(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			case "waterfallBuilds":
				return ec.fieldContext_Version_waterfallBuilds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UseSpruceOptions_spruceV1(ctx context.Context, field graphql.CollectedField, obj *model.APIUseSpruceOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UseSpruceOptions_spruceV1(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpruceV1, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UseSpruceOptions_spruceV1(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UseSpruceOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_betaFeatures(ctx context.Context, field graphql.CollectedField, obj *model.APIDBUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_betaFeatures(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BetaFeatures, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIBetaFeatures)
	fc.Result = res
	return ec.marshalNBetaFeatures2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIBetaFeatures(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_betaFeatures(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "spruceWaterfallEnabled":
				return ec.fieldContext_BetaFeatures_spruceWaterfallEnabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BetaFeatures", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_displayName(ctx context.Context, field graphql.CollectedField, obj *model.APIDBUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_emailAddress(ctx context.Context, field graphql.CollectedField, obj *model.APIDBUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_emailAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EmailAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_emailAddress(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_parsleyFilters(ctx context.Context, field graphql.CollectedField, obj *model.APIDBUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_parsleyFilters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParsleyFilters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APIParsleyFilter)
	fc.Result = res
	return ec.marshalNParsleyFilter2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParsleyFilterᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_parsleyFilters(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "caseSensitive":
				return ec.fieldContext_ParsleyFilter_caseSensitive(ctx, field)
			case "description":
				return ec.fieldContext_ParsleyFilter_description(ctx, field)
			case "exactMatch":
				return ec.fieldContext_ParsleyFilter_exactMatch(ctx, field)
			case "expression":
				return ec.fieldContext_ParsleyFilter_expression(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ParsleyFilter", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_parsleySettings(ctx context.Context, field graphql.CollectedField, obj *model.APIDBUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_parsleySettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParsleySettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIParsleySettings)
	fc.Result = res
	return ec.marshalNParsleySettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParsleySettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_parsleySettings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "sectionsEnabled":
				return ec.fieldContext_ParsleySettings_sectionsEnabled(ctx, field)
			case "jumpToFailingLineEnabled":
				return ec.fieldContext_ParsleySettings_jumpToFailingLineEnabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ParsleySettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_patches(ctx context.Context, field graphql.CollectedField, obj *model.APIDBUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_patches(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().Patches(rctx, obj, fc.Args["patchesInput"].(PatchesInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Patches)
	fc.Result = res
	return ec.marshalNPatches2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPatches(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_patches(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "filteredPatchCount":
				return ec.fieldContext_Patches_filteredPatchCount(ctx, field)
			case "patches":
				return ec.fieldContext_Patches_patches(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Patches", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_User_patches_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _User_permissions(ctx context.Context, field graphql.CollectedField, obj *model.APIDBUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_permissions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().Permissions(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Permissions)
	fc.Result = res
	return ec.marshalNPermissions2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPermissions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_permissions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "canCreateDistro":
				return ec.fieldContext_Permissions_canCreateDistro(ctx, field)
			case "canCreateProject":
				return ec.fieldContext_Permissions_canCreateProject(ctx, field)
			case "canEditAdminSettings":
				return ec.fieldContext_Permissions_canEditAdminSettings(ctx, field)
			case "distroPermissions":
				return ec.fieldContext_Permissions_distroPermissions(ctx, field)
			case "projectPermissions":
				return ec.fieldContext_Permissions_projectPermissions(ctx, field)
			case "repoPermissions":
				return ec.fieldContext_Permissions_repoPermissions(ctx, field)
			case "userId":
				return ec.fieldContext_Permissions_userId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Permissions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_settings(ctx context.Context, field graphql.CollectedField, obj *model.APIDBUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_settings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Settings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIUserSettings)
	fc.Result = res
	return ec.marshalNUserSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIUserSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_settings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "githubUser":
				return ec.fieldContext_UserSettings_githubUser(ctx, field)
			case "notifications":
				return ec.fieldContext_UserSettings_notifications(ctx, field)
			case "region":
				return ec.fieldContext_UserSettings_region(ctx, field)
			case "slackUsername":
				return ec.fieldContext_UserSettings_slackUsername(ctx, field)
			case "slackMemberId":
				return ec.fieldContext_UserSettings_slackMemberId(ctx, field)
			case "timezone":
				return ec.fieldContext_UserSettings_timezone(ctx, field)
			case "useSpruceOptions":
				return ec.fieldContext_UserSettings_useSpruceOptions(ctx, field)
			case "dateFormat":
				return ec.fieldContext_UserSettings_dateFormat(ctx, field)
			case "timeFormat":
				return ec.fieldContext_UserSettings_timeFormat(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_subscriptions(ctx context.Context, field graphql.CollectedField, obj *model.APIDBUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_subscriptions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().Subscriptions(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.APISubscription)
	fc.Result = res
	return ec.marshalOGeneralSubscription2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISubscriptionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_subscriptions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GeneralSubscription_id(ctx, field)
			case "ownerType":
				return ec.fieldContext_GeneralSubscription_ownerType(ctx, field)
			case "regexSelectors":
				return ec.fieldContext_GeneralSubscription_regexSelectors(ctx, field)
			case "resourceType":
				return ec.fieldContext_GeneralSubscription_resourceType(ctx, field)
			case "selectors":
				return ec.fieldContext_GeneralSubscription_selectors(ctx, field)
			case "subscriber":
				return ec.fieldContext_GeneralSubscription_subscriber(ctx, field)
			case "trigger":
				return ec.fieldContext_GeneralSubscription_trigger(ctx, field)
			case "triggerData":
				return ec.fieldContext_GeneralSubscription_triggerData(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GeneralSubscription", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_userId(ctx context.Context, field graphql.CollectedField, obj *model.APIDBUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_userId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserConfig_api_key(ctx context.Context, field graphql.CollectedField, obj *UserConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserConfig_api_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserConfig_api_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserConfig_api_server_host(ctx context.Context, field graphql.CollectedField, obj *UserConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserConfig_api_server_host(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIServerHost, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserConfig_api_server_host(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserConfig_ui_server_host(ctx context.Context, field graphql.CollectedField, obj *UserConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserConfig_ui_server_host(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UIServerHost, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserConfig_ui_server_host(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserConfig_user(ctx context.Context, field graphql.CollectedField, obj *UserConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserConfig_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserConfig_user(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettings_githubUser(ctx context.Context, field graphql.CollectedField, obj *model.APIUserSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSettings_githubUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GithubUser, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIGithubUser)
	fc.Result = res
	return ec.marshalOGithubUser2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGithubUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSettings_githubUser(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lastKnownAs":
				return ec.fieldContext_GithubUser_lastKnownAs(ctx, field)
			case "uid":
				return ec.fieldContext_GithubUser_uid(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettings_notifications(ctx context.Context, field graphql.CollectedField, obj *model.APIUserSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSettings_notifications(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Notifications, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APINotificationPreferences)
	fc.Result = res
	return ec.marshalONotifications2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPINotificationPreferences(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSettings_notifications(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "buildBreak":
				return ec.fieldContext_Notifications_buildBreak(ctx, field)
			case "buildBreakId":
				return ec.fieldContext_Notifications_buildBreakId(ctx, field)
			case "patchFinish":
				return ec.fieldContext_Notifications_patchFinish(ctx, field)
			case "patchFinishId":
				return ec.fieldContext_Notifications_patchFinishId(ctx, field)
			case "patchFirstFailure":
				return ec.fieldContext_Notifications_patchFirstFailure(ctx, field)
			case "patchFirstFailureId":
				return ec.fieldContext_Notifications_patchFirstFailureId(ctx, field)
			case "spawnHostExpiration":
				return ec.fieldContext_Notifications_spawnHostExpiration(ctx, field)
			case "spawnHostExpirationId":
				return ec.fieldContext_Notifications_spawnHostExpirationId(ctx, field)
			case "spawnHostOutcome":
				return ec.fieldContext_Notifications_spawnHostOutcome(ctx, field)
			case "spawnHostOutcomeId":
				return ec.fieldContext_Notifications_spawnHostOutcomeId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Notifications", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettings_region(ctx context.Context, field graphql.CollectedField, obj *model.APIUserSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSettings_region(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Region, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSettings_region(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettings_slackUsername(ctx context.Context, field graphql.CollectedField, obj *model.APIUserSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSettings_slackUsername(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SlackUsername, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSettings_slackUsername(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettings_slackMemberId(ctx context.Context, field graphql.CollectedField, obj *model.APIUserSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSettings_slackMemberId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SlackMemberId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSettings_slackMemberId(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettings_timezone(ctx context.Context, field graphql.CollectedField, obj *model.APIUserSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSettings_timezone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timezone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSettings_timezone(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettings_useSpruceOptions(ctx context.Context, field graphql.CollectedField, obj *model.APIUserSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSettings_useSpruceOptions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UseSpruceOptions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIUseSpruceOptions)
	fc.Result = res
	return ec.marshalOUseSpruceOptions2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIUseSpruceOptions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSettings_useSpruceOptions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "spruceV1":
				return ec.fieldContext_UseSpruceOptions_spruceV1(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UseSpruceOptions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettings_dateFormat(ctx context.Context, field graphql.CollectedField, obj *model.APIUserSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSettings_dateFormat(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DateFormat, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSettings_dateFormat(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettings_timeFormat(ctx context.Context, field graphql.CollectedField, obj *model.APIUserSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSettings_timeFormat(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimeFormat, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSettings_timeFormat(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VariantTask_name(ctx context.Context, field graphql.CollectedField, obj *model.VariantTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VariantTask_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VariantTask_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VariantTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VariantTask_tasks(ctx context.Context, field graphql.CollectedField, obj *model.VariantTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VariantTask_tasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalNString2ᚕᚖstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VariantTask_tasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VariantTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_id(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_activated(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_activated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Activated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_activated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_author(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_author(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Author, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_author(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_authorEmail(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_authorEmail(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthorEmail, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_authorEmail(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_baseTaskStatuses(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_baseTaskStatuses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().BaseTaskStatuses(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_baseTaskStatuses(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_baseVersion(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_baseVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().BaseVersion(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIVersion)
	fc.Result = res
	return ec.marshalOVersion2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_baseVersion(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "authorEmail":
				return ec.fieldContext_Version_authorEmail(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Version_generatedTaskCounts(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "ignored":
				return ec.fieldContext_Version_ignored(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			case "waterfallBuilds":
				return ec.fieldContext_Version_waterfallBuilds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_branch(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_branch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Branch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_branch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_buildVariants(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_buildVariants(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().BuildVariants(rctx, obj, fc.Args["options"].(BuildVariantOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*GroupedBuildVariant)
	fc.Result = res
	return ec.marshalOGroupedBuildVariant2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐGroupedBuildVariantᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_buildVariants(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "displayName":
				return ec.fieldContext_GroupedBuildVariant_displayName(ctx, field)
			case "tasks":
				return ec.fieldContext_GroupedBuildVariant_tasks(ctx, field)
			case "variant":
				return ec.fieldContext_GroupedBuildVariant_variant(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupedBuildVariant", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Version_buildVariants_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Version_buildVariantStats(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_buildVariantStats(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().BuildVariantStats(rctx, obj, fc.Args["options"].(BuildVariantOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*task.GroupedTaskStatusCount)
	fc.Result = res
	return ec.marshalOGroupedTaskStatusCount2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋtaskᚐGroupedTaskStatusCountᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_buildVariantStats(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "displayName":
				return ec.fieldContext_GroupedTaskStatusCount_displayName(ctx, field)
			case "statusCounts":
				return ec.fieldContext_GroupedTaskStatusCount_statusCounts(ctx, field)
			case "variant":
				return ec.fieldContext_GroupedTaskStatusCount_variant(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupedTaskStatusCount", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Version_buildVariantStats_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Version_childVersions(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_childVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().ChildVersions(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.APIVersion)
	fc.Result = res
	return ec.marshalOVersion2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVersionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_childVersions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "authorEmail":
				return ec.fieldContext_Version_authorEmail(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Version_generatedTaskCounts(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "ignored":
				return ec.fieldContext_Version_ignored(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			case "waterfallBuilds":
				return ec.fieldContext_Version_waterfallBuilds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_createTime(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_createTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreateTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_createTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_errors(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalNString2ᚕᚖstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_errors(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_externalLinksForMetadata(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().ExternalLinksForMetadata(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ExternalLinkForMetadata)
	fc.Result = res
	return ec.marshalNExternalLinkForMetadata2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐExternalLinkForMetadataᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_externalLinksForMetadata(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "url":
				return ec.fieldContext_ExternalLinkForMetadata_url(ctx, field)
			case "displayName":
				return ec.fieldContext_ExternalLinkForMetadata_displayName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ExternalLinkForMetadata", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_finishTime(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_finishTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FinishTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_finishTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_generatedTaskCounts(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_generatedTaskCounts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().GeneratedTaskCounts(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*GeneratedTaskCountResults)
	fc.Result = res
	return ec.marshalNGeneratedTaskCountResults2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐGeneratedTaskCountResultsᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_generatedTaskCounts(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "buildVariantName":
				return ec.fieldContext_GeneratedTaskCountResults_buildVariantName(ctx, field)
			case "taskName":
				return ec.fieldContext_GeneratedTaskCountResults_taskName(ctx, field)
			case "taskId":
				return ec.fieldContext_GeneratedTaskCountResults_taskId(ctx, field)
			case "estimatedTasks":
				return ec.fieldContext_GeneratedTaskCountResults_estimatedTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GeneratedTaskCountResults", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_gitTags(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_gitTags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GitTags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIGitTag)
	fc.Result = res
	return ec.marshalOGitTag2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGitTagᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_gitTags(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tag":
				return ec.fieldContext_GitTag_tag(ctx, field)
			case "pusher":
				return ec.fieldContext_GitTag_pusher(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GitTag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_ignored(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_ignored(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ignored, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_ignored(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_isPatch(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_isPatch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().IsPatch(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_isPatch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_manifest(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_manifest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().Manifest(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Manifest)
	fc.Result = res
	return ec.marshalOManifest2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐManifest(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_manifest(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Manifest_id(ctx, field)
			case "branch":
				return ec.fieldContext_Manifest_branch(ctx, field)
			case "isBase":
				return ec.fieldContext_Manifest_isBase(ctx, field)
			case "moduleOverrides":
				return ec.fieldContext_Manifest_moduleOverrides(ctx, field)
			case "modules":
				return ec.fieldContext_Manifest_modules(ctx, field)
			case "project":
				return ec.fieldContext_Manifest_project(ctx, field)
			case "revision":
				return ec.fieldContext_Manifest_revision(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Manifest", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_message(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_message(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_order(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_order(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Order, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_order(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_parameters(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_parameters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Parameters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APIParameter)
	fc.Result = res
	return ec.marshalNParameter2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParameterᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_parameters(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_Parameter_key(ctx, field)
			case "value":
				return ec.fieldContext_Parameter_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Parameter", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_patch(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_patch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().Patch(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIPatch)
	fc.Result = res
	return ec.marshalOPatch2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_patch(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Patch_id(ctx, field)
			case "activated":
				return ec.fieldContext_Patch_activated(ctx, field)
			case "alias":
				return ec.fieldContext_Patch_alias(ctx, field)
			case "author":
				return ec.fieldContext_Patch_author(ctx, field)
			case "authorDisplayName":
				return ec.fieldContext_Patch_authorDisplayName(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Patch_baseTaskStatuses(ctx, field)
			case "builds":
				return ec.fieldContext_Patch_builds(ctx, field)
			case "childPatchAliases":
				return ec.fieldContext_Patch_childPatchAliases(ctx, field)
			case "childPatches":
				return ec.fieldContext_Patch_childPatches(ctx, field)
			case "createTime":
				return ec.fieldContext_Patch_createTime(ctx, field)
			case "description":
				return ec.fieldContext_Patch_description(ctx, field)
			case "duration":
				return ec.fieldContext_Patch_duration(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Patch_generatedTaskCounts(ctx, field)
			case "githash":
				return ec.fieldContext_Patch_githash(ctx, field)
			case "githubPatchData":
				return ec.fieldContext_Patch_githubPatchData(ctx, field)
			case "hidden":
				return ec.fieldContext_Patch_hidden(ctx, field)
			case "moduleCodeChanges":
				return ec.fieldContext_Patch_moduleCodeChanges(ctx, field)
			case "parameters":
				return ec.fieldContext_Patch_parameters(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Patch_patchNumber(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Patch_patchTriggerAliases(ctx, field)
			case "project":
				return ec.fieldContext_Patch_project(ctx, field)
			case "projectID":
				return ec.fieldContext_Patch_projectID(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Patch_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Patch_projectMetadata(ctx, field)
			case "status":
				return ec.fieldContext_Patch_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Patch_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Patch_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Patch_taskStatuses(ctx, field)
			case "time":
				return ec.fieldContext_Patch_time(ctx, field)
			case "variants":
				return ec.fieldContext_Patch_variants(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_Patch_variantsTasks(ctx, field)
			case "versionFull":
				return ec.fieldContext_Patch_versionFull(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Patch", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_previousVersion(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_previousVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().PreviousVersion(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIVersion)
	fc.Result = res
	return ec.marshalOVersion2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_previousVersion(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "authorEmail":
				return ec.fieldContext_Version_authorEmail(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Version_generatedTaskCounts(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "ignored":
				return ec.fieldContext_Version_ignored(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			case "waterfallBuilds":
				return ec.fieldContext_Version_waterfallBuilds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_project(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_project(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Project, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_project(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_projectIdentifier(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_projectIdentifier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectIdentifier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_projectIdentifier(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_projectMetadata(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_projectMetadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().ProjectMetadata(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectRef)
	fc.Result = res
	return ec.marshalOProject2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_projectMetadata(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubDynamicTokenPermissionGroups":
				return ec.fieldContext_Project_githubDynamicTokenPermissionGroups(ctx, field)
			case "githubPermissionGroupByRequester":
				return ec.fieldContext_Project_githubPermissionGroupByRequester(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "githubPRTriggerAliases":
				return ec.fieldContext_Project_githubPRTriggerAliases(ctx, field)
			case "githubMQTriggerAliases":
				return ec.fieldContext_Project_githubMQTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "oldestAllowedMergeBase":
				return ec.fieldContext_Project_oldestAllowedMergeBase(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "repotrackerError":
				return ec.fieldContext_Project_repotrackerError(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "stepbackBisect":
				return ec.fieldContext_Project_stepbackBisect(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_repo(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_repo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_repo(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_requester(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_requester(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Requester, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_requester(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_revision(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_revision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_revision(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_startTime(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_startTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_startTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_status(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().Status(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_taskCount(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_taskCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().TaskCount(rctx, obj, fc.Args["options"].(*TaskCountOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_taskCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Version_taskCount_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Version_tasks(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_tasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().Tasks(rctx, obj, fc.Args["options"].(TaskFilterOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*VersionTasks)
	fc.Result = res
	return ec.marshalNVersionTasks2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐVersionTasks(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_tasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_VersionTasks_count(ctx, field)
			case "data":
				return ec.fieldContext_VersionTasks_data(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VersionTasks", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Version_tasks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Version_taskStatuses(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_taskStatuses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().TaskStatuses(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_taskStatuses(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_taskStatusStats(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_taskStatusStats(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().TaskStatusStats(rctx, obj, fc.Args["options"].(BuildVariantOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*task.TaskStats)
	fc.Result = res
	return ec.marshalOTaskStats2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋtaskᚐTaskStats(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_taskStatusStats(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "counts":
				return ec.fieldContext_TaskStats_counts(ctx, field)
			case "eta":
				return ec.fieldContext_TaskStats_eta(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskStats", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Version_taskStatusStats_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) _Version_upstreamProject(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_upstreamProject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().UpstreamProject(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*UpstreamProject)
	fc.Result = res
	return ec.marshalOUpstreamProject2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐUpstreamProject(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_upstreamProject(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "owner":
				return ec.fieldContext_UpstreamProject_owner(ctx, field)
			case "project":
				return ec.fieldContext_UpstreamProject_project(ctx, field)
			case "repo":
				return ec.fieldContext_UpstreamProject_repo(ctx, field)
			case "resourceID":
				return ec.fieldContext_UpstreamProject_resourceID(ctx, field)
			case "revision":
				return ec.fieldContext_UpstreamProject_revision(ctx, field)
			case "task":
				return ec.fieldContext_UpstreamProject_task(ctx, field)
			case "triggerID":
				return ec.fieldContext_UpstreamProject_triggerID(ctx, field)
			case "triggerType":
				return ec.fieldContext_UpstreamProject_triggerType(ctx, field)
			case "version":
				return ec.fieldContext_UpstreamProject_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpstreamProject", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_versionTiming(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_versionTiming(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().VersionTiming(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*VersionTiming)
	fc.Result = res
	return ec.marshalOVersionTiming2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐVersionTiming(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_versionTiming(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "makespan":
				return ec.fieldContext_VersionTiming_makespan(ctx, field)
			case "timeTaken":
				return ec.fieldContext_VersionTiming_timeTaken(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VersionTiming", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_warnings(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_warnings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().Warnings(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_warnings(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_waterfallBuilds(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_waterfallBuilds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().WaterfallBuilds(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model1.WaterfallBuild)
	fc.Result = res
	return ec.marshalOWaterfallBuild2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐWaterfallBuildᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_waterfallBuilds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_WaterfallBuild_id(ctx, field)
			case "activated":
				return ec.fieldContext_WaterfallBuild_activated(ctx, field)
			case "buildVariant":
				return ec.fieldContext_WaterfallBuild_buildVariant(ctx, field)
			case "displayName":
				return ec.fieldContext_WaterfallBuild_displayName(ctx, field)
			case "version":
				return ec.fieldContext_WaterfallBuild_version(ctx, field)
			case "tasks":
				return ec.fieldContext_WaterfallBuild_tasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WaterfallBuild", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionTasks_count(ctx context.Context, field graphql.CollectedField, obj *VersionTasks) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionTasks_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionTasks_count(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionTasks",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionTasks_data(ctx context.Context, field graphql.CollectedField, obj *VersionTasks) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionTasks_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APITask)
	fc.Result = res
	return ec.marshalNTask2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionTasks_data(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionTasks",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayStatus":
				return ec.fieldContext_Task_displayStatus(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "files":
				return ec.fieldContext_Task_files(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hasTestResults":
				return ec.fieldContext_Task_hasTestResults(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "imageId":
				return ec.fieldContext_Task_imageId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "tags":
				return ec.fieldContext_Task_tags(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "stepbackInfo":
				return ec.fieldContext_Task_stepbackInfo(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "taskOwnerTeam":
				return ec.fieldContext_Task_taskOwnerTeam(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionTiming_makespan(ctx context.Context, field graphql.CollectedField, obj *VersionTiming) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionTiming_makespan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Makespan, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIDuration)
	fc.Result = res
	return ec.marshalODuration2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionTiming_makespan(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionTiming",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionTiming_timeTaken(ctx context.Context, field graphql.CollectedField, obj *VersionTiming) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionTiming_timeTaken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimeTaken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIDuration)
	fc.Result = res
	return ec.marshalODuration2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionTiming_timeTaken(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionTiming",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_id(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_availabilityZone(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_availabilityZone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvailabilityZone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_availabilityZone(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_createdBy(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_createdBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_createdBy(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_creationTime(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_creationTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_creationTime(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_deviceName(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_deviceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeviceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_deviceName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_displayName(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_expiration(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_expiration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Expiration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_expiration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_homeVolume(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_homeVolume(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HomeVolume, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_homeVolume(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_host(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_host(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Volume().Host(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIHost)
	fc.Result = res
	return ec.marshalOHost2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_host(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "availabilityZone":
				return ec.fieldContext_Host_availabilityZone(ctx, field)
			case "ami":
				return ec.fieldContext_Host_ami(ctx, field)
			case "displayName":
				return ec.fieldContext_Host_displayName(ctx, field)
			case "distro":
				return ec.fieldContext_Host_distro(ctx, field)
			case "distroId":
				return ec.fieldContext_Host_distroId(ctx, field)
			case "elapsed":
				return ec.fieldContext_Host_elapsed(ctx, field)
			case "events":
				return ec.fieldContext_Host_events(ctx, field)
			case "eventTypes":
				return ec.fieldContext_Host_eventTypes(ctx, field)
			case "expiration":
				return ec.fieldContext_Host_expiration(ctx, field)
			case "hostUrl":
				return ec.fieldContext_Host_hostUrl(ctx, field)
			case "homeVolume":
				return ec.fieldContext_Host_homeVolume(ctx, field)
			case "homeVolumeID":
				return ec.fieldContext_Host_homeVolumeID(ctx, field)
			case "instanceType":
				return ec.fieldContext_Host_instanceType(ctx, field)
			case "instanceTags":
				return ec.fieldContext_Host_instanceTags(ctx, field)
			case "lastCommunicationTime":
				return ec.fieldContext_Host_lastCommunicationTime(ctx, field)
			case "noExpiration":
				return ec.fieldContext_Host_noExpiration(ctx, field)
			case "persistentDnsName":
				return ec.fieldContext_Host_persistentDnsName(ctx, field)
			case "provider":
				return ec.fieldContext_Host_provider(ctx, field)
			case "runningTask":
				return ec.fieldContext_Host_runningTask(ctx, field)
			case "sleepSchedule":
				return ec.fieldContext_Host_sleepSchedule(ctx, field)
			case "startedBy":
				return ec.fieldContext_Host_startedBy(ctx, field)
			case "status":
				return ec.fieldContext_Host_status(ctx, field)
			case "tag":
				return ec.fieldContext_Host_tag(ctx, field)
			case "totalIdleTime":
				return ec.fieldContext_Host_totalIdleTime(ctx, field)
			case "uptime":
				return ec.fieldContext_Host_uptime(ctx, field)
			case "user":
				return ec.fieldContext_Host_user(ctx, field)
			case "volumes":
				return ec.fieldContext_Host_volumes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_hostID(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_hostID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_hostID(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_migrating(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_migrating(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Migrating, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_migrating(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_noExpiration(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_noExpiration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NoExpiration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_noExpiration(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_size(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_size(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_type(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Waterfall_flattenedVersions(ctx context.Context, field graphql.CollectedField, obj *Waterfall) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Waterfall_flattenedVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FlattenedVersions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIVersion)
	fc.Result = res
	return ec.marshalNVersion2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVersionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Waterfall_flattenedVersions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Waterfall",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "authorEmail":
				return ec.fieldContext_Version_authorEmail(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Version_generatedTaskCounts(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "ignored":
				return ec.fieldContext_Version_ignored(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			case "waterfallBuilds":
				return ec.fieldContext_Version_waterfallBuilds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Waterfall_pagination(ctx context.Context, field graphql.CollectedField, obj *Waterfall) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Waterfall_pagination(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pagination, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*WaterfallPagination)
	fc.Result = res
	return ec.marshalNWaterfallPagination2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐWaterfallPagination(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Waterfall_pagination(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Waterfall",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "activeVersionIds":
				return ec.fieldContext_WaterfallPagination_activeVersionIds(ctx, field)
			case "hasNextPage":
				return ec.fieldContext_WaterfallPagination_hasNextPage(ctx, field)
			case "hasPrevPage":
				return ec.fieldContext_WaterfallPagination_hasPrevPage(ctx, field)
			case "mostRecentVersionOrder":
				return ec.fieldContext_WaterfallPagination_mostRecentVersionOrder(ctx, field)
			case "nextPageOrder":
				return ec.fieldContext_WaterfallPagination_nextPageOrder(ctx, field)
			case "prevPageOrder":
				return ec.fieldContext_WaterfallPagination_prevPageOrder(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WaterfallPagination", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallBuild_id(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallBuild) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallBuild_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallBuild_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallBuild_activated(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallBuild) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallBuild_activated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Activated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallBuild_activated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallBuild_buildVariant(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallBuild) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallBuild_buildVariant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildVariant, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallBuild_buildVariant(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallBuild_displayName(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallBuild) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallBuild_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallBuild_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallBuild_version(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallBuild) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallBuild_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallBuild_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallBuild_tasks(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallBuild) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallBuild_tasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model1.WaterfallTask)
	fc.Result = res
	return ec.marshalNWaterfallTask2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐWaterfallTaskᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallBuild_tasks(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_WaterfallTask_id(ctx, field)
			case "displayName":
				return ec.fieldContext_WaterfallTask_displayName(ctx, field)
			case "displayStatusCache":
				return ec.fieldContext_WaterfallTask_displayStatusCache(ctx, field)
			case "execution":
				return ec.fieldContext_WaterfallTask_execution(ctx, field)
			case "status":
				return ec.fieldContext_WaterfallTask_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WaterfallTask", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallBuildVariant_id(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallBuildVariant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallBuildVariant_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallBuildVariant_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallBuildVariant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallBuildVariant_builds(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallBuildVariant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallBuildVariant_builds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Builds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model1.WaterfallBuild)
	fc.Result = res
	return ec.marshalNWaterfallBuild2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐWaterfallBuildᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallBuildVariant_builds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallBuildVariant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_WaterfallBuild_id(ctx, field)
			case "activated":
				return ec.fieldContext_WaterfallBuild_activated(ctx, field)
			case "buildVariant":
				return ec.fieldContext_WaterfallBuild_buildVariant(ctx, field)
			case "displayName":
				return ec.fieldContext_WaterfallBuild_displayName(ctx, field)
			case "version":
				return ec.fieldContext_WaterfallBuild_version(ctx, field)
			case "tasks":
				return ec.fieldContext_WaterfallBuild_tasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WaterfallBuild", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallBuildVariant_displayName(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallBuildVariant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallBuildVariant_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallBuildVariant_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallBuildVariant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallBuildVariant_version(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallBuildVariant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallBuildVariant_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallBuildVariant_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallBuildVariant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallPagination_activeVersionIds(ctx context.Context, field graphql.CollectedField, obj *WaterfallPagination) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallPagination_activeVersionIds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ActiveVersionIds, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallPagination_activeVersionIds(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallPagination",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallPagination_hasNextPage(ctx context.Context, field graphql.CollectedField, obj *WaterfallPagination) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallPagination_hasNextPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasNextPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallPagination_hasNextPage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallPagination",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallPagination_hasPrevPage(ctx context.Context, field graphql.CollectedField, obj *WaterfallPagination) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallPagination_hasPrevPage(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasPrevPage, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallPagination_hasPrevPage(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallPagination",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallPagination_mostRecentVersionOrder(ctx context.Context, field graphql.CollectedField, obj *WaterfallPagination) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallPagination_mostRecentVersionOrder(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MostRecentVersionOrder, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallPagination_mostRecentVersionOrder(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallPagination",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallPagination_nextPageOrder(ctx context.Context, field graphql.CollectedField, obj *WaterfallPagination) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallPagination_nextPageOrder(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextPageOrder, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallPagination_nextPageOrder(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallPagination",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallPagination_prevPageOrder(ctx context.Context, field graphql.CollectedField, obj *WaterfallPagination) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallPagination_prevPageOrder(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrevPageOrder, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallPagination_prevPageOrder(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallPagination",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallTask_id(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallTask_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallTask_id(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallTask_displayName(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallTask_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallTask_displayName(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallTask_displayStatusCache(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallTask_displayStatusCache(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayStatusCache, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallTask_displayStatusCache(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallTask_execution(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallTask_execution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Execution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallTask_execution(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallTask_status(ctx context.Context, field graphql.CollectedField, obj *model1.WaterfallTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallTask_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallTask_status(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallVersion_inactiveVersions(ctx context.Context, field graphql.CollectedField, obj *WaterfallVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallVersion_inactiveVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InactiveVersions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.APIVersion)
	fc.Result = res
	return ec.marshalOVersion2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVersionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallVersion_inactiveVersions(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "authorEmail":
				return ec.fieldContext_Version_authorEmail(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Version_generatedTaskCounts(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "ignored":
				return ec.fieldContext_Version_ignored(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			case "waterfallBuilds":
				return ec.fieldContext_Version_waterfallBuilds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WaterfallVersion_version(ctx context.Context, field graphql.CollectedField, obj *WaterfallVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WaterfallVersion_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIVersion)
	fc.Result = res
	return ec.marshalOVersion2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WaterfallVersion_version(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WaterfallVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "authorEmail":
				return ec.fieldContext_Version_authorEmail(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "generatedTaskCounts":
				return ec.fieldContext_Version_generatedTaskCounts(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "ignored":
				return ec.fieldContext_Version_ignored(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			case "waterfallBuilds":
				return ec.fieldContext_Version_waterfallBuilds(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_endpoint(ctx context.Context, field graphql.CollectedField, obj *model.APIWebHook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_endpoint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Endpoint, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_endpoint(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_secret(ctx context.Context, field graphql.CollectedField, obj *model.APIWebHook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_secret(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Secret, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_secret(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookHeader_key(ctx context.Context, field graphql.CollectedField, obj *model.APIWebhookHeader) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WebhookHeader_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WebhookHeader_key(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookHeader",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookHeader_value(ctx context.Context, field graphql.CollectedField, obj *model.APIWebhookHeader) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WebhookHeader_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WebhookHeader_value(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookHeader",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookSubscriber_headers(ctx context.Context, field graphql.CollectedField, obj *model.APIWebhookSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WebhookSubscriber_headers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Headers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APIWebhookHeader)
	fc.Result = res
	return ec.marshalNWebhookHeader2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWebhookHeaderᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WebhookSubscriber_headers(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_WebhookHeader_key(ctx, field)
			case "value":
				return ec.fieldContext_WebhookHeader_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WebhookHeader", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookSubscriber_secret(ctx context.Context, field graphql.CollectedField, obj *model.APIWebhookSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WebhookSubscriber_secret(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Secret, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WebhookSubscriber_secret(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookSubscriber_url(ctx context.Context, field graphql.CollectedField, obj *model.APIWebhookSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WebhookSubscriber_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WebhookSubscriber_url(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookSubscriber_retries(ctx context.Context, field graphql.CollectedField, obj *model.APIWebhookSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WebhookSubscriber_retries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Retries, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WebhookSubscriber_retries(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookSubscriber_minDelayMs(ctx context.Context, field graphql.CollectedField, obj *model.APIWebhookSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WebhookSubscriber_minDelayMs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MinDelayMS, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WebhookSubscriber_minDelayMs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookSubscriber_timeoutMs(ctx context.Context, field graphql.CollectedField, obj *model.APIWebhookSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WebhookSubscriber_timeoutMs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimeoutMS, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WebhookSubscriber_timeoutMs(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkstationConfig_gitClone(ctx context.Context, field graphql.CollectedField, obj *model.APIWorkstationConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkstationConfig_gitClone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GitClone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkstationConfig_gitClone(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkstationConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkstationConfig_setupCommands(ctx context.Context, field graphql.CollectedField, obj *model.APIWorkstationConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkstationConfig_setupCommands(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SetupCommands, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIWorkstationSetupCommand)
	fc.Result = res
	return ec.marshalOWorkstationSetupCommand2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWorkstationSetupCommandᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkstationConfig_setupCommands(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkstationConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "command":
				return ec.fieldContext_WorkstationSetupCommand_command(ctx, field)
			case "directory":
				return ec.fieldContext_WorkstationSetupCommand_directory(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkstationSetupCommand", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkstationSetupCommand_command(ctx context.Context, field graphql.CollectedField, obj *model.APIWorkstationSetupCommand) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkstationSetupCommand_command(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Command, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkstationSetupCommand_command(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkstationSetupCommand",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkstationSetupCommand_directory(ctx context.Context, field graphql.CollectedField, obj *model.APIWorkstationSetupCommand) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkstationSetupCommand_directory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkstationSetupCommand_directory(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkstationSetupCommand",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Directive_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Field_args_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_isDeprecated(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_deprecationReason(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return fc, err
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___InputValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___InputValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "isOneOf":
				return ec.fieldContext___Type_isOneOf(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_isOneOf(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_isOneOf(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (any, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsOneOf(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_isOneOf(_ context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputAPIConfigInput(ctx context.Context, obj any) (model.APIapiConfig, error) {
	var it model.APIapiConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"httpListenAddr", "url", "corpUrl"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "httpListenAddr":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("httpListenAddr"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.HttpListenAddr = data
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		case "corpUrl":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("corpUrl"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CorpURL = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAddFavoriteProjectInput(ctx context.Context, obj any) (AddFavoriteProjectInput, error) {
	var it AddFavoriteProjectInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"projectIdentifier"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "projectIdentifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdentifier"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProjectIdentifier = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAdminEventsInput(ctx context.Context, obj any) (AdminEventsInput, error) {
	var it AdminEventsInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["limit"]; !present {
		asMap["limit"] = 10
	}

	fieldsInOrder := [...]string{"before", "limit"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "before":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Before = data
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAdminSettingsInput(ctx context.Context, obj any) (model.APIAdminSettings, error) {
	var it model.APIAdminSettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"amboy", "amboyDB", "authConfig", "banner", "bannerTheme", "cedar", "fws", "jira", "slack", "splunk", "runtimeEnvironments", "testSelection", "serviceFlags", "notify", "taskLimits", "hostInit", "podLifecycle", "scheduler", "repotracker", "api", "ui", "disabledGQLQueries", "loggerConfig", "triggers"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "amboy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amboy"))
			data, err := ec.unmarshalOAmboyConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAmboyConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.Amboy = data
		case "amboyDB":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("amboyDB"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOAmboyDBConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAmboyDBConfig(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *model.APIAmboyDBConfig
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*model.APIAmboyDBConfig); ok {
				it.AmboyDB = data
			} else if tmp == nil {
				it.AmboyDB = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/evergreen-ci/evergreen/rest/model.APIAmboyDBConfig`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "authConfig":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authConfig"))
			data, err := ec.unmarshalOAuthConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAuthConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.AuthConfig = data
		case "banner":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("banner"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Banner = data
		case "bannerTheme":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bannerTheme"))
			data, err := ec.unmarshalOBannerTheme2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚐBannerTheme(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.AdminSettingsInput().BannerTheme(ctx, &it, data); err != nil {
				return it, err
			}
		case "cedar":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cedar"))
			data, err := ec.unmarshalOCedarConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPICedarConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.Cedar = data
		case "fws":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fws"))
			data, err := ec.unmarshalOFWSConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIFWSConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.FWS = data
		case "jira":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jira"))
			data, err := ec.unmarshalOJiraConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIJiraConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.Jira = data
		case "slack":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slack"))
			data, err := ec.unmarshalOSlackConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISlackConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.Slack = data
		case "splunk":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("splunk"))
			data, err := ec.unmarshalOSplunkConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISplunkConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.Splunk = data
		case "runtimeEnvironments":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("runtimeEnvironments"))
			data, err := ec.unmarshalORuntimeEnvironmentConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIRuntimeEnvironmentsConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.RuntimeEnvironments = data
		case "testSelection":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("testSelection"))
			data, err := ec.unmarshalOTestSelectionConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITestSelectionConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.TestSelection = data
		case "serviceFlags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("serviceFlags"))
			data, err := ec.unmarshalOServiceFlagsInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIServiceFlags(ctx, v)
			if err != nil {
				return it, err
			}
			it.ServiceFlags = data
		case "notify":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("notify"))
			data, err := ec.unmarshalONotifyConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPINotifyConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.Notify = data
		case "taskLimits":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskLimits"))
			data, err := ec.unmarshalOTaskLimitsConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskLimitsConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskLimits = data
		case "hostInit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostInit"))
			data, err := ec.unmarshalOHostInitConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHostInitConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.HostInit = data
		case "podLifecycle":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("podLifecycle"))
			data, err := ec.unmarshalOPodLifecycleConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPodLifecycleConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.PodLifecycle = data
		case "scheduler":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scheduler"))
			data, err := ec.unmarshalOSchedulerConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISchedulerConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.Scheduler = data
		case "repotracker":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repotracker"))
			data, err := ec.unmarshalORepotrackerConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIRepoTrackerConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.RepoTracker = data
		case "api":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("api"))
			data, err := ec.unmarshalOAPIConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIapiConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.Api = data
		case "ui":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ui"))
			data, err := ec.unmarshalOUIConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIUIConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.Ui = data
		case "disabledGQLQueries":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("disabledGQLQueries"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisabledGQLQueries = data
		case "loggerConfig":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("loggerConfig"))
			data, err := ec.unmarshalOLoggerConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPILoggerConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.LoggerConfig = data
		case "triggers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("triggers"))
			data, err := ec.unmarshalOTriggerConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITriggerConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.Triggers = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAmboyConfigInput(ctx context.Context, obj any) (model.APIAmboyConfig, error) {
	var it model.APIAmboyConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "singleName", "poolSizeLocal", "poolSizeRemote", "localStorage", "groupDefaultWorkers", "groupBackgroundCreateFrequencyMinutes", "groupPruneFrequencyMinutes", "groupTTLMinutes", "lockTimeoutMinutes", "sampleSize", "retry", "namedQueues"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "singleName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("singleName"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SingleName = data
		case "poolSizeLocal":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("poolSizeLocal"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.PoolSizeLocal = data
		case "poolSizeRemote":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("poolSizeRemote"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.PoolSizeRemote = data
		case "localStorage":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("localStorage"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LocalStorage = data
		case "groupDefaultWorkers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("groupDefaultWorkers"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.GroupDefaultWorkers = data
		case "groupBackgroundCreateFrequencyMinutes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("groupBackgroundCreateFrequencyMinutes"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.GroupBackgroundCreateFrequencyMinutes = data
		case "groupPruneFrequencyMinutes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("groupPruneFrequencyMinutes"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.GroupPruneFrequencyMinutes = data
		case "groupTTLMinutes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("groupTTLMinutes"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.GroupTTLMinutes = data
		case "lockTimeoutMinutes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lockTimeoutMinutes"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LockTimeoutMinutes = data
		case "sampleSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sampleSize"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.SampleSize = data
		case "retry":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("retry"))
			data, err := ec.unmarshalNAmboyRetryConfigInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAmboyRetryConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.Retry = data
		case "namedQueues":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("namedQueues"))
			data, err := ec.unmarshalNAmboyNamedQueueConfigInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAmboyNamedQueueConfigᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.NamedQueues = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAmboyDBConfigInput(ctx context.Context, obj any) (model.APIAmboyDBConfig, error) {
	var it model.APIAmboyDBConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"url", "database"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		case "database":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("database"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Database = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAmboyNamedQueueConfigInput(ctx context.Context, obj any) (model.APIAmboyNamedQueueConfig, error) {
	var it model.APIAmboyNamedQueueConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "regexp", "numWorkers", "sampleSize", "lockTimeoutSeconds"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "regexp":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("regexp"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Regexp = data
		case "numWorkers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("numWorkers"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.NumWorkers = data
		case "sampleSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sampleSize"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.SampleSize = data
		case "lockTimeoutSeconds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lockTimeoutSeconds"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LockTimeoutSeconds = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAmboyRetryConfigInput(ctx context.Context, obj any) (model.APIAmboyRetryConfig, error) {
	var it model.APIAmboyRetryConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"numWorkers", "maxCapacity", "maxRetryAttempts", "maxRetryTimeSeconds", "retryBackoffSeconds", "staleRetryingMonitorIntervalSeconds"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "numWorkers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("numWorkers"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.NumWorkers = data
		case "maxCapacity":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxCapacity"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxCapacity = data
		case "maxRetryAttempts":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxRetryAttempts"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxRetryAttempts = data
		case "maxRetryTimeSeconds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxRetryTimeSeconds"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxRetryTimeSeconds = data
		case "retryBackoffSeconds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("retryBackoffSeconds"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.RetryBackoffSeconds = data
		case "staleRetryingMonitorIntervalSeconds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("staleRetryingMonitorIntervalSeconds"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.StaleRetryingMonitorIntervalSeconds = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAuthConfigInput(ctx context.Context, obj any) (model.APIAuthConfig, error) {
	var it model.APIAuthConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"okta", "naive", "github", "multi", "kanopy", "preferredType", "backgroundReauthMinutes", "allowServiceUsers"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "okta":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("okta"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOOktaConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIOktaConfig(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *model.APIOktaConfig
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*model.APIOktaConfig); ok {
				it.Okta = data
			} else if tmp == nil {
				it.Okta = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/evergreen-ci/evergreen/rest/model.APIOktaConfig`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "naive":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("naive"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalONaiveAuthConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPINaiveAuthConfig(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *model.APINaiveAuthConfig
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*model.APINaiveAuthConfig); ok {
				it.Naive = data
			} else if tmp == nil {
				it.Naive = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/evergreen-ci/evergreen/rest/model.APINaiveAuthConfig`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "github":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("github"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOGitHubAuthConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGithubAuthConfig(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *model.APIGithubAuthConfig
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*model.APIGithubAuthConfig); ok {
				it.Github = data
			} else if tmp == nil {
				it.Github = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/evergreen-ci/evergreen/rest/model.APIGithubAuthConfig`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "multi":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("multi"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOMultiAuthConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIMultiAuthConfig(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *model.APIMultiAuthConfig
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*model.APIMultiAuthConfig); ok {
				it.Multi = data
			} else if tmp == nil {
				it.Multi = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/evergreen-ci/evergreen/rest/model.APIMultiAuthConfig`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "kanopy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("kanopy"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOKanopyAuthConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIKanopyAuthConfig(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *model.APIKanopyAuthConfig
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*model.APIKanopyAuthConfig); ok {
				it.Kanopy = data
			} else if tmp == nil {
				it.Kanopy = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/evergreen-ci/evergreen/rest/model.APIKanopyAuthConfig`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "preferredType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("preferredType"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOPreferredAuthType2ᚖstring(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.PreferredType = data
			} else if tmp == nil {
				it.PreferredType = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "backgroundReauthMinutes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backgroundReauthMinutes"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.BackgroundReauthMinutes = data
		case "allowServiceUsers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("allowServiceUsers"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AllowServiceUsers = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputAuthUserInput(ctx context.Context, obj any) (model.APIAuthUser, error) {
	var it model.APIAuthUser
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"username", "displayName", "password", "email"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "username":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Username = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "password":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("password"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Password = data
		case "email":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Email = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBetaFeaturesInput(ctx context.Context, obj any) (model.APIBetaFeatures, error) {
	var it model.APIBetaFeatures
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"spruceWaterfallEnabled"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "spruceWaterfallEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spruceWaterfallEnabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpruceWaterfallEnabled = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBootstrapSettingsInput(ctx context.Context, obj any) (model.APIBootstrapSettings, error) {
	var it model.APIBootstrapSettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"clientDir", "communication", "env", "jasperBinaryDir", "jasperCredentialsPath", "method", "preconditionScripts", "resourceLimits", "rootDir", "serviceUser", "shellPath"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "clientDir":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientDir"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientDir = data
		case "communication":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("communication"))
			data, err := ec.unmarshalNCommunicationMethod2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Communication = data
		case "env":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("env"))
			data, err := ec.unmarshalNEnvVarInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIEnvVarᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Env = data
		case "jasperBinaryDir":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jasperBinaryDir"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.JasperBinaryDir = data
		case "jasperCredentialsPath":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jasperCredentialsPath"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.JasperCredentialsPath = data
		case "method":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("method"))
			data, err := ec.unmarshalNBootstrapMethod2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Method = data
		case "preconditionScripts":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("preconditionScripts"))
			data, err := ec.unmarshalNPreconditionScriptInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPreconditionScriptᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.PreconditionScripts = data
		case "resourceLimits":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceLimits"))
			data, err := ec.unmarshalNResourceLimitsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIResourceLimits(ctx, v)
			if err != nil {
				return it, err
			}
			it.ResourceLimits = data
		case "rootDir":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rootDir"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.RootDir = data
		case "serviceUser":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("serviceUser"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ServiceUser = data
		case "shellPath":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("shellPath"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShellPath = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBuildBaronSettingsInput(ctx context.Context, obj any) (model.APIBuildBaronSettings, error) {
	var it model.APIBuildBaronSettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"bfSuggestionFeaturesURL", "bfSuggestionPassword", "bfSuggestionServer", "bfSuggestionTimeoutSecs", "bfSuggestionUsername", "ticketCreateProject", "ticketSearchProjects", "ticketCreateIssueType"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "bfSuggestionFeaturesURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bfSuggestionFeaturesURL"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.BFSuggestionFeaturesURL = data
		case "bfSuggestionPassword":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bfSuggestionPassword"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.BFSuggestionPassword = data
		case "bfSuggestionServer":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bfSuggestionServer"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.BFSuggestionServer = data
		case "bfSuggestionTimeoutSecs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bfSuggestionTimeoutSecs"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.BFSuggestionTimeoutSecs = data
		case "bfSuggestionUsername":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bfSuggestionUsername"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.BFSuggestionUsername = data
		case "ticketCreateProject":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ticketCreateProject"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.TicketCreateProject = data
		case "ticketSearchProjects":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ticketSearchProjects"))
			data, err := ec.unmarshalOString2ᚕᚖstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.TicketSearchProjects = data
		case "ticketCreateIssueType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ticketCreateIssueType"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.TicketCreateIssueType = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBuildVariantOptions(ctx context.Context, obj any) (BuildVariantOptions, error) {
	var it BuildVariantOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"includeBaseTasks", "includeNeverActivatedTasks", "statuses", "tasks", "variants"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "includeBaseTasks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeBaseTasks"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IncludeBaseTasks = data
		case "includeNeverActivatedTasks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeNeverActivatedTasks"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IncludeNeverActivatedTasks = data
		case "statuses":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statuses"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Statuses = data
		case "tasks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tasks"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tasks = data
		case "variants":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("variants"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Variants = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCedarConfigInput(ctx context.Context, obj any) (model.APICedarConfig, error) {
	var it model.APICedarConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"dbUrl", "dbName"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "dbUrl":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dbUrl"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2ᚖstring(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.DBURL = data
			} else if tmp == nil {
				it.DBURL = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "dbName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dbName"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DBName = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCommitQueueParamsInput(ctx context.Context, obj any) (model.APICommitQueueParams, error) {
	var it model.APICommitQueueParams
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"enabled", "mergeMethod", "message"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "enabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("enabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Enabled = data
		case "mergeMethod":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mergeMethod"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.MergeMethod = data
		case "message":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("message"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Message = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputContainerResourcesInput(ctx context.Context, obj any) (model.APIContainerResources, error) {
	var it model.APIContainerResources
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "cpu", "memoryMb"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "cpu":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cpu"))
			data, err := ec.unmarshalNInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.CPU = data
		case "memoryMb":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("memoryMb"))
			data, err := ec.unmarshalNInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MemoryMB = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCopyDistroInput(ctx context.Context, obj any) (model.CopyDistroOpts, error) {
	var it model.CopyDistroOpts
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"newDistroId", "distroIdToCopy"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "newDistroId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("newDistroId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NewDistroId = data
		case "distroIdToCopy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("distroIdToCopy"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DistroIdToCopy = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCopyProjectInput(ctx context.Context, obj any) (model.CopyProjectOpts, error) {
	var it model.CopyProjectOpts
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"newProjectId", "newProjectIdentifier", "projectIdToCopy"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "newProjectId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("newProjectId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NewProjectId = data
		case "newProjectIdentifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("newProjectIdentifier"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NewProjectIdentifier = data
		case "projectIdToCopy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdToCopy"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProjectIdToCopy = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateDistroInput(ctx context.Context, obj any) (CreateDistroInput, error) {
	var it CreateDistroInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"newDistroId", "singleTaskDistro"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "newDistroId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("newDistroId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NewDistroID = data
		case "singleTaskDistro":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("singleTaskDistro"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SingleTaskDistro = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateProjectInput(ctx context.Context, obj any) (model.APIProjectRef, error) {
	var it model.APIProjectRef
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "identifier", "owner", "repo", "repoRefId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Id = data
		case "identifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("identifier"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Identifier = data
		case "owner":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("owner"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Owner = data
		case "repo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repo"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Repo = data
		case "repoRefId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repoRefId"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.RepoRefId = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCursorParams(ctx context.Context, obj any) (CursorParams, error) {
	var it CursorParams
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"cursorId", "direction", "includeCursor"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "cursorId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cursorId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.CursorID = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNTaskHistoryDirection2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskHistoryDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "includeCursor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeCursor"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IncludeCursor = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDeactivateStepbackTaskInput(ctx context.Context, obj any) (DeactivateStepbackTaskInput, error) {
	var it DeactivateStepbackTaskInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"projectId", "buildVariantName", "taskName"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "projectId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				permission, err := ec.unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx, "SETTINGS")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				access, err := ec.unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx, "EDIT")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireProjectAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireProjectAccess is not implemented")
				}
				return ec.directives.RequireProjectAccess(ctx, obj, directive0, permission, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.ProjectID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "buildVariantName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildVariantName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BuildVariantName = data
		case "taskName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskName = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDefaultSectionToRepoInput(ctx context.Context, obj any) (DefaultSectionToRepoInput, error) {
	var it DefaultSectionToRepoInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"projectId", "section"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "projectId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				permission, err := ec.unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx, "SETTINGS")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				access, err := ec.unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx, "EDIT")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireProjectAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireProjectAccess is not implemented")
				}
				return ec.directives.RequireProjectAccess(ctx, obj, directive0, permission, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.ProjectID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "section":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("section"))
			data, err := ec.unmarshalNProjectSettingsSection2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectSettingsSection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Section = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDeleteDistroInput(ctx context.Context, obj any) (DeleteDistroInput, error) {
	var it DeleteDistroInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"distroId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "distroId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("distroId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				access, err := ec.unmarshalNDistroSettingsAccess2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroSettingsAccess(ctx, "ADMIN")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireDistroAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireDistroAccess is not implemented")
				}
				return ec.directives.RequireDistroAccess(ctx, obj, directive0, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.DistroID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDeleteGithubAppCredentialsInput(ctx context.Context, obj any) (DeleteGithubAppCredentialsInput, error) {
	var it DeleteGithubAppCredentialsInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"projectId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "projectId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				permission, err := ec.unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx, "SETTINGS")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				access, err := ec.unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx, "EDIT")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireProjectAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireProjectAccess is not implemented")
				}
				return ec.directives.RequireProjectAccess(ctx, obj, directive0, permission, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.ProjectID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDispatcherSettingsInput(ctx context.Context, obj any) (model.APIDispatcherSettings, error) {
	var it model.APIDispatcherSettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"version"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "version":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalNDispatcherVersion2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Version = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDisplayTask(ctx context.Context, obj any) (DisplayTask, error) {
	var it DisplayTask
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ExecTasks", "Name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ExecTasks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ExecTasks"))
			data, err := ec.unmarshalNString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExecTasks = data
		case "Name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDistroEventsInput(ctx context.Context, obj any) (DistroEventsInput, error) {
	var it DistroEventsInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"before", "distroId", "limit"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "before":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Before = data
		case "distroId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("distroId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				access, err := ec.unmarshalNDistroSettingsAccess2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroSettingsAccess(ctx, "VIEW")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireDistroAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireDistroAccess is not implemented")
				}
				return ec.directives.RequireDistroAccess(ctx, obj, directive0, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.DistroID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDistroInput(ctx context.Context, obj any) (model.APIDistro, error) {
	var it model.APIDistro
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"adminOnly", "aliases", "arch", "authorizedKeysFile", "bootstrapSettings", "containerPool", "disabled", "disableShallowClone", "dispatcherSettings", "execUser", "expansions", "finderSettings", "homeVolumeSettings", "hostAllocatorSettings", "iceCreamSettings", "imageId", "isCluster", "isVirtualWorkStation", "mountpoints", "name", "note", "plannerSettings", "provider", "providerAccount", "providerSettingsList", "setup", "setupAsSudo", "singleTaskDistro", "sshOptions", "user", "userSpawnAllowed", "validProjects", "warningNote", "workDir"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "adminOnly":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("adminOnly"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AdminOnly = data
		case "aliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("aliases"))
			data, err := ec.unmarshalNString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Aliases = data
		case "arch":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("arch"))
			data, err := ec.unmarshalNArch2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Arch = data
		case "authorizedKeysFile":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizedKeysFile"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.AuthorizedKeysFile = data
		case "bootstrapSettings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bootstrapSettings"))
			data, err := ec.unmarshalNBootstrapSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIBootstrapSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.BootstrapSettings = data
		case "containerPool":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("containerPool"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ContainerPool = data
		case "disabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("disabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Disabled = data
		case "disableShallowClone":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("disableShallowClone"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisableShallowClone = data
		case "dispatcherSettings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dispatcherSettings"))
			data, err := ec.unmarshalNDispatcherSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDispatcherSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.DispatcherSettings = data
		case "execUser":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("execUser"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExecUser = data
		case "expansions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expansions"))
			data, err := ec.unmarshalNExpansionInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIExpansionᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Expansions = data
		case "finderSettings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("finderSettings"))
			data, err := ec.unmarshalNFinderSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIFinderSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.FinderSettings = data
		case "homeVolumeSettings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeVolumeSettings"))
			data, err := ec.unmarshalNHomeVolumeSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHomeVolumeSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.HomeVolumeSettings = data
		case "hostAllocatorSettings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostAllocatorSettings"))
			data, err := ec.unmarshalNHostAllocatorSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHostAllocatorSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.HostAllocatorSettings = data
		case "iceCreamSettings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iceCreamSettings"))
			data, err := ec.unmarshalNIceCreamSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIIceCreamSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.IcecreamSettings = data
		case "imageId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("imageId"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ImageID = data
		case "isCluster":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isCluster"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsCluster = data
		case "isVirtualWorkStation":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isVirtualWorkStation"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsVirtualWorkstation = data
		case "mountpoints":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mountpoints"))
			data, err := ec.unmarshalNString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Mountpoints = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2ᚖstring(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				access, err := ec.unmarshalNDistroSettingsAccess2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroSettingsAccess(ctx, "EDIT")
				if err != nil {
					var zeroVal *string
					return zeroVal, err
				}
				if ec.directives.RequireDistroAccess == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive requireDistroAccess is not implemented")
				}
				return ec.directives.RequireDistroAccess(ctx, obj, directive0, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Name = data
			} else if tmp == nil {
				it.Name = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "note":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("note"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Note = data
		case "plannerSettings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("plannerSettings"))
			data, err := ec.unmarshalNPlannerSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPlannerSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.PlannerSettings = data
		case "provider":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("provider"))
			data, err := ec.unmarshalNProvider2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Provider = data
		case "providerAccount":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("providerAccount"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProviderAccount = data
		case "providerSettingsList":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("providerSettingsList"))
			data, err := ec.unmarshalNMap2ᚕmapᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.DistroInput().ProviderSettingsList(ctx, &it, data); err != nil {
				return it, err
			}
		case "setup":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("setup"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Setup = data
		case "setupAsSudo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("setupAsSudo"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SetupAsSudo = data
		case "singleTaskDistro":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("singleTaskDistro"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SingleTaskDistro = data
		case "sshOptions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sshOptions"))
			data, err := ec.unmarshalNString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSHOptions = data
		case "user":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("user"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.User = data
		case "userSpawnAllowed":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userSpawnAllowed"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserSpawnAllowed = data
		case "validProjects":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("validProjects"))
			data, err := ec.unmarshalNString2ᚕᚖstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ValidProjects = data
		case "warningNote":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("warningNote"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.WarningNote = data
		case "workDir":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("workDir"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.WorkDir = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDistroPermissionsOptions(ctx context.Context, obj any) (DistroPermissionsOptions, error) {
	var it DistroPermissionsOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"distroId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "distroId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("distroId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DistroID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEditSpawnHostInput(ctx context.Context, obj any) (EditSpawnHostInput, error) {
	var it EditSpawnHostInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"addedInstanceTags", "deletedInstanceTags", "displayName", "expiration", "hostId", "instanceType", "noExpiration", "publicKey", "savePublicKey", "servicePassword", "sleepSchedule", "volume"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "addedInstanceTags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addedInstanceTags"))
			data, err := ec.unmarshalOInstanceTagInput2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋhostᚐTagᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddedInstanceTags = data
		case "deletedInstanceTags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedInstanceTags"))
			data, err := ec.unmarshalOInstanceTagInput2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋhostᚐTagᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedInstanceTags = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "expiration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiration"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Expiration = data
		case "hostId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				access, err := ec.unmarshalNHostAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐHostAccessLevel(ctx, "EDIT")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireHostAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireHostAccess is not implemented")
				}
				return ec.directives.RequireHostAccess(ctx, obj, directive0, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.HostID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "instanceType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("instanceType"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.InstanceType = data
		case "noExpiration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("noExpiration"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.NoExpiration = data
		case "publicKey":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publicKey"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOPublicKeyInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPublicKeyInput(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *PublicKeyInput
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*PublicKeyInput); ok {
				it.PublicKey = data
			} else if tmp == nil {
				it.PublicKey = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *github.com/evergreen-ci/evergreen/graphql.PublicKeyInput`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "savePublicKey":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("savePublicKey"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SavePublicKey = data
		case "servicePassword":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("servicePassword"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2ᚖstring(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.ServicePassword = data
			} else if tmp == nil {
				it.ServicePassword = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "sleepSchedule":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sleepSchedule"))
			data, err := ec.unmarshalOSleepScheduleInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋhostᚐSleepScheduleInfo(ctx, v)
			if err != nil {
				return it, err
			}
			it.SleepSchedule = data
		case "volume":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("volume"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Volume = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEnvVarInput(ctx context.Context, obj any) (model.APIEnvVar, error) {
	var it model.APIEnvVar
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputExpansionInput(ctx context.Context, obj any) (model.APIExpansion, error) {
	var it model.APIExpansion
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputExternalLinkInput(ctx context.Context, obj any) (model.APIExternalLink, error) {
	var it model.APIExternalLink
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"displayName", "requesters", "urlTemplate"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "requesters":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requesters"))
			data, err := ec.unmarshalNString2ᚕᚖstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Requesters = data
		case "urlTemplate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("urlTemplate"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.URLTemplate = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFWSConfigInput(ctx context.Context, obj any) (model.APIFWSConfig, error) {
	var it model.APIFWSConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"url"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFinderSettingsInput(ctx context.Context, obj any) (model.APIFinderSettings, error) {
	var it model.APIFinderSettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"version"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "version":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalNFinderVersion2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Version = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGitHubAuthConfigInput(ctx context.Context, obj any) (model.APIGithubAuthConfig, error) {
	var it model.APIGithubAuthConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"appId", "clientId", "clientSecret", "defaultOwner", "defaultRepo", "organization", "users"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "appId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("appId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOInt2int64(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal int64
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(int64); ok {
				it.AppId = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be int64`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "clientId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2ᚖstring(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.ClientId = data
			} else if tmp == nil {
				it.ClientId = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "clientSecret":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientSecret"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2ᚖstring(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.ClientSecret = data
			} else if tmp == nil {
				it.ClientSecret = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "defaultOwner":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("defaultOwner"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2ᚖstring(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.DefaultOwner = data
			} else if tmp == nil {
				it.DefaultOwner = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "defaultRepo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("defaultRepo"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2ᚖstring(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.DefaultRepo = data
			} else if tmp == nil {
				it.DefaultRepo = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "organization":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("organization"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2ᚖstring(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Organization = data
			} else if tmp == nil {
				it.Organization = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "users":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("users"))
			data, err := ec.unmarshalNString2ᚕᚖstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Users = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGitHubDynamicTokenPermissionGroupInput(ctx context.Context, obj any) (model.APIGitHubDynamicTokenPermissionGroup, error) {
	var it model.APIGitHubDynamicTokenPermissionGroup
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "permissions"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "permissions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("permissions"))
			data, err := ec.unmarshalNStringMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Permissions = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGithubAppAuthInput(ctx context.Context, obj any) (model.APIGithubAppAuth, error) {
	var it model.APIGithubAppAuth
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"appId", "privateKey"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "appId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("appId"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AppID = data
		case "privateKey":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("privateKey"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.PrivateKey = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGithubUserInput(ctx context.Context, obj any) (model.APIGithubUser, error) {
	var it model.APIGithubUser
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"lastKnownAs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "lastKnownAs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastKnownAs"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastKnownAs = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputHomeVolumeSettingsInput(ctx context.Context, obj any) (model.APIHomeVolumeSettings, error) {
	var it model.APIHomeVolumeSettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"formatCommand"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "formatCommand":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("formatCommand"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.FormatCommand = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputHostAllocatorSettingsInput(ctx context.Context, obj any) (model.APIHostAllocatorSettings, error) {
	var it model.APIHostAllocatorSettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"acceptableHostIdleTime", "autoTuneMaximumHosts", "feedbackRule", "futureHostFraction", "hostsOverallocatedRule", "maximumHosts", "minimumHosts", "roundingRule", "version"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "acceptableHostIdleTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("acceptableHostIdleTime"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.HostAllocatorSettingsInput().AcceptableHostIdleTime(ctx, &it, data); err != nil {
				return it, err
			}
		case "autoTuneMaximumHosts":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("autoTuneMaximumHosts"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AutoTuneMaximumHosts = data
		case "feedbackRule":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feedbackRule"))
			data, err := ec.unmarshalNFeedbackRule2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeedbackRule = data
		case "futureHostFraction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("futureHostFraction"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.FutureHostFraction = data
		case "hostsOverallocatedRule":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostsOverallocatedRule"))
			data, err := ec.unmarshalNOverallocatedRule2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.HostsOverallocatedRule = data
		case "maximumHosts":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maximumHosts"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaximumHosts = data
		case "minimumHosts":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minimumHosts"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MinimumHosts = data
		case "roundingRule":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roundingRule"))
			data, err := ec.unmarshalNRoundingRule2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.RoundingRule = data
		case "version":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalNHostAllocatorVersion2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Version = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputHostEventsInput(ctx context.Context, obj any) (HostEventsInput, error) {
	var it HostEventsInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["limit"]; !present {
		asMap["limit"] = 0
	}
	if _, present := asMap["page"]; !present {
		asMap["page"] = 0
	}
	if _, present := asMap["sortDir"]; !present {
		asMap["sortDir"] = "DESC"
	}

	fieldsInOrder := [...]string{"limit", "page", "sortDir", "eventTypes"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "sortDir":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortDir"))
			data, err := ec.unmarshalOSortDirection2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSortDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortDir = data
		case "eventTypes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventTypes"))
			data, err := ec.unmarshalOHostEventType2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.EventTypes = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputHostInitConfigInput(ctx context.Context, obj any) (model.APIHostInitConfig, error) {
	var it model.APIHostInitConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"hostThrottle", "provisioningThrottle", "cloudStatusBatchSize", "maxTotalDynamicHosts"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "hostThrottle":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostThrottle"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.HostThrottle = data
		case "provisioningThrottle":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("provisioningThrottle"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProvisioningThrottle = data
		case "cloudStatusBatchSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cloudStatusBatchSize"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CloudStatusBatchSize = data
		case "maxTotalDynamicHosts":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxTotalDynamicHosts"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxTotalDynamicHosts = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputIceCreamSettingsInput(ctx context.Context, obj any) (model.APIIceCreamSettings, error) {
	var it model.APIIceCreamSettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"configPath", "schedulerHost"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "configPath":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("configPath"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConfigPath = data
		case "schedulerHost":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("schedulerHost"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SchedulerHost = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputInstanceTagInput(ctx context.Context, obj any) (host.Tag, error) {
	var it host.Tag
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputIssueLinkInput(ctx context.Context, obj any) (model.APIIssueLink, error) {
	var it model.APIIssueLink
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"confidenceScore", "issueKey", "url"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "confidenceScore":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("confidenceScore"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConfidenceScore = data
		case "issueKey":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("issueKey"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IssueKey = data
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputJiraConfigInput(ctx context.Context, obj any) (model.APIJiraConfig, error) {
	var it model.APIJiraConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"email", "host", "personalAccessToken"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "email":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("email"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Email = data
		case "host":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("host"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Host = data
		case "personalAccessToken":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("personalAccessToken"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2ᚖstring(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.PersonalAccessToken = data
			} else if tmp == nil {
				it.PersonalAccessToken = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputJiraIssueSubscriberInput(ctx context.Context, obj any) (model.APIJIRAIssueSubscriber, error) {
	var it model.APIJIRAIssueSubscriber
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"issueType", "project"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "issueType":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("issueType"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IssueType = data
		case "project":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("project"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Project = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputKanopyAuthConfigInput(ctx context.Context, obj any) (model.APIKanopyAuthConfig, error) {
	var it model.APIKanopyAuthConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"headerName", "issuer", "keysetURL"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "headerName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("headerName"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2ᚖstring(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.HeaderName = data
			} else if tmp == nil {
				it.HeaderName = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "issuer":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("issuer"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2ᚖstring(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Issuer = data
			} else if tmp == nil {
				it.Issuer = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "keysetURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keysetURL"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2ᚖstring(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.KeysetURL = data
			} else if tmp == nil {
				it.KeysetURL = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLogBufferingInput(ctx context.Context, obj any) (model.APILogBuffering, error) {
	var it model.APILogBuffering
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"useAsync", "durationSeconds", "count", "incomingBufferFactor"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "useAsync":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("useAsync"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UseAsync = data
		case "durationSeconds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("durationSeconds"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.DurationSeconds = data
		case "count":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("count"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Count = data
		case "incomingBufferFactor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("incomingBufferFactor"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.IncomingBufferFactor = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputLoggerConfigInput(ctx context.Context, obj any) (model.APILoggerConfig, error) {
	var it model.APILoggerConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"buffer", "defaultLevel", "thresholdLevel", "logkeeperURL", "redactKeys"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "buffer":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buffer"))
			data, err := ec.unmarshalNLogBufferingInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPILogBuffering(ctx, v)
			if err != nil {
				return it, err
			}
			it.Buffer = data
		case "defaultLevel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("defaultLevel"))
			data, err := ec.unmarshalNPriorityLevel2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DefaultLevel = data
		case "thresholdLevel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("thresholdLevel"))
			data, err := ec.unmarshalNPriorityLevel2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ThresholdLevel = data
		case "logkeeperURL":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("logkeeperURL"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.LogkeeperURL = data
		case "redactKeys":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("redactKeys"))
			data, err := ec.unmarshalNString2ᚕᚖstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.RedactKeys = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMainlineCommitsOptions(ctx context.Context, obj any) (MainlineCommitsOptions, error) {
	var it MainlineCommitsOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["limit"]; !present {
		asMap["limit"] = 7
	}
	if _, present := asMap["shouldCollapse"]; !present {
		asMap["shouldCollapse"] = false
	}

	fieldsInOrder := [...]string{"limit", "projectIdentifier", "requesters", "revision", "shouldCollapse", "skipOrderNumber"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "projectIdentifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdentifier"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				permission, err := ec.unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx, "TASKS")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				access, err := ec.unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx, "VIEW")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireProjectAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireProjectAccess is not implemented")
				}
				return ec.directives.RequireProjectAccess(ctx, obj, directive0, permission, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.ProjectIdentifier = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "requesters":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requesters"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Requesters = data
		case "revision":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("revision"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Revision = data
		case "shouldCollapse":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("shouldCollapse"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShouldCollapse = data
		case "skipOrderNumber":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("skipOrderNumber"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.SkipOrderNumber = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMetadataLinkInput(ctx context.Context, obj any) (model.APIMetadataLink, error) {
	var it model.APIMetadataLink
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"text", "url"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "text":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("text"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Text = data
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMoveProjectInput(ctx context.Context, obj any) (MoveProjectInput, error) {
	var it MoveProjectInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"newOwner", "newRepo", "projectId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "newOwner":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("newOwner"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NewOwner = data
		case "newRepo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("newRepo"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NewRepo = data
		case "projectId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				permission, err := ec.unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx, "SETTINGS")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				access, err := ec.unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx, "EDIT")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireProjectAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireProjectAccess is not implemented")
				}
				return ec.directives.RequireProjectAccess(ctx, obj, directive0, permission, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.ProjectID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMultiAuthConfigInput(ctx context.Context, obj any) (model.APIMultiAuthConfig, error) {
	var it model.APIMultiAuthConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"readWrite", "readOnly"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "readWrite":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("readWrite"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ReadWrite = data
		case "readOnly":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("readOnly"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ReadOnly = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNaiveAuthConfigInput(ctx context.Context, obj any) (model.APINaiveAuthConfig, error) {
	var it model.APINaiveAuthConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"users"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "users":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("users"))
			data, err := ec.unmarshalOAuthUserInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAuthUserᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Users = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNotificationsInput(ctx context.Context, obj any) (model.APINotificationPreferences, error) {
	var it model.APINotificationPreferences
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"buildBreak", "patchFinish", "patchFirstFailure", "spawnHostExpiration", "spawnHostOutcome"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "buildBreak":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildBreak"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.BuildBreak = data
		case "patchFinish":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchFinish"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchFinish = data
		case "patchFirstFailure":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchFirstFailure"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchFirstFailure = data
		case "spawnHostExpiration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spawnHostExpiration"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpawnHostExpiration = data
		case "spawnHostOutcome":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spawnHostOutcome"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpawnHostOutcome = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNotifyConfigInput(ctx context.Context, obj any) (model.APINotifyConfig, error) {
	var it model.APINotifyConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ses", "bufferTargetPerInterval", "bufferIntervalSeconds"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ses":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ses"))
			data, err := ec.unmarshalOSESConfigInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISESConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.SES = data
		case "bufferTargetPerInterval":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bufferTargetPerInterval"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.BufferTargetPerInterval = data
		case "bufferIntervalSeconds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bufferIntervalSeconds"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.BufferIntervalSeconds = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOktaConfigInput(ctx context.Context, obj any) (model.APIOktaConfig, error) {
	var it model.APIOktaConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"clientId", "clientSecret", "issuer", "scopes", "userGroup", "expireAfterMinutes"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "clientId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2ᚖstring(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.ClientID = data
			} else if tmp == nil {
				it.ClientID = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "clientSecret":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientSecret"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2ᚖstring(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.ClientSecret = data
			} else if tmp == nil {
				it.ClientSecret = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "issuer":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("issuer"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2ᚖstring(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Issuer = data
			} else if tmp == nil {
				it.Issuer = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "scopes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("scopes"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Scopes = data
		case "userGroup":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userGroup"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserGroup = data
		case "expireAfterMinutes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expireAfterMinutes"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpireAfterMinutes = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputOperatingSystemOpts(ctx context.Context, obj any) (thirdparty.OSInfoFilterOptions, error) {
	var it thirdparty.OSInfoFilterOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "limit", "page"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPackageOpts(ctx context.Context, obj any) (thirdparty.PackageFilterOptions, error) {
	var it thirdparty.PackageFilterOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "manager", "limit", "page"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "manager":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("manager"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Manager = data
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputParameterInput(ctx context.Context, obj any) (model.APIParameter, error) {
	var it model.APIParameter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputParsleyFilterInput(ctx context.Context, obj any) (model.APIParsleyFilter, error) {
	var it model.APIParsleyFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"caseSensitive", "description", "exactMatch", "expression"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "caseSensitive":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("caseSensitive"))
			data, err := ec.unmarshalNBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CaseSensitive = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "exactMatch":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("exactMatch"))
			data, err := ec.unmarshalNBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExactMatch = data
		case "expression":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expression"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Expression = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputParsleySettingsInput(ctx context.Context, obj any) (model.APIParsleySettings, error) {
	var it model.APIParsleySettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"sectionsEnabled", "jumpToFailingLineEnabled"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "sectionsEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sectionsEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SectionsEnabled = data
		case "jumpToFailingLineEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jumpToFailingLineEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.JumpToFailingLineEnabled = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPatchConfigure(ctx context.Context, obj any) (PatchConfigure, error) {
	var it PatchConfigure
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"description", "parameters", "patchTriggerAliases", "variantsTasks"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "parameters":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parameters"))
			data, err := ec.unmarshalOParameterInput2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParameterᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Parameters = data
		case "patchTriggerAliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchTriggerAliases"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchTriggerAliases = data
		case "variantsTasks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("variantsTasks"))
			data, err := ec.unmarshalNVariantTasks2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐVariantTasksᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.VariantsTasks = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPatchTriggerAliasInput(ctx context.Context, obj any) (model.APIPatchTriggerDefinition, error) {
	var it model.APIPatchTriggerDefinition
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"alias", "childProjectIdentifier", "parentAsModule", "status", "downstreamRevision", "taskSpecifiers"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "alias":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alias"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Alias = data
		case "childProjectIdentifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("childProjectIdentifier"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChildProjectIdentifier = data
		case "parentAsModule":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentAsModule"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParentAsModule = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "downstreamRevision":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("downstreamRevision"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DownstreamRevision = data
		case "taskSpecifiers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskSpecifiers"))
			data, err := ec.unmarshalNTaskSpecifierInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskSpecifierᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskSpecifiers = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPatchesInput(ctx context.Context, obj any) (PatchesInput, error) {
	var it PatchesInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["limit"]; !present {
		asMap["limit"] = 0
	}
	if _, present := asMap["includeHidden"]; !present {
		asMap["includeHidden"] = false
	}
	if _, present := asMap["page"]; !present {
		asMap["page"] = 0
	}
	if _, present := asMap["patchName"]; !present {
		asMap["patchName"] = ""
	}
	if _, present := asMap["statuses"]; !present {
		asMap["statuses"] = []any{}
	}

	fieldsInOrder := [...]string{"limit", "onlyMergeQueue", "includeHidden", "page", "patchName", "statuses", "requesters"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "onlyMergeQueue":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("onlyMergeQueue"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.OnlyMergeQueue = data
		case "includeHidden":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeHidden"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IncludeHidden = data
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "patchName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchName = data
		case "statuses":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statuses"))
			data, err := ec.unmarshalNString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Statuses = data
		case "requesters":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requesters"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Requesters = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPeriodicBuildInput(ctx context.Context, obj any) (model.APIPeriodicBuildDefinition, error) {
	var it model.APIPeriodicBuildDefinition
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "alias", "configFile", "cron", "intervalHours", "message", "nextRunTime"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "alias":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alias"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Alias = data
		case "configFile":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("configFile"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConfigFile = data
		case "cron":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cron"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Cron = data
		case "intervalHours":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("intervalHours"))
			data, err := ec.unmarshalNInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IntervalHours = data
		case "message":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("message"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Message = data
		case "nextRunTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nextRunTime"))
			data, err := ec.unmarshalNTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.NextRunTime = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPlannerSettingsInput(ctx context.Context, obj any) (model.APIPlannerSettings, error) {
	var it model.APIPlannerSettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"commitQueueFactor", "expectedRuntimeFactor", "generateTaskFactor", "groupVersions", "mainlineTimeInQueueFactor", "numDependentsFactor", "patchFactor", "patchTimeInQueueFactor", "targetTime", "version"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "commitQueueFactor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("commitQueueFactor"))
			data, err := ec.unmarshalNInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CommitQueueFactor = data
		case "expectedRuntimeFactor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expectedRuntimeFactor"))
			data, err := ec.unmarshalNInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpectedRuntimeFactor = data
		case "generateTaskFactor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("generateTaskFactor"))
			data, err := ec.unmarshalNInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.GenerateTaskFactor = data
		case "groupVersions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("groupVersions"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GroupVersions = data
		case "mainlineTimeInQueueFactor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mainlineTimeInQueueFactor"))
			data, err := ec.unmarshalNInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.MainlineTimeInQueueFactor = data
		case "numDependentsFactor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("numDependentsFactor"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.NumDependentsFactor = data
		case "patchFactor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchFactor"))
			data, err := ec.unmarshalNInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchFactor = data
		case "patchTimeInQueueFactor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchTimeInQueueFactor"))
			data, err := ec.unmarshalNInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchTimeInQueueFactor = data
		case "targetTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetTime"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.PlannerSettingsInput().TargetTime(ctx, &it, data); err != nil {
				return it, err
			}
		case "version":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalNPlannerVersion2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Version = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPodLifecycleConfigInput(ctx context.Context, obj any) (model.APIPodLifecycleConfig, error) {
	var it model.APIPodLifecycleConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"maxParallelPodRequests", "maxPodDefinitionCleanupRate", "maxSecretCleanupRate"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "maxParallelPodRequests":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxParallelPodRequests"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxParallelPodRequests = data
		case "maxPodDefinitionCleanupRate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxPodDefinitionCleanupRate"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxPodDefinitionCleanupRate = data
		case "maxSecretCleanupRate":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxSecretCleanupRate"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxSecretCleanupRate = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPreconditionScriptInput(ctx context.Context, obj any) (model.APIPreconditionScript, error) {
	var it model.APIPreconditionScript
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"path", "script"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "path":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Path = data
		case "script":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("script"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Script = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProjectAliasInput(ctx context.Context, obj any) (model.APIProjectAlias, error) {
	var it model.APIProjectAlias
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "alias", "description", "gitTag", "remotePath", "task", "taskTags", "variant", "variantTags", "parameters"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "alias":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alias"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Alias = data
		case "description":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "gitTag":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gitTag"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitTag = data
		case "remotePath":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remotePath"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemotePath = data
		case "task":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("task"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Task = data
		case "taskTags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskTags"))
			data, err := ec.unmarshalNString2ᚕᚖstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskTags = data
		case "variant":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("variant"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Variant = data
		case "variantTags":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("variantTags"))
			data, err := ec.unmarshalNString2ᚕᚖstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.VariantTags = data
		case "parameters":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parameters"))
			data, err := ec.unmarshalOParameterInput2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParameterᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Parameters = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProjectBannerInput(ctx context.Context, obj any) (model.APIProjectBanner, error) {
	var it model.APIProjectBanner
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"text", "theme"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "text":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("text"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Text = data
		case "theme":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("theme"))
			data, err := ec.unmarshalNBannerTheme2githubᚗcomᚋevergreenᚑciᚋevergreenᚐBannerTheme(ctx, v)
			if err != nil {
				return it, err
			}
			it.Theme = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProjectInput(ctx context.Context, obj any) (model.APIProjectRef, error) {
	var it model.APIProjectRef
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "admins", "banner", "batchTime", "branch", "buildBaronSettings", "commitQueue", "containerSizeDefinitions", "deactivatePrevious", "disabledStatsCache", "dispatchingDisabled", "displayName", "enabled", "externalLinks", "githubChecksEnabled", "githubDynamicTokenPermissionGroups", "githubPermissionGroupByRequester", "githubTriggerAliases", "githubPRTriggerAliases", "githubMQTriggerAliases", "gitTagAuthorizedTeams", "gitTagAuthorizedUsers", "gitTagVersionsEnabled", "identifier", "manualPrTestingEnabled", "notifyOnBuildFailure", "oldestAllowedMergeBase", "owner", "parsleyFilters", "patchingDisabled", "patchTriggerAliases", "perfEnabled", "periodicBuilds", "projectHealthView", "prTestingEnabled", "remotePath", "repo", "repotrackerDisabled", "restricted", "spawnHostScriptPath", "stepbackDisabled", "stepbackBisect", "taskAnnotationSettings", "tracksPushEvents", "triggers", "versionControlEnabled", "workstationConfig"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Id = data
		case "admins":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("admins"))
			data, err := ec.unmarshalOString2ᚕᚖstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Admins = data
		case "banner":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("banner"))
			data, err := ec.unmarshalOProjectBannerInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectBanner(ctx, v)
			if err != nil {
				return it, err
			}
			it.Banner = data
		case "batchTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("batchTime"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.BatchTime = data
		case "branch":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("branch"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Branch = data
		case "buildBaronSettings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildBaronSettings"))
			data, err := ec.unmarshalOBuildBaronSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIBuildBaronSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.BuildBaronSettings = data
		case "commitQueue":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("commitQueue"))
			data, err := ec.unmarshalOCommitQueueParamsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPICommitQueueParams(ctx, v)
			if err != nil {
				return it, err
			}
			it.CommitQueue = data
		case "containerSizeDefinitions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("containerSizeDefinitions"))
			data, err := ec.unmarshalOContainerResourcesInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIContainerResourcesᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ContainerSizeDefinitions = data
		case "deactivatePrevious":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deactivatePrevious"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeactivatePrevious = data
		case "disabledStatsCache":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("disabledStatsCache"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisabledStatsCache = data
		case "dispatchingDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dispatchingDisabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DispatchingDisabled = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "enabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("enabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Enabled = data
		case "externalLinks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalLinks"))
			data, err := ec.unmarshalOExternalLinkInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIExternalLinkᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalLinks = data
		case "githubChecksEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubChecksEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GithubChecksEnabled = data
		case "githubDynamicTokenPermissionGroups":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubDynamicTokenPermissionGroups"))
			data, err := ec.unmarshalOGitHubDynamicTokenPermissionGroupInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGitHubDynamicTokenPermissionGroupᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitHubDynamicTokenPermissionGroups = data
		case "githubPermissionGroupByRequester":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubPermissionGroupByRequester"))
			data, err := ec.unmarshalOStringMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitHubPermissionGroupByRequester = data
		case "githubTriggerAliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubTriggerAliases"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.ProjectInput().GithubTriggerAliases(ctx, &it, data); err != nil {
				return it, err
			}
		case "githubPRTriggerAliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubPRTriggerAliases"))
			data, err := ec.unmarshalOString2ᚕᚖstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.GithubPRTriggerAliases = data
		case "githubMQTriggerAliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubMQTriggerAliases"))
			data, err := ec.unmarshalOString2ᚕᚖstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.GithubMQTriggerAliases = data
		case "gitTagAuthorizedTeams":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gitTagAuthorizedTeams"))
			data, err := ec.unmarshalOString2ᚕᚖstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitTagAuthorizedTeams = data
		case "gitTagAuthorizedUsers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gitTagAuthorizedUsers"))
			data, err := ec.unmarshalOString2ᚕᚖstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitTagAuthorizedUsers = data
		case "gitTagVersionsEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gitTagVersionsEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitTagVersionsEnabled = data
		case "identifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("identifier"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Identifier = data
		case "manualPrTestingEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("manualPrTestingEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ManualPRTestingEnabled = data
		case "notifyOnBuildFailure":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("notifyOnBuildFailure"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.NotifyOnBuildFailure = data
		case "oldestAllowedMergeBase":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("oldestAllowedMergeBase"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.OldestAllowedMergeBase = data
		case "owner":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("owner"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Owner = data
		case "parsleyFilters":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parsleyFilters"))
			data, err := ec.unmarshalOParsleyFilterInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParsleyFilterᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParsleyFilters = data
		case "patchingDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchingDisabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchingDisabled = data
		case "patchTriggerAliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchTriggerAliases"))
			data, err := ec.unmarshalOPatchTriggerAliasInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatchTriggerDefinitionᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchTriggerAliases = data
		case "perfEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("perfEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PerfEnabled = data
		case "periodicBuilds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("periodicBuilds"))
			data, err := ec.unmarshalOPeriodicBuildInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPeriodicBuildDefinitionᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.PeriodicBuilds = data
		case "projectHealthView":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectHealthView"))
			data, err := ec.unmarshalOProjectHealthView2githubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐProjectHealthView(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProjectHealthView = data
		case "prTestingEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("prTestingEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PRTestingEnabled = data
		case "remotePath":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remotePath"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemotePath = data
		case "repo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repo"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Repo = data
		case "repotrackerDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repotrackerDisabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.RepotrackerDisabled = data
		case "restricted":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("restricted"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Restricted = data
		case "spawnHostScriptPath":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spawnHostScriptPath"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpawnHostScriptPath = data
		case "stepbackDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stepbackDisabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.StepbackDisabled = data
		case "stepbackBisect":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stepbackBisect"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.StepbackBisect = data
		case "taskAnnotationSettings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskAnnotationSettings"))
			data, err := ec.unmarshalOTaskAnnotationSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskAnnotationSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskAnnotationSettings = data
		case "tracksPushEvents":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tracksPushEvents"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.TracksPushEvents = data
		case "triggers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("triggers"))
			data, err := ec.unmarshalOTriggerAliasInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITriggerDefinitionᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Triggers = data
		case "versionControlEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionControlEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.VersionControlEnabled = data
		case "workstationConfig":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("workstationConfig"))
			data, err := ec.unmarshalOWorkstationConfigInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWorkstationConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.WorkstationConfig = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProjectPermissionsOptions(ctx context.Context, obj any) (ProjectPermissionsOptions, error) {
	var it ProjectPermissionsOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"projectIdentifier"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "projectIdentifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdentifier"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProjectIdentifier = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProjectSettingsInput(ctx context.Context, obj any) (model.APIProjectSettings, error) {
	var it model.APIProjectSettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"projectId", "aliases", "githubAppAuth", "githubWebhooksEnabled", "projectRef", "subscriptions", "vars"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "projectId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				permission, err := ec.unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx, "SETTINGS")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				access, err := ec.unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx, "EDIT")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireProjectAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireProjectAccess is not implemented")
				}
				return ec.directives.RequireProjectAccess(ctx, obj, directive0, permission, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				if err = ec.resolvers.ProjectSettingsInput().ProjectID(ctx, &it, data); err != nil {
					return it, err
				}
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "aliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("aliases"))
			data, err := ec.unmarshalOProjectAliasInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectAliasᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Aliases = data
		case "githubAppAuth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubAppAuth"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOGithubAppAuthInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGithubAppAuth(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal model.APIGithubAppAuth
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(model.APIGithubAppAuth); ok {
				it.GithubAppAuth = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/rest/model.APIGithubAppAuth`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "githubWebhooksEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubWebhooksEnabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GithubWebhooksEnabled = data
		case "projectRef":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectRef"))
			data, err := ec.unmarshalOProjectInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProjectRef = data
		case "subscriptions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subscriptions"))
			data, err := ec.unmarshalOSubscriptionInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISubscriptionᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Subscriptions = data
		case "vars":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("vars"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOProjectVarsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectVars(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal model.APIProjectVars
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(model.APIProjectVars); ok {
				it.Vars = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/rest/model.APIProjectVars`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProjectVarsInput(ctx context.Context, obj any) (model.APIProjectVars, error) {
	var it model.APIProjectVars
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"adminOnlyVarsList", "privateVarsList", "vars"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "adminOnlyVarsList":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("adminOnlyVarsList"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.AdminOnlyVarsList = data
		case "privateVarsList":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("privateVarsList"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.PrivateVarsList = data
		case "vars":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("vars"))
			data, err := ec.unmarshalOStringMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Vars = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPromoteVarsToRepoInput(ctx context.Context, obj any) (PromoteVarsToRepoInput, error) {
	var it PromoteVarsToRepoInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"projectId", "varNames"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "projectId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				permission, err := ec.unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx, "SETTINGS")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				access, err := ec.unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx, "EDIT")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireProjectAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireProjectAccess is not implemented")
				}
				return ec.directives.RequireProjectAccess(ctx, obj, directive0, permission, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.ProjectID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "varNames":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("varNames"))
			data, err := ec.unmarshalNString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.VarNames = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPublicKeyInput(ctx context.Context, obj any) (PublicKeyInput, error) {
	var it PublicKeyInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRemoveFavoriteProjectInput(ctx context.Context, obj any) (RemoveFavoriteProjectInput, error) {
	var it RemoveFavoriteProjectInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"projectIdentifier"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "projectIdentifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdentifier"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProjectIdentifier = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRepoPermissionsOptions(ctx context.Context, obj any) (RepoPermissionsOptions, error) {
	var it RepoPermissionsOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"repoId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "repoId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repoId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.RepoID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRepoRefInput(ctx context.Context, obj any) (model.APIProjectRef, error) {
	var it model.APIProjectRef
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "admins", "batchTime", "buildBaronSettings", "commitQueue", "deactivatePrevious", "disabledStatsCache", "dispatchingDisabled", "displayName", "enabled", "externalLinks", "githubChecksEnabled", "githubDynamicTokenPermissionGroups", "githubPermissionGroupByRequester", "githubTriggerAliases", "githubPRTriggerAliases", "githubMQTriggerAliases", "gitTagAuthorizedTeams", "gitTagAuthorizedUsers", "gitTagVersionsEnabled", "manualPrTestingEnabled", "notifyOnBuildFailure", "oldestAllowedMergeBase", "owner", "parsleyFilters", "patchingDisabled", "patchTriggerAliases", "perfEnabled", "periodicBuilds", "prTestingEnabled", "remotePath", "repo", "repotrackerDisabled", "restricted", "spawnHostScriptPath", "stepbackDisabled", "stepbackBisect", "taskAnnotationSettings", "tracksPushEvents", "triggers", "versionControlEnabled", "workstationConfig", "containerSizeDefinitions"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Id = data
		case "admins":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("admins"))
			data, err := ec.unmarshalOString2ᚕᚖstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Admins = data
		case "batchTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("batchTime"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.BatchTime = data
		case "buildBaronSettings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildBaronSettings"))
			data, err := ec.unmarshalOBuildBaronSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIBuildBaronSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.BuildBaronSettings = data
		case "commitQueue":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("commitQueue"))
			data, err := ec.unmarshalOCommitQueueParamsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPICommitQueueParams(ctx, v)
			if err != nil {
				return it, err
			}
			it.CommitQueue = data
		case "deactivatePrevious":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deactivatePrevious"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeactivatePrevious = data
		case "disabledStatsCache":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("disabledStatsCache"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisabledStatsCache = data
		case "dispatchingDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dispatchingDisabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DispatchingDisabled = data
		case "displayName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "enabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("enabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Enabled = data
		case "externalLinks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalLinks"))
			data, err := ec.unmarshalOExternalLinkInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIExternalLinkᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalLinks = data
		case "githubChecksEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubChecksEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GithubChecksEnabled = data
		case "githubDynamicTokenPermissionGroups":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubDynamicTokenPermissionGroups"))
			data, err := ec.unmarshalOGitHubDynamicTokenPermissionGroupInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGitHubDynamicTokenPermissionGroupᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitHubDynamicTokenPermissionGroups = data
		case "githubPermissionGroupByRequester":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubPermissionGroupByRequester"))
			data, err := ec.unmarshalOStringMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitHubPermissionGroupByRequester = data
		case "githubTriggerAliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubTriggerAliases"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.RepoRefInput().GithubTriggerAliases(ctx, &it, data); err != nil {
				return it, err
			}
		case "githubPRTriggerAliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubPRTriggerAliases"))
			data, err := ec.unmarshalOString2ᚕᚖstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.GithubPRTriggerAliases = data
		case "githubMQTriggerAliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubMQTriggerAliases"))
			data, err := ec.unmarshalOString2ᚕᚖstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.GithubMQTriggerAliases = data
		case "gitTagAuthorizedTeams":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gitTagAuthorizedTeams"))
			data, err := ec.unmarshalOString2ᚕᚖstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitTagAuthorizedTeams = data
		case "gitTagAuthorizedUsers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gitTagAuthorizedUsers"))
			data, err := ec.unmarshalOString2ᚕᚖstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitTagAuthorizedUsers = data
		case "gitTagVersionsEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gitTagVersionsEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitTagVersionsEnabled = data
		case "manualPrTestingEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("manualPrTestingEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ManualPRTestingEnabled = data
		case "notifyOnBuildFailure":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("notifyOnBuildFailure"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.NotifyOnBuildFailure = data
		case "oldestAllowedMergeBase":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("oldestAllowedMergeBase"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.OldestAllowedMergeBase = data
		case "owner":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("owner"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Owner = data
		case "parsleyFilters":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parsleyFilters"))
			data, err := ec.unmarshalOParsleyFilterInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParsleyFilterᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParsleyFilters = data
		case "patchingDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchingDisabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchingDisabled = data
		case "patchTriggerAliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchTriggerAliases"))
			data, err := ec.unmarshalOPatchTriggerAliasInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatchTriggerDefinitionᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchTriggerAliases = data
		case "perfEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("perfEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PerfEnabled = data
		case "periodicBuilds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("periodicBuilds"))
			data, err := ec.unmarshalOPeriodicBuildInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPeriodicBuildDefinitionᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.PeriodicBuilds = data
		case "prTestingEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("prTestingEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PRTestingEnabled = data
		case "remotePath":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remotePath"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemotePath = data
		case "repo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repo"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Repo = data
		case "repotrackerDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repotrackerDisabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.RepotrackerDisabled = data
		case "restricted":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("restricted"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Restricted = data
		case "spawnHostScriptPath":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spawnHostScriptPath"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpawnHostScriptPath = data
		case "stepbackDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stepbackDisabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.StepbackDisabled = data
		case "stepbackBisect":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stepbackBisect"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.StepbackBisect = data
		case "taskAnnotationSettings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskAnnotationSettings"))
			data, err := ec.unmarshalOTaskAnnotationSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskAnnotationSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskAnnotationSettings = data
		case "tracksPushEvents":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tracksPushEvents"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.TracksPushEvents = data
		case "triggers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("triggers"))
			data, err := ec.unmarshalOTriggerAliasInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITriggerDefinitionᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Triggers = data
		case "versionControlEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionControlEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.VersionControlEnabled = data
		case "workstationConfig":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("workstationConfig"))
			data, err := ec.unmarshalOWorkstationConfigInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWorkstationConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.WorkstationConfig = data
		case "containerSizeDefinitions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("containerSizeDefinitions"))
			data, err := ec.unmarshalOContainerResourcesInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIContainerResourcesᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ContainerSizeDefinitions = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRepoSettingsInput(ctx context.Context, obj any) (model.APIProjectSettings, error) {
	var it model.APIProjectSettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"repoId", "aliases", "githubAppAuth", "githubWebhooksEnabled", "projectRef", "subscriptions", "vars"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "repoId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repoId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				permission, err := ec.unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx, "SETTINGS")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				access, err := ec.unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx, "EDIT")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireProjectAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireProjectAccess is not implemented")
				}
				return ec.directives.RequireProjectAccess(ctx, obj, directive0, permission, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				if err = ec.resolvers.RepoSettingsInput().RepoID(ctx, &it, data); err != nil {
					return it, err
				}
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "aliases":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("aliases"))
			data, err := ec.unmarshalOProjectAliasInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectAliasᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Aliases = data
		case "githubAppAuth":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubAppAuth"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOGithubAppAuthInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGithubAppAuth(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal model.APIGithubAppAuth
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(model.APIGithubAppAuth); ok {
				it.GithubAppAuth = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/rest/model.APIGithubAppAuth`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "githubWebhooksEnabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubWebhooksEnabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GithubWebhooksEnabled = data
		case "projectRef":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectRef"))
			data, err := ec.unmarshalORepoRefInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProjectRef = data
		case "subscriptions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subscriptions"))
			data, err := ec.unmarshalOSubscriptionInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISubscriptionᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Subscriptions = data
		case "vars":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("vars"))
			directive0 := func(ctx context.Context) (any, error) {
				return ec.unmarshalOProjectVarsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectVars(ctx, v)
			}

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal model.APIProjectVars
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(model.APIProjectVars); ok {
				it.Vars = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/rest/model.APIProjectVars`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRepotrackerConfigInput(ctx context.Context, obj any) (model.APIRepoTrackerConfig, error) {
	var it model.APIRepoTrackerConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"numNewRepoRevisionsToFetch", "maxRepoRevisionsToSearch", "maxConcurrentRequests"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "numNewRepoRevisionsToFetch":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("numNewRepoRevisionsToFetch"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.NumNewRepoRevisionsToFetch = data
		case "maxRepoRevisionsToSearch":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxRepoRevisionsToSearch"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxRepoRevisionsToSearch = data
		case "maxConcurrentRequests":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxConcurrentRequests"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxConcurrentRequests = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputResourceLimitsInput(ctx context.Context, obj any) (model.APIResourceLimits, error) {
	var it model.APIResourceLimits
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"lockedMemoryKb", "numFiles", "numProcesses", "numTasks", "virtualMemoryKb"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "lockedMemoryKb":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lockedMemoryKb"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LockedMemoryKB = data
		case "numFiles":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("numFiles"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.NumFiles = data
		case "numProcesses":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("numProcesses"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.NumProcesses = data
		case "numTasks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("numTasks"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.NumTasks = data
		case "virtualMemoryKb":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("virtualMemoryKb"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.VirtualMemoryKB = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRestartAdminTasksOptions(ctx context.Context, obj any) (model1.RestartOptions, error) {
	var it model1.RestartOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"startTime", "endTime", "includeTestFailed", "includeSystemFailed", "includeSetupFailed"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "startTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startTime"))
			data, err := ec.unmarshalNTime2timeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.StartTime = data
		case "endTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endTime"))
			data, err := ec.unmarshalNTime2timeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.EndTime = data
		case "includeTestFailed":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeTestFailed"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IncludeTestFailed = data
		case "includeSystemFailed":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeSystemFailed"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IncludeSysFailed = data
		case "includeSetupFailed":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeSetupFailed"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IncludeSetupFailed = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRuntimeEnvironmentConfigInput(ctx context.Context, obj any) (model.APIRuntimeEnvironmentsConfig, error) {
	var it model.APIRuntimeEnvironmentsConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"baseUrl", "apiKey"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "baseUrl":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseUrl"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.BaseURL = data
		case "apiKey":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("apiKey"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalOString2ᚖstring(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.APIKey = data
			} else if tmp == nil {
				it.APIKey = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSESConfigInput(ctx context.Context, obj any) (model.APISESConfig, error) {
	var it model.APISESConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"senderAddress"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "senderAddress":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("senderAddress"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2ᚖstring(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.SenderAddress = data
			} else if tmp == nil {
				it.SenderAddress = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSaveAdminSettingsInput(ctx context.Context, obj any) (SaveAdminSettingsInput, error) {
	var it SaveAdminSettingsInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"adminSettings"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "adminSettings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("adminSettings"))
			data, err := ec.unmarshalNAdminSettingsInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAdminSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.AdminSettings = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSaveDistroInput(ctx context.Context, obj any) (SaveDistroInput, error) {
	var it SaveDistroInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"distro", "onSave"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "distro":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("distro"))
			data, err := ec.unmarshalNDistroInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDistro(ctx, v)
			if err != nil {
				return it, err
			}
			it.Distro = data
		case "onSave":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("onSave"))
			data, err := ec.unmarshalNDistroOnSaveOperation2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroOnSaveOperation(ctx, v)
			if err != nil {
				return it, err
			}
			it.OnSave = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSchedulerConfigInput(ctx context.Context, obj any) (model.APISchedulerConfig, error) {
	var it model.APISchedulerConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"taskFinder", "hostAllocator", "hostAllocatorRoundingRule", "hostAllocatorFeedbackRule", "hostsOverallocatedRule", "futureHostFraction", "cacheDurationSeconds", "targetTimeSeconds", "acceptableHostIdleTimeSeconds", "groupVersions", "patchFactor", "patchTimeInQueueFactor", "commitQueueFactor", "mainlineTimeInQueueFactor", "expectedRuntimeFactor", "generateTaskFactor", "numDependentsFactor", "stepbackTaskFactor"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "taskFinder":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskFinder"))
			data, err := ec.unmarshalNFinderVersion2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskFinder = data
		case "hostAllocator":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostAllocator"))
			data, err := ec.unmarshalNHostAllocatorVersion2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.HostAllocator = data
		case "hostAllocatorRoundingRule":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostAllocatorRoundingRule"))
			data, err := ec.unmarshalNRoundingRule2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.HostAllocatorRoundingRule = data
		case "hostAllocatorFeedbackRule":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostAllocatorFeedbackRule"))
			data, err := ec.unmarshalNFeedbackRule2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.HostAllocatorFeedbackRule = data
		case "hostsOverallocatedRule":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostsOverallocatedRule"))
			data, err := ec.unmarshalNOverallocatedRule2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.HostsOverallocatedRule = data
		case "futureHostFraction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("futureHostFraction"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.FutureHostFraction = data
		case "cacheDurationSeconds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cacheDurationSeconds"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.CacheDurationSeconds = data
		case "targetTimeSeconds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetTimeSeconds"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.TargetTimeSeconds = data
		case "acceptableHostIdleTimeSeconds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("acceptableHostIdleTimeSeconds"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.AcceptableHostIdleTimeSeconds = data
		case "groupVersions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("groupVersions"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GroupVersions = data
		case "patchFactor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchFactor"))
			data, err := ec.unmarshalNInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchFactor = data
		case "patchTimeInQueueFactor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchTimeInQueueFactor"))
			data, err := ec.unmarshalNInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchTimeInQueueFactor = data
		case "commitQueueFactor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("commitQueueFactor"))
			data, err := ec.unmarshalNInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CommitQueueFactor = data
		case "mainlineTimeInQueueFactor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mainlineTimeInQueueFactor"))
			data, err := ec.unmarshalNInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.MainlineTimeInQueueFactor = data
		case "expectedRuntimeFactor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expectedRuntimeFactor"))
			data, err := ec.unmarshalNInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpectedRuntimeFactor = data
		case "generateTaskFactor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("generateTaskFactor"))
			data, err := ec.unmarshalNInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.GenerateTaskFactor = data
		case "numDependentsFactor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("numDependentsFactor"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.NumDependentsFactor = data
		case "stepbackTaskFactor":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stepbackTaskFactor"))
			data, err := ec.unmarshalNInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.StepbackTaskFactor = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSelectorInput(ctx context.Context, obj any) (model.APISelector, error) {
	var it model.APISelector
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"data", "type"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Data = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputServiceFlagsInput(ctx context.Context, obj any) (model.APIServiceFlags, error) {
	var it model.APIServiceFlags
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"taskDispatchDisabled", "hostInitDisabled", "podInitDisabled", "largeParserProjectsDisabled", "monitorDisabled", "alertsDisabled", "agentStartDisabled", "repotrackerDisabled", "schedulerDisabled", "checkBlockedTasksDisabled", "githubPRTestingDisabled", "cliUpdatesDisabled", "backgroundStatsDisabled", "taskLoggingDisabled", "cacheStatsJobDisabled", "cacheStatsEndpointDisabled", "taskReliabilityDisabled", "hostAllocatorDisabled", "podAllocatorDisabled", "unrecognizedPodCleanupDisabled", "backgroundReauthDisabled", "cloudCleanupDisabled", "sleepScheduleDisabled", "staticAPIKeysDisabled", "jwtTokenForCLIDisabled", "systemFailedTaskRestartDisabled", "degradedModeDisabled", "elasticIPsDisabled", "releaseModeDisabled", "adminParameterStoreDisabled", "eventProcessingDisabled", "jiraNotificationsDisabled", "slackNotificationsDisabled", "emailNotificationsDisabled", "webhookNotificationsDisabled", "githubStatusAPIDisabled"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "taskDispatchDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskDispatchDisabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskDispatchDisabled = data
		case "hostInitDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostInitDisabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HostInitDisabled = data
		case "podInitDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("podInitDisabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PodInitDisabled = data
		case "largeParserProjectsDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("largeParserProjectsDisabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.LargeParserProjectsDisabled = data
		case "monitorDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("monitorDisabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.MonitorDisabled = data
		case "alertsDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alertsDisabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AlertsDisabled = data
		case "agentStartDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("agentStartDisabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AgentStartDisabled = data
		case "repotrackerDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repotrackerDisabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.RepotrackerDisabled = data
		case "schedulerDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("schedulerDisabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SchedulerDisabled = data
		case "checkBlockedTasksDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("checkBlockedTasksDisabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CheckBlockedTasksDisabled = data
		case "githubPRTestingDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubPRTestingDisabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GithubPRTestingDisabled = data
		case "cliUpdatesDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cliUpdatesDisabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CLIUpdatesDisabled = data
		case "backgroundStatsDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backgroundStatsDisabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.BackgroundStatsDisabled = data
		case "taskLoggingDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskLoggingDisabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskLoggingDisabled = data
		case "cacheStatsJobDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cacheStatsJobDisabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CacheStatsJobDisabled = data
		case "cacheStatsEndpointDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cacheStatsEndpointDisabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CacheStatsEndpointDisabled = data
		case "taskReliabilityDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskReliabilityDisabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskReliabilityDisabled = data
		case "hostAllocatorDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostAllocatorDisabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HostAllocatorDisabled = data
		case "podAllocatorDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("podAllocatorDisabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PodAllocatorDisabled = data
		case "unrecognizedPodCleanupDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unrecognizedPodCleanupDisabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UnrecognizedPodCleanupDisabled = data
		case "backgroundReauthDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("backgroundReauthDisabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.BackgroundReauthDisabled = data
		case "cloudCleanupDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cloudCleanupDisabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CloudCleanupDisabled = data
		case "sleepScheduleDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sleepScheduleDisabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SleepScheduleDisabled = data
		case "staticAPIKeysDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("staticAPIKeysDisabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.StaticAPIKeysDisabled = data
		case "jwtTokenForCLIDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jwtTokenForCLIDisabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.JWTTokenForCLIDisabled = data
		case "systemFailedTaskRestartDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("systemFailedTaskRestartDisabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SystemFailedTaskRestartDisabled = data
		case "degradedModeDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("degradedModeDisabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DegradedModeDisabled = data
		case "elasticIPsDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("elasticIPsDisabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ElasticIPsDisabled = data
		case "releaseModeDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("releaseModeDisabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ReleaseModeDisabled = data
		case "adminParameterStoreDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("adminParameterStoreDisabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AdminParameterStoreDisabled = data
		case "eventProcessingDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("eventProcessingDisabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.EventProcessingDisabled = data
		case "jiraNotificationsDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jiraNotificationsDisabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.JIRANotificationsDisabled = data
		case "slackNotificationsDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slackNotificationsDisabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SlackNotificationsDisabled = data
		case "emailNotificationsDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("emailNotificationsDisabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.EmailNotificationsDisabled = data
		case "webhookNotificationsDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("webhookNotificationsDisabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.WebhookNotificationsDisabled = data
		case "githubStatusAPIDisabled":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubStatusAPIDisabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GithubStatusAPIDisabled = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSetLastRevisionInput(ctx context.Context, obj any) (SetLastRevisionInput, error) {
	var it SetLastRevisionInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"projectIdentifier", "revision"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "projectIdentifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdentifier"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProjectIdentifier = data
		case "revision":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("revision"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Revision = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSlackConfigInput(ctx context.Context, obj any) (model.APISlackConfig, error) {
	var it model.APISlackConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"options", "token", "level", "name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "options":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("options"))
			data, err := ec.unmarshalOSlackOptionsInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISlackOptions(ctx, v)
			if err != nil {
				return it, err
			}
			it.Options = data
		case "token":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("token"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2ᚖstring(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Token = data
			} else if tmp == nil {
				it.Token = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "level":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("level"))
			data, err := ec.unmarshalNPriorityLevel2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Level = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSlackOptionsInput(ctx context.Context, obj any) (model.APISlackOptions, error) {
	var it model.APISlackOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"channel", "hostname", "name", "username", "basicMetadata", "fields", "allFields", "fieldsSet"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "channel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("channel"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Channel = data
		case "hostname":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostname"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Hostname = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "username":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("username"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Username = data
		case "basicMetadata":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("basicMetadata"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.BasicMetadata = data
		case "fields":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fields"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Fields = data
		case "allFields":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("allFields"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.AllFields = data
		case "fieldsSet":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fieldsSet"))
			data, err := ec.unmarshalOBooleanMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.FieldsSet = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSleepScheduleInput(ctx context.Context, obj any) (host.SleepScheduleInfo, error) {
	var it host.SleepScheduleInfo
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"dailyStartTime", "dailyStopTime", "permanentlyExempt", "shouldKeepOff", "timeZone", "temporarilyExemptUntil", "wholeWeekdaysOff"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "dailyStartTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dailyStartTime"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DailyStartTime = data
		case "dailyStopTime":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dailyStopTime"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DailyStopTime = data
		case "permanentlyExempt":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("permanentlyExempt"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PermanentlyExempt = data
		case "shouldKeepOff":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("shouldKeepOff"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShouldKeepOff = data
		case "timeZone":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timeZone"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TimeZone = data
		case "temporarilyExemptUntil":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("temporarilyExemptUntil"))
			data, err := ec.unmarshalOTime2timeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.TemporarilyExemptUntil = data
		case "wholeWeekdaysOff":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("wholeWeekdaysOff"))
			data, err := ec.unmarshalNInt2ᚕintᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.SleepScheduleInput().WholeWeekdaysOff(ctx, &it, data); err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSortOrder(ctx context.Context, obj any) (SortOrder, error) {
	var it SortOrder
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"Direction", "Key"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "Direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Direction"))
			data, err := ec.unmarshalNSortDirection2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSortDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "Key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Key"))
			data, err := ec.unmarshalNTaskSortCategory2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskSortCategory(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSpawnHostInput(ctx context.Context, obj any) (SpawnHostInput, error) {
	var it SpawnHostInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"distroId", "expiration", "homeVolumeSize", "isVirtualWorkStation", "noExpiration", "publicKey", "region", "savePublicKey", "setUpScript", "sleepSchedule", "spawnHostsStartedByTask", "taskId", "useProjectSetupScript", "userDataScript", "useTaskConfig", "volumeId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "distroId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("distroId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DistroID = data
		case "expiration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiration"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Expiration = data
		case "homeVolumeSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeVolumeSize"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.HomeVolumeSize = data
		case "isVirtualWorkStation":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isVirtualWorkStation"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsVirtualWorkStation = data
		case "noExpiration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("noExpiration"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.NoExpiration = data
		case "publicKey":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publicKey"))
			data, err := ec.unmarshalNPublicKeyInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPublicKeyInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.PublicKey = data
		case "region":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("region"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Region = data
		case "savePublicKey":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("savePublicKey"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SavePublicKey = data
		case "setUpScript":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("setUpScript"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SetUpScript = data
		case "sleepSchedule":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sleepSchedule"))
			data, err := ec.unmarshalOSleepScheduleInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋhostᚐSleepScheduleInfo(ctx, v)
			if err != nil {
				return it, err
			}
			it.SleepSchedule = data
		case "spawnHostsStartedByTask":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spawnHostsStartedByTask"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpawnHostsStartedByTask = data
		case "taskId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskID = data
		case "useProjectSetupScript":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("useProjectSetupScript"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UseProjectSetupScript = data
		case "userDataScript":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userDataScript"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserDataScript = data
		case "useTaskConfig":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("useTaskConfig"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UseTaskConfig = data
		case "volumeId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("volumeId"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.VolumeID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSpawnVolumeInput(ctx context.Context, obj any) (SpawnVolumeInput, error) {
	var it SpawnVolumeInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"availabilityZone", "expiration", "host", "noExpiration", "size", "type"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "availabilityZone":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("availabilityZone"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvailabilityZone = data
		case "expiration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiration"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Expiration = data
		case "host":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("host"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Host = data
		case "noExpiration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("noExpiration"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.NoExpiration = data
		case "size":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("size"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Size = data
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSplunkConfigInput(ctx context.Context, obj any) (model.APISplunkConfig, error) {
	var it model.APISplunkConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"splunkConnectionInfo"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "splunkConnectionInfo":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("splunkConnectionInfo"))
			data, err := ec.unmarshalNSplunkConnectionInfoInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISplunkConnectionInfo(ctx, v)
			if err != nil {
				return it, err
			}
			it.SplunkConnectionInfo = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSplunkConnectionInfoInput(ctx context.Context, obj any) (model.APISplunkConnectionInfo, error) {
	var it model.APISplunkConnectionInfo
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"serverUrl", "token", "channel"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "serverUrl":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("serverUrl"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ServerURL = data
		case "token":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("token"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2ᚖstring(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Token = data
			} else if tmp == nil {
				it.Token = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "channel":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("channel"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Channel = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSubscriberInput(ctx context.Context, obj any) (model.APISubscriber, error) {
	var it model.APISubscriber
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"target", "type", "webhookSubscriber", "jiraIssueSubscriber"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "target":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("target"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.SubscriberInput().Target(ctx, &it, data); err != nil {
				return it, err
			}
		case "type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "webhookSubscriber":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("webhookSubscriber"))
			data, err := ec.unmarshalOWebhookSubscriberInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWebhookSubscriber(ctx, v)
			if err != nil {
				return it, err
			}
			it.WebhookSubscriber = data
		case "jiraIssueSubscriber":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jiraIssueSubscriber"))
			data, err := ec.unmarshalOJiraIssueSubscriberInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIJIRAIssueSubscriber(ctx, v)
			if err != nil {
				return it, err
			}
			it.JiraIssueSubscriber = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSubscriptionInput(ctx context.Context, obj any) (model.APISubscription, error) {
	var it model.APISubscription
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "owner_type", "owner", "regex_selectors", "resource_type", "selectors", "subscriber", "trigger_data", "trigger"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "owner_type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("owner_type"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.OwnerType = data
		case "owner":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("owner"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Owner = data
		case "regex_selectors":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("regex_selectors"))
			data, err := ec.unmarshalNSelectorInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISelectorᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.RegexSelectors = data
		case "resource_type":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resource_type"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ResourceType = data
		case "selectors":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("selectors"))
			data, err := ec.unmarshalNSelectorInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISelectorᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Selectors = data
		case "subscriber":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subscriber"))
			data, err := ec.unmarshalNSubscriberInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISubscriber(ctx, v)
			if err != nil {
				return it, err
			}
			it.Subscriber = data
		case "trigger_data":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trigger_data"))
			data, err := ec.unmarshalNStringMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.TriggerData = data
		case "trigger":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trigger"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Trigger = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTaskAnnotationSettingsInput(ctx context.Context, obj any) (model.APITaskAnnotationSettings, error) {
	var it model.APITaskAnnotationSettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"fileTicketWebhook"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "fileTicketWebhook":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fileTicketWebhook"))
			data, err := ec.unmarshalOWebhookInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWebHook(ctx, v)
			if err != nil {
				return it, err
			}
			it.FileTicketWebhook = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTaskCountOptions(ctx context.Context, obj any) (TaskCountOptions, error) {
	var it TaskCountOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"includeNeverActivatedTasks"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "includeNeverActivatedTasks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeNeverActivatedTasks"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IncludeNeverActivatedTasks = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTaskFilterOptions(ctx context.Context, obj any) (TaskFilterOptions, error) {
	var it TaskFilterOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["baseStatuses"]; !present {
		asMap["baseStatuses"] = []any{}
	}
	if _, present := asMap["includeNeverActivatedTasks"]; !present {
		asMap["includeNeverActivatedTasks"] = false
	}
	if _, present := asMap["limit"]; !present {
		asMap["limit"] = 0
	}
	if _, present := asMap["page"]; !present {
		asMap["page"] = 0
	}
	if _, present := asMap["statuses"]; !present {
		asMap["statuses"] = []any{}
	}

	fieldsInOrder := [...]string{"baseStatuses", "includeNeverActivatedTasks", "limit", "page", "sorts", "statuses", "taskName", "variant"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "baseStatuses":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseStatuses"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.BaseStatuses = data
		case "includeNeverActivatedTasks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeNeverActivatedTasks"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IncludeNeverActivatedTasks = data
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "sorts":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sorts"))
			data, err := ec.unmarshalOSortOrder2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSortOrderᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Sorts = data
		case "statuses":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statuses"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Statuses = data
		case "taskName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskName = data
		case "variant":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("variant"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Variant = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTaskHistoryOpts(ctx context.Context, obj any) (TaskHistoryOpts, error) {
	var it TaskHistoryOpts
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["limit"]; !present {
		asMap["limit"] = 50
	}

	fieldsInOrder := [...]string{"projectIdentifier", "taskName", "buildVariant", "cursorParams", "limit", "date"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "projectIdentifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdentifier"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				permission, err := ec.unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx, "TASKS")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				access, err := ec.unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx, "VIEW")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireProjectAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireProjectAccess is not implemented")
				}
				return ec.directives.RequireProjectAccess(ctx, obj, directive0, permission, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.ProjectIdentifier = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "taskName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskName = data
		case "buildVariant":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildVariant"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.BuildVariant = data
		case "cursorParams":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cursorParams"))
			data, err := ec.unmarshalNCursorParams2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐCursorParams(ctx, v)
			if err != nil {
				return it, err
			}
			it.CursorParams = data
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "date":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("date"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Date = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTaskLimitsConfigInput(ctx context.Context, obj any) (model.APITaskLimitsConfig, error) {
	var it model.APITaskLimitsConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"maxTasksPerVersion", "maxIncludesPerVersion", "maxHourlyPatchTasks", "maxPendingGeneratedTasks", "maxGenerateTaskJSONSize", "maxConcurrentLargeParserProjectTasks", "maxDegradedModeConcurrentLargeParserProjectTasks", "maxDegradedModeParserProjectSize", "maxParserProjectSize", "maxExecTimeoutSecs", "maxTaskExecution", "maxDailyAutomaticRestarts"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "maxTasksPerVersion":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxTasksPerVersion"))
			data, err := ec.unmarshalNInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxTasksPerVersion = data
		case "maxIncludesPerVersion":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxIncludesPerVersion"))
			data, err := ec.unmarshalNInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxIncludesPerVersion = data
		case "maxHourlyPatchTasks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxHourlyPatchTasks"))
			data, err := ec.unmarshalNInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxHourlyPatchTasks = data
		case "maxPendingGeneratedTasks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxPendingGeneratedTasks"))
			data, err := ec.unmarshalNInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxPendingGeneratedTasks = data
		case "maxGenerateTaskJSONSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxGenerateTaskJSONSize"))
			data, err := ec.unmarshalNInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxGenerateTaskJSONSize = data
		case "maxConcurrentLargeParserProjectTasks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxConcurrentLargeParserProjectTasks"))
			data, err := ec.unmarshalNInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxConcurrentLargeParserProjectTasks = data
		case "maxDegradedModeConcurrentLargeParserProjectTasks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxDegradedModeConcurrentLargeParserProjectTasks"))
			data, err := ec.unmarshalNInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxDegradedModeConcurrentLargeParserProjectTasks = data
		case "maxDegradedModeParserProjectSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxDegradedModeParserProjectSize"))
			data, err := ec.unmarshalNInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxDegradedModeParserProjectSize = data
		case "maxParserProjectSize":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxParserProjectSize"))
			data, err := ec.unmarshalNInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxParserProjectSize = data
		case "maxExecTimeoutSecs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxExecTimeoutSecs"))
			data, err := ec.unmarshalNInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxExecTimeoutSecs = data
		case "maxTaskExecution":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxTaskExecution"))
			data, err := ec.unmarshalNInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxTaskExecution = data
		case "maxDailyAutomaticRestarts":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxDailyAutomaticRestarts"))
			data, err := ec.unmarshalNInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxDailyAutomaticRestarts = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTaskPriority(ctx context.Context, obj any) (TaskPriority, error) {
	var it TaskPriority
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"taskId", "priority"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "taskId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				permission, err := ec.unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx, "TASKS")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				access, err := ec.unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx, "EDIT")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireProjectAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireProjectAccess is not implemented")
				}
				return ec.directives.RequireProjectAccess(ctx, obj, directive0, permission, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.TaskID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "priority":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("priority"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Priority = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTaskSpecifierInput(ctx context.Context, obj any) (model.APITaskSpecifier, error) {
	var it model.APITaskSpecifier
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"patchAlias", "taskRegex", "variantRegex"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "patchAlias":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchAlias"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchAlias = data
		case "taskRegex":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskRegex"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskRegex = data
		case "variantRegex":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("variantRegex"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.VariantRegex = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTestFilter(ctx context.Context, obj any) (TestFilter, error) {
	var it TestFilter
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"testName", "testStatus"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "testName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("testName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TestName = data
		case "testStatus":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("testStatus"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TestStatus = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTestFilterOptions(ctx context.Context, obj any) (TestFilterOptions, error) {
	var it TestFilterOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"testName", "excludeDisplayNames", "statuses", "groupID", "sort", "limit", "page"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "testName":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("testName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.TestName = data
		case "excludeDisplayNames":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("excludeDisplayNames"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExcludeDisplayNames = data
		case "statuses":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statuses"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Statuses = data
		case "groupID":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("groupID"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.GroupID = data
		case "sort":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sort"))
			data, err := ec.unmarshalOTestSortOptions2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTestSortOptionsᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Sort = data
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTestSelectionConfigInput(ctx context.Context, obj any) (model.APITestSelectionConfig, error) {
	var it model.APITestSelectionConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"url"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTestSortOptions(ctx context.Context, obj any) (TestSortOptions, error) {
	var it TestSortOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"sortBy", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "sortBy":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortBy"))
			data, err := ec.unmarshalNTestSortCategory2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTestSortCategory(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortBy = data
		case "direction":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNSortDirection2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSortDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputToolchainOpts(ctx context.Context, obj any) (thirdparty.ToolchainFilterOptions, error) {
	var it thirdparty.ToolchainFilterOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "limit", "page"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "page":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTriggerAliasInput(ctx context.Context, obj any) (model.APITriggerDefinition, error) {
	var it model.APITriggerDefinition
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"alias", "buildVariantRegex", "configFile", "dateCutoff", "level", "project", "status", "taskRegex", "unscheduleDownstreamVersions"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "alias":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alias"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Alias = data
		case "buildVariantRegex":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildVariantRegex"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.BuildVariantRegex = data
		case "configFile":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("configFile"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConfigFile = data
		case "dateCutoff":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dateCutoff"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.DateCutoff = data
		case "level":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("level"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Level = data
		case "project":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("project"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Project = data
		case "status":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "taskRegex":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskRegex"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskRegex = data
		case "unscheduleDownstreamVersions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("unscheduleDownstreamVersions"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UnscheduleDownstreamVersions = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTriggerConfigInput(ctx context.Context, obj any) (model.APITriggerConfig, error) {
	var it model.APITriggerConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"generateTaskDistro"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "generateTaskDistro":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("generateTaskDistro"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.GenerateTaskDistro = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUIConfigInput(ctx context.Context, obj any) (model.APIUIConfig, error) {
	var it model.APIUIConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"url", "helpUrl", "uiv2Url", "parsleyUrl", "httpListenAddr", "secret", "defaultProject", "corsOrigins", "fileStreamingContentTypes", "loginDomain", "userVoice", "csrfKey", "cacheTemplates", "stagingEnvironment", "betaFeatures"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Url = data
		case "helpUrl":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("helpUrl"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.HelpUrl = data
		case "uiv2Url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("uiv2Url"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.UIv2Url = data
		case "parsleyUrl":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parsleyUrl"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParsleyUrl = data
		case "httpListenAddr":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("httpListenAddr"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.HttpListenAddr = data
		case "secret":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("secret"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2ᚖstring(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Secret = data
			} else if tmp == nil {
				it.Secret = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "defaultProject":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("defaultProject"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DefaultProject = data
		case "corsOrigins":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("corsOrigins"))
			data, err := ec.unmarshalNString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.CORSOrigins = data
		case "fileStreamingContentTypes":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fileStreamingContentTypes"))
			data, err := ec.unmarshalNString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.FileStreamingContentTypes = data
		case "loginDomain":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("loginDomain"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.LoginDomain = data
		case "userVoice":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userVoice"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserVoice = data
		case "csrfKey":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("csrfKey"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2ᚖstring(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.CsrfKey = data
			} else if tmp == nil {
				it.CsrfKey = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "cacheTemplates":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cacheTemplates"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CacheTemplates = data
		case "stagingEnvironment":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stagingEnvironment"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.StagingEnvironment = data
		case "betaFeatures":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("betaFeatures"))
			data, err := ec.unmarshalNBetaFeaturesInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIBetaFeatures(ctx, v)
			if err != nil {
				return it, err
			}
			it.BetaFeatures = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateBetaFeaturesInput(ctx context.Context, obj any) (UpdateBetaFeaturesInput, error) {
	var it UpdateBetaFeaturesInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"betaFeatures"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "betaFeatures":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("betaFeatures"))
			data, err := ec.unmarshalNBetaFeaturesInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIBetaFeatures(ctx, v)
			if err != nil {
				return it, err
			}
			it.BetaFeatures = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateParsleySettingsInput(ctx context.Context, obj any) (UpdateParsleySettingsInput, error) {
	var it UpdateParsleySettingsInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"parsleySettings"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "parsleySettings":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parsleySettings"))
			data, err := ec.unmarshalNParsleySettingsInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParsleySettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParsleySettings = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateSpawnHostStatusInput(ctx context.Context, obj any) (UpdateSpawnHostStatusInput, error) {
	var it UpdateSpawnHostStatusInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"action", "hostId", "shouldKeepOff"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "action":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("action"))
			data, err := ec.unmarshalNSpawnHostStatusActions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSpawnHostStatusActions(ctx, v)
			if err != nil {
				return it, err
			}
			it.Action = data
		case "hostId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostId"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				access, err := ec.unmarshalNHostAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐHostAccessLevel(ctx, "EDIT")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireHostAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireHostAccess is not implemented")
				}
				return ec.directives.RequireHostAccess(ctx, obj, directive0, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.HostID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "shouldKeepOff":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("shouldKeepOff"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShouldKeepOff = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateVolumeInput(ctx context.Context, obj any) (UpdateVolumeInput, error) {
	var it UpdateVolumeInput
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"expiration", "name", "noExpiration", "size", "volumeId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "expiration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiration"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Expiration = data
		case "name":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "noExpiration":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("noExpiration"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.NoExpiration = data
		case "size":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("size"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Size = data
		case "volumeId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("volumeId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.VolumeID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUseSpruceOptionsInput(ctx context.Context, obj any) (model.APIUseSpruceOptions, error) {
	var it model.APIUseSpruceOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"spruceV1"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "spruceV1":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spruceV1"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpruceV1 = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserSettingsInput(ctx context.Context, obj any) (model.APIUserSettings, error) {
	var it model.APIUserSettings
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"githubUser", "notifications", "region", "slackUsername", "slackMemberId", "timezone", "useSpruceOptions", "dateFormat", "timeFormat"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "githubUser":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubUser"))
			data, err := ec.unmarshalOGithubUserInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGithubUser(ctx, v)
			if err != nil {
				return it, err
			}
			it.GithubUser = data
		case "notifications":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("notifications"))
			data, err := ec.unmarshalONotificationsInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPINotificationPreferences(ctx, v)
			if err != nil {
				return it, err
			}
			it.Notifications = data
		case "region":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("region"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Region = data
		case "slackUsername":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slackUsername"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SlackUsername = data
		case "slackMemberId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slackMemberId"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SlackMemberId = data
		case "timezone":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timezone"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Timezone = data
		case "useSpruceOptions":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("useSpruceOptions"))
			data, err := ec.unmarshalOUseSpruceOptionsInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIUseSpruceOptions(ctx, v)
			if err != nil {
				return it, err
			}
			it.UseSpruceOptions = data
		case "dateFormat":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dateFormat"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DateFormat = data
		case "timeFormat":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timeFormat"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.TimeFormat = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputVariantTasks(ctx context.Context, obj any) (VariantTasks, error) {
	var it VariantTasks
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"displayTasks", "tasks", "variant"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "displayTasks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayTasks"))
			data, err := ec.unmarshalNDisplayTask2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDisplayTaskᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayTasks = data
		case "tasks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tasks"))
			data, err := ec.unmarshalNString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tasks = data
		case "variant":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("variant"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Variant = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputVersionToRestart(ctx context.Context, obj any) (model1.VersionToRestart, error) {
	var it model1.VersionToRestart
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"versionId", "taskIds"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "versionId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.VersionId = data
		case "taskIds":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskIds"))
			data, err := ec.unmarshalNString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskIds = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputVolumeHost(ctx context.Context, obj any) (VolumeHost, error) {
	var it VolumeHost
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"volumeId", "hostId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "volumeId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("volumeId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.VolumeID = data
		case "hostId":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.HostID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWaterfallOptions(ctx context.Context, obj any) (WaterfallOptions, error) {
	var it WaterfallOptions
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["limit"]; !present {
		asMap["limit"] = 5
	}

	fieldsInOrder := [...]string{"date", "limit", "minOrder", "maxOrder", "projectIdentifier", "requesters", "revision", "statuses", "tasks", "taskCaseSensitive", "variants", "variantCaseSensitive"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "date":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("date"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Date = data
		case "limit":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "minOrder":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minOrder"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MinOrder = data
		case "maxOrder":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maxOrder"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaxOrder = data
		case "projectIdentifier":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdentifier"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2string(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				permission, err := ec.unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx, "TASKS")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				access, err := ec.unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx, "VIEW")
				if err != nil {
					var zeroVal string
					return zeroVal, err
				}
				if ec.directives.RequireProjectAccess == nil {
					var zeroVal string
					return zeroVal, errors.New("directive requireProjectAccess is not implemented")
				}
				return ec.directives.RequireProjectAccess(ctx, obj, directive0, permission, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.ProjectIdentifier = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "requesters":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requesters"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Requesters = data
		case "revision":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("revision"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Revision = data
		case "statuses":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statuses"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Statuses = data
		case "tasks":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tasks"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tasks = data
		case "taskCaseSensitive":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskCaseSensitive"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskCaseSensitive = data
		case "variants":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("variants"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Variants = data
		case "variantCaseSensitive":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("variantCaseSensitive"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.VariantCaseSensitive = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWebhookHeaderInput(ctx context.Context, obj any) (model.APIWebhookHeader, error) {
	var it model.APIWebhookHeader
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "value":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWebhookInput(ctx context.Context, obj any) (model.APIWebHook, error) {
	var it model.APIWebHook
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"endpoint", "secret"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "endpoint":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endpoint"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Endpoint = data
		case "secret":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("secret"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2ᚖstring(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Secret = data
			} else if tmp == nil {
				it.Secret = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWebhookSubscriberInput(ctx context.Context, obj any) (model.APIWebhookSubscriber, error) {
	var it model.APIWebhookSubscriber
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	if _, present := asMap["retries"]; !present {
		asMap["retries"] = 0
	}
	if _, present := asMap["minDelayMs"]; !present {
		asMap["minDelayMs"] = 0
	}
	if _, present := asMap["timeoutMs"]; !present {
		asMap["timeoutMs"] = 0
	}

	fieldsInOrder := [...]string{"headers", "secret", "url", "retries", "minDelayMs", "timeoutMs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "headers":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("headers"))
			data, err := ec.unmarshalNWebhookHeaderInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWebhookHeaderᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Headers = data
		case "secret":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("secret"))
			directive0 := func(ctx context.Context) (any, error) { return ec.unmarshalNString2ᚖstring(ctx, v) }

			directive1 := func(ctx context.Context) (any, error) {
				if ec.directives.RedactSecrets == nil {
					var zeroVal *string
					return zeroVal, errors.New("directive redactSecrets is not implemented")
				}
				return ec.directives.RedactSecrets(ctx, obj, directive0)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Secret = data
			} else if tmp == nil {
				it.Secret = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "url":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		case "retries":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("retries"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Retries = data
		case "minDelayMs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minDelayMs"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MinDelayMS = data
		case "timeoutMs":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timeoutMs"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.TimeoutMS = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWorkstationConfigInput(ctx context.Context, obj any) (model.APIWorkstationConfig, error) {
	var it model.APIWorkstationConfig
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"gitClone", "setupCommands"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "gitClone":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gitClone"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitClone = data
		case "setupCommands":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("setupCommands"))
			data, err := ec.unmarshalOWorkstationSetupCommandInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWorkstationSetupCommandᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.SetupCommands = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWorkstationSetupCommandInput(ctx context.Context, obj any) (model.APIWorkstationSetupCommand, error) {
	var it model.APIWorkstationSetupCommand
	asMap := map[string]any{}
	for k, v := range obj.(map[string]any) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"command", "directory"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "command":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("command"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Command = data
		case "directory":
			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("directory"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Directory = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var aPIConfigImplementors = []string{"APIConfig"}

func (ec *executionContext) _APIConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIapiConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, aPIConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("APIConfig")
		case "httpListenAddr":
			out.Values[i] = ec._APIConfig_httpListenAddr(ctx, field, obj)
		case "url":
			out.Values[i] = ec._APIConfig_url(ctx, field, obj)
		case "corpUrl":
			out.Values[i] = ec._APIConfig_corpUrl(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var aWSConfigImplementors = []string{"AWSConfig"}

func (ec *executionContext) _AWSConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIAWSConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, aWSConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AWSConfig")
		case "maxVolumeSizePerUser":
			out.Values[i] = ec._AWSConfig_maxVolumeSizePerUser(ctx, field, obj)
		case "pod":
			out.Values[i] = ec._AWSConfig_pod(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var aWSPodConfigImplementors = []string{"AWSPodConfig"}

func (ec *executionContext) _AWSPodConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIAWSPodConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, aWSPodConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AWSPodConfig")
		case "ecs":
			out.Values[i] = ec._AWSPodConfig_ecs(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var abortInfoImplementors = []string{"AbortInfo"}

func (ec *executionContext) _AbortInfo(ctx context.Context, sel ast.SelectionSet, obj *AbortInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, abortInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AbortInfo")
		case "buildVariantDisplayName":
			out.Values[i] = ec._AbortInfo_buildVariantDisplayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "newVersion":
			out.Values[i] = ec._AbortInfo_newVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "prClosed":
			out.Values[i] = ec._AbortInfo_prClosed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskDisplayName":
			out.Values[i] = ec._AbortInfo_taskDisplayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskID":
			out.Values[i] = ec._AbortInfo_taskID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "user":
			out.Values[i] = ec._AbortInfo_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var adminEventImplementors = []string{"AdminEvent"}

func (ec *executionContext) _AdminEvent(ctx context.Context, sel ast.SelectionSet, obj *AdminEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adminEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdminEvent")
		case "section":
			out.Values[i] = ec._AdminEvent_section(ctx, field, obj)
		case "after":
			out.Values[i] = ec._AdminEvent_after(ctx, field, obj)
		case "before":
			out.Values[i] = ec._AdminEvent_before(ctx, field, obj)
		case "timestamp":
			out.Values[i] = ec._AdminEvent_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "user":
			out.Values[i] = ec._AdminEvent_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var adminEventsPayloadImplementors = []string{"AdminEventsPayload"}

func (ec *executionContext) _AdminEventsPayload(ctx context.Context, sel ast.SelectionSet, obj *AdminEventsPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adminEventsPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdminEventsPayload")
		case "count":
			out.Values[i] = ec._AdminEventsPayload_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "eventLogEntries":
			out.Values[i] = ec._AdminEventsPayload_eventLogEntries(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var adminSettingsImplementors = []string{"AdminSettings"}

func (ec *executionContext) _AdminSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIAdminSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adminSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdminSettings")
		case "amboy":
			out.Values[i] = ec._AdminSettings_amboy(ctx, field, obj)
		case "amboyDB":
			out.Values[i] = ec._AdminSettings_amboyDB(ctx, field, obj)
		case "authConfig":
			out.Values[i] = ec._AdminSettings_authConfig(ctx, field, obj)
		case "banner":
			out.Values[i] = ec._AdminSettings_banner(ctx, field, obj)
		case "bannerTheme":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._AdminSettings_bannerTheme(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "cedar":
			out.Values[i] = ec._AdminSettings_cedar(ctx, field, obj)
		case "fws":
			out.Values[i] = ec._AdminSettings_fws(ctx, field, obj)
		case "jira":
			out.Values[i] = ec._AdminSettings_jira(ctx, field, obj)
		case "slack":
			out.Values[i] = ec._AdminSettings_slack(ctx, field, obj)
		case "splunk":
			out.Values[i] = ec._AdminSettings_splunk(ctx, field, obj)
		case "runtimeEnvironments":
			out.Values[i] = ec._AdminSettings_runtimeEnvironments(ctx, field, obj)
		case "testSelection":
			out.Values[i] = ec._AdminSettings_testSelection(ctx, field, obj)
		case "serviceFlags":
			out.Values[i] = ec._AdminSettings_serviceFlags(ctx, field, obj)
		case "notify":
			out.Values[i] = ec._AdminSettings_notify(ctx, field, obj)
		case "taskLimits":
			out.Values[i] = ec._AdminSettings_taskLimits(ctx, field, obj)
		case "hostInit":
			out.Values[i] = ec._AdminSettings_hostInit(ctx, field, obj)
		case "podLifecycle":
			out.Values[i] = ec._AdminSettings_podLifecycle(ctx, field, obj)
		case "scheduler":
			out.Values[i] = ec._AdminSettings_scheduler(ctx, field, obj)
		case "repotracker":
			out.Values[i] = ec._AdminSettings_repotracker(ctx, field, obj)
		case "api":
			out.Values[i] = ec._AdminSettings_api(ctx, field, obj)
		case "ui":
			out.Values[i] = ec._AdminSettings_ui(ctx, field, obj)
		case "disabledGQLQueries":
			out.Values[i] = ec._AdminSettings_disabledGQLQueries(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "loggerConfig":
			out.Values[i] = ec._AdminSettings_loggerConfig(ctx, field, obj)
		case "triggers":
			out.Values[i] = ec._AdminSettings_triggers(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var adminTasksToRestartPayloadImplementors = []string{"AdminTasksToRestartPayload"}

func (ec *executionContext) _AdminTasksToRestartPayload(ctx context.Context, sel ast.SelectionSet, obj *AdminTasksToRestartPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, adminTasksToRestartPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AdminTasksToRestartPayload")
		case "tasksToRestart":
			out.Values[i] = ec._AdminTasksToRestartPayload_tasksToRestart(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var amboyConfigImplementors = []string{"AmboyConfig"}

func (ec *executionContext) _AmboyConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIAmboyConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, amboyConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AmboyConfig")
		case "name":
			out.Values[i] = ec._AmboyConfig_name(ctx, field, obj)
		case "singleName":
			out.Values[i] = ec._AmboyConfig_singleName(ctx, field, obj)
		case "poolSizeLocal":
			out.Values[i] = ec._AmboyConfig_poolSizeLocal(ctx, field, obj)
		case "poolSizeRemote":
			out.Values[i] = ec._AmboyConfig_poolSizeRemote(ctx, field, obj)
		case "localStorage":
			out.Values[i] = ec._AmboyConfig_localStorage(ctx, field, obj)
		case "groupDefaultWorkers":
			out.Values[i] = ec._AmboyConfig_groupDefaultWorkers(ctx, field, obj)
		case "groupBackgroundCreateFrequencyMinutes":
			out.Values[i] = ec._AmboyConfig_groupBackgroundCreateFrequencyMinutes(ctx, field, obj)
		case "groupPruneFrequencyMinutes":
			out.Values[i] = ec._AmboyConfig_groupPruneFrequencyMinutes(ctx, field, obj)
		case "groupTTLMinutes":
			out.Values[i] = ec._AmboyConfig_groupTTLMinutes(ctx, field, obj)
		case "lockTimeoutMinutes":
			out.Values[i] = ec._AmboyConfig_lockTimeoutMinutes(ctx, field, obj)
		case "sampleSize":
			out.Values[i] = ec._AmboyConfig_sampleSize(ctx, field, obj)
		case "retry":
			out.Values[i] = ec._AmboyConfig_retry(ctx, field, obj)
		case "namedQueues":
			out.Values[i] = ec._AmboyConfig_namedQueues(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var amboyDBConfigImplementors = []string{"AmboyDBConfig"}

func (ec *executionContext) _AmboyDBConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIAmboyDBConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, amboyDBConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AmboyDBConfig")
		case "url":
			out.Values[i] = ec._AmboyDBConfig_url(ctx, field, obj)
		case "database":
			out.Values[i] = ec._AmboyDBConfig_database(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var amboyNamedQueueConfigImplementors = []string{"AmboyNamedQueueConfig"}

func (ec *executionContext) _AmboyNamedQueueConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIAmboyNamedQueueConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, amboyNamedQueueConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AmboyNamedQueueConfig")
		case "name":
			out.Values[i] = ec._AmboyNamedQueueConfig_name(ctx, field, obj)
		case "regexp":
			out.Values[i] = ec._AmboyNamedQueueConfig_regexp(ctx, field, obj)
		case "numWorkers":
			out.Values[i] = ec._AmboyNamedQueueConfig_numWorkers(ctx, field, obj)
		case "sampleSize":
			out.Values[i] = ec._AmboyNamedQueueConfig_sampleSize(ctx, field, obj)
		case "lockTimeoutSeconds":
			out.Values[i] = ec._AmboyNamedQueueConfig_lockTimeoutSeconds(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var amboyRetryConfigImplementors = []string{"AmboyRetryConfig"}

func (ec *executionContext) _AmboyRetryConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIAmboyRetryConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, amboyRetryConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AmboyRetryConfig")
		case "numWorkers":
			out.Values[i] = ec._AmboyRetryConfig_numWorkers(ctx, field, obj)
		case "maxCapacity":
			out.Values[i] = ec._AmboyRetryConfig_maxCapacity(ctx, field, obj)
		case "maxRetryAttempts":
			out.Values[i] = ec._AmboyRetryConfig_maxRetryAttempts(ctx, field, obj)
		case "maxRetryTimeSeconds":
			out.Values[i] = ec._AmboyRetryConfig_maxRetryTimeSeconds(ctx, field, obj)
		case "retryBackoffSeconds":
			out.Values[i] = ec._AmboyRetryConfig_retryBackoffSeconds(ctx, field, obj)
		case "staleRetryingMonitorIntervalSeconds":
			out.Values[i] = ec._AmboyRetryConfig_staleRetryingMonitorIntervalSeconds(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var annotationImplementors = []string{"Annotation"}

func (ec *executionContext) _Annotation(ctx context.Context, sel ast.SelectionSet, obj *model.APITaskAnnotation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, annotationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Annotation")
		case "id":
			out.Values[i] = ec._Annotation_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdIssues":
			out.Values[i] = ec._Annotation_createdIssues(ctx, field, obj)
		case "issues":
			out.Values[i] = ec._Annotation_issues(ctx, field, obj)
		case "note":
			out.Values[i] = ec._Annotation_note(ctx, field, obj)
		case "suspectedIssues":
			out.Values[i] = ec._Annotation_suspectedIssues(ctx, field, obj)
		case "metadataLinks":
			out.Values[i] = ec._Annotation_metadataLinks(ctx, field, obj)
		case "taskId":
			out.Values[i] = ec._Annotation_taskId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "taskExecution":
			out.Values[i] = ec._Annotation_taskExecution(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "webhookConfigured":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Annotation_webhookConfigured(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var authConfigImplementors = []string{"AuthConfig"}

func (ec *executionContext) _AuthConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIAuthConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, authConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AuthConfig")
		case "okta":
			out.Values[i] = ec._AuthConfig_okta(ctx, field, obj)
		case "naive":
			out.Values[i] = ec._AuthConfig_naive(ctx, field, obj)
		case "github":
			out.Values[i] = ec._AuthConfig_github(ctx, field, obj)
		case "multi":
			out.Values[i] = ec._AuthConfig_multi(ctx, field, obj)
		case "kanopy":
			out.Values[i] = ec._AuthConfig_kanopy(ctx, field, obj)
		case "preferredType":
			out.Values[i] = ec._AuthConfig_preferredType(ctx, field, obj)
		case "backgroundReauthMinutes":
			out.Values[i] = ec._AuthConfig_backgroundReauthMinutes(ctx, field, obj)
		case "allowServiceUsers":
			out.Values[i] = ec._AuthConfig_allowServiceUsers(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var authUserImplementors = []string{"AuthUser"}

func (ec *executionContext) _AuthUser(ctx context.Context, sel ast.SelectionSet, obj *model.APIAuthUser) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, authUserImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AuthUser")
		case "username":
			out.Values[i] = ec._AuthUser_username(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._AuthUser_displayName(ctx, field, obj)
		case "password":
			out.Values[i] = ec._AuthUser_password(ctx, field, obj)
		case "email":
			out.Values[i] = ec._AuthUser_email(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var betaFeaturesImplementors = []string{"BetaFeatures"}

func (ec *executionContext) _BetaFeatures(ctx context.Context, sel ast.SelectionSet, obj *model.APIBetaFeatures) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, betaFeaturesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BetaFeatures")
		case "spruceWaterfallEnabled":
			out.Values[i] = ec._BetaFeatures_spruceWaterfallEnabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var bootstrapSettingsImplementors = []string{"BootstrapSettings"}

func (ec *executionContext) _BootstrapSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIBootstrapSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bootstrapSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BootstrapSettings")
		case "clientDir":
			out.Values[i] = ec._BootstrapSettings_clientDir(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "communication":
			out.Values[i] = ec._BootstrapSettings_communication(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "env":
			out.Values[i] = ec._BootstrapSettings_env(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "jasperBinaryDir":
			out.Values[i] = ec._BootstrapSettings_jasperBinaryDir(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "jasperCredentialsPath":
			out.Values[i] = ec._BootstrapSettings_jasperCredentialsPath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "method":
			out.Values[i] = ec._BootstrapSettings_method(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "preconditionScripts":
			out.Values[i] = ec._BootstrapSettings_preconditionScripts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceLimits":
			out.Values[i] = ec._BootstrapSettings_resourceLimits(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rootDir":
			out.Values[i] = ec._BootstrapSettings_rootDir(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "serviceUser":
			out.Values[i] = ec._BootstrapSettings_serviceUser(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "shellPath":
			out.Values[i] = ec._BootstrapSettings_shellPath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var buildImplementors = []string{"Build"}

func (ec *executionContext) _Build(ctx context.Context, sel ast.SelectionSet, obj *model.APIBuild) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, buildImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Build")
		case "id":
			out.Values[i] = ec._Build_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "actualMakespan":
			out.Values[i] = ec._Build_actualMakespan(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "buildVariant":
			out.Values[i] = ec._Build_buildVariant(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "predictedMakespan":
			out.Values[i] = ec._Build_predictedMakespan(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._Build_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var buildBaronImplementors = []string{"BuildBaron"}

func (ec *executionContext) _BuildBaron(ctx context.Context, sel ast.SelectionSet, obj *BuildBaron) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, buildBaronImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BuildBaron")
		case "bbTicketCreationDefined":
			out.Values[i] = ec._BuildBaron_bbTicketCreationDefined(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "buildBaronConfigured":
			out.Values[i] = ec._BuildBaron_buildBaronConfigured(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "searchReturnInfo":
			out.Values[i] = ec._BuildBaron_searchReturnInfo(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var buildBaronSettingsImplementors = []string{"BuildBaronSettings"}

func (ec *executionContext) _BuildBaronSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIBuildBaronSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, buildBaronSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BuildBaronSettings")
		case "bfSuggestionFeaturesURL":
			out.Values[i] = ec._BuildBaronSettings_bfSuggestionFeaturesURL(ctx, field, obj)
		case "bfSuggestionPassword":
			out.Values[i] = ec._BuildBaronSettings_bfSuggestionPassword(ctx, field, obj)
		case "bfSuggestionServer":
			out.Values[i] = ec._BuildBaronSettings_bfSuggestionServer(ctx, field, obj)
		case "bfSuggestionTimeoutSecs":
			out.Values[i] = ec._BuildBaronSettings_bfSuggestionTimeoutSecs(ctx, field, obj)
		case "bfSuggestionUsername":
			out.Values[i] = ec._BuildBaronSettings_bfSuggestionUsername(ctx, field, obj)
		case "ticketCreateProject":
			out.Values[i] = ec._BuildBaronSettings_ticketCreateProject(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ticketSearchProjects":
			out.Values[i] = ec._BuildBaronSettings_ticketSearchProjects(ctx, field, obj)
		case "ticketCreateIssueType":
			out.Values[i] = ec._BuildBaronSettings_ticketCreateIssueType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var buildVariantTupleImplementors = []string{"BuildVariantTuple"}

func (ec *executionContext) _BuildVariantTuple(ctx context.Context, sel ast.SelectionSet, obj *task.BuildVariantTuple) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, buildVariantTupleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BuildVariantTuple")
		case "buildVariant":
			out.Values[i] = ec._BuildVariantTuple_buildVariant(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "displayName":
			out.Values[i] = ec._BuildVariantTuple_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var cedarConfigImplementors = []string{"CedarConfig"}

func (ec *executionContext) _CedarConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APICedarConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cedarConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CedarConfig")
		case "dbUrl":
			out.Values[i] = ec._CedarConfig_dbUrl(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "dbName":
			out.Values[i] = ec._CedarConfig_dbName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var childPatchAliasImplementors = []string{"ChildPatchAlias"}

func (ec *executionContext) _ChildPatchAlias(ctx context.Context, sel ast.SelectionSet, obj *model.APIChildPatchAlias) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, childPatchAliasImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChildPatchAlias")
		case "alias":
			out.Values[i] = ec._ChildPatchAlias_alias(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "patchId":
			out.Values[i] = ec._ChildPatchAlias_patchId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var clientBinaryImplementors = []string{"ClientBinary"}

func (ec *executionContext) _ClientBinary(ctx context.Context, sel ast.SelectionSet, obj *model.APIClientBinary) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, clientBinaryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ClientBinary")
		case "arch":
			out.Values[i] = ec._ClientBinary_arch(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._ClientBinary_displayName(ctx, field, obj)
		case "os":
			out.Values[i] = ec._ClientBinary_os(ctx, field, obj)
		case "url":
			out.Values[i] = ec._ClientBinary_url(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var clientConfigImplementors = []string{"ClientConfig"}

func (ec *executionContext) _ClientConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIClientConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, clientConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ClientConfig")
		case "clientBinaries":
			out.Values[i] = ec._ClientConfig_clientBinaries(ctx, field, obj)
		case "latestRevision":
			out.Values[i] = ec._ClientConfig_latestRevision(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var cloudProviderConfigImplementors = []string{"CloudProviderConfig"}

func (ec *executionContext) _CloudProviderConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APICloudProviders) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cloudProviderConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CloudProviderConfig")
		case "aws":
			out.Values[i] = ec._CloudProviderConfig_aws(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var commitQueueParamsImplementors = []string{"CommitQueueParams"}

func (ec *executionContext) _CommitQueueParams(ctx context.Context, sel ast.SelectionSet, obj *model.APICommitQueueParams) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, commitQueueParamsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CommitQueueParams")
		case "enabled":
			out.Values[i] = ec._CommitQueueParams_enabled(ctx, field, obj)
		case "mergeMethod":
			out.Values[i] = ec._CommitQueueParams_mergeMethod(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._CommitQueueParams_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var containerPoolImplementors = []string{"ContainerPool"}

func (ec *executionContext) _ContainerPool(ctx context.Context, sel ast.SelectionSet, obj *model.APIContainerPool) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, containerPoolImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ContainerPool")
		case "id":
			out.Values[i] = ec._ContainerPool_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "distro":
			out.Values[i] = ec._ContainerPool_distro(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "maxContainers":
			out.Values[i] = ec._ContainerPool_maxContainers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "port":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ContainerPool_port(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var containerPoolsConfigImplementors = []string{"ContainerPoolsConfig"}

func (ec *executionContext) _ContainerPoolsConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIContainerPoolsConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, containerPoolsConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ContainerPoolsConfig")
		case "pools":
			out.Values[i] = ec._ContainerPoolsConfig_pools(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var containerResourcesImplementors = []string{"ContainerResources"}

func (ec *executionContext) _ContainerResources(ctx context.Context, sel ast.SelectionSet, obj *model.APIContainerResources) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, containerResourcesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ContainerResources")
		case "name":
			out.Values[i] = ec._ContainerResources_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cpu":
			out.Values[i] = ec._ContainerResources_cpu(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "memoryMb":
			out.Values[i] = ec._ContainerResources_memoryMb(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deleteDistroPayloadImplementors = []string{"DeleteDistroPayload"}

func (ec *executionContext) _DeleteDistroPayload(ctx context.Context, sel ast.SelectionSet, obj *DeleteDistroPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteDistroPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteDistroPayload")
		case "deletedDistroId":
			out.Values[i] = ec._DeleteDistroPayload_deletedDistroId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var deleteGithubAppCredentialsPayloadImplementors = []string{"DeleteGithubAppCredentialsPayload"}

func (ec *executionContext) _DeleteGithubAppCredentialsPayload(ctx context.Context, sel ast.SelectionSet, obj *DeleteGithubAppCredentialsPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteGithubAppCredentialsPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteGithubAppCredentialsPayload")
		case "oldAppId":
			out.Values[i] = ec._DeleteGithubAppCredentialsPayload_oldAppId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dependencyImplementors = []string{"Dependency"}

func (ec *executionContext) _Dependency(ctx context.Context, sel ast.SelectionSet, obj *Dependency) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dependencyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Dependency")
		case "buildVariant":
			out.Values[i] = ec._Dependency_buildVariant(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "metStatus":
			out.Values[i] = ec._Dependency_metStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._Dependency_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requiredStatus":
			out.Values[i] = ec._Dependency_requiredStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskId":
			out.Values[i] = ec._Dependency_taskId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var dispatcherSettingsImplementors = []string{"DispatcherSettings"}

func (ec *executionContext) _DispatcherSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIDispatcherSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dispatcherSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DispatcherSettings")
		case "version":
			out.Values[i] = ec._DispatcherSettings_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var distroImplementors = []string{"Distro"}

func (ec *executionContext) _Distro(ctx context.Context, sel ast.SelectionSet, obj *model.APIDistro) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, distroImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Distro")
		case "adminOnly":
			out.Values[i] = ec._Distro_adminOnly(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "aliases":
			out.Values[i] = ec._Distro_aliases(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "arch":
			out.Values[i] = ec._Distro_arch(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "authorizedKeysFile":
			out.Values[i] = ec._Distro_authorizedKeysFile(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "availableRegions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Distro_availableRegions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "bootstrapSettings":
			out.Values[i] = ec._Distro_bootstrapSettings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "containerPool":
			out.Values[i] = ec._Distro_containerPool(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "disabled":
			out.Values[i] = ec._Distro_disabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "disableShallowClone":
			out.Values[i] = ec._Distro_disableShallowClone(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "dispatcherSettings":
			out.Values[i] = ec._Distro_dispatcherSettings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "execUser":
			out.Values[i] = ec._Distro_execUser(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "expansions":
			out.Values[i] = ec._Distro_expansions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "finderSettings":
			out.Values[i] = ec._Distro_finderSettings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "homeVolumeSettings":
			out.Values[i] = ec._Distro_homeVolumeSettings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "hostAllocatorSettings":
			out.Values[i] = ec._Distro_hostAllocatorSettings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "iceCreamSettings":
			out.Values[i] = ec._Distro_iceCreamSettings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "imageId":
			out.Values[i] = ec._Distro_imageId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "isCluster":
			out.Values[i] = ec._Distro_isCluster(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "isVirtualWorkStation":
			out.Values[i] = ec._Distro_isVirtualWorkStation(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "mountpoints":
			out.Values[i] = ec._Distro_mountpoints(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "name":
			out.Values[i] = ec._Distro_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "note":
			out.Values[i] = ec._Distro_note(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "plannerSettings":
			out.Values[i] = ec._Distro_plannerSettings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "provider":
			out.Values[i] = ec._Distro_provider(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "providerAccount":
			out.Values[i] = ec._Distro_providerAccount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "providerSettingsList":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Distro_providerSettingsList(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "setup":
			out.Values[i] = ec._Distro_setup(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "setupAsSudo":
			out.Values[i] = ec._Distro_setupAsSudo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "singleTaskDistro":
			out.Values[i] = ec._Distro_singleTaskDistro(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "sshOptions":
			out.Values[i] = ec._Distro_sshOptions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "user":
			out.Values[i] = ec._Distro_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "userSpawnAllowed":
			out.Values[i] = ec._Distro_userSpawnAllowed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "validProjects":
			out.Values[i] = ec._Distro_validProjects(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "warningNote":
			out.Values[i] = ec._Distro_warningNote(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "workDir":
			out.Values[i] = ec._Distro_workDir(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var distroEventImplementors = []string{"DistroEvent"}

func (ec *executionContext) _DistroEvent(ctx context.Context, sel ast.SelectionSet, obj *DistroEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, distroEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DistroEvent")
		case "after":
			out.Values[i] = ec._DistroEvent_after(ctx, field, obj)
		case "before":
			out.Values[i] = ec._DistroEvent_before(ctx, field, obj)
		case "data":
			out.Values[i] = ec._DistroEvent_data(ctx, field, obj)
		case "timestamp":
			out.Values[i] = ec._DistroEvent_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "user":
			out.Values[i] = ec._DistroEvent_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var distroEventsPayloadImplementors = []string{"DistroEventsPayload"}

func (ec *executionContext) _DistroEventsPayload(ctx context.Context, sel ast.SelectionSet, obj *DistroEventsPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, distroEventsPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DistroEventsPayload")
		case "count":
			out.Values[i] = ec._DistroEventsPayload_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "eventLogEntries":
			out.Values[i] = ec._DistroEventsPayload_eventLogEntries(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var distroInfoImplementors = []string{"DistroInfo"}

func (ec *executionContext) _DistroInfo(ctx context.Context, sel ast.SelectionSet, obj *model.DistroInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, distroInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DistroInfo")
		case "id":
			out.Values[i] = ec._DistroInfo_id(ctx, field, obj)
		case "bootstrapMethod":
			out.Values[i] = ec._DistroInfo_bootstrapMethod(ctx, field, obj)
		case "isVirtualWorkStation":
			out.Values[i] = ec._DistroInfo_isVirtualWorkStation(ctx, field, obj)
		case "isWindows":
			out.Values[i] = ec._DistroInfo_isWindows(ctx, field, obj)
		case "user":
			out.Values[i] = ec._DistroInfo_user(ctx, field, obj)
		case "workDir":
			out.Values[i] = ec._DistroInfo_workDir(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var distroPermissionsImplementors = []string{"DistroPermissions"}

func (ec *executionContext) _DistroPermissions(ctx context.Context, sel ast.SelectionSet, obj *DistroPermissions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, distroPermissionsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DistroPermissions")
		case "admin":
			out.Values[i] = ec._DistroPermissions_admin(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "edit":
			out.Values[i] = ec._DistroPermissions_edit(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "view":
			out.Values[i] = ec._DistroPermissions_view(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var eCSConfigImplementors = []string{"ECSConfig"}

func (ec *executionContext) _ECSConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIECSConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eCSConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ECSConfig")
		case "maxCPU":
			out.Values[i] = ec._ECSConfig_maxCPU(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "maxMemoryMb":
			out.Values[i] = ec._ECSConfig_maxMemoryMb(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var envVarImplementors = []string{"EnvVar"}

func (ec *executionContext) _EnvVar(ctx context.Context, sel ast.SelectionSet, obj *model.APIEnvVar) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, envVarImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EnvVar")
		case "key":
			out.Values[i] = ec._EnvVar_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "value":
			out.Values[i] = ec._EnvVar_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var expansionImplementors = []string{"Expansion"}

func (ec *executionContext) _Expansion(ctx context.Context, sel ast.SelectionSet, obj *model.APIExpansion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, expansionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Expansion")
		case "key":
			out.Values[i] = ec._Expansion_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "value":
			out.Values[i] = ec._Expansion_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var externalLinkImplementors = []string{"ExternalLink"}

func (ec *executionContext) _ExternalLink(ctx context.Context, sel ast.SelectionSet, obj *model.APIExternalLink) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, externalLinkImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ExternalLink")
		case "displayName":
			out.Values[i] = ec._ExternalLink_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requesters":
			out.Values[i] = ec._ExternalLink_requesters(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "urlTemplate":
			out.Values[i] = ec._ExternalLink_urlTemplate(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var externalLinkForMetadataImplementors = []string{"ExternalLinkForMetadata"}

func (ec *executionContext) _ExternalLinkForMetadata(ctx context.Context, sel ast.SelectionSet, obj *ExternalLinkForMetadata) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, externalLinkForMetadataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ExternalLinkForMetadata")
		case "url":
			out.Values[i] = ec._ExternalLinkForMetadata_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "displayName":
			out.Values[i] = ec._ExternalLinkForMetadata_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var fWSConfigImplementors = []string{"FWSConfig"}

func (ec *executionContext) _FWSConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIFWSConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fWSConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FWSConfig")
		case "url":
			out.Values[i] = ec._FWSConfig_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var failingCommandImplementors = []string{"FailingCommand"}

func (ec *executionContext) _FailingCommand(ctx context.Context, sel ast.SelectionSet, obj *model.APIFailingCommand) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, failingCommandImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FailingCommand")
		case "fullDisplayName":
			out.Values[i] = ec._FailingCommand_fullDisplayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "failureMetadataTags":
			out.Values[i] = ec._FailingCommand_failureMetadataTags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var fileImplementors = []string{"File"}

func (ec *executionContext) _File(ctx context.Context, sel ast.SelectionSet, obj *model.APIFile) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fileImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("File")
		case "link":
			out.Values[i] = ec._File_link(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._File_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "urlParsley":
			out.Values[i] = ec._File_urlParsley(ctx, field, obj)
		case "visibility":
			out.Values[i] = ec._File_visibility(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var fileDiffImplementors = []string{"FileDiff"}

func (ec *executionContext) _FileDiff(ctx context.Context, sel ast.SelectionSet, obj *model.FileDiff) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fileDiffImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FileDiff")
		case "additions":
			out.Values[i] = ec._FileDiff_additions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deletions":
			out.Values[i] = ec._FileDiff_deletions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._FileDiff_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "diffLink":
			out.Values[i] = ec._FileDiff_diffLink(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fileName":
			out.Values[i] = ec._FileDiff_fileName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var finderSettingsImplementors = []string{"FinderSettings"}

func (ec *executionContext) _FinderSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIFinderSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, finderSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FinderSettings")
		case "version":
			out.Values[i] = ec._FinderSettings_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var generalSubscriptionImplementors = []string{"GeneralSubscription"}

func (ec *executionContext) _GeneralSubscription(ctx context.Context, sel ast.SelectionSet, obj *model.APISubscription) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, generalSubscriptionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GeneralSubscription")
		case "id":
			out.Values[i] = ec._GeneralSubscription_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ownerType":
			out.Values[i] = ec._GeneralSubscription_ownerType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "regexSelectors":
			out.Values[i] = ec._GeneralSubscription_regexSelectors(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._GeneralSubscription_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "selectors":
			out.Values[i] = ec._GeneralSubscription_selectors(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "subscriber":
			out.Values[i] = ec._GeneralSubscription_subscriber(ctx, field, obj)
		case "trigger":
			out.Values[i] = ec._GeneralSubscription_trigger(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "triggerData":
			out.Values[i] = ec._GeneralSubscription_triggerData(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var generatedTaskCountResultsImplementors = []string{"GeneratedTaskCountResults"}

func (ec *executionContext) _GeneratedTaskCountResults(ctx context.Context, sel ast.SelectionSet, obj *GeneratedTaskCountResults) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, generatedTaskCountResultsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GeneratedTaskCountResults")
		case "buildVariantName":
			out.Values[i] = ec._GeneratedTaskCountResults_buildVariantName(ctx, field, obj)
		case "taskName":
			out.Values[i] = ec._GeneratedTaskCountResults_taskName(ctx, field, obj)
		case "taskId":
			out.Values[i] = ec._GeneratedTaskCountResults_taskId(ctx, field, obj)
		case "estimatedTasks":
			out.Values[i] = ec._GeneratedTaskCountResults_estimatedTasks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gitHubAuthConfigImplementors = []string{"GitHubAuthConfig"}

func (ec *executionContext) _GitHubAuthConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIGithubAuthConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gitHubAuthConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GitHubAuthConfig")
		case "appId":
			out.Values[i] = ec._GitHubAuthConfig_appId(ctx, field, obj)
		case "clientId":
			out.Values[i] = ec._GitHubAuthConfig_clientId(ctx, field, obj)
		case "clientSecret":
			out.Values[i] = ec._GitHubAuthConfig_clientSecret(ctx, field, obj)
		case "defaultOwner":
			out.Values[i] = ec._GitHubAuthConfig_defaultOwner(ctx, field, obj)
		case "defaultRepo":
			out.Values[i] = ec._GitHubAuthConfig_defaultRepo(ctx, field, obj)
		case "organization":
			out.Values[i] = ec._GitHubAuthConfig_organization(ctx, field, obj)
		case "users":
			out.Values[i] = ec._GitHubAuthConfig_users(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gitHubDynamicTokenPermissionGroupImplementors = []string{"GitHubDynamicTokenPermissionGroup"}

func (ec *executionContext) _GitHubDynamicTokenPermissionGroup(ctx context.Context, sel ast.SelectionSet, obj *model.APIGitHubDynamicTokenPermissionGroup) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gitHubDynamicTokenPermissionGroupImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GitHubDynamicTokenPermissionGroup")
		case "name":
			out.Values[i] = ec._GitHubDynamicTokenPermissionGroup_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "permissions":
			out.Values[i] = ec._GitHubDynamicTokenPermissionGroup_permissions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var gitTagImplementors = []string{"GitTag"}

func (ec *executionContext) _GitTag(ctx context.Context, sel ast.SelectionSet, obj *model.APIGitTag) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gitTagImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GitTag")
		case "tag":
			out.Values[i] = ec._GitTag_tag(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pusher":
			out.Values[i] = ec._GitTag_pusher(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var githubAppAuthImplementors = []string{"GithubAppAuth"}

func (ec *executionContext) _GithubAppAuth(ctx context.Context, sel ast.SelectionSet, obj *model.APIGithubAppAuth) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubAppAuthImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubAppAuth")
		case "appId":
			out.Values[i] = ec._GithubAppAuth_appId(ctx, field, obj)
		case "privateKey":
			out.Values[i] = ec._GithubAppAuth_privateKey(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var githubCheckSubscriberImplementors = []string{"GithubCheckSubscriber"}

func (ec *executionContext) _GithubCheckSubscriber(ctx context.Context, sel ast.SelectionSet, obj *model.APIGithubCheckSubscriber) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubCheckSubscriberImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubCheckSubscriber")
		case "owner":
			out.Values[i] = ec._GithubCheckSubscriber_owner(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ref":
			out.Values[i] = ec._GithubCheckSubscriber_ref(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "repo":
			out.Values[i] = ec._GithubCheckSubscriber_repo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var githubPRSubscriberImplementors = []string{"GithubPRSubscriber"}

func (ec *executionContext) _GithubPRSubscriber(ctx context.Context, sel ast.SelectionSet, obj *model.APIGithubPRSubscriber) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubPRSubscriberImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubPRSubscriber")
		case "owner":
			out.Values[i] = ec._GithubPRSubscriber_owner(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "prNumber":
			out.Values[i] = ec._GithubPRSubscriber_prNumber(ctx, field, obj)
		case "ref":
			out.Values[i] = ec._GithubPRSubscriber_ref(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "repo":
			out.Values[i] = ec._GithubPRSubscriber_repo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var githubPatchImplementors = []string{"GithubPatch"}

func (ec *executionContext) _GithubPatch(ctx context.Context, sel ast.SelectionSet, obj *model.APIGithubPatch) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubPatchImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubPatch")
		case "author":
			out.Values[i] = ec._GithubPatch_author(ctx, field, obj)
		case "baseOwner":
			out.Values[i] = ec._GithubPatch_baseOwner(ctx, field, obj)
		case "baseRepo":
			out.Values[i] = ec._GithubPatch_baseRepo(ctx, field, obj)
		case "headBranch":
			out.Values[i] = ec._GithubPatch_headBranch(ctx, field, obj)
		case "headHash":
			out.Values[i] = ec._GithubPatch_headHash(ctx, field, obj)
		case "headOwner":
			out.Values[i] = ec._GithubPatch_headOwner(ctx, field, obj)
		case "headRepo":
			out.Values[i] = ec._GithubPatch_headRepo(ctx, field, obj)
		case "prNumber":
			out.Values[i] = ec._GithubPatch_prNumber(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var githubProjectConflictsImplementors = []string{"GithubProjectConflicts"}

func (ec *executionContext) _GithubProjectConflicts(ctx context.Context, sel ast.SelectionSet, obj *model1.GithubProjectConflicts) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubProjectConflictsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubProjectConflicts")
		case "commitCheckIdentifiers":
			out.Values[i] = ec._GithubProjectConflicts_commitCheckIdentifiers(ctx, field, obj)
		case "commitQueueIdentifiers":
			out.Values[i] = ec._GithubProjectConflicts_commitQueueIdentifiers(ctx, field, obj)
		case "prTestingIdentifiers":
			out.Values[i] = ec._GithubProjectConflicts_prTestingIdentifiers(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var githubUserImplementors = []string{"GithubUser"}

func (ec *executionContext) _GithubUser(ctx context.Context, sel ast.SelectionSet, obj *model.APIGithubUser) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubUserImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubUser")
		case "lastKnownAs":
			out.Values[i] = ec._GithubUser_lastKnownAs(ctx, field, obj)
		case "uid":
			out.Values[i] = ec._GithubUser_uid(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var groupedBuildVariantImplementors = []string{"GroupedBuildVariant"}

func (ec *executionContext) _GroupedBuildVariant(ctx context.Context, sel ast.SelectionSet, obj *GroupedBuildVariant) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupedBuildVariantImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GroupedBuildVariant")
		case "displayName":
			out.Values[i] = ec._GroupedBuildVariant_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "tasks":
			out.Values[i] = ec._GroupedBuildVariant_tasks(ctx, field, obj)
		case "variant":
			out.Values[i] = ec._GroupedBuildVariant_variant(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var groupedFilesImplementors = []string{"GroupedFiles"}

func (ec *executionContext) _GroupedFiles(ctx context.Context, sel ast.SelectionSet, obj *GroupedFiles) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupedFilesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GroupedFiles")
		case "files":
			out.Values[i] = ec._GroupedFiles_files(ctx, field, obj)
		case "taskName":
			out.Values[i] = ec._GroupedFiles_taskName(ctx, field, obj)
		case "taskId":
			out.Values[i] = ec._GroupedFiles_taskId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "execution":
			out.Values[i] = ec._GroupedFiles_execution(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var groupedProjectsImplementors = []string{"GroupedProjects"}

func (ec *executionContext) _GroupedProjects(ctx context.Context, sel ast.SelectionSet, obj *GroupedProjects) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupedProjectsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GroupedProjects")
		case "groupDisplayName":
			out.Values[i] = ec._GroupedProjects_groupDisplayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "projects":
			out.Values[i] = ec._GroupedProjects_projects(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "repo":
			out.Values[i] = ec._GroupedProjects_repo(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var groupedTaskStatusCountImplementors = []string{"GroupedTaskStatusCount"}

func (ec *executionContext) _GroupedTaskStatusCount(ctx context.Context, sel ast.SelectionSet, obj *task.GroupedTaskStatusCount) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupedTaskStatusCountImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GroupedTaskStatusCount")
		case "displayName":
			out.Values[i] = ec._GroupedTaskStatusCount_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "statusCounts":
			out.Values[i] = ec._GroupedTaskStatusCount_statusCounts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "variant":
			out.Values[i] = ec._GroupedTaskStatusCount_variant(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var homeVolumeSettingsImplementors = []string{"HomeVolumeSettings"}

func (ec *executionContext) _HomeVolumeSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIHomeVolumeSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, homeVolumeSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HomeVolumeSettings")
		case "formatCommand":
			out.Values[i] = ec._HomeVolumeSettings_formatCommand(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var hostImplementors = []string{"Host"}

func (ec *executionContext) _Host(ctx context.Context, sel ast.SelectionSet, obj *model.APIHost) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hostImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Host")
		case "id":
			out.Values[i] = ec._Host_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "availabilityZone":
			out.Values[i] = ec._Host_availabilityZone(ctx, field, obj)
		case "ami":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_ami(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "displayName":
			out.Values[i] = ec._Host_displayName(ctx, field, obj)
		case "distro":
			out.Values[i] = ec._Host_distro(ctx, field, obj)
		case "distroId":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_distroId(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "elapsed":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_elapsed(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "events":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_events(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "eventTypes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_eventTypes(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "expiration":
			out.Values[i] = ec._Host_expiration(ctx, field, obj)
		case "hostUrl":
			out.Values[i] = ec._Host_hostUrl(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "homeVolume":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_homeVolume(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "homeVolumeID":
			out.Values[i] = ec._Host_homeVolumeID(ctx, field, obj)
		case "instanceType":
			out.Values[i] = ec._Host_instanceType(ctx, field, obj)
		case "instanceTags":
			out.Values[i] = ec._Host_instanceTags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "lastCommunicationTime":
			out.Values[i] = ec._Host_lastCommunicationTime(ctx, field, obj)
		case "noExpiration":
			out.Values[i] = ec._Host_noExpiration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "persistentDnsName":
			out.Values[i] = ec._Host_persistentDnsName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "provider":
			out.Values[i] = ec._Host_provider(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "runningTask":
			out.Values[i] = ec._Host_runningTask(ctx, field, obj)
		case "sleepSchedule":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_sleepSchedule(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "startedBy":
			out.Values[i] = ec._Host_startedBy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "status":
			out.Values[i] = ec._Host_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tag":
			out.Values[i] = ec._Host_tag(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "totalIdleTime":
			out.Values[i] = ec._Host_totalIdleTime(ctx, field, obj)
		case "uptime":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_uptime(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "user":
			out.Values[i] = ec._Host_user(ctx, field, obj)
		case "volumes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_volumes(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var hostAllocatorSettingsImplementors = []string{"HostAllocatorSettings"}

func (ec *executionContext) _HostAllocatorSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIHostAllocatorSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hostAllocatorSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HostAllocatorSettings")
		case "acceptableHostIdleTime":
			out.Values[i] = ec._HostAllocatorSettings_acceptableHostIdleTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "autoTuneMaximumHosts":
			out.Values[i] = ec._HostAllocatorSettings_autoTuneMaximumHosts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "feedbackRule":
			out.Values[i] = ec._HostAllocatorSettings_feedbackRule(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "futureHostFraction":
			out.Values[i] = ec._HostAllocatorSettings_futureHostFraction(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hostsOverallocatedRule":
			out.Values[i] = ec._HostAllocatorSettings_hostsOverallocatedRule(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "maximumHosts":
			out.Values[i] = ec._HostAllocatorSettings_maximumHosts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "minimumHosts":
			out.Values[i] = ec._HostAllocatorSettings_minimumHosts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "roundingRule":
			out.Values[i] = ec._HostAllocatorSettings_roundingRule(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._HostAllocatorSettings_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var hostEventLogDataImplementors = []string{"HostEventLogData"}

func (ec *executionContext) _HostEventLogData(ctx context.Context, sel ast.SelectionSet, obj *model.HostAPIEventData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hostEventLogDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HostEventLogData")
		case "agentBuild":
			out.Values[i] = ec._HostEventLogData_agentBuild(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "agentRevision":
			out.Values[i] = ec._HostEventLogData_agentRevision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "duration":
			out.Values[i] = ec._HostEventLogData_duration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "execution":
			out.Values[i] = ec._HostEventLogData_execution(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hostname":
			out.Values[i] = ec._HostEventLogData_hostname(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "jasperRevision":
			out.Values[i] = ec._HostEventLogData_jasperRevision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "logs":
			out.Values[i] = ec._HostEventLogData_logs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "monitorOp":
			out.Values[i] = ec._HostEventLogData_monitorOp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "newStatus":
			out.Values[i] = ec._HostEventLogData_newStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "oldStatus":
			out.Values[i] = ec._HostEventLogData_oldStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "provisioningMethod":
			out.Values[i] = ec._HostEventLogData_provisioningMethod(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "successful":
			out.Values[i] = ec._HostEventLogData_successful(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskId":
			out.Values[i] = ec._HostEventLogData_taskId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskPid":
			out.Values[i] = ec._HostEventLogData_taskPid(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskStatus":
			out.Values[i] = ec._HostEventLogData_taskStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "user":
			out.Values[i] = ec._HostEventLogData_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var hostEventLogEntryImplementors = []string{"HostEventLogEntry"}

func (ec *executionContext) _HostEventLogEntry(ctx context.Context, sel ast.SelectionSet, obj *model.HostAPIEventLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hostEventLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HostEventLogEntry")
		case "id":
			out.Values[i] = ec._HostEventLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._HostEventLogEntry_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "eventType":
			out.Values[i] = ec._HostEventLogEntry_eventType(ctx, field, obj)
		case "processedAt":
			out.Values[i] = ec._HostEventLogEntry_processedAt(ctx, field, obj)
		case "resourceId":
			out.Values[i] = ec._HostEventLogEntry_resourceId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._HostEventLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timestamp":
			out.Values[i] = ec._HostEventLogEntry_timestamp(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var hostEventsImplementors = []string{"HostEvents"}

func (ec *executionContext) _HostEvents(ctx context.Context, sel ast.SelectionSet, obj *HostEvents) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hostEventsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HostEvents")
		case "count":
			out.Values[i] = ec._HostEvents_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "eventLogEntries":
			out.Values[i] = ec._HostEvents_eventLogEntries(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var hostInitConfigImplementors = []string{"HostInitConfig"}

func (ec *executionContext) _HostInitConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIHostInitConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hostInitConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HostInitConfig")
		case "hostThrottle":
			out.Values[i] = ec._HostInitConfig_hostThrottle(ctx, field, obj)
		case "provisioningThrottle":
			out.Values[i] = ec._HostInitConfig_provisioningThrottle(ctx, field, obj)
		case "cloudStatusBatchSize":
			out.Values[i] = ec._HostInitConfig_cloudStatusBatchSize(ctx, field, obj)
		case "maxTotalDynamicHosts":
			out.Values[i] = ec._HostInitConfig_maxTotalDynamicHosts(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var hostsResponseImplementors = []string{"HostsResponse"}

func (ec *executionContext) _HostsResponse(ctx context.Context, sel ast.SelectionSet, obj *HostsResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hostsResponseImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HostsResponse")
		case "filteredHostsCount":
			out.Values[i] = ec._HostsResponse_filteredHostsCount(ctx, field, obj)
		case "hosts":
			out.Values[i] = ec._HostsResponse_hosts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalHostsCount":
			out.Values[i] = ec._HostsResponse_totalHostsCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var iceCreamSettingsImplementors = []string{"IceCreamSettings"}

func (ec *executionContext) _IceCreamSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIIceCreamSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, iceCreamSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IceCreamSettings")
		case "configPath":
			out.Values[i] = ec._IceCreamSettings_configPath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "schedulerHost":
			out.Values[i] = ec._IceCreamSettings_schedulerHost(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageImplementors = []string{"Image"}

func (ec *executionContext) _Image(ctx context.Context, sel ast.SelectionSet, obj *model.APIImage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Image")
		case "id":
			out.Values[i] = ec._Image_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "ami":
			out.Values[i] = ec._Image_ami(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "distros":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Image_distros(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "events":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Image_events(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "lastDeployed":
			out.Values[i] = ec._Image_lastDeployed(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "latestTask":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Image_latestTask(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "operatingSystem":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Image_operatingSystem(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "packages":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Image_packages(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "toolchains":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Image_toolchains(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageEventImplementors = []string{"ImageEvent"}

func (ec *executionContext) _ImageEvent(ctx context.Context, sel ast.SelectionSet, obj *model.APIImageEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageEventImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageEvent")
		case "entries":
			out.Values[i] = ec._ImageEvent_entries(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timestamp":
			out.Values[i] = ec._ImageEvent_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "amiBefore":
			out.Values[i] = ec._ImageEvent_amiBefore(ctx, field, obj)
		case "amiAfter":
			out.Values[i] = ec._ImageEvent_amiAfter(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageEventEntryImplementors = []string{"ImageEventEntry"}

func (ec *executionContext) _ImageEventEntry(ctx context.Context, sel ast.SelectionSet, obj *model.APIImageEventEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageEventEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageEventEntry")
		case "name":
			out.Values[i] = ec._ImageEventEntry_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "after":
			out.Values[i] = ec._ImageEventEntry_after(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "before":
			out.Values[i] = ec._ImageEventEntry_before(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._ImageEventEntry_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "action":
			out.Values[i] = ec._ImageEventEntry_action(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageEventsPayloadImplementors = []string{"ImageEventsPayload"}

func (ec *executionContext) _ImageEventsPayload(ctx context.Context, sel ast.SelectionSet, obj *ImageEventsPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageEventsPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageEventsPayload")
		case "count":
			out.Values[i] = ec._ImageEventsPayload_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "eventLogEntries":
			out.Values[i] = ec._ImageEventsPayload_eventLogEntries(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageOperatingSystemPayloadImplementors = []string{"ImageOperatingSystemPayload"}

func (ec *executionContext) _ImageOperatingSystemPayload(ctx context.Context, sel ast.SelectionSet, obj *ImageOperatingSystemPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageOperatingSystemPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageOperatingSystemPayload")
		case "data":
			out.Values[i] = ec._ImageOperatingSystemPayload_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "filteredCount":
			out.Values[i] = ec._ImageOperatingSystemPayload_filteredCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._ImageOperatingSystemPayload_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imagePackagesPayloadImplementors = []string{"ImagePackagesPayload"}

func (ec *executionContext) _ImagePackagesPayload(ctx context.Context, sel ast.SelectionSet, obj *ImagePackagesPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imagePackagesPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImagePackagesPayload")
		case "data":
			out.Values[i] = ec._ImagePackagesPayload_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "filteredCount":
			out.Values[i] = ec._ImagePackagesPayload_filteredCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._ImagePackagesPayload_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var imageToolchainsPayloadImplementors = []string{"ImageToolchainsPayload"}

func (ec *executionContext) _ImageToolchainsPayload(ctx context.Context, sel ast.SelectionSet, obj *ImageToolchainsPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, imageToolchainsPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ImageToolchainsPayload")
		case "data":
			out.Values[i] = ec._ImageToolchainsPayload_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "filteredCount":
			out.Values[i] = ec._ImageToolchainsPayload_filteredCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalCount":
			out.Values[i] = ec._ImageToolchainsPayload_totalCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var instanceTagImplementors = []string{"InstanceTag"}

func (ec *executionContext) _InstanceTag(ctx context.Context, sel ast.SelectionSet, obj *host.Tag) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, instanceTagImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InstanceTag")
		case "canBeModified":
			out.Values[i] = ec._InstanceTag_canBeModified(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "key":
			out.Values[i] = ec._InstanceTag_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "value":
			out.Values[i] = ec._InstanceTag_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var issueLinkImplementors = []string{"IssueLink"}

func (ec *executionContext) _IssueLink(ctx context.Context, sel ast.SelectionSet, obj *model.APIIssueLink) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, issueLinkImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IssueLink")
		case "confidenceScore":
			out.Values[i] = ec._IssueLink_confidenceScore(ctx, field, obj)
		case "issueKey":
			out.Values[i] = ec._IssueLink_issueKey(ctx, field, obj)
		case "jiraTicket":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._IssueLink_jiraTicket(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "source":
			out.Values[i] = ec._IssueLink_source(ctx, field, obj)
		case "url":
			out.Values[i] = ec._IssueLink_url(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jiraConfigImplementors = []string{"JiraConfig"}

func (ec *executionContext) _JiraConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIJiraConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jiraConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JiraConfig")
		case "email":
			out.Values[i] = ec._JiraConfig_email(ctx, field, obj)
		case "host":
			out.Values[i] = ec._JiraConfig_host(ctx, field, obj)
		case "personalAccessToken":
			out.Values[i] = ec._JiraConfig_personalAccessToken(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jiraIssueSubscriberImplementors = []string{"JiraIssueSubscriber"}

func (ec *executionContext) _JiraIssueSubscriber(ctx context.Context, sel ast.SelectionSet, obj *model.APIJIRAIssueSubscriber) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jiraIssueSubscriberImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JiraIssueSubscriber")
		case "issueType":
			out.Values[i] = ec._JiraIssueSubscriber_issueType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "project":
			out.Values[i] = ec._JiraIssueSubscriber_project(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jiraStatusImplementors = []string{"JiraStatus"}

func (ec *executionContext) _JiraStatus(ctx context.Context, sel ast.SelectionSet, obj *thirdparty.JiraStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jiraStatusImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JiraStatus")
		case "id":
			out.Values[i] = ec._JiraStatus_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._JiraStatus_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var jiraTicketImplementors = []string{"JiraTicket"}

func (ec *executionContext) _JiraTicket(ctx context.Context, sel ast.SelectionSet, obj *thirdparty.JiraTicket) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jiraTicketImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JiraTicket")
		case "fields":
			out.Values[i] = ec._JiraTicket_fields(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "key":
			out.Values[i] = ec._JiraTicket_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var kanopyAuthConfigImplementors = []string{"KanopyAuthConfig"}

func (ec *executionContext) _KanopyAuthConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIKanopyAuthConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, kanopyAuthConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KanopyAuthConfig")
		case "headerName":
			out.Values[i] = ec._KanopyAuthConfig_headerName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "issuer":
			out.Values[i] = ec._KanopyAuthConfig_issuer(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "keysetURL":
			out.Values[i] = ec._KanopyAuthConfig_keysetURL(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var logBufferingImplementors = []string{"LogBuffering"}

func (ec *executionContext) _LogBuffering(ctx context.Context, sel ast.SelectionSet, obj *model.APILogBuffering) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, logBufferingImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LogBuffering")
		case "useAsync":
			out.Values[i] = ec._LogBuffering_useAsync(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "durationSeconds":
			out.Values[i] = ec._LogBuffering_durationSeconds(ctx, field, obj)
		case "count":
			out.Values[i] = ec._LogBuffering_count(ctx, field, obj)
		case "incomingBufferFactor":
			out.Values[i] = ec._LogBuffering_incomingBufferFactor(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var logMessageImplementors = []string{"LogMessage"}

func (ec *executionContext) _LogMessage(ctx context.Context, sel ast.SelectionSet, obj *apimodels.LogMessage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, logMessageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LogMessage")
		case "message":
			out.Values[i] = ec._LogMessage_message(ctx, field, obj)
		case "severity":
			out.Values[i] = ec._LogMessage_severity(ctx, field, obj)
		case "timestamp":
			out.Values[i] = ec._LogMessage_timestamp(ctx, field, obj)
		case "type":
			out.Values[i] = ec._LogMessage_type(ctx, field, obj)
		case "version":
			out.Values[i] = ec._LogMessage_version(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var loggerConfigImplementors = []string{"LoggerConfig"}

func (ec *executionContext) _LoggerConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APILoggerConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, loggerConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LoggerConfig")
		case "buffer":
			out.Values[i] = ec._LoggerConfig_buffer(ctx, field, obj)
		case "defaultLevel":
			out.Values[i] = ec._LoggerConfig_defaultLevel(ctx, field, obj)
		case "thresholdLevel":
			out.Values[i] = ec._LoggerConfig_thresholdLevel(ctx, field, obj)
		case "logkeeperURL":
			out.Values[i] = ec._LoggerConfig_logkeeperURL(ctx, field, obj)
		case "redactKeys":
			out.Values[i] = ec._LoggerConfig_redactKeys(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var logkeeperBuildImplementors = []string{"LogkeeperBuild"}

func (ec *executionContext) _LogkeeperBuild(ctx context.Context, sel ast.SelectionSet, obj *plank.Build) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, logkeeperBuildImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LogkeeperBuild")
		case "id":
			out.Values[i] = ec._LogkeeperBuild_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "builder":
			out.Values[i] = ec._LogkeeperBuild_builder(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "buildNum":
			out.Values[i] = ec._LogkeeperBuild_buildNum(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "taskId":
			out.Values[i] = ec._LogkeeperBuild_taskId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "taskExecution":
			out.Values[i] = ec._LogkeeperBuild_taskExecution(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tests":
			out.Values[i] = ec._LogkeeperBuild_tests(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "task":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LogkeeperBuild_task(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var logkeeperTestImplementors = []string{"LogkeeperTest"}

func (ec *executionContext) _LogkeeperTest(ctx context.Context, sel ast.SelectionSet, obj *plank.Test) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, logkeeperTestImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LogkeeperTest")
		case "id":
			out.Values[i] = ec._LogkeeperTest_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._LogkeeperTest_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "buildId":
			out.Values[i] = ec._LogkeeperTest_buildId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskId":
			out.Values[i] = ec._LogkeeperTest_taskId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskExecution":
			out.Values[i] = ec._LogkeeperTest_taskExecution(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "phase":
			out.Values[i] = ec._LogkeeperTest_phase(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "command":
			out.Values[i] = ec._LogkeeperTest_command(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mainlineCommitVersionImplementors = []string{"MainlineCommitVersion"}

func (ec *executionContext) _MainlineCommitVersion(ctx context.Context, sel ast.SelectionSet, obj *MainlineCommitVersion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mainlineCommitVersionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MainlineCommitVersion")
		case "rolledUpVersions":
			out.Values[i] = ec._MainlineCommitVersion_rolledUpVersions(ctx, field, obj)
		case "version":
			out.Values[i] = ec._MainlineCommitVersion_version(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mainlineCommitsImplementors = []string{"MainlineCommits"}

func (ec *executionContext) _MainlineCommits(ctx context.Context, sel ast.SelectionSet, obj *MainlineCommits) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mainlineCommitsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MainlineCommits")
		case "nextPageOrderNumber":
			out.Values[i] = ec._MainlineCommits_nextPageOrderNumber(ctx, field, obj)
		case "prevPageOrderNumber":
			out.Values[i] = ec._MainlineCommits_prevPageOrderNumber(ctx, field, obj)
		case "versions":
			out.Values[i] = ec._MainlineCommits_versions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var manifestImplementors = []string{"Manifest"}

func (ec *executionContext) _Manifest(ctx context.Context, sel ast.SelectionSet, obj *Manifest) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, manifestImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Manifest")
		case "id":
			out.Values[i] = ec._Manifest_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "branch":
			out.Values[i] = ec._Manifest_branch(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isBase":
			out.Values[i] = ec._Manifest_isBase(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "moduleOverrides":
			out.Values[i] = ec._Manifest_moduleOverrides(ctx, field, obj)
		case "modules":
			out.Values[i] = ec._Manifest_modules(ctx, field, obj)
		case "project":
			out.Values[i] = ec._Manifest_project(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "revision":
			out.Values[i] = ec._Manifest_revision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var metadataLinkImplementors = []string{"MetadataLink"}

func (ec *executionContext) _MetadataLink(ctx context.Context, sel ast.SelectionSet, obj *model.APIMetadataLink) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, metadataLinkImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MetadataLink")
		case "url":
			out.Values[i] = ec._MetadataLink_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "text":
			out.Values[i] = ec._MetadataLink_text(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "source":
			out.Values[i] = ec._MetadataLink_source(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var moduleCodeChangeImplementors = []string{"ModuleCodeChange"}

func (ec *executionContext) _ModuleCodeChange(ctx context.Context, sel ast.SelectionSet, obj *model.APIModulePatch) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, moduleCodeChangeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ModuleCodeChange")
		case "branchName":
			out.Values[i] = ec._ModuleCodeChange_branchName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fileDiffs":
			out.Values[i] = ec._ModuleCodeChange_fileDiffs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "htmlLink":
			out.Values[i] = ec._ModuleCodeChange_htmlLink(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "rawLink":
			out.Values[i] = ec._ModuleCodeChange_rawLink(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var multiAuthConfigImplementors = []string{"MultiAuthConfig"}

func (ec *executionContext) _MultiAuthConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIMultiAuthConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, multiAuthConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MultiAuthConfig")
		case "readWrite":
			out.Values[i] = ec._MultiAuthConfig_readWrite(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "readOnly":
			out.Values[i] = ec._MultiAuthConfig_readOnly(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "bbCreateTicket":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_bbCreateTicket(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addAnnotationIssue":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addAnnotationIssue(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "editAnnotationNote":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_editAnnotationNote(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "moveAnnotationIssue":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_moveAnnotationIssue(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "removeAnnotationIssue":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_removeAnnotationIssue(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setAnnotationMetadataLinks":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setAnnotationMetadataLinks(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "saveAdminSettings":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_saveAdminSettings(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "restartAdminTasks":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_restartAdminTasks(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteDistro":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteDistro(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "copyDistro":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_copyDistro(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createDistro":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createDistro(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "saveDistro":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_saveDistro(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "reprovisionToNew":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_reprovisionToNew(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "restartJasper":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_restartJasper(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateHostStatus":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateHostStatus(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setPatchVisibility":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setPatchVisibility(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "schedulePatch":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_schedulePatch(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "attachProjectToNewRepo":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_attachProjectToNewRepo(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "attachProjectToRepo":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_attachProjectToRepo(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createProject":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createProject(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "copyProject":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_copyProject(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deactivateStepbackTask":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deactivateStepbackTask(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultSectionToRepo":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_defaultSectionToRepo(ctx, field)
			})
		case "deleteGithubAppCredentials":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteGithubAppCredentials(ctx, field)
			})
		case "deleteProject":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteProject(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "detachProjectFromRepo":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_detachProjectFromRepo(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "forceRepotrackerRun":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_forceRepotrackerRun(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "promoteVarsToRepo":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_promoteVarsToRepo(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "saveProjectSettingsForSection":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_saveProjectSettingsForSection(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "saveRepoSettingsForSection":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_saveRepoSettingsForSection(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setLastRevision":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setLastRevision(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "attachVolumeToHost":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_attachVolumeToHost(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "detachVolumeFromHost":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_detachVolumeFromHost(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "editSpawnHost":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_editSpawnHost(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "migrateVolume":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_migrateVolume(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "spawnHost":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_spawnHost(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "spawnVolume":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_spawnVolume(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "removeVolume":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_removeVolume(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateSpawnHostStatus":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateSpawnHostStatus(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateVolume":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateVolume(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "abortTask":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_abortTask(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "overrideTaskDependencies":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_overrideTaskDependencies(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "restartTask":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_restartTask(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "scheduleTasks":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_scheduleTasks(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setTaskPriority":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setTaskPriority(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setTaskPriorities":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setTaskPriorities(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unscheduleTask":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_unscheduleTask(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "addFavoriteProject":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addFavoriteProject(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "clearMySubscriptions":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_clearMySubscriptions(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "createPublicKey":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createPublicKey(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deleteSubscriptions":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteSubscriptions(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "removeFavoriteProject":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_removeFavoriteProject(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "removePublicKey":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_removePublicKey(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "saveSubscription":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_saveSubscription(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateBetaFeatures":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateBetaFeatures(ctx, field)
			})
		case "updateParsleySettings":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateParsleySettings(ctx, field)
			})
		case "updatePublicKey":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updatePublicKey(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "updateUserSettings":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateUserSettings(ctx, field)
			})
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "restartVersions":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_restartVersions(ctx, field)
			})
		case "scheduleUndispatchedBaseTasks":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_scheduleUndispatchedBaseTasks(ctx, field)
			})
		case "setVersionPriority":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setVersionPriority(ctx, field)
			})
		case "unscheduleVersionTasks":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_unscheduleVersionTasks(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var naiveAuthConfigImplementors = []string{"NaiveAuthConfig"}

func (ec *executionContext) _NaiveAuthConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APINaiveAuthConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, naiveAuthConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NaiveAuthConfig")
		case "users":
			out.Values[i] = ec._NaiveAuthConfig_users(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var newDistroPayloadImplementors = []string{"NewDistroPayload"}

func (ec *executionContext) _NewDistroPayload(ctx context.Context, sel ast.SelectionSet, obj *NewDistroPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, newDistroPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NewDistroPayload")
		case "newDistroId":
			out.Values[i] = ec._NewDistroPayload_newDistroId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var noteImplementors = []string{"Note"}

func (ec *executionContext) _Note(ctx context.Context, sel ast.SelectionSet, obj *model.APINote) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, noteImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Note")
		case "message":
			out.Values[i] = ec._Note_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "source":
			out.Values[i] = ec._Note_source(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var notificationsImplementors = []string{"Notifications"}

func (ec *executionContext) _Notifications(ctx context.Context, sel ast.SelectionSet, obj *model.APINotificationPreferences) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, notificationsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Notifications")
		case "buildBreak":
			out.Values[i] = ec._Notifications_buildBreak(ctx, field, obj)
		case "buildBreakId":
			out.Values[i] = ec._Notifications_buildBreakId(ctx, field, obj)
		case "patchFinish":
			out.Values[i] = ec._Notifications_patchFinish(ctx, field, obj)
		case "patchFinishId":
			out.Values[i] = ec._Notifications_patchFinishId(ctx, field, obj)
		case "patchFirstFailure":
			out.Values[i] = ec._Notifications_patchFirstFailure(ctx, field, obj)
		case "patchFirstFailureId":
			out.Values[i] = ec._Notifications_patchFirstFailureId(ctx, field, obj)
		case "spawnHostExpiration":
			out.Values[i] = ec._Notifications_spawnHostExpiration(ctx, field, obj)
		case "spawnHostExpirationId":
			out.Values[i] = ec._Notifications_spawnHostExpirationId(ctx, field, obj)
		case "spawnHostOutcome":
			out.Values[i] = ec._Notifications_spawnHostOutcome(ctx, field, obj)
		case "spawnHostOutcomeId":
			out.Values[i] = ec._Notifications_spawnHostOutcomeId(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var notifyConfigImplementors = []string{"NotifyConfig"}

func (ec *executionContext) _NotifyConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APINotifyConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, notifyConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NotifyConfig")
		case "ses":
			out.Values[i] = ec._NotifyConfig_ses(ctx, field, obj)
		case "bufferTargetPerInterval":
			out.Values[i] = ec._NotifyConfig_bufferTargetPerInterval(ctx, field, obj)
		case "bufferIntervalSeconds":
			out.Values[i] = ec._NotifyConfig_bufferIntervalSeconds(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var oSInfoImplementors = []string{"OSInfo"}

func (ec *executionContext) _OSInfo(ctx context.Context, sel ast.SelectionSet, obj *model.APIOSInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oSInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OSInfo")
		case "name":
			out.Values[i] = ec._OSInfo_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._OSInfo_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var oktaConfigImplementors = []string{"OktaConfig"}

func (ec *executionContext) _OktaConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIOktaConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oktaConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OktaConfig")
		case "clientId":
			out.Values[i] = ec._OktaConfig_clientId(ctx, field, obj)
		case "clientSecret":
			out.Values[i] = ec._OktaConfig_clientSecret(ctx, field, obj)
		case "issuer":
			out.Values[i] = ec._OktaConfig_issuer(ctx, field, obj)
		case "scopes":
			out.Values[i] = ec._OktaConfig_scopes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "userGroup":
			out.Values[i] = ec._OktaConfig_userGroup(ctx, field, obj)
		case "expireAfterMinutes":
			out.Values[i] = ec._OktaConfig_expireAfterMinutes(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var oomTrackerInfoImplementors = []string{"OomTrackerInfo"}

func (ec *executionContext) _OomTrackerInfo(ctx context.Context, sel ast.SelectionSet, obj *model.APIOomTrackerInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oomTrackerInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OomTrackerInfo")
		case "detected":
			out.Values[i] = ec._OomTrackerInfo_detected(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pids":
			out.Values[i] = ec._OomTrackerInfo_pids(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var packageImplementors = []string{"Package"}

func (ec *executionContext) _Package(ctx context.Context, sel ast.SelectionSet, obj *model.APIPackage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, packageImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Package")
		case "name":
			out.Values[i] = ec._Package_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "manager":
			out.Values[i] = ec._Package_manager(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._Package_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var parameterImplementors = []string{"Parameter"}

func (ec *executionContext) _Parameter(ctx context.Context, sel ast.SelectionSet, obj *model.APIParameter) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, parameterImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Parameter")
		case "key":
			out.Values[i] = ec._Parameter_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "value":
			out.Values[i] = ec._Parameter_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var parsleyFilterImplementors = []string{"ParsleyFilter"}

func (ec *executionContext) _ParsleyFilter(ctx context.Context, sel ast.SelectionSet, obj *model.APIParsleyFilter) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, parsleyFilterImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ParsleyFilter")
		case "caseSensitive":
			out.Values[i] = ec._ParsleyFilter_caseSensitive(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._ParsleyFilter_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "exactMatch":
			out.Values[i] = ec._ParsleyFilter_exactMatch(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "expression":
			out.Values[i] = ec._ParsleyFilter_expression(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var parsleySettingsImplementors = []string{"ParsleySettings"}

func (ec *executionContext) _ParsleySettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIParsleySettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, parsleySettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ParsleySettings")
		case "sectionsEnabled":
			out.Values[i] = ec._ParsleySettings_sectionsEnabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "jumpToFailingLineEnabled":
			out.Values[i] = ec._ParsleySettings_jumpToFailingLineEnabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var patchImplementors = []string{"Patch"}

func (ec *executionContext) _Patch(ctx context.Context, sel ast.SelectionSet, obj *model.APIPatch) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, patchImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Patch")
		case "id":
			out.Values[i] = ec._Patch_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "activated":
			out.Values[i] = ec._Patch_activated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "alias":
			out.Values[i] = ec._Patch_alias(ctx, field, obj)
		case "author":
			out.Values[i] = ec._Patch_author(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "authorDisplayName":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_authorDisplayName(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "baseTaskStatuses":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_baseTaskStatuses(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "builds":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_builds(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "childPatchAliases":
			out.Values[i] = ec._Patch_childPatchAliases(ctx, field, obj)
		case "childPatches":
			out.Values[i] = ec._Patch_childPatches(ctx, field, obj)
		case "createTime":
			out.Values[i] = ec._Patch_createTime(ctx, field, obj)
		case "description":
			out.Values[i] = ec._Patch_description(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "duration":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_duration(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "generatedTaskCounts":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_generatedTaskCounts(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "githash":
			out.Values[i] = ec._Patch_githash(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "githubPatchData":
			out.Values[i] = ec._Patch_githubPatchData(ctx, field, obj)
		case "hidden":
			out.Values[i] = ec._Patch_hidden(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "moduleCodeChanges":
			out.Values[i] = ec._Patch_moduleCodeChanges(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "parameters":
			out.Values[i] = ec._Patch_parameters(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "patchNumber":
			out.Values[i] = ec._Patch_patchNumber(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "patchTriggerAliases":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_patchTriggerAliases(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "project":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_project(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "projectID":
			out.Values[i] = ec._Patch_projectID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "projectIdentifier":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_projectIdentifier(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "projectMetadata":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_projectMetadata(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "status":
			out.Values[i] = ec._Patch_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "taskCount":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_taskCount(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "tasks":
			out.Values[i] = ec._Patch_tasks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "taskStatuses":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_taskStatuses(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "time":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_time(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "variants":
			out.Values[i] = ec._Patch_variants(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "variantsTasks":
			out.Values[i] = ec._Patch_variantsTasks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "versionFull":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_versionFull(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var patchDurationImplementors = []string{"PatchDuration"}

func (ec *executionContext) _PatchDuration(ctx context.Context, sel ast.SelectionSet, obj *PatchDuration) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, patchDurationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PatchDuration")
		case "makespan":
			out.Values[i] = ec._PatchDuration_makespan(ctx, field, obj)
		case "time":
			out.Values[i] = ec._PatchDuration_time(ctx, field, obj)
		case "timeTaken":
			out.Values[i] = ec._PatchDuration_timeTaken(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var patchProjectImplementors = []string{"PatchProject"}

func (ec *executionContext) _PatchProject(ctx context.Context, sel ast.SelectionSet, obj *PatchProject) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, patchProjectImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PatchProject")
		case "variants":
			out.Values[i] = ec._PatchProject_variants(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var patchTimeImplementors = []string{"PatchTime"}

func (ec *executionContext) _PatchTime(ctx context.Context, sel ast.SelectionSet, obj *PatchTime) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, patchTimeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PatchTime")
		case "finished":
			out.Values[i] = ec._PatchTime_finished(ctx, field, obj)
		case "started":
			out.Values[i] = ec._PatchTime_started(ctx, field, obj)
		case "submittedAt":
			out.Values[i] = ec._PatchTime_submittedAt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var patchTriggerAliasImplementors = []string{"PatchTriggerAlias"}

func (ec *executionContext) _PatchTriggerAlias(ctx context.Context, sel ast.SelectionSet, obj *model.APIPatchTriggerDefinition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, patchTriggerAliasImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PatchTriggerAlias")
		case "alias":
			out.Values[i] = ec._PatchTriggerAlias_alias(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "childProjectId":
			out.Values[i] = ec._PatchTriggerAlias_childProjectId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "childProjectIdentifier":
			out.Values[i] = ec._PatchTriggerAlias_childProjectIdentifier(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "parentAsModule":
			out.Values[i] = ec._PatchTriggerAlias_parentAsModule(ctx, field, obj)
		case "status":
			out.Values[i] = ec._PatchTriggerAlias_status(ctx, field, obj)
		case "downstreamRevision":
			out.Values[i] = ec._PatchTriggerAlias_downstreamRevision(ctx, field, obj)
		case "taskSpecifiers":
			out.Values[i] = ec._PatchTriggerAlias_taskSpecifiers(ctx, field, obj)
		case "variantsTasks":
			out.Values[i] = ec._PatchTriggerAlias_variantsTasks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var patchesImplementors = []string{"Patches"}

func (ec *executionContext) _Patches(ctx context.Context, sel ast.SelectionSet, obj *Patches) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, patchesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Patches")
		case "filteredPatchCount":
			out.Values[i] = ec._Patches_filteredPatchCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "patches":
			out.Values[i] = ec._Patches_patches(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var periodicBuildImplementors = []string{"PeriodicBuild"}

func (ec *executionContext) _PeriodicBuild(ctx context.Context, sel ast.SelectionSet, obj *model.APIPeriodicBuildDefinition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, periodicBuildImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PeriodicBuild")
		case "id":
			out.Values[i] = ec._PeriodicBuild_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "alias":
			out.Values[i] = ec._PeriodicBuild_alias(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "configFile":
			out.Values[i] = ec._PeriodicBuild_configFile(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "intervalHours":
			out.Values[i] = ec._PeriodicBuild_intervalHours(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cron":
			out.Values[i] = ec._PeriodicBuild_cron(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._PeriodicBuild_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nextRunTime":
			out.Values[i] = ec._PeriodicBuild_nextRunTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var permissionsImplementors = []string{"Permissions"}

func (ec *executionContext) _Permissions(ctx context.Context, sel ast.SelectionSet, obj *Permissions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, permissionsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Permissions")
		case "canCreateDistro":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Permissions_canCreateDistro(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "canCreateProject":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Permissions_canCreateProject(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "canEditAdminSettings":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Permissions_canEditAdminSettings(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "distroPermissions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Permissions_distroPermissions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "projectPermissions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Permissions_projectPermissions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "repoPermissions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Permissions_repoPermissions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "userId":
			out.Values[i] = ec._Permissions_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var plannerSettingsImplementors = []string{"PlannerSettings"}

func (ec *executionContext) _PlannerSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIPlannerSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, plannerSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PlannerSettings")
		case "commitQueueFactor":
			out.Values[i] = ec._PlannerSettings_commitQueueFactor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "expectedRuntimeFactor":
			out.Values[i] = ec._PlannerSettings_expectedRuntimeFactor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "generateTaskFactor":
			out.Values[i] = ec._PlannerSettings_generateTaskFactor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "numDependentsFactor":
			out.Values[i] = ec._PlannerSettings_numDependentsFactor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "groupVersions":
			out.Values[i] = ec._PlannerSettings_groupVersions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mainlineTimeInQueueFactor":
			out.Values[i] = ec._PlannerSettings_mainlineTimeInQueueFactor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "patchFactor":
			out.Values[i] = ec._PlannerSettings_patchFactor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "patchTimeInQueueFactor":
			out.Values[i] = ec._PlannerSettings_patchTimeInQueueFactor(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "targetTime":
			out.Values[i] = ec._PlannerSettings_targetTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._PlannerSettings_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var podImplementors = []string{"Pod"}

func (ec *executionContext) _Pod(ctx context.Context, sel ast.SelectionSet, obj *model.APIPod) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, podImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Pod")
		case "events":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Pod_events(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "id":
			out.Values[i] = ec._Pod_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "status":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Pod_status(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "task":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Pod_task(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "taskContainerCreationOpts":
			out.Values[i] = ec._Pod_taskContainerCreationOpts(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "type":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Pod_type(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var podEventLogDataImplementors = []string{"PodEventLogData"}

func (ec *executionContext) _PodEventLogData(ctx context.Context, sel ast.SelectionSet, obj *model.PodAPIEventData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, podEventLogDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PodEventLogData")
		case "oldStatus":
			out.Values[i] = ec._PodEventLogData_oldStatus(ctx, field, obj)
		case "newStatus":
			out.Values[i] = ec._PodEventLogData_newStatus(ctx, field, obj)
		case "reason":
			out.Values[i] = ec._PodEventLogData_reason(ctx, field, obj)
		case "taskID":
			out.Values[i] = ec._PodEventLogData_taskID(ctx, field, obj)
		case "taskExecution":
			out.Values[i] = ec._PodEventLogData_taskExecution(ctx, field, obj)
		case "taskStatus":
			out.Values[i] = ec._PodEventLogData_taskStatus(ctx, field, obj)
		case "task":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PodEventLogData_task(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var podEventLogEntryImplementors = []string{"PodEventLogEntry"}

func (ec *executionContext) _PodEventLogEntry(ctx context.Context, sel ast.SelectionSet, obj *model.PodAPIEventLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, podEventLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PodEventLogEntry")
		case "id":
			out.Values[i] = ec._PodEventLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._PodEventLogEntry_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "eventType":
			out.Values[i] = ec._PodEventLogEntry_eventType(ctx, field, obj)
		case "processedAt":
			out.Values[i] = ec._PodEventLogEntry_processedAt(ctx, field, obj)
		case "resourceId":
			out.Values[i] = ec._PodEventLogEntry_resourceId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._PodEventLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timestamp":
			out.Values[i] = ec._PodEventLogEntry_timestamp(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var podEventsImplementors = []string{"PodEvents"}

func (ec *executionContext) _PodEvents(ctx context.Context, sel ast.SelectionSet, obj *PodEvents) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, podEventsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PodEvents")
		case "count":
			out.Values[i] = ec._PodEvents_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "eventLogEntries":
			out.Values[i] = ec._PodEvents_eventLogEntries(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var podLifecycleConfigImplementors = []string{"PodLifecycleConfig"}

func (ec *executionContext) _PodLifecycleConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIPodLifecycleConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, podLifecycleConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PodLifecycleConfig")
		case "maxParallelPodRequests":
			out.Values[i] = ec._PodLifecycleConfig_maxParallelPodRequests(ctx, field, obj)
		case "maxPodDefinitionCleanupRate":
			out.Values[i] = ec._PodLifecycleConfig_maxPodDefinitionCleanupRate(ctx, field, obj)
		case "maxSecretCleanupRate":
			out.Values[i] = ec._PodLifecycleConfig_maxSecretCleanupRate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var preconditionScriptImplementors = []string{"PreconditionScript"}

func (ec *executionContext) _PreconditionScript(ctx context.Context, sel ast.SelectionSet, obj *model.APIPreconditionScript) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, preconditionScriptImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PreconditionScript")
		case "path":
			out.Values[i] = ec._PreconditionScript_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "script":
			out.Values[i] = ec._PreconditionScript_script(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectImplementors = []string{"Project"}

func (ec *executionContext) _Project(ctx context.Context, sel ast.SelectionSet, obj *model.APIProjectRef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Project")
		case "id":
			out.Values[i] = ec._Project_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "admins":
			out.Values[i] = ec._Project_admins(ctx, field, obj)
		case "banner":
			out.Values[i] = ec._Project_banner(ctx, field, obj)
		case "batchTime":
			out.Values[i] = ec._Project_batchTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "branch":
			out.Values[i] = ec._Project_branch(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "buildBaronSettings":
			out.Values[i] = ec._Project_buildBaronSettings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "commitQueue":
			out.Values[i] = ec._Project_commitQueue(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "containerSizeDefinitions":
			out.Values[i] = ec._Project_containerSizeDefinitions(ctx, field, obj)
		case "deactivatePrevious":
			out.Values[i] = ec._Project_deactivatePrevious(ctx, field, obj)
		case "disabledStatsCache":
			out.Values[i] = ec._Project_disabledStatsCache(ctx, field, obj)
		case "dispatchingDisabled":
			out.Values[i] = ec._Project_dispatchingDisabled(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._Project_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "enabled":
			out.Values[i] = ec._Project_enabled(ctx, field, obj)
		case "externalLinks":
			out.Values[i] = ec._Project_externalLinks(ctx, field, obj)
		case "githubChecksEnabled":
			out.Values[i] = ec._Project_githubChecksEnabled(ctx, field, obj)
		case "githubDynamicTokenPermissionGroups":
			out.Values[i] = ec._Project_githubDynamicTokenPermissionGroups(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "githubPermissionGroupByRequester":
			out.Values[i] = ec._Project_githubPermissionGroupByRequester(ctx, field, obj)
		case "githubTriggerAliases":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Project_githubTriggerAliases(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "githubPRTriggerAliases":
			out.Values[i] = ec._Project_githubPRTriggerAliases(ctx, field, obj)
		case "githubMQTriggerAliases":
			out.Values[i] = ec._Project_githubMQTriggerAliases(ctx, field, obj)
		case "gitTagAuthorizedTeams":
			out.Values[i] = ec._Project_gitTagAuthorizedTeams(ctx, field, obj)
		case "gitTagAuthorizedUsers":
			out.Values[i] = ec._Project_gitTagAuthorizedUsers(ctx, field, obj)
		case "gitTagVersionsEnabled":
			out.Values[i] = ec._Project_gitTagVersionsEnabled(ctx, field, obj)
		case "hidden":
			out.Values[i] = ec._Project_hidden(ctx, field, obj)
		case "identifier":
			out.Values[i] = ec._Project_identifier(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "isFavorite":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Project_isFavorite(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "manualPrTestingEnabled":
			out.Values[i] = ec._Project_manualPrTestingEnabled(ctx, field, obj)
		case "notifyOnBuildFailure":
			out.Values[i] = ec._Project_notifyOnBuildFailure(ctx, field, obj)
		case "oldestAllowedMergeBase":
			out.Values[i] = ec._Project_oldestAllowedMergeBase(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "owner":
			out.Values[i] = ec._Project_owner(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "parsleyFilters":
			out.Values[i] = ec._Project_parsleyFilters(ctx, field, obj)
		case "patches":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Project_patches(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "patchingDisabled":
			out.Values[i] = ec._Project_patchingDisabled(ctx, field, obj)
		case "patchTriggerAliases":
			out.Values[i] = ec._Project_patchTriggerAliases(ctx, field, obj)
		case "perfEnabled":
			out.Values[i] = ec._Project_perfEnabled(ctx, field, obj)
		case "periodicBuilds":
			out.Values[i] = ec._Project_periodicBuilds(ctx, field, obj)
		case "projectHealthView":
			out.Values[i] = ec._Project_projectHealthView(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "prTestingEnabled":
			out.Values[i] = ec._Project_prTestingEnabled(ctx, field, obj)
		case "remotePath":
			out.Values[i] = ec._Project_remotePath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "repo":
			out.Values[i] = ec._Project_repo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "repoRefId":
			out.Values[i] = ec._Project_repoRefId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "repotrackerDisabled":
			out.Values[i] = ec._Project_repotrackerDisabled(ctx, field, obj)
		case "repotrackerError":
			out.Values[i] = ec._Project_repotrackerError(ctx, field, obj)
		case "restricted":
			out.Values[i] = ec._Project_restricted(ctx, field, obj)
		case "spawnHostScriptPath":
			out.Values[i] = ec._Project_spawnHostScriptPath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "stepbackDisabled":
			out.Values[i] = ec._Project_stepbackDisabled(ctx, field, obj)
		case "stepbackBisect":
			out.Values[i] = ec._Project_stepbackBisect(ctx, field, obj)
		case "taskAnnotationSettings":
			out.Values[i] = ec._Project_taskAnnotationSettings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tracksPushEvents":
			out.Values[i] = ec._Project_tracksPushEvents(ctx, field, obj)
		case "triggers":
			out.Values[i] = ec._Project_triggers(ctx, field, obj)
		case "versionControlEnabled":
			out.Values[i] = ec._Project_versionControlEnabled(ctx, field, obj)
		case "workstationConfig":
			out.Values[i] = ec._Project_workstationConfig(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectAliasImplementors = []string{"ProjectAlias"}

func (ec *executionContext) _ProjectAlias(ctx context.Context, sel ast.SelectionSet, obj *model.APIProjectAlias) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectAliasImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectAlias")
		case "id":
			out.Values[i] = ec._ProjectAlias_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "alias":
			out.Values[i] = ec._ProjectAlias_alias(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec._ProjectAlias_description(ctx, field, obj)
		case "gitTag":
			out.Values[i] = ec._ProjectAlias_gitTag(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "remotePath":
			out.Values[i] = ec._ProjectAlias_remotePath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "task":
			out.Values[i] = ec._ProjectAlias_task(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskTags":
			out.Values[i] = ec._ProjectAlias_taskTags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "variant":
			out.Values[i] = ec._ProjectAlias_variant(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "variantTags":
			out.Values[i] = ec._ProjectAlias_variantTags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "parameters":
			out.Values[i] = ec._ProjectAlias_parameters(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectBannerImplementors = []string{"ProjectBanner"}

func (ec *executionContext) _ProjectBanner(ctx context.Context, sel ast.SelectionSet, obj *model.APIProjectBanner) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectBannerImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectBanner")
		case "text":
			out.Values[i] = ec._ProjectBanner_text(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "theme":
			out.Values[i] = ec._ProjectBanner_theme(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectBuildVariantImplementors = []string{"ProjectBuildVariant"}

func (ec *executionContext) _ProjectBuildVariant(ctx context.Context, sel ast.SelectionSet, obj *ProjectBuildVariant) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectBuildVariantImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectBuildVariant")
		case "displayName":
			out.Values[i] = ec._ProjectBuildVariant_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._ProjectBuildVariant_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "tasks":
			out.Values[i] = ec._ProjectBuildVariant_tasks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectEventLogEntryImplementors = []string{"ProjectEventLogEntry"}

func (ec *executionContext) _ProjectEventLogEntry(ctx context.Context, sel ast.SelectionSet, obj *model.APIProjectEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectEventLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectEventLogEntry")
		case "after":
			out.Values[i] = ec._ProjectEventLogEntry_after(ctx, field, obj)
		case "before":
			out.Values[i] = ec._ProjectEventLogEntry_before(ctx, field, obj)
		case "timestamp":
			out.Values[i] = ec._ProjectEventLogEntry_timestamp(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "user":
			out.Values[i] = ec._ProjectEventLogEntry_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectEventSettingsImplementors = []string{"ProjectEventSettings"}

func (ec *executionContext) _ProjectEventSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIProjectEventSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectEventSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectEventSettings")
		case "aliases":
			out.Values[i] = ec._ProjectEventSettings_aliases(ctx, field, obj)
		case "githubAppAuth":
			out.Values[i] = ec._ProjectEventSettings_githubAppAuth(ctx, field, obj)
		case "githubWebhooksEnabled":
			out.Values[i] = ec._ProjectEventSettings_githubWebhooksEnabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "projectRef":
			out.Values[i] = ec._ProjectEventSettings_projectRef(ctx, field, obj)
		case "subscriptions":
			out.Values[i] = ec._ProjectEventSettings_subscriptions(ctx, field, obj)
		case "vars":
			out.Values[i] = ec._ProjectEventSettings_vars(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectEventsImplementors = []string{"ProjectEvents"}

func (ec *executionContext) _ProjectEvents(ctx context.Context, sel ast.SelectionSet, obj *ProjectEvents) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectEventsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectEvents")
		case "count":
			out.Values[i] = ec._ProjectEvents_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "eventLogEntries":
			out.Values[i] = ec._ProjectEvents_eventLogEntries(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectPermissionsImplementors = []string{"ProjectPermissions"}

func (ec *executionContext) _ProjectPermissions(ctx context.Context, sel ast.SelectionSet, obj *ProjectPermissions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectPermissionsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectPermissions")
		case "edit":
			out.Values[i] = ec._ProjectPermissions_edit(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "view":
			out.Values[i] = ec._ProjectPermissions_view(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectSettingsImplementors = []string{"ProjectSettings"}

func (ec *executionContext) _ProjectSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIProjectSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectSettings")
		case "aliases":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProjectSettings_aliases(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "githubAppAuth":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProjectSettings_githubAppAuth(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "githubWebhooksEnabled":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProjectSettings_githubWebhooksEnabled(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "projectRef":
			out.Values[i] = ec._ProjectSettings_projectRef(ctx, field, obj)
		case "subscriptions":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProjectSettings_subscriptions(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "vars":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProjectSettings_vars(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectTasksPairImplementors = []string{"ProjectTasksPair"}

func (ec *executionContext) _ProjectTasksPair(ctx context.Context, sel ast.SelectionSet, obj *model.APIProjectTasksPair) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectTasksPairImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectTasksPair")
		case "projectId":
			out.Values[i] = ec._ProjectTasksPair_projectId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "allowedTasks":
			out.Values[i] = ec._ProjectTasksPair_allowedTasks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "allowedBVs":
			out.Values[i] = ec._ProjectTasksPair_allowedBVs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var projectVarsImplementors = []string{"ProjectVars"}

func (ec *executionContext) _ProjectVars(ctx context.Context, sel ast.SelectionSet, obj *model.APIProjectVars) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectVarsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectVars")
		case "adminOnlyVars":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProjectVars_adminOnlyVars(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "privateVars":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProjectVars_privateVars(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "vars":
			out.Values[i] = ec._ProjectVars_vars(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var publicKeyImplementors = []string{"PublicKey"}

func (ec *executionContext) _PublicKey(ctx context.Context, sel ast.SelectionSet, obj *model.APIPubKey) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, publicKeyImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PublicKey")
		case "key":
			out.Values[i] = ec._PublicKey_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec._PublicKey_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "bbGetCreatedTickets":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_bbGetCreatedTickets(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "buildBaron":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_buildBaron(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "adminEvents":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_adminEvents(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "adminSettings":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_adminSettings(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "adminTasksToRestart":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_adminTasksToRestart(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "awsRegions":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_awsRegions(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "clientConfig":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_clientConfig(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "instanceTypes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_instanceTypes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "spruceConfig":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_spruceConfig(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "subnetAvailabilityZones":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_subnetAvailabilityZones(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "distro":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_distro(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "distroEvents":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_distroEvents(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "distros":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_distros(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "distroTaskQueue":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_distroTaskQueue(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "host":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_host(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "hostEvents":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_hostEvents(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "hosts":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_hosts(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "taskQueueDistros":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_taskQueueDistros(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "pod":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_pod(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "patch":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_patch(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "githubProjectConflicts":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_githubProjectConflicts(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "project":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_project(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "projects":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_projects(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "projectEvents":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_projectEvents(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "projectSettings":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_projectSettings(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "repoEvents":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_repoEvents(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "repoSettings":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_repoSettings(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "viewableProjectRefs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_viewableProjectRefs(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "isRepo":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_isRepo(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "myHosts":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_myHosts(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "myVolumes":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_myVolumes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "logkeeperBuildMetadata":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_logkeeperBuildMetadata(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "task":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_task(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "taskAllExecutions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_taskAllExecutions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "taskTestSample":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_taskTestSample(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "myPublicKeys":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_myPublicKeys(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "user":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_user(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "userConfig":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userConfig(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "buildVariantsForTaskName":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_buildVariantsForTaskName(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "mainlineCommits":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_mainlineCommits(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "taskNamesForBuildVariant":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_taskNamesForBuildVariant(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "waterfall":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_waterfall(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "taskHistory":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_taskHistory(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "hasVersion":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_hasVersion(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "version":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_version(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "image":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_image(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "images":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_images(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx,
					func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return rrm(innerCtx) })
		case "__type":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})
		case "__schema":
			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var repoCommitQueueParamsImplementors = []string{"RepoCommitQueueParams"}

func (ec *executionContext) _RepoCommitQueueParams(ctx context.Context, sel ast.SelectionSet, obj *model.APICommitQueueParams) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repoCommitQueueParamsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepoCommitQueueParams")
		case "enabled":
			out.Values[i] = ec._RepoCommitQueueParams_enabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mergeMethod":
			out.Values[i] = ec._RepoCommitQueueParams_mergeMethod(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "message":
			out.Values[i] = ec._RepoCommitQueueParams_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var repoPermissionsImplementors = []string{"RepoPermissions"}

func (ec *executionContext) _RepoPermissions(ctx context.Context, sel ast.SelectionSet, obj *RepoPermissions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repoPermissionsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepoPermissions")
		case "edit":
			out.Values[i] = ec._RepoPermissions_edit(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "view":
			out.Values[i] = ec._RepoPermissions_view(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var repoRefImplementors = []string{"RepoRef"}

func (ec *executionContext) _RepoRef(ctx context.Context, sel ast.SelectionSet, obj *model.APIProjectRef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repoRefImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepoRef")
		case "id":
			out.Values[i] = ec._RepoRef_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "admins":
			out.Values[i] = ec._RepoRef_admins(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "batchTime":
			out.Values[i] = ec._RepoRef_batchTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "buildBaronSettings":
			out.Values[i] = ec._RepoRef_buildBaronSettings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "commitQueue":
			out.Values[i] = ec._RepoRef_commitQueue(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "containerSizeDefinitions":
			out.Values[i] = ec._RepoRef_containerSizeDefinitions(ctx, field, obj)
		case "deactivatePrevious":
			out.Values[i] = ec._RepoRef_deactivatePrevious(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "disabledStatsCache":
			out.Values[i] = ec._RepoRef_disabledStatsCache(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "dispatchingDisabled":
			out.Values[i] = ec._RepoRef_dispatchingDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "displayName":
			out.Values[i] = ec._RepoRef_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "enabled":
			out.Values[i] = ec._RepoRef_enabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "githubChecksEnabled":
			out.Values[i] = ec._RepoRef_githubChecksEnabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "githubDynamicTokenPermissionGroups":
			out.Values[i] = ec._RepoRef_githubDynamicTokenPermissionGroups(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "githubPermissionGroupByRequester":
			out.Values[i] = ec._RepoRef_githubPermissionGroupByRequester(ctx, field, obj)
		case "githubTriggerAliases":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RepoRef_githubTriggerAliases(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "githubPRTriggerAliases":
			out.Values[i] = ec._RepoRef_githubPRTriggerAliases(ctx, field, obj)
		case "githubMQTriggerAliases":
			out.Values[i] = ec._RepoRef_githubMQTriggerAliases(ctx, field, obj)
		case "gitTagAuthorizedTeams":
			out.Values[i] = ec._RepoRef_gitTagAuthorizedTeams(ctx, field, obj)
		case "gitTagAuthorizedUsers":
			out.Values[i] = ec._RepoRef_gitTagAuthorizedUsers(ctx, field, obj)
		case "gitTagVersionsEnabled":
			out.Values[i] = ec._RepoRef_gitTagVersionsEnabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "manualPrTestingEnabled":
			out.Values[i] = ec._RepoRef_manualPrTestingEnabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "notifyOnBuildFailure":
			out.Values[i] = ec._RepoRef_notifyOnBuildFailure(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "oldestAllowedMergeBase":
			out.Values[i] = ec._RepoRef_oldestAllowedMergeBase(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "owner":
			out.Values[i] = ec._RepoRef_owner(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "parsleyFilters":
			out.Values[i] = ec._RepoRef_parsleyFilters(ctx, field, obj)
		case "patchingDisabled":
			out.Values[i] = ec._RepoRef_patchingDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "patchTriggerAliases":
			out.Values[i] = ec._RepoRef_patchTriggerAliases(ctx, field, obj)
		case "perfEnabled":
			out.Values[i] = ec._RepoRef_perfEnabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "periodicBuilds":
			out.Values[i] = ec._RepoRef_periodicBuilds(ctx, field, obj)
		case "prTestingEnabled":
			out.Values[i] = ec._RepoRef_prTestingEnabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "remotePath":
			out.Values[i] = ec._RepoRef_remotePath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "repo":
			out.Values[i] = ec._RepoRef_repo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "repotrackerDisabled":
			out.Values[i] = ec._RepoRef_repotrackerDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "restricted":
			out.Values[i] = ec._RepoRef_restricted(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "spawnHostScriptPath":
			out.Values[i] = ec._RepoRef_spawnHostScriptPath(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "stepbackDisabled":
			out.Values[i] = ec._RepoRef_stepbackDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "stepbackBisect":
			out.Values[i] = ec._RepoRef_stepbackBisect(ctx, field, obj)
		case "taskAnnotationSettings":
			out.Values[i] = ec._RepoRef_taskAnnotationSettings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tracksPushEvents":
			out.Values[i] = ec._RepoRef_tracksPushEvents(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "triggers":
			out.Values[i] = ec._RepoRef_triggers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "versionControlEnabled":
			out.Values[i] = ec._RepoRef_versionControlEnabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "workstationConfig":
			out.Values[i] = ec._RepoRef_workstationConfig(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "externalLinks":
			out.Values[i] = ec._RepoRef_externalLinks(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var repoSettingsImplementors = []string{"RepoSettings"}

func (ec *executionContext) _RepoSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIProjectSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repoSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepoSettings")
		case "aliases":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RepoSettings_aliases(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "githubAppAuth":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RepoSettings_githubAppAuth(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "githubWebhooksEnabled":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RepoSettings_githubWebhooksEnabled(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "projectRef":
			out.Values[i] = ec._RepoSettings_projectRef(ctx, field, obj)
		case "subscriptions":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RepoSettings_subscriptions(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "vars":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RepoSettings_vars(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var repoWorkstationConfigImplementors = []string{"RepoWorkstationConfig"}

func (ec *executionContext) _RepoWorkstationConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIWorkstationConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repoWorkstationConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepoWorkstationConfig")
		case "gitClone":
			out.Values[i] = ec._RepoWorkstationConfig_gitClone(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "setupCommands":
			out.Values[i] = ec._RepoWorkstationConfig_setupCommands(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var repotrackerConfigImplementors = []string{"RepotrackerConfig"}

func (ec *executionContext) _RepotrackerConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIRepoTrackerConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repotrackerConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepotrackerConfig")
		case "numNewRepoRevisionsToFetch":
			out.Values[i] = ec._RepotrackerConfig_numNewRepoRevisionsToFetch(ctx, field, obj)
		case "maxRepoRevisionsToSearch":
			out.Values[i] = ec._RepotrackerConfig_maxRepoRevisionsToSearch(ctx, field, obj)
		case "maxConcurrentRequests":
			out.Values[i] = ec._RepotrackerConfig_maxConcurrentRequests(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var repotrackerErrorImplementors = []string{"RepotrackerError"}

func (ec *executionContext) _RepotrackerError(ctx context.Context, sel ast.SelectionSet, obj *model.APIRepositoryErrorDetails) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repotrackerErrorImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepotrackerError")
		case "exists":
			out.Values[i] = ec._RepotrackerError_exists(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "invalidRevision":
			out.Values[i] = ec._RepotrackerError_invalidRevision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mergeBaseRevision":
			out.Values[i] = ec._RepotrackerError_mergeBaseRevision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var resourceLimitsImplementors = []string{"ResourceLimits"}

func (ec *executionContext) _ResourceLimits(ctx context.Context, sel ast.SelectionSet, obj *model.APIResourceLimits) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, resourceLimitsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResourceLimits")
		case "lockedMemoryKb":
			out.Values[i] = ec._ResourceLimits_lockedMemoryKb(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "numFiles":
			out.Values[i] = ec._ResourceLimits_numFiles(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "numProcesses":
			out.Values[i] = ec._ResourceLimits_numProcesses(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "numTasks":
			out.Values[i] = ec._ResourceLimits_numTasks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "virtualMemoryKb":
			out.Values[i] = ec._ResourceLimits_virtualMemoryKb(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var restartAdminTasksPayloadImplementors = []string{"RestartAdminTasksPayload"}

func (ec *executionContext) _RestartAdminTasksPayload(ctx context.Context, sel ast.SelectionSet, obj *RestartAdminTasksPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, restartAdminTasksPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RestartAdminTasksPayload")
		case "numRestartedTasks":
			out.Values[i] = ec._RestartAdminTasksPayload_numRestartedTasks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var runtimeEnvironmentConfigImplementors = []string{"RuntimeEnvironmentConfig"}

func (ec *executionContext) _RuntimeEnvironmentConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIRuntimeEnvironmentsConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, runtimeEnvironmentConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RuntimeEnvironmentConfig")
		case "baseUrl":
			out.Values[i] = ec._RuntimeEnvironmentConfig_baseUrl(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "apiKey":
			out.Values[i] = ec._RuntimeEnvironmentConfig_apiKey(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sESConfigImplementors = []string{"SESConfig"}

func (ec *executionContext) _SESConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APISESConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sESConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SESConfig")
		case "senderAddress":
			out.Values[i] = ec._SESConfig_senderAddress(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var saveDistroPayloadImplementors = []string{"SaveDistroPayload"}

func (ec *executionContext) _SaveDistroPayload(ctx context.Context, sel ast.SelectionSet, obj *SaveDistroPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, saveDistroPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SaveDistroPayload")
		case "distro":
			out.Values[i] = ec._SaveDistroPayload_distro(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hostCount":
			out.Values[i] = ec._SaveDistroPayload_hostCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var schedulerConfigImplementors = []string{"SchedulerConfig"}

func (ec *executionContext) _SchedulerConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APISchedulerConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, schedulerConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SchedulerConfig")
		case "taskFinder":
			out.Values[i] = ec._SchedulerConfig_taskFinder(ctx, field, obj)
		case "hostAllocator":
			out.Values[i] = ec._SchedulerConfig_hostAllocator(ctx, field, obj)
		case "hostAllocatorRoundingRule":
			out.Values[i] = ec._SchedulerConfig_hostAllocatorRoundingRule(ctx, field, obj)
		case "hostAllocatorFeedbackRule":
			out.Values[i] = ec._SchedulerConfig_hostAllocatorFeedbackRule(ctx, field, obj)
		case "hostsOverallocatedRule":
			out.Values[i] = ec._SchedulerConfig_hostsOverallocatedRule(ctx, field, obj)
		case "futureHostFraction":
			out.Values[i] = ec._SchedulerConfig_futureHostFraction(ctx, field, obj)
		case "cacheDurationSeconds":
			out.Values[i] = ec._SchedulerConfig_cacheDurationSeconds(ctx, field, obj)
		case "targetTimeSeconds":
			out.Values[i] = ec._SchedulerConfig_targetTimeSeconds(ctx, field, obj)
		case "acceptableHostIdleTimeSeconds":
			out.Values[i] = ec._SchedulerConfig_acceptableHostIdleTimeSeconds(ctx, field, obj)
		case "groupVersions":
			out.Values[i] = ec._SchedulerConfig_groupVersions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "patchFactor":
			out.Values[i] = ec._SchedulerConfig_patchFactor(ctx, field, obj)
		case "patchTimeInQueueFactor":
			out.Values[i] = ec._SchedulerConfig_patchTimeInQueueFactor(ctx, field, obj)
		case "commitQueueFactor":
			out.Values[i] = ec._SchedulerConfig_commitQueueFactor(ctx, field, obj)
		case "mainlineTimeInQueueFactor":
			out.Values[i] = ec._SchedulerConfig_mainlineTimeInQueueFactor(ctx, field, obj)
		case "expectedRuntimeFactor":
			out.Values[i] = ec._SchedulerConfig_expectedRuntimeFactor(ctx, field, obj)
		case "generateTaskFactor":
			out.Values[i] = ec._SchedulerConfig_generateTaskFactor(ctx, field, obj)
		case "numDependentsFactor":
			out.Values[i] = ec._SchedulerConfig_numDependentsFactor(ctx, field, obj)
		case "stepbackTaskFactor":
			out.Values[i] = ec._SchedulerConfig_stepbackTaskFactor(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var searchReturnInfoImplementors = []string{"SearchReturnInfo"}

func (ec *executionContext) _SearchReturnInfo(ctx context.Context, sel ast.SelectionSet, obj *thirdparty.SearchReturnInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, searchReturnInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SearchReturnInfo")
		case "featuresURL":
			out.Values[i] = ec._SearchReturnInfo_featuresURL(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "issues":
			out.Values[i] = ec._SearchReturnInfo_issues(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "search":
			out.Values[i] = ec._SearchReturnInfo_search(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "source":
			out.Values[i] = ec._SearchReturnInfo_source(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var selectorImplementors = []string{"Selector"}

func (ec *executionContext) _Selector(ctx context.Context, sel ast.SelectionSet, obj *model.APISelector) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, selectorImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Selector")
		case "data":
			out.Values[i] = ec._Selector_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec._Selector_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var serviceFlagsImplementors = []string{"ServiceFlags"}

func (ec *executionContext) _ServiceFlags(ctx context.Context, sel ast.SelectionSet, obj *model.APIServiceFlags) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, serviceFlagsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ServiceFlags")
		case "taskDispatchDisabled":
			out.Values[i] = ec._ServiceFlags_taskDispatchDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hostInitDisabled":
			out.Values[i] = ec._ServiceFlags_hostInitDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "podInitDisabled":
			out.Values[i] = ec._ServiceFlags_podInitDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "largeParserProjectsDisabled":
			out.Values[i] = ec._ServiceFlags_largeParserProjectsDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "monitorDisabled":
			out.Values[i] = ec._ServiceFlags_monitorDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "alertsDisabled":
			out.Values[i] = ec._ServiceFlags_alertsDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "agentStartDisabled":
			out.Values[i] = ec._ServiceFlags_agentStartDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "repotrackerDisabled":
			out.Values[i] = ec._ServiceFlags_repotrackerDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "schedulerDisabled":
			out.Values[i] = ec._ServiceFlags_schedulerDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "checkBlockedTasksDisabled":
			out.Values[i] = ec._ServiceFlags_checkBlockedTasksDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "githubPRTestingDisabled":
			out.Values[i] = ec._ServiceFlags_githubPRTestingDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cliUpdatesDisabled":
			out.Values[i] = ec._ServiceFlags_cliUpdatesDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "backgroundStatsDisabled":
			out.Values[i] = ec._ServiceFlags_backgroundStatsDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskLoggingDisabled":
			out.Values[i] = ec._ServiceFlags_taskLoggingDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cacheStatsJobDisabled":
			out.Values[i] = ec._ServiceFlags_cacheStatsJobDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cacheStatsEndpointDisabled":
			out.Values[i] = ec._ServiceFlags_cacheStatsEndpointDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskReliabilityDisabled":
			out.Values[i] = ec._ServiceFlags_taskReliabilityDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hostAllocatorDisabled":
			out.Values[i] = ec._ServiceFlags_hostAllocatorDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "podAllocatorDisabled":
			out.Values[i] = ec._ServiceFlags_podAllocatorDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unrecognizedPodCleanupDisabled":
			out.Values[i] = ec._ServiceFlags_unrecognizedPodCleanupDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "backgroundReauthDisabled":
			out.Values[i] = ec._ServiceFlags_backgroundReauthDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "cloudCleanupDisabled":
			out.Values[i] = ec._ServiceFlags_cloudCleanupDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "sleepScheduleDisabled":
			out.Values[i] = ec._ServiceFlags_sleepScheduleDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "staticAPIKeysDisabled":
			out.Values[i] = ec._ServiceFlags_staticAPIKeysDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "jwtTokenForCLIDisabled":
			out.Values[i] = ec._ServiceFlags_jwtTokenForCLIDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "systemFailedTaskRestartDisabled":
			out.Values[i] = ec._ServiceFlags_systemFailedTaskRestartDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "degradedModeDisabled":
			out.Values[i] = ec._ServiceFlags_degradedModeDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "elasticIPsDisabled":
			out.Values[i] = ec._ServiceFlags_elasticIPsDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "releaseModeDisabled":
			out.Values[i] = ec._ServiceFlags_releaseModeDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "adminParameterStoreDisabled":
			out.Values[i] = ec._ServiceFlags_adminParameterStoreDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "eventProcessingDisabled":
			out.Values[i] = ec._ServiceFlags_eventProcessingDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "jiraNotificationsDisabled":
			out.Values[i] = ec._ServiceFlags_jiraNotificationsDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "slackNotificationsDisabled":
			out.Values[i] = ec._ServiceFlags_slackNotificationsDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "emailNotificationsDisabled":
			out.Values[i] = ec._ServiceFlags_emailNotificationsDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "webhookNotificationsDisabled":
			out.Values[i] = ec._ServiceFlags_webhookNotificationsDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "githubStatusAPIDisabled":
			out.Values[i] = ec._ServiceFlags_githubStatusAPIDisabled(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var setLastRevisionPayloadImplementors = []string{"SetLastRevisionPayload"}

func (ec *executionContext) _SetLastRevisionPayload(ctx context.Context, sel ast.SelectionSet, obj *SetLastRevisionPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, setLastRevisionPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SetLastRevisionPayload")
		case "mergeBaseRevision":
			out.Values[i] = ec._SetLastRevisionPayload_mergeBaseRevision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var singleTaskDistroConfigImplementors = []string{"SingleTaskDistroConfig"}

func (ec *executionContext) _SingleTaskDistroConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APISingleTaskDistroConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, singleTaskDistroConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SingleTaskDistroConfig")
		case "projectTasksPairs":
			out.Values[i] = ec._SingleTaskDistroConfig_projectTasksPairs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var slackConfigImplementors = []string{"SlackConfig"}

func (ec *executionContext) _SlackConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APISlackConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, slackConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SlackConfig")
		case "options":
			out.Values[i] = ec._SlackConfig_options(ctx, field, obj)
		case "token":
			out.Values[i] = ec._SlackConfig_token(ctx, field, obj)
		case "level":
			out.Values[i] = ec._SlackConfig_level(ctx, field, obj)
		case "name":
			out.Values[i] = ec._SlackConfig_name(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var slackOptionsImplementors = []string{"SlackOptions"}

func (ec *executionContext) _SlackOptions(ctx context.Context, sel ast.SelectionSet, obj *model.APISlackOptions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, slackOptionsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SlackOptions")
		case "channel":
			out.Values[i] = ec._SlackOptions_channel(ctx, field, obj)
		case "hostname":
			out.Values[i] = ec._SlackOptions_hostname(ctx, field, obj)
		case "name":
			out.Values[i] = ec._SlackOptions_name(ctx, field, obj)
		case "username":
			out.Values[i] = ec._SlackOptions_username(ctx, field, obj)
		case "basicMetadata":
			out.Values[i] = ec._SlackOptions_basicMetadata(ctx, field, obj)
		case "fields":
			out.Values[i] = ec._SlackOptions_fields(ctx, field, obj)
		case "allFields":
			out.Values[i] = ec._SlackOptions_allFields(ctx, field, obj)
		case "fieldsSet":
			out.Values[i] = ec._SlackOptions_fieldsSet(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sleepScheduleImplementors = []string{"SleepSchedule"}

func (ec *executionContext) _SleepSchedule(ctx context.Context, sel ast.SelectionSet, obj *host.SleepScheduleInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sleepScheduleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SleepSchedule")
		case "dailyStartTime":
			out.Values[i] = ec._SleepSchedule_dailyStartTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "dailyStopTime":
			out.Values[i] = ec._SleepSchedule_dailyStopTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "nextStartTime":
			out.Values[i] = ec._SleepSchedule_nextStartTime(ctx, field, obj)
		case "nextStopTime":
			out.Values[i] = ec._SleepSchedule_nextStopTime(ctx, field, obj)
		case "permanentlyExempt":
			out.Values[i] = ec._SleepSchedule_permanentlyExempt(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "shouldKeepOff":
			out.Values[i] = ec._SleepSchedule_shouldKeepOff(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "timeZone":
			out.Values[i] = ec._SleepSchedule_timeZone(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "temporarilyExemptUntil":
			out.Values[i] = ec._SleepSchedule_temporarilyExemptUntil(ctx, field, obj)
		case "wholeWeekdaysOff":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SleepSchedule_wholeWeekdaysOff(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var sourceImplementors = []string{"Source"}

func (ec *executionContext) _Source(ctx context.Context, sel ast.SelectionSet, obj *model.APISource) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sourceImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Source")
		case "author":
			out.Values[i] = ec._Source_author(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "requester":
			out.Values[i] = ec._Source_requester(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "time":
			out.Values[i] = ec._Source_time(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var spawnHostConfigImplementors = []string{"SpawnHostConfig"}

func (ec *executionContext) _SpawnHostConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APISpawnHostConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, spawnHostConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SpawnHostConfig")
		case "spawnHostsPerUser":
			out.Values[i] = ec._SpawnHostConfig_spawnHostsPerUser(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unexpirableHostsPerUser":
			out.Values[i] = ec._SpawnHostConfig_unexpirableHostsPerUser(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unexpirableVolumesPerUser":
			out.Values[i] = ec._SpawnHostConfig_unexpirableVolumesPerUser(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var splunkConfigImplementors = []string{"SplunkConfig"}

func (ec *executionContext) _SplunkConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APISplunkConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, splunkConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SplunkConfig")
		case "splunkConnectionInfo":
			out.Values[i] = ec._SplunkConfig_splunkConnectionInfo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var splunkConnectionInfoImplementors = []string{"SplunkConnectionInfo"}

func (ec *executionContext) _SplunkConnectionInfo(ctx context.Context, sel ast.SelectionSet, obj *model.APISplunkConnectionInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, splunkConnectionInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SplunkConnectionInfo")
		case "serverUrl":
			out.Values[i] = ec._SplunkConnectionInfo_serverUrl(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "token":
			out.Values[i] = ec._SplunkConnectionInfo_token(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "channel":
			out.Values[i] = ec._SplunkConnectionInfo_channel(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var spruceConfigImplementors = []string{"SpruceConfig"}

func (ec *executionContext) _SpruceConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIAdminSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, spruceConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SpruceConfig")
		case "banner":
			out.Values[i] = ec._SpruceConfig_banner(ctx, field, obj)
		case "bannerTheme":
			out.Values[i] = ec._SpruceConfig_bannerTheme(ctx, field, obj)
		case "containerPools":
			out.Values[i] = ec._SpruceConfig_containerPools(ctx, field, obj)
		case "githubOrgs":
			out.Values[i] = ec._SpruceConfig_githubOrgs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "jira":
			out.Values[i] = ec._SpruceConfig_jira(ctx, field, obj)
		case "providers":
			out.Values[i] = ec._SpruceConfig_providers(ctx, field, obj)
		case "secretFields":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SpruceConfig_secretFields(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "singleTaskDistro":
			out.Values[i] = ec._SpruceConfig_singleTaskDistro(ctx, field, obj)
		case "slack":
			out.Values[i] = ec._SpruceConfig_slack(ctx, field, obj)
		case "spawnHost":
			out.Values[i] = ec._SpruceConfig_spawnHost(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "ui":
			out.Values[i] = ec._SpruceConfig_ui(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var statusCountImplementors = []string{"StatusCount"}

func (ec *executionContext) _StatusCount(ctx context.Context, sel ast.SelectionSet, obj *task.StatusCount) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, statusCountImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StatusCount")
		case "count":
			out.Values[i] = ec._StatusCount_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._StatusCount_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var stepbackInfoImplementors = []string{"StepbackInfo"}

func (ec *executionContext) _StepbackInfo(ctx context.Context, sel ast.SelectionSet, obj *model.APIStepbackInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, stepbackInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StepbackInfo")
		case "lastFailingStepbackTaskId":
			out.Values[i] = ec._StepbackInfo_lastFailingStepbackTaskId(ctx, field, obj)
		case "lastPassingStepbackTaskId":
			out.Values[i] = ec._StepbackInfo_lastPassingStepbackTaskId(ctx, field, obj)
		case "nextStepbackTaskId":
			out.Values[i] = ec._StepbackInfo_nextStepbackTaskId(ctx, field, obj)
		case "previousStepbackTaskId":
			out.Values[i] = ec._StepbackInfo_previousStepbackTaskId(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var subscriberImplementors = []string{"Subscriber"}

func (ec *executionContext) _Subscriber(ctx context.Context, sel ast.SelectionSet, obj *Subscriber) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subscriberImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Subscriber")
		case "emailSubscriber":
			out.Values[i] = ec._Subscriber_emailSubscriber(ctx, field, obj)
		case "githubCheckSubscriber":
			out.Values[i] = ec._Subscriber_githubCheckSubscriber(ctx, field, obj)
		case "githubPRSubscriber":
			out.Values[i] = ec._Subscriber_githubPRSubscriber(ctx, field, obj)
		case "jiraCommentSubscriber":
			out.Values[i] = ec._Subscriber_jiraCommentSubscriber(ctx, field, obj)
		case "jiraIssueSubscriber":
			out.Values[i] = ec._Subscriber_jiraIssueSubscriber(ctx, field, obj)
		case "slackSubscriber":
			out.Values[i] = ec._Subscriber_slackSubscriber(ctx, field, obj)
		case "webhookSubscriber":
			out.Values[i] = ec._Subscriber_webhookSubscriber(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var subscriberWrapperImplementors = []string{"SubscriberWrapper"}

func (ec *executionContext) _SubscriberWrapper(ctx context.Context, sel ast.SelectionSet, obj *model.APISubscriber) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subscriberWrapperImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SubscriberWrapper")
		case "subscriber":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SubscriberWrapper_subscriber(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "type":
			out.Values[i] = ec._SubscriberWrapper_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskImplementors = []string{"Task"}

func (ec *executionContext) _Task(ctx context.Context, sel ast.SelectionSet, obj *model.APITask) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Task")
		case "aborted":
			out.Values[i] = ec._Task_aborted(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "abortInfo":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_abortInfo(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "activated":
			out.Values[i] = ec._Task_activated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "activatedBy":
			out.Values[i] = ec._Task_activatedBy(ctx, field, obj)
		case "activatedTime":
			out.Values[i] = ec._Task_activatedTime(ctx, field, obj)
		case "ami":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_ami(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "annotation":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_annotation(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "id":
			out.Values[i] = ec._Task_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "baseStatus":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_baseStatus(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "baseTask":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_baseTask(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "blocked":
			out.Values[i] = ec._Task_blocked(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "buildId":
			out.Values[i] = ec._Task_buildId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "buildVariant":
			out.Values[i] = ec._Task_buildVariant(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "buildVariantDisplayName":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_buildVariantDisplayName(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "canAbort":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_canAbort(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "canDisable":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_canDisable(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "canModifyAnnotation":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_canModifyAnnotation(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "canOverrideDependencies":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_canOverrideDependencies(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "canRestart":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_canRestart(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "canSchedule":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_canSchedule(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "canSetPriority":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_canSetPriority(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "canUnschedule":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_canUnschedule(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "containerAllocatedTime":
			out.Values[i] = ec._Task_containerAllocatedTime(ctx, field, obj)
		case "createTime":
			out.Values[i] = ec._Task_createTime(ctx, field, obj)
		case "dependsOn":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_dependsOn(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "details":
			out.Values[i] = ec._Task_details(ctx, field, obj)
		case "dispatchTime":
			out.Values[i] = ec._Task_dispatchTime(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._Task_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "displayOnly":
			out.Values[i] = ec._Task_displayOnly(ctx, field, obj)
		case "displayStatus":
			out.Values[i] = ec._Task_displayStatus(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "displayTask":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_displayTask(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "distroId":
			out.Values[i] = ec._Task_distroId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "estimatedStart":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_estimatedStart(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "execution":
			out.Values[i] = ec._Task_execution(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "executionTasks":
			out.Values[i] = ec._Task_executionTasks(ctx, field, obj)
		case "executionTasksFull":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_executionTasksFull(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "expectedDuration":
			out.Values[i] = ec._Task_expectedDuration(ctx, field, obj)
		case "failedTestCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_failedTestCount(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "files":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_files(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "finishTime":
			out.Values[i] = ec._Task_finishTime(ctx, field, obj)
		case "generatedBy":
			out.Values[i] = ec._Task_generatedBy(ctx, field, obj)
		case "generatedByName":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_generatedByName(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "generateTask":
			out.Values[i] = ec._Task_generateTask(ctx, field, obj)
		case "hasTestResults":
			out.Values[i] = ec._Task_hasTestResults(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "hostId":
			out.Values[i] = ec._Task_hostId(ctx, field, obj)
		case "imageId":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_imageId(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "ingestTime":
			out.Values[i] = ec._Task_ingestTime(ctx, field, obj)
		case "isPerfPluginEnabled":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_isPerfPluginEnabled(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "latestExecution":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_latestExecution(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "logs":
			out.Values[i] = ec._Task_logs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "minQueuePosition":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_minQueuePosition(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "order":
			out.Values[i] = ec._Task_order(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "patch":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_patch(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "patchNumber":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_patchNumber(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "pod":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_pod(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "priority":
			out.Values[i] = ec._Task_priority(ctx, field, obj)
		case "project":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_project(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "projectId":
			out.Values[i] = ec._Task_projectId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "projectIdentifier":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_projectIdentifier(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "requester":
			out.Values[i] = ec._Task_requester(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "resetWhenFinished":
			out.Values[i] = ec._Task_resetWhenFinished(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "revision":
			out.Values[i] = ec._Task_revision(ctx, field, obj)
		case "scheduledTime":
			out.Values[i] = ec._Task_scheduledTime(ctx, field, obj)
		case "spawnHostLink":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_spawnHostLink(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "startTime":
			out.Values[i] = ec._Task_startTime(ctx, field, obj)
		case "status":
			out.Values[i] = ec._Task_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "tags":
			out.Values[i] = ec._Task_tags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "taskGroup":
			out.Values[i] = ec._Task_taskGroup(ctx, field, obj)
		case "taskGroupMaxHosts":
			out.Values[i] = ec._Task_taskGroupMaxHosts(ctx, field, obj)
		case "stepbackInfo":
			out.Values[i] = ec._Task_stepbackInfo(ctx, field, obj)
		case "taskLogs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_taskLogs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "taskOwnerTeam":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_taskOwnerTeam(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "tests":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_tests(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "timeTaken":
			out.Values[i] = ec._Task_timeTaken(ctx, field, obj)
		case "totalTestCount":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_totalTestCount(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "versionMetadata":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_versionMetadata(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskAnnotationSettingsImplementors = []string{"TaskAnnotationSettings"}

func (ec *executionContext) _TaskAnnotationSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APITaskAnnotationSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskAnnotationSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskAnnotationSettings")
		case "fileTicketWebhook":
			out.Values[i] = ec._TaskAnnotationSettings_fileTicketWebhook(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskContainerCreationOptsImplementors = []string{"TaskContainerCreationOpts"}

func (ec *executionContext) _TaskContainerCreationOpts(ctx context.Context, sel ast.SelectionSet, obj *model.APIPodTaskContainerCreationOptions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskContainerCreationOptsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskContainerCreationOpts")
		case "image":
			out.Values[i] = ec._TaskContainerCreationOpts_image(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "memoryMB":
			out.Values[i] = ec._TaskContainerCreationOpts_memoryMB(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "cpu":
			out.Values[i] = ec._TaskContainerCreationOpts_cpu(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "os":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TaskContainerCreationOpts_os(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "arch":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TaskContainerCreationOpts_arch(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "workingDir":
			out.Values[i] = ec._TaskContainerCreationOpts_workingDir(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskEndDetailImplementors = []string{"TaskEndDetail"}

func (ec *executionContext) _TaskEndDetail(ctx context.Context, sel ast.SelectionSet, obj *model.ApiTaskEndDetail) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskEndDetailImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskEndDetail")
		case "description":
			out.Values[i] = ec._TaskEndDetail_description(ctx, field, obj)
		case "diskDevices":
			out.Values[i] = ec._TaskEndDetail_diskDevices(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "failingCommand":
			out.Values[i] = ec._TaskEndDetail_failingCommand(ctx, field, obj)
		case "failureMetadataTags":
			out.Values[i] = ec._TaskEndDetail_failureMetadataTags(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "oomTracker":
			out.Values[i] = ec._TaskEndDetail_oomTracker(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "otherFailingCommands":
			out.Values[i] = ec._TaskEndDetail_otherFailingCommands(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._TaskEndDetail_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timedOut":
			out.Values[i] = ec._TaskEndDetail_timedOut(ctx, field, obj)
		case "timeoutType":
			out.Values[i] = ec._TaskEndDetail_timeoutType(ctx, field, obj)
		case "traceID":
			out.Values[i] = ec._TaskEndDetail_traceID(ctx, field, obj)
		case "type":
			out.Values[i] = ec._TaskEndDetail_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskEventLogDataImplementors = []string{"TaskEventLogData"}

func (ec *executionContext) _TaskEventLogData(ctx context.Context, sel ast.SelectionSet, obj *model.TaskEventData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskEventLogDataImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskEventLogData")
		case "hostId":
			out.Values[i] = ec._TaskEventLogData_hostId(ctx, field, obj)
		case "podId":
			out.Values[i] = ec._TaskEventLogData_podId(ctx, field, obj)
		case "jiraIssue":
			out.Values[i] = ec._TaskEventLogData_jiraIssue(ctx, field, obj)
		case "jiraLink":
			out.Values[i] = ec._TaskEventLogData_jiraLink(ctx, field, obj)
		case "priority":
			out.Values[i] = ec._TaskEventLogData_priority(ctx, field, obj)
		case "status":
			out.Values[i] = ec._TaskEventLogData_status(ctx, field, obj)
		case "timestamp":
			out.Values[i] = ec._TaskEventLogData_timestamp(ctx, field, obj)
		case "userId":
			out.Values[i] = ec._TaskEventLogData_userId(ctx, field, obj)
		case "blockedOn":
			out.Values[i] = ec._TaskEventLogData_blockedOn(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskEventLogEntryImplementors = []string{"TaskEventLogEntry"}

func (ec *executionContext) _TaskEventLogEntry(ctx context.Context, sel ast.SelectionSet, obj *model.TaskAPIEventLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskEventLogEntryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskEventLogEntry")
		case "id":
			out.Values[i] = ec._TaskEventLogEntry_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._TaskEventLogEntry_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "eventType":
			out.Values[i] = ec._TaskEventLogEntry_eventType(ctx, field, obj)
		case "processedAt":
			out.Values[i] = ec._TaskEventLogEntry_processedAt(ctx, field, obj)
		case "resourceId":
			out.Values[i] = ec._TaskEventLogEntry_resourceId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceType":
			out.Values[i] = ec._TaskEventLogEntry_resourceType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timestamp":
			out.Values[i] = ec._TaskEventLogEntry_timestamp(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskFilesImplementors = []string{"TaskFiles"}

func (ec *executionContext) _TaskFiles(ctx context.Context, sel ast.SelectionSet, obj *TaskFiles) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskFilesImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskFiles")
		case "fileCount":
			out.Values[i] = ec._TaskFiles_fileCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "groupedFiles":
			out.Values[i] = ec._TaskFiles_groupedFiles(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskHistoryImplementors = []string{"TaskHistory"}

func (ec *executionContext) _TaskHistory(ctx context.Context, sel ast.SelectionSet, obj *TaskHistory) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskHistoryImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskHistory")
		case "tasks":
			out.Values[i] = ec._TaskHistory_tasks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pagination":
			out.Values[i] = ec._TaskHistory_pagination(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskHistoryPaginationImplementors = []string{"TaskHistoryPagination"}

func (ec *executionContext) _TaskHistoryPagination(ctx context.Context, sel ast.SelectionSet, obj *TaskHistoryPagination) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskHistoryPaginationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskHistoryPagination")
		case "mostRecentTaskOrder":
			out.Values[i] = ec._TaskHistoryPagination_mostRecentTaskOrder(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "oldestTaskOrder":
			out.Values[i] = ec._TaskHistoryPagination_oldestTaskOrder(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskInfoImplementors = []string{"TaskInfo"}

func (ec *executionContext) _TaskInfo(ctx context.Context, sel ast.SelectionSet, obj *model.TaskInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskInfoImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskInfo")
		case "id":
			out.Values[i] = ec._TaskInfo_id(ctx, field, obj)
		case "name":
			out.Values[i] = ec._TaskInfo_name(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskLimitsConfigImplementors = []string{"TaskLimitsConfig"}

func (ec *executionContext) _TaskLimitsConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APITaskLimitsConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskLimitsConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskLimitsConfig")
		case "maxTasksPerVersion":
			out.Values[i] = ec._TaskLimitsConfig_maxTasksPerVersion(ctx, field, obj)
		case "maxIncludesPerVersion":
			out.Values[i] = ec._TaskLimitsConfig_maxIncludesPerVersion(ctx, field, obj)
		case "maxHourlyPatchTasks":
			out.Values[i] = ec._TaskLimitsConfig_maxHourlyPatchTasks(ctx, field, obj)
		case "maxPendingGeneratedTasks":
			out.Values[i] = ec._TaskLimitsConfig_maxPendingGeneratedTasks(ctx, field, obj)
		case "maxGenerateTaskJSONSize":
			out.Values[i] = ec._TaskLimitsConfig_maxGenerateTaskJSONSize(ctx, field, obj)
		case "maxConcurrentLargeParserProjectTasks":
			out.Values[i] = ec._TaskLimitsConfig_maxConcurrentLargeParserProjectTasks(ctx, field, obj)
		case "maxDegradedModeConcurrentLargeParserProjectTasks":
			out.Values[i] = ec._TaskLimitsConfig_maxDegradedModeConcurrentLargeParserProjectTasks(ctx, field, obj)
		case "maxDegradedModeParserProjectSize":
			out.Values[i] = ec._TaskLimitsConfig_maxDegradedModeParserProjectSize(ctx, field, obj)
		case "maxParserProjectSize":
			out.Values[i] = ec._TaskLimitsConfig_maxParserProjectSize(ctx, field, obj)
		case "maxExecTimeoutSecs":
			out.Values[i] = ec._TaskLimitsConfig_maxExecTimeoutSecs(ctx, field, obj)
		case "maxTaskExecution":
			out.Values[i] = ec._TaskLimitsConfig_maxTaskExecution(ctx, field, obj)
		case "maxDailyAutomaticRestarts":
			out.Values[i] = ec._TaskLimitsConfig_maxDailyAutomaticRestarts(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskLogLinksImplementors = []string{"TaskLogLinks"}

func (ec *executionContext) _TaskLogLinks(ctx context.Context, sel ast.SelectionSet, obj *model.LogLinks) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskLogLinksImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskLogLinks")
		case "agentLogLink":
			out.Values[i] = ec._TaskLogLinks_agentLogLink(ctx, field, obj)
		case "allLogLink":
			out.Values[i] = ec._TaskLogLinks_allLogLink(ctx, field, obj)
		case "eventLogLink":
			out.Values[i] = ec._TaskLogLinks_eventLogLink(ctx, field, obj)
		case "systemLogLink":
			out.Values[i] = ec._TaskLogLinks_systemLogLink(ctx, field, obj)
		case "taskLogLink":
			out.Values[i] = ec._TaskLogLinks_taskLogLink(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskLogsImplementors = []string{"TaskLogs"}

func (ec *executionContext) _TaskLogs(ctx context.Context, sel ast.SelectionSet, obj *TaskLogs) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskLogsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskLogs")
		case "agentLogs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TaskLogs_agentLogs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "allLogs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TaskLogs_allLogs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "eventLogs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TaskLogs_eventLogs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "execution":
			out.Values[i] = ec._TaskLogs_execution(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "systemLogs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TaskLogs_systemLogs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "taskId":
			out.Values[i] = ec._TaskLogs_taskId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "taskLogs":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TaskLogs_taskLogs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskOwnerTeamImplementors = []string{"TaskOwnerTeam"}

func (ec *executionContext) _TaskOwnerTeam(ctx context.Context, sel ast.SelectionSet, obj *TaskOwnerTeam) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskOwnerTeamImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskOwnerTeam")
		case "assignmentType":
			out.Values[i] = ec._TaskOwnerTeam_assignmentType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "messages":
			out.Values[i] = ec._TaskOwnerTeam_messages(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "teamName":
			out.Values[i] = ec._TaskOwnerTeam_teamName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "jiraProject":
			out.Values[i] = ec._TaskOwnerTeam_jiraProject(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskQueueDistroImplementors = []string{"TaskQueueDistro"}

func (ec *executionContext) _TaskQueueDistro(ctx context.Context, sel ast.SelectionSet, obj *TaskQueueDistro) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskQueueDistroImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskQueueDistro")
		case "id":
			out.Values[i] = ec._TaskQueueDistro_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hostCount":
			out.Values[i] = ec._TaskQueueDistro_hostCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskCount":
			out.Values[i] = ec._TaskQueueDistro_taskCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskQueueItemImplementors = []string{"TaskQueueItem"}

func (ec *executionContext) _TaskQueueItem(ctx context.Context, sel ast.SelectionSet, obj *model.APITaskQueueItem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskQueueItemImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskQueueItem")
		case "id":
			out.Values[i] = ec._TaskQueueItem_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "buildVariant":
			out.Values[i] = ec._TaskQueueItem_buildVariant(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "displayName":
			out.Values[i] = ec._TaskQueueItem_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "expectedDuration":
			out.Values[i] = ec._TaskQueueItem_expectedDuration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "priority":
			out.Values[i] = ec._TaskQueueItem_priority(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "project":
			out.Values[i] = ec._TaskQueueItem_project(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "projectIdentifier":
			out.Values[i] = ec._TaskQueueItem_projectIdentifier(ctx, field, obj)
		case "requester":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TaskQueueItem_requester(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "activatedBy":
			out.Values[i] = ec._TaskQueueItem_activatedBy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "revision":
			out.Values[i] = ec._TaskQueueItem_revision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "version":
			out.Values[i] = ec._TaskQueueItem_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskSpecifierImplementors = []string{"TaskSpecifier"}

func (ec *executionContext) _TaskSpecifier(ctx context.Context, sel ast.SelectionSet, obj *model.APITaskSpecifier) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskSpecifierImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskSpecifier")
		case "patchAlias":
			out.Values[i] = ec._TaskSpecifier_patchAlias(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskRegex":
			out.Values[i] = ec._TaskSpecifier_taskRegex(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "variantRegex":
			out.Values[i] = ec._TaskSpecifier_variantRegex(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskStatsImplementors = []string{"TaskStats"}

func (ec *executionContext) _TaskStats(ctx context.Context, sel ast.SelectionSet, obj *task.TaskStats) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskStatsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskStats")
		case "counts":
			out.Values[i] = ec._TaskStats_counts(ctx, field, obj)
		case "eta":
			out.Values[i] = ec._TaskStats_eta(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskTestResultImplementors = []string{"TaskTestResult"}

func (ec *executionContext) _TaskTestResult(ctx context.Context, sel ast.SelectionSet, obj *TaskTestResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskTestResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskTestResult")
		case "testResults":
			out.Values[i] = ec._TaskTestResult_testResults(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalTestCount":
			out.Values[i] = ec._TaskTestResult_totalTestCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "filteredTestCount":
			out.Values[i] = ec._TaskTestResult_filteredTestCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var taskTestResultSampleImplementors = []string{"TaskTestResultSample"}

func (ec *executionContext) _TaskTestResultSample(ctx context.Context, sel ast.SelectionSet, obj *TaskTestResultSample) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskTestResultSampleImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskTestResultSample")
		case "execution":
			out.Values[i] = ec._TaskTestResultSample_execution(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "matchingFailedTestNames":
			out.Values[i] = ec._TaskTestResultSample_matchingFailedTestNames(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskId":
			out.Values[i] = ec._TaskTestResultSample_taskId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "totalTestCount":
			out.Values[i] = ec._TaskTestResultSample_totalTestCount(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var testLogImplementors = []string{"TestLog"}

func (ec *executionContext) _TestLog(ctx context.Context, sel ast.SelectionSet, obj *model.TestLogs) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, testLogImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TestLog")
		case "lineNum":
			out.Values[i] = ec._TestLog_lineNum(ctx, field, obj)
		case "url":
			out.Values[i] = ec._TestLog_url(ctx, field, obj)
		case "urlParsley":
			out.Values[i] = ec._TestLog_urlParsley(ctx, field, obj)
		case "urlRaw":
			out.Values[i] = ec._TestLog_urlRaw(ctx, field, obj)
		case "renderingType":
			out.Values[i] = ec._TestLog_renderingType(ctx, field, obj)
		case "version":
			out.Values[i] = ec._TestLog_version(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var testResultImplementors = []string{"TestResult"}

func (ec *executionContext) _TestResult(ctx context.Context, sel ast.SelectionSet, obj *model.APITest) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, testResultImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TestResult")
		case "id":
			out.Values[i] = ec._TestResult_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "baseStatus":
			out.Values[i] = ec._TestResult_baseStatus(ctx, field, obj)
		case "duration":
			out.Values[i] = ec._TestResult_duration(ctx, field, obj)
		case "endTime":
			out.Values[i] = ec._TestResult_endTime(ctx, field, obj)
		case "execution":
			out.Values[i] = ec._TestResult_execution(ctx, field, obj)
		case "exitCode":
			out.Values[i] = ec._TestResult_exitCode(ctx, field, obj)
		case "groupID":
			out.Values[i] = ec._TestResult_groupID(ctx, field, obj)
		case "logs":
			out.Values[i] = ec._TestResult_logs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "startTime":
			out.Values[i] = ec._TestResult_startTime(ctx, field, obj)
		case "status":
			out.Values[i] = ec._TestResult_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskId":
			out.Values[i] = ec._TestResult_taskId(ctx, field, obj)
		case "testFile":
			out.Values[i] = ec._TestResult_testFile(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var testSelectionConfigImplementors = []string{"TestSelectionConfig"}

func (ec *executionContext) _TestSelectionConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APITestSelectionConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, testSelectionConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TestSelectionConfig")
		case "url":
			out.Values[i] = ec._TestSelectionConfig_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var ticketFieldsImplementors = []string{"TicketFields"}

func (ec *executionContext) _TicketFields(ctx context.Context, sel ast.SelectionSet, obj *thirdparty.TicketFields) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ticketFieldsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TicketFields")
		case "assignedTeam":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TicketFields_assignedTeam(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "assigneeDisplayName":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TicketFields_assigneeDisplayName(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "created":
			out.Values[i] = ec._TicketFields_created(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "resolutionName":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TicketFields_resolutionName(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "status":
			out.Values[i] = ec._TicketFields_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "summary":
			out.Values[i] = ec._TicketFields_summary(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "updated":
			out.Values[i] = ec._TicketFields_updated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var toolchainImplementors = []string{"Toolchain"}

func (ec *executionContext) _Toolchain(ctx context.Context, sel ast.SelectionSet, obj *model.APIToolchain) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, toolchainImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Toolchain")
		case "name":
			out.Values[i] = ec._Toolchain_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "path":
			out.Values[i] = ec._Toolchain_path(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._Toolchain_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var triggerAliasImplementors = []string{"TriggerAlias"}

func (ec *executionContext) _TriggerAlias(ctx context.Context, sel ast.SelectionSet, obj *model.APITriggerDefinition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, triggerAliasImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TriggerAlias")
		case "alias":
			out.Values[i] = ec._TriggerAlias_alias(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "buildVariantRegex":
			out.Values[i] = ec._TriggerAlias_buildVariantRegex(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "configFile":
			out.Values[i] = ec._TriggerAlias_configFile(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "dateCutoff":
			out.Values[i] = ec._TriggerAlias_dateCutoff(ctx, field, obj)
		case "level":
			out.Values[i] = ec._TriggerAlias_level(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "project":
			out.Values[i] = ec._TriggerAlias_project(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._TriggerAlias_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "taskRegex":
			out.Values[i] = ec._TriggerAlias_taskRegex(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "unscheduleDownstreamVersions":
			out.Values[i] = ec._TriggerAlias_unscheduleDownstreamVersions(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var triggerConfigImplementors = []string{"TriggerConfig"}

func (ec *executionContext) _TriggerConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APITriggerConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, triggerConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TriggerConfig")
		case "generateTaskDistro":
			out.Values[i] = ec._TriggerConfig_generateTaskDistro(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var uIConfigImplementors = []string{"UIConfig"}

func (ec *executionContext) _UIConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIUIConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, uIConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UIConfig")
		case "betaFeatures":
			out.Values[i] = ec._UIConfig_betaFeatures(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "url":
			out.Values[i] = ec._UIConfig_url(ctx, field, obj)
		case "helpUrl":
			out.Values[i] = ec._UIConfig_helpUrl(ctx, field, obj)
		case "uiv2Url":
			out.Values[i] = ec._UIConfig_uiv2Url(ctx, field, obj)
		case "parsleyUrl":
			out.Values[i] = ec._UIConfig_parsleyUrl(ctx, field, obj)
		case "httpListenAddr":
			out.Values[i] = ec._UIConfig_httpListenAddr(ctx, field, obj)
		case "secret":
			out.Values[i] = ec._UIConfig_secret(ctx, field, obj)
		case "defaultProject":
			out.Values[i] = ec._UIConfig_defaultProject(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "corsOrigins":
			out.Values[i] = ec._UIConfig_corsOrigins(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "fileStreamingContentTypes":
			out.Values[i] = ec._UIConfig_fileStreamingContentTypes(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "loginDomain":
			out.Values[i] = ec._UIConfig_loginDomain(ctx, field, obj)
		case "userVoice":
			out.Values[i] = ec._UIConfig_userVoice(ctx, field, obj)
		case "csrfKey":
			out.Values[i] = ec._UIConfig_csrfKey(ctx, field, obj)
		case "cacheTemplates":
			out.Values[i] = ec._UIConfig_cacheTemplates(ctx, field, obj)
		case "stagingEnvironment":
			out.Values[i] = ec._UIConfig_stagingEnvironment(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateBetaFeaturesPayloadImplementors = []string{"UpdateBetaFeaturesPayload"}

func (ec *executionContext) _UpdateBetaFeaturesPayload(ctx context.Context, sel ast.SelectionSet, obj *UpdateBetaFeaturesPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateBetaFeaturesPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateBetaFeaturesPayload")
		case "betaFeatures":
			out.Values[i] = ec._UpdateBetaFeaturesPayload_betaFeatures(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var updateParsleySettingsPayloadImplementors = []string{"UpdateParsleySettingsPayload"}

func (ec *executionContext) _UpdateParsleySettingsPayload(ctx context.Context, sel ast.SelectionSet, obj *UpdateParsleySettingsPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, updateParsleySettingsPayloadImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpdateParsleySettingsPayload")
		case "parsleySettings":
			out.Values[i] = ec._UpdateParsleySettingsPayload_parsleySettings(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var upstreamProjectImplementors = []string{"UpstreamProject"}

func (ec *executionContext) _UpstreamProject(ctx context.Context, sel ast.SelectionSet, obj *UpstreamProject) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, upstreamProjectImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpstreamProject")
		case "owner":
			out.Values[i] = ec._UpstreamProject_owner(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "project":
			out.Values[i] = ec._UpstreamProject_project(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "repo":
			out.Values[i] = ec._UpstreamProject_repo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "resourceID":
			out.Values[i] = ec._UpstreamProject_resourceID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "revision":
			out.Values[i] = ec._UpstreamProject_revision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "task":
			out.Values[i] = ec._UpstreamProject_task(ctx, field, obj)
		case "triggerID":
			out.Values[i] = ec._UpstreamProject_triggerID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "triggerType":
			out.Values[i] = ec._UpstreamProject_triggerType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._UpstreamProject_version(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var useSpruceOptionsImplementors = []string{"UseSpruceOptions"}

func (ec *executionContext) _UseSpruceOptions(ctx context.Context, sel ast.SelectionSet, obj *model.APIUseSpruceOptions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, useSpruceOptionsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UseSpruceOptions")
		case "spruceV1":
			out.Values[i] = ec._UseSpruceOptions_spruceV1(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userImplementors = []string{"User"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *model.APIDBUser) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "betaFeatures":
			out.Values[i] = ec._User_betaFeatures(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "displayName":
			out.Values[i] = ec._User_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "emailAddress":
			out.Values[i] = ec._User_emailAddress(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "parsleyFilters":
			out.Values[i] = ec._User_parsleyFilters(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "parsleySettings":
			out.Values[i] = ec._User_parsleySettings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "patches":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_patches(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "permissions":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_permissions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "settings":
			out.Values[i] = ec._User_settings(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "subscriptions":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_subscriptions(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "userId":
			out.Values[i] = ec._User_userId(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userConfigImplementors = []string{"UserConfig"}

func (ec *executionContext) _UserConfig(ctx context.Context, sel ast.SelectionSet, obj *UserConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserConfig")
		case "api_key":
			out.Values[i] = ec._UserConfig_api_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "api_server_host":
			out.Values[i] = ec._UserConfig_api_server_host(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "ui_server_host":
			out.Values[i] = ec._UserConfig_ui_server_host(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "user":
			out.Values[i] = ec._UserConfig_user(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var userSettingsImplementors = []string{"UserSettings"}

func (ec *executionContext) _UserSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIUserSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userSettingsImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserSettings")
		case "githubUser":
			out.Values[i] = ec._UserSettings_githubUser(ctx, field, obj)
		case "notifications":
			out.Values[i] = ec._UserSettings_notifications(ctx, field, obj)
		case "region":
			out.Values[i] = ec._UserSettings_region(ctx, field, obj)
		case "slackUsername":
			out.Values[i] = ec._UserSettings_slackUsername(ctx, field, obj)
		case "slackMemberId":
			out.Values[i] = ec._UserSettings_slackMemberId(ctx, field, obj)
		case "timezone":
			out.Values[i] = ec._UserSettings_timezone(ctx, field, obj)
		case "useSpruceOptions":
			out.Values[i] = ec._UserSettings_useSpruceOptions(ctx, field, obj)
		case "dateFormat":
			out.Values[i] = ec._UserSettings_dateFormat(ctx, field, obj)
		case "timeFormat":
			out.Values[i] = ec._UserSettings_timeFormat(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var variantTaskImplementors = []string{"VariantTask"}

func (ec *executionContext) _VariantTask(ctx context.Context, sel ast.SelectionSet, obj *model.VariantTask) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, variantTaskImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VariantTask")
		case "name":
			out.Values[i] = ec._VariantTask_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "tasks":
			out.Values[i] = ec._VariantTask_tasks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var versionImplementors = []string{"Version"}

func (ec *executionContext) _Version(ctx context.Context, sel ast.SelectionSet, obj *model.APIVersion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, versionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Version")
		case "id":
			out.Values[i] = ec._Version_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "activated":
			out.Values[i] = ec._Version_activated(ctx, field, obj)
		case "author":
			out.Values[i] = ec._Version_author(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "authorEmail":
			out.Values[i] = ec._Version_authorEmail(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "baseTaskStatuses":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_baseTaskStatuses(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "baseVersion":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_baseVersion(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "branch":
			out.Values[i] = ec._Version_branch(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "buildVariants":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_buildVariants(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "buildVariantStats":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_buildVariantStats(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "childVersions":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_childVersions(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "createTime":
			out.Values[i] = ec._Version_createTime(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "errors":
			out.Values[i] = ec._Version_errors(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "externalLinksForMetadata":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_externalLinksForMetadata(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "finishTime":
			out.Values[i] = ec._Version_finishTime(ctx, field, obj)
		case "generatedTaskCounts":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_generatedTaskCounts(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "gitTags":
			out.Values[i] = ec._Version_gitTags(ctx, field, obj)
		case "ignored":
			out.Values[i] = ec._Version_ignored(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "isPatch":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_isPatch(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "manifest":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_manifest(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "message":
			out.Values[i] = ec._Version_message(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "order":
			out.Values[i] = ec._Version_order(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "parameters":
			out.Values[i] = ec._Version_parameters(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "patch":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_patch(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "previousVersion":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_previousVersion(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "project":
			out.Values[i] = ec._Version_project(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "projectIdentifier":
			out.Values[i] = ec._Version_projectIdentifier(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "projectMetadata":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_projectMetadata(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "repo":
			out.Values[i] = ec._Version_repo(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "requester":
			out.Values[i] = ec._Version_requester(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "revision":
			out.Values[i] = ec._Version_revision(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "startTime":
			out.Values[i] = ec._Version_startTime(ctx, field, obj)
		case "status":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_status(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "taskCount":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_taskCount(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "tasks":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_tasks(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "taskStatuses":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_taskStatuses(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "taskStatusStats":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_taskStatusStats(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "upstreamProject":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_upstreamProject(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "versionTiming":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_versionTiming(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "warnings":
			field := field

			innerFunc := func(ctx context.Context, fs *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_warnings(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&fs.Invalids, 1)
				}
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "waterfallBuilds":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_waterfallBuilds(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var versionTasksImplementors = []string{"VersionTasks"}

func (ec *executionContext) _VersionTasks(ctx context.Context, sel ast.SelectionSet, obj *VersionTasks) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, versionTasksImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VersionTasks")
		case "count":
			out.Values[i] = ec._VersionTasks_count(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "data":
			out.Values[i] = ec._VersionTasks_data(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var versionTimingImplementors = []string{"VersionTiming"}

func (ec *executionContext) _VersionTiming(ctx context.Context, sel ast.SelectionSet, obj *VersionTiming) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, versionTimingImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VersionTiming")
		case "makespan":
			out.Values[i] = ec._VersionTiming_makespan(ctx, field, obj)
		case "timeTaken":
			out.Values[i] = ec._VersionTiming_timeTaken(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var volumeImplementors = []string{"Volume"}

func (ec *executionContext) _Volume(ctx context.Context, sel ast.SelectionSet, obj *model.APIVolume) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, volumeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Volume")
		case "id":
			out.Values[i] = ec._Volume_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "availabilityZone":
			out.Values[i] = ec._Volume_availabilityZone(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "createdBy":
			out.Values[i] = ec._Volume_createdBy(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "creationTime":
			out.Values[i] = ec._Volume_creationTime(ctx, field, obj)
		case "deviceName":
			out.Values[i] = ec._Volume_deviceName(ctx, field, obj)
		case "displayName":
			out.Values[i] = ec._Volume_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "expiration":
			out.Values[i] = ec._Volume_expiration(ctx, field, obj)
		case "homeVolume":
			out.Values[i] = ec._Volume_homeVolume(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "host":
			field := field

			innerFunc := func(ctx context.Context, _ *graphql.FieldSet) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Volume_host(ctx, field, obj)
				return res
			}

			if field.Deferrable != nil {
				dfs, ok := deferred[field.Deferrable.Label]
				di := 0
				if ok {
					dfs.AddField(field)
					di = len(dfs.Values) - 1
				} else {
					dfs = graphql.NewFieldSet([]graphql.CollectedField{field})
					deferred[field.Deferrable.Label] = dfs
				}
				dfs.Concurrently(di, func(ctx context.Context) graphql.Marshaler {
					return innerFunc(ctx, dfs)
				})

				// don't run the out.Concurrently() call below
				out.Values[i] = graphql.Null
				continue
			}

			out.Concurrently(i, func(ctx context.Context) graphql.Marshaler { return innerFunc(ctx, out) })
		case "hostID":
			out.Values[i] = ec._Volume_hostID(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "migrating":
			out.Values[i] = ec._Volume_migrating(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "noExpiration":
			out.Values[i] = ec._Volume_noExpiration(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "size":
			out.Values[i] = ec._Volume_size(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		case "type":
			out.Values[i] = ec._Volume_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&out.Invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var waterfallImplementors = []string{"Waterfall"}

func (ec *executionContext) _Waterfall(ctx context.Context, sel ast.SelectionSet, obj *Waterfall) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, waterfallImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Waterfall")
		case "flattenedVersions":
			out.Values[i] = ec._Waterfall_flattenedVersions(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "pagination":
			out.Values[i] = ec._Waterfall_pagination(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var waterfallBuildImplementors = []string{"WaterfallBuild"}

func (ec *executionContext) _WaterfallBuild(ctx context.Context, sel ast.SelectionSet, obj *model1.WaterfallBuild) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, waterfallBuildImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WaterfallBuild")
		case "id":
			out.Values[i] = ec._WaterfallBuild_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "activated":
			out.Values[i] = ec._WaterfallBuild_activated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "buildVariant":
			out.Values[i] = ec._WaterfallBuild_buildVariant(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "displayName":
			out.Values[i] = ec._WaterfallBuild_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._WaterfallBuild_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "tasks":
			out.Values[i] = ec._WaterfallBuild_tasks(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var waterfallBuildVariantImplementors = []string{"WaterfallBuildVariant"}

func (ec *executionContext) _WaterfallBuildVariant(ctx context.Context, sel ast.SelectionSet, obj *model1.WaterfallBuildVariant) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, waterfallBuildVariantImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WaterfallBuildVariant")
		case "id":
			out.Values[i] = ec._WaterfallBuildVariant_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "builds":
			out.Values[i] = ec._WaterfallBuildVariant_builds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "displayName":
			out.Values[i] = ec._WaterfallBuildVariant_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "version":
			out.Values[i] = ec._WaterfallBuildVariant_version(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var waterfallPaginationImplementors = []string{"WaterfallPagination"}

func (ec *executionContext) _WaterfallPagination(ctx context.Context, sel ast.SelectionSet, obj *WaterfallPagination) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, waterfallPaginationImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WaterfallPagination")
		case "activeVersionIds":
			out.Values[i] = ec._WaterfallPagination_activeVersionIds(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasNextPage":
			out.Values[i] = ec._WaterfallPagination_hasNextPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "hasPrevPage":
			out.Values[i] = ec._WaterfallPagination_hasPrevPage(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mostRecentVersionOrder":
			out.Values[i] = ec._WaterfallPagination_mostRecentVersionOrder(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "nextPageOrder":
			out.Values[i] = ec._WaterfallPagination_nextPageOrder(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "prevPageOrder":
			out.Values[i] = ec._WaterfallPagination_prevPageOrder(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var waterfallTaskImplementors = []string{"WaterfallTask"}

func (ec *executionContext) _WaterfallTask(ctx context.Context, sel ast.SelectionSet, obj *model1.WaterfallTask) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, waterfallTaskImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WaterfallTask")
		case "id":
			out.Values[i] = ec._WaterfallTask_id(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "displayName":
			out.Values[i] = ec._WaterfallTask_displayName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "displayStatusCache":
			out.Values[i] = ec._WaterfallTask_displayStatusCache(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "execution":
			out.Values[i] = ec._WaterfallTask_execution(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "status":
			out.Values[i] = ec._WaterfallTask_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var waterfallVersionImplementors = []string{"WaterfallVersion"}

func (ec *executionContext) _WaterfallVersion(ctx context.Context, sel ast.SelectionSet, obj *WaterfallVersion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, waterfallVersionImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WaterfallVersion")
		case "inactiveVersions":
			out.Values[i] = ec._WaterfallVersion_inactiveVersions(ctx, field, obj)
		case "version":
			out.Values[i] = ec._WaterfallVersion_version(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var webhookImplementors = []string{"Webhook"}

func (ec *executionContext) _Webhook(ctx context.Context, sel ast.SelectionSet, obj *model.APIWebHook) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, webhookImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Webhook")
		case "endpoint":
			out.Values[i] = ec._Webhook_endpoint(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "secret":
			out.Values[i] = ec._Webhook_secret(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var webhookHeaderImplementors = []string{"WebhookHeader"}

func (ec *executionContext) _WebhookHeader(ctx context.Context, sel ast.SelectionSet, obj *model.APIWebhookHeader) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, webhookHeaderImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WebhookHeader")
		case "key":
			out.Values[i] = ec._WebhookHeader_key(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "value":
			out.Values[i] = ec._WebhookHeader_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var webhookSubscriberImplementors = []string{"WebhookSubscriber"}

func (ec *executionContext) _WebhookSubscriber(ctx context.Context, sel ast.SelectionSet, obj *model.APIWebhookSubscriber) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, webhookSubscriberImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WebhookSubscriber")
		case "headers":
			out.Values[i] = ec._WebhookSubscriber_headers(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "secret":
			out.Values[i] = ec._WebhookSubscriber_secret(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "url":
			out.Values[i] = ec._WebhookSubscriber_url(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "retries":
			out.Values[i] = ec._WebhookSubscriber_retries(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "minDelayMs":
			out.Values[i] = ec._WebhookSubscriber_minDelayMs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "timeoutMs":
			out.Values[i] = ec._WebhookSubscriber_timeoutMs(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workstationConfigImplementors = []string{"WorkstationConfig"}

func (ec *executionContext) _WorkstationConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIWorkstationConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workstationConfigImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkstationConfig")
		case "gitClone":
			out.Values[i] = ec._WorkstationConfig_gitClone(ctx, field, obj)
		case "setupCommands":
			out.Values[i] = ec._WorkstationConfig_setupCommands(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var workstationSetupCommandImplementors = []string{"WorkstationSetupCommand"}

func (ec *executionContext) _WorkstationSetupCommand(ctx context.Context, sel ast.SelectionSet, obj *model.APIWorkstationSetupCommand) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workstationSetupCommandImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkstationSetupCommand")
		case "command":
			out.Values[i] = ec._WorkstationSetupCommand_command(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "directory":
			out.Values[i] = ec._WorkstationSetupCommand_directory(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "isRepeatable":
			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___InputValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "deprecationReason":
			out.Values[i] = ec.___InputValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":
			out.Values[i] = ec.___Schema_description(ctx, field, obj)
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)

	out := graphql.NewFieldSet(fields)
	deferred := make(map[string]*graphql.FieldSet)
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				out.Invalids++
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "specifiedByURL":
			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		case "isOneOf":
			out.Values[i] = ec.___Type_isOneOf(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch(ctx)
	if out.Invalids > 0 {
		return graphql.Null
	}

	atomic.AddInt32(&ec.deferred, int32(len(deferred)))

	for label, dfs := range deferred {
		ec.processDeferredGroup(graphql.DeferredGroup{
			Label:    label,
			Path:     graphql.GetPath(ctx),
			FieldSet: dfs,
			Context:  ctx,
		})
	}

	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx context.Context, v any) (AccessLevel, error) {
	var res AccessLevel
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAccessLevel(ctx context.Context, sel ast.SelectionSet, v AccessLevel) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNAddFavoriteProjectInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAddFavoriteProjectInput(ctx context.Context, v any) (AddFavoriteProjectInput, error) {
	res, err := ec.unmarshalInputAddFavoriteProjectInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAdminEvent2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAdminEventᚄ(ctx context.Context, sel ast.SelectionSet, v []*AdminEvent) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAdminEvent2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAdminEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNAdminEvent2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAdminEvent(ctx context.Context, sel ast.SelectionSet, v *AdminEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AdminEvent(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAdminEventsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAdminEventsInput(ctx context.Context, v any) (AdminEventsInput, error) {
	res, err := ec.unmarshalInputAdminEventsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAdminEventsPayload2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAdminEventsPayload(ctx context.Context, sel ast.SelectionSet, v AdminEventsPayload) graphql.Marshaler {
	return ec._AdminEventsPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNAdminEventsPayload2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAdminEventsPayload(ctx context.Context, sel ast.SelectionSet, v *AdminEventsPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AdminEventsPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNAdminSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAdminSettings(ctx context.Context, sel ast.SelectionSet, v model.APIAdminSettings) graphql.Marshaler {
	return ec._AdminSettings(ctx, sel, &v)
}

func (ec *executionContext) marshalNAdminSettings2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAdminSettings(ctx context.Context, sel ast.SelectionSet, v *model.APIAdminSettings) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AdminSettings(ctx, sel, v)
}

func (ec *executionContext) unmarshalNAdminSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAdminSettings(ctx context.Context, v any) (model.APIAdminSettings, error) {
	res, err := ec.unmarshalInputAdminSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNAdminSettingsInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAdminSettings(ctx context.Context, v any) (*model.APIAdminSettings, error) {
	res, err := ec.unmarshalInputAdminSettingsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNAdminTasksToRestartPayload2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAdminTasksToRestartPayload(ctx context.Context, sel ast.SelectionSet, v AdminTasksToRestartPayload) graphql.Marshaler {
	return ec._AdminTasksToRestartPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNAdminTasksToRestartPayload2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAdminTasksToRestartPayload(ctx context.Context, sel ast.SelectionSet, v *AdminTasksToRestartPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._AdminTasksToRestartPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNAmboyNamedQueueConfig2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAmboyNamedQueueConfig(ctx context.Context, sel ast.SelectionSet, v model.APIAmboyNamedQueueConfig) graphql.Marshaler {
	return ec._AmboyNamedQueueConfig(ctx, sel, &v)
}

func (ec *executionContext) marshalNAmboyNamedQueueConfig2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAmboyNamedQueueConfigᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIAmboyNamedQueueConfig) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAmboyNamedQueueConfig2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAmboyNamedQueueConfig(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNAmboyNamedQueueConfigInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAmboyNamedQueueConfig(ctx context.Context, v any) (model.APIAmboyNamedQueueConfig, error) {
	res, err := ec.unmarshalInputAmboyNamedQueueConfigInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNAmboyNamedQueueConfigInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAmboyNamedQueueConfigᚄ(ctx context.Context, v any) ([]model.APIAmboyNamedQueueConfig, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIAmboyNamedQueueConfig, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAmboyNamedQueueConfigInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAmboyNamedQueueConfig(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNAmboyRetryConfigInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAmboyRetryConfig(ctx context.Context, v any) (model.APIAmboyRetryConfig, error) {
	res, err := ec.unmarshalInputAmboyRetryConfigInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNArch2ᚖstring(ctx context.Context, v any) (*string, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalNArch2ᚖstring[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNArch2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalString(marshalNArch2ᚖstring[*v])
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

var (
	unmarshalNArch2ᚖstring = map[string]string{
		"LINUX_64_BIT":     evergreen.ArchLinuxAmd64,
		"LINUX_ARM_64_BIT": evergreen.ArchLinuxArm64,
		"LINUX_PPC_64_BIT": evergreen.ArchLinuxPpc64le,
		"LINUX_ZSERIES":    evergreen.ArchLinuxS390x,
		"OSX_64_BIT":       evergreen.ArchDarwinAmd64,
		"OSX_ARM_64_BIT":   evergreen.ArchDarwinArm64,
		"WINDOWS_64_BIT":   evergreen.ArchWindowsAmd64,
	}
	marshalNArch2ᚖstring = map[string]string{
		evergreen.ArchLinuxAmd64:   "LINUX_64_BIT",
		evergreen.ArchLinuxArm64:   "LINUX_ARM_64_BIT",
		evergreen.ArchLinuxPpc64le: "LINUX_PPC_64_BIT",
		evergreen.ArchLinuxS390x:   "LINUX_ZSERIES",
		evergreen.ArchDarwinAmd64:  "OSX_64_BIT",
		evergreen.ArchDarwinArm64:  "OSX_ARM_64_BIT",
		evergreen.ArchWindowsAmd64: "WINDOWS_64_BIT",
	}
)

func (ec *executionContext) marshalNAuthUser2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAuthUser(ctx context.Context, sel ast.SelectionSet, v model.APIAuthUser) graphql.Marshaler {
	return ec._AuthUser(ctx, sel, &v)
}

func (ec *executionContext) marshalNAuthUser2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAuthUserᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIAuthUser) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNAuthUser2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAuthUser(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNAuthUserInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAuthUser(ctx context.Context, v any) (model.APIAuthUser, error) {
	res, err := ec.unmarshalInputAuthUserInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBannerTheme2githubᚗcomᚋevergreenᚑciᚋevergreenᚐBannerTheme(ctx context.Context, v any) (evergreen.BannerTheme, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := evergreen.BannerTheme(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBannerTheme2githubᚗcomᚋevergreenᚑciᚋevergreenᚐBannerTheme(ctx context.Context, sel ast.SelectionSet, v evergreen.BannerTheme) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNBetaFeatures2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIBetaFeatures(ctx context.Context, sel ast.SelectionSet, v model.APIBetaFeatures) graphql.Marshaler {
	return ec._BetaFeatures(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNBetaFeaturesInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIBetaFeatures(ctx context.Context, v any) (model.APIBetaFeatures, error) {
	res, err := ec.unmarshalInputBetaFeaturesInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBetaFeaturesInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIBetaFeatures(ctx context.Context, v any) (*model.APIBetaFeatures, error) {
	res, err := ec.unmarshalInputBetaFeaturesInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNBoolean2ᚖbool(ctx context.Context, v any) (*bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalBoolean(*v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNBootstrapMethod2ᚖstring(ctx context.Context, v any) (*string, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalNBootstrapMethod2ᚖstring[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBootstrapMethod2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalString(marshalNBootstrapMethod2ᚖstring[*v])
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

var (
	unmarshalNBootstrapMethod2ᚖstring = map[string]string{
		"LEGACY_SSH": distro.BootstrapMethodLegacySSH,
		"SSH":        distro.BootstrapMethodSSH,
		"USER_DATA":  distro.BootstrapMethodUserData,
	}
	marshalNBootstrapMethod2ᚖstring = map[string]string{
		distro.BootstrapMethodLegacySSH: "LEGACY_SSH",
		distro.BootstrapMethodSSH:       "SSH",
		distro.BootstrapMethodUserData:  "USER_DATA",
	}
)

func (ec *executionContext) marshalNBootstrapSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIBootstrapSettings(ctx context.Context, sel ast.SelectionSet, v model.APIBootstrapSettings) graphql.Marshaler {
	return ec._BootstrapSettings(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNBootstrapSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIBootstrapSettings(ctx context.Context, v any) (model.APIBootstrapSettings, error) {
	res, err := ec.unmarshalInputBootstrapSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBuild2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIBuildᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.APIBuild) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBuild2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIBuild(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNBuild2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIBuild(ctx context.Context, sel ast.SelectionSet, v *model.APIBuild) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Build(ctx, sel, v)
}

func (ec *executionContext) marshalNBuildBaron2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐBuildBaron(ctx context.Context, sel ast.SelectionSet, v BuildBaron) graphql.Marshaler {
	return ec._BuildBaron(ctx, sel, &v)
}

func (ec *executionContext) marshalNBuildBaron2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐBuildBaron(ctx context.Context, sel ast.SelectionSet, v *BuildBaron) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BuildBaron(ctx, sel, v)
}

func (ec *executionContext) marshalNBuildBaronSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIBuildBaronSettings(ctx context.Context, sel ast.SelectionSet, v model.APIBuildBaronSettings) graphql.Marshaler {
	return ec._BuildBaronSettings(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNBuildVariantOptions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐBuildVariantOptions(ctx context.Context, v any) (BuildVariantOptions, error) {
	res, err := ec.unmarshalInputBuildVariantOptions(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBuildVariantTuple2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋtaskᚐBuildVariantTuple(ctx context.Context, sel ast.SelectionSet, v *task.BuildVariantTuple) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BuildVariantTuple(ctx, sel, v)
}

func (ec *executionContext) marshalNChildPatchAlias2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIChildPatchAlias(ctx context.Context, sel ast.SelectionSet, v model.APIChildPatchAlias) graphql.Marshaler {
	return ec._ChildPatchAlias(ctx, sel, &v)
}

func (ec *executionContext) marshalNClientBinary2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIClientBinary(ctx context.Context, sel ast.SelectionSet, v model.APIClientBinary) graphql.Marshaler {
	return ec._ClientBinary(ctx, sel, &v)
}

func (ec *executionContext) marshalNCommitQueueParams2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPICommitQueueParams(ctx context.Context, sel ast.SelectionSet, v model.APICommitQueueParams) graphql.Marshaler {
	return ec._CommitQueueParams(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNCommunicationMethod2ᚖstring(ctx context.Context, v any) (*string, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalNCommunicationMethod2ᚖstring[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCommunicationMethod2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalString(marshalNCommunicationMethod2ᚖstring[*v])
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

var (
	unmarshalNCommunicationMethod2ᚖstring = map[string]string{
		"LEGACY_SSH": distro.CommunicationMethodLegacySSH,
		"SSH":        distro.CommunicationMethodSSH,
		"RPC":        distro.CommunicationMethodRPC,
	}
	marshalNCommunicationMethod2ᚖstring = map[string]string{
		distro.CommunicationMethodLegacySSH: "LEGACY_SSH",
		distro.CommunicationMethodSSH:       "SSH",
		distro.CommunicationMethodRPC:       "RPC",
	}
)

func (ec *executionContext) marshalNContainerPool2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIContainerPool(ctx context.Context, sel ast.SelectionSet, v model.APIContainerPool) graphql.Marshaler {
	return ec._ContainerPool(ctx, sel, &v)
}

func (ec *executionContext) marshalNContainerPool2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIContainerPoolᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIContainerPool) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNContainerPool2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIContainerPool(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNContainerResources2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIContainerResources(ctx context.Context, sel ast.SelectionSet, v model.APIContainerResources) graphql.Marshaler {
	return ec._ContainerResources(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNContainerResourcesInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIContainerResources(ctx context.Context, v any) (model.APIContainerResources, error) {
	res, err := ec.unmarshalInputContainerResourcesInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCopyDistroInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐCopyDistroOpts(ctx context.Context, v any) (model.CopyDistroOpts, error) {
	res, err := ec.unmarshalInputCopyDistroInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCopyProjectInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐCopyProjectOpts(ctx context.Context, v any) (model.CopyProjectOpts, error) {
	res, err := ec.unmarshalInputCopyProjectInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateDistroInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐCreateDistroInput(ctx context.Context, v any) (CreateDistroInput, error) {
	res, err := ec.unmarshalInputCreateDistroInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateProjectInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx context.Context, v any) (model.APIProjectRef, error) {
	res, err := ec.unmarshalInputCreateProjectInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCursorParams2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐCursorParams(ctx context.Context, v any) (*CursorParams, error) {
	res, err := ec.unmarshalInputCursorParams(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDeactivateStepbackTaskInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDeactivateStepbackTaskInput(ctx context.Context, v any) (DeactivateStepbackTaskInput, error) {
	res, err := ec.unmarshalInputDeactivateStepbackTaskInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDefaultSectionToRepoInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDefaultSectionToRepoInput(ctx context.Context, v any) (DefaultSectionToRepoInput, error) {
	res, err := ec.unmarshalInputDefaultSectionToRepoInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDeleteDistroInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDeleteDistroInput(ctx context.Context, v any) (DeleteDistroInput, error) {
	res, err := ec.unmarshalInputDeleteDistroInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDeleteDistroPayload2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDeleteDistroPayload(ctx context.Context, sel ast.SelectionSet, v DeleteDistroPayload) graphql.Marshaler {
	return ec._DeleteDistroPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNDeleteDistroPayload2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDeleteDistroPayload(ctx context.Context, sel ast.SelectionSet, v *DeleteDistroPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DeleteDistroPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDeleteGithubAppCredentialsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDeleteGithubAppCredentialsInput(ctx context.Context, v any) (DeleteGithubAppCredentialsInput, error) {
	res, err := ec.unmarshalInputDeleteGithubAppCredentialsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDependency2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDependency(ctx context.Context, sel ast.SelectionSet, v *Dependency) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Dependency(ctx, sel, v)
}

func (ec *executionContext) marshalNDispatcherSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDispatcherSettings(ctx context.Context, sel ast.SelectionSet, v model.APIDispatcherSettings) graphql.Marshaler {
	return ec._DispatcherSettings(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNDispatcherSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDispatcherSettings(ctx context.Context, v any) (model.APIDispatcherSettings, error) {
	res, err := ec.unmarshalInputDispatcherSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDispatcherVersion2ᚖstring(ctx context.Context, v any) (*string, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalNDispatcherVersion2ᚖstring[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDispatcherVersion2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalString(marshalNDispatcherVersion2ᚖstring[*v])
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

var (
	unmarshalNDispatcherVersion2ᚖstring = map[string]string{
		"REVISED_WITH_DEPENDENCIES": evergreen.DispatcherVersionRevisedWithDependencies,
	}
	marshalNDispatcherVersion2ᚖstring = map[string]string{
		evergreen.DispatcherVersionRevisedWithDependencies: "REVISED_WITH_DEPENDENCIES",
	}
)

func (ec *executionContext) unmarshalNDisplayTask2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDisplayTaskᚄ(ctx context.Context, v any) ([]*DisplayTask, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*DisplayTask, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNDisplayTask2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDisplayTask(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNDisplayTask2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDisplayTask(ctx context.Context, v any) (*DisplayTask, error) {
	res, err := ec.unmarshalInputDisplayTask(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDistro2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDistroᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.APIDistro) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDistro2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDistro(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNDistro2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDistro(ctx context.Context, sel ast.SelectionSet, v *model.APIDistro) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Distro(ctx, sel, v)
}

func (ec *executionContext) marshalNDistroEvent2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroEventᚄ(ctx context.Context, sel ast.SelectionSet, v []*DistroEvent) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDistroEvent2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNDistroEvent2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroEvent(ctx context.Context, sel ast.SelectionSet, v *DistroEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DistroEvent(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDistroEventsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroEventsInput(ctx context.Context, v any) (DistroEventsInput, error) {
	res, err := ec.unmarshalInputDistroEventsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDistroEventsPayload2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroEventsPayload(ctx context.Context, sel ast.SelectionSet, v DistroEventsPayload) graphql.Marshaler {
	return ec._DistroEventsPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNDistroEventsPayload2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroEventsPayload(ctx context.Context, sel ast.SelectionSet, v *DistroEventsPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DistroEventsPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDistroInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDistro(ctx context.Context, v any) (*model.APIDistro, error) {
	res, err := ec.unmarshalInputDistroInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDistroOnSaveOperation2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroOnSaveOperation(ctx context.Context, v any) (DistroOnSaveOperation, error) {
	var res DistroOnSaveOperation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDistroOnSaveOperation2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroOnSaveOperation(ctx context.Context, sel ast.SelectionSet, v DistroOnSaveOperation) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNDistroPermissions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroPermissions(ctx context.Context, sel ast.SelectionSet, v DistroPermissions) graphql.Marshaler {
	return ec._DistroPermissions(ctx, sel, &v)
}

func (ec *executionContext) marshalNDistroPermissions2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroPermissions(ctx context.Context, sel ast.SelectionSet, v *DistroPermissions) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DistroPermissions(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDistroPermissionsOptions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroPermissionsOptions(ctx context.Context, v any) (DistroPermissionsOptions, error) {
	res, err := ec.unmarshalInputDistroPermissionsOptions(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDistroSettingsAccess2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroSettingsAccess(ctx context.Context, v any) (DistroSettingsAccess, error) {
	var res DistroSettingsAccess
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDistroSettingsAccess2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroSettingsAccess(ctx context.Context, sel ast.SelectionSet, v DistroSettingsAccess) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNDuration2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDuration(ctx context.Context, v any) (model.APIDuration, error) {
	res, err := model.UnmarshalAPIDuration(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDuration2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDuration(ctx context.Context, sel ast.SelectionSet, v model.APIDuration) graphql.Marshaler {
	_ = sel
	res := model.MarshalAPIDuration(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNEnvVar2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIEnvVar(ctx context.Context, sel ast.SelectionSet, v model.APIEnvVar) graphql.Marshaler {
	return ec._EnvVar(ctx, sel, &v)
}

func (ec *executionContext) marshalNEnvVar2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIEnvVarᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIEnvVar) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEnvVar2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIEnvVar(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNEnvVarInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIEnvVar(ctx context.Context, v any) (model.APIEnvVar, error) {
	res, err := ec.unmarshalInputEnvVarInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNEnvVarInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIEnvVarᚄ(ctx context.Context, v any) ([]model.APIEnvVar, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIEnvVar, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNEnvVarInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIEnvVar(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNExpansion2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIExpansion(ctx context.Context, sel ast.SelectionSet, v model.APIExpansion) graphql.Marshaler {
	return ec._Expansion(ctx, sel, &v)
}

func (ec *executionContext) marshalNExpansion2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIExpansionᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIExpansion) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNExpansion2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIExpansion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNExpansionInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIExpansion(ctx context.Context, v any) (model.APIExpansion, error) {
	res, err := ec.unmarshalInputExpansionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNExpansionInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIExpansionᚄ(ctx context.Context, v any) ([]model.APIExpansion, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIExpansion, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNExpansionInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIExpansion(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNExternalLink2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIExternalLink(ctx context.Context, sel ast.SelectionSet, v model.APIExternalLink) graphql.Marshaler {
	return ec._ExternalLink(ctx, sel, &v)
}

func (ec *executionContext) marshalNExternalLinkForMetadata2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐExternalLinkForMetadataᚄ(ctx context.Context, sel ast.SelectionSet, v []*ExternalLinkForMetadata) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNExternalLinkForMetadata2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐExternalLinkForMetadata(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNExternalLinkForMetadata2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐExternalLinkForMetadata(ctx context.Context, sel ast.SelectionSet, v *ExternalLinkForMetadata) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ExternalLinkForMetadata(ctx, sel, v)
}

func (ec *executionContext) unmarshalNExternalLinkInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIExternalLink(ctx context.Context, v any) (model.APIExternalLink, error) {
	res, err := ec.unmarshalInputExternalLinkInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFailingCommand2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIFailingCommand(ctx context.Context, sel ast.SelectionSet, v model.APIFailingCommand) graphql.Marshaler {
	return ec._FailingCommand(ctx, sel, &v)
}

func (ec *executionContext) marshalNFailingCommand2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIFailingCommandᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIFailingCommand) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFailingCommand2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIFailingCommand(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNFeedbackRule2ᚖstring(ctx context.Context, v any) (*string, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalNFeedbackRule2ᚖstring[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFeedbackRule2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalString(marshalNFeedbackRule2ᚖstring[*v])
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

var (
	unmarshalNFeedbackRule2ᚖstring = map[string]string{
		"WAITS_OVER_THRESH": evergreen.HostAllocatorWaitsOverThreshFeedback,
		"NO_FEEDBACK":       evergreen.HostAllocatorNoFeedback,
		"DEFAULT":           evergreen.HostAllocatorUseDefaultFeedback,
	}
	marshalNFeedbackRule2ᚖstring = map[string]string{
		evergreen.HostAllocatorWaitsOverThreshFeedback: "WAITS_OVER_THRESH",
		evergreen.HostAllocatorNoFeedback:              "NO_FEEDBACK",
		evergreen.HostAllocatorUseDefaultFeedback:      "DEFAULT",
	}
)

func (ec *executionContext) marshalNFile2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIFile(ctx context.Context, sel ast.SelectionSet, v *model.APIFile) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._File(ctx, sel, v)
}

func (ec *executionContext) marshalNFileDiff2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐFileDiff(ctx context.Context, sel ast.SelectionSet, v model.FileDiff) graphql.Marshaler {
	return ec._FileDiff(ctx, sel, &v)
}

func (ec *executionContext) marshalNFileDiff2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐFileDiffᚄ(ctx context.Context, sel ast.SelectionSet, v []model.FileDiff) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFileDiff2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐFileDiff(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFinderSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIFinderSettings(ctx context.Context, sel ast.SelectionSet, v model.APIFinderSettings) graphql.Marshaler {
	return ec._FinderSettings(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNFinderSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIFinderSettings(ctx context.Context, v any) (model.APIFinderSettings, error) {
	res, err := ec.unmarshalInputFinderSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNFinderVersion2ᚖstring(ctx context.Context, v any) (*string, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalNFinderVersion2ᚖstring[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFinderVersion2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalString(marshalNFinderVersion2ᚖstring[*v])
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

var (
	unmarshalNFinderVersion2ᚖstring = map[string]string{
		"LEGACY":    evergreen.FinderVersionLegacy,
		"PARALLEL":  evergreen.FinderVersionParallel,
		"PIPELINE":  evergreen.FinderVersionPipeline,
		"ALTERNATE": evergreen.FinderVersionAlternate,
	}
	marshalNFinderVersion2ᚖstring = map[string]string{
		evergreen.FinderVersionLegacy:    "LEGACY",
		evergreen.FinderVersionParallel:  "PARALLEL",
		evergreen.FinderVersionPipeline:  "PIPELINE",
		evergreen.FinderVersionAlternate: "ALTERNATE",
	}
)

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v any) (float64, error) {
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalFloatContext(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) marshalNGeneralSubscription2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISubscription(ctx context.Context, sel ast.SelectionSet, v model.APISubscription) graphql.Marshaler {
	return ec._GeneralSubscription(ctx, sel, &v)
}

func (ec *executionContext) marshalNGeneralSubscription2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISubscription(ctx context.Context, sel ast.SelectionSet, v *model.APISubscription) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GeneralSubscription(ctx, sel, v)
}

func (ec *executionContext) marshalNGeneratedTaskCountResults2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐGeneratedTaskCountResultsᚄ(ctx context.Context, sel ast.SelectionSet, v []*GeneratedTaskCountResults) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGeneratedTaskCountResults2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐGeneratedTaskCountResults(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNGeneratedTaskCountResults2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐGeneratedTaskCountResults(ctx context.Context, sel ast.SelectionSet, v *GeneratedTaskCountResults) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GeneratedTaskCountResults(ctx, sel, v)
}

func (ec *executionContext) marshalNGitHubDynamicTokenPermissionGroup2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGitHubDynamicTokenPermissionGroup(ctx context.Context, sel ast.SelectionSet, v model.APIGitHubDynamicTokenPermissionGroup) graphql.Marshaler {
	return ec._GitHubDynamicTokenPermissionGroup(ctx, sel, &v)
}

func (ec *executionContext) marshalNGitHubDynamicTokenPermissionGroup2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGitHubDynamicTokenPermissionGroupᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIGitHubDynamicTokenPermissionGroup) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGitHubDynamicTokenPermissionGroup2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGitHubDynamicTokenPermissionGroup(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNGitHubDynamicTokenPermissionGroupInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGitHubDynamicTokenPermissionGroup(ctx context.Context, v any) (model.APIGitHubDynamicTokenPermissionGroup, error) {
	res, err := ec.unmarshalInputGitHubDynamicTokenPermissionGroupInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNGitTag2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGitTag(ctx context.Context, sel ast.SelectionSet, v model.APIGitTag) graphql.Marshaler {
	return ec._GitTag(ctx, sel, &v)
}

func (ec *executionContext) marshalNGithubProjectConflicts2githubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐGithubProjectConflicts(ctx context.Context, sel ast.SelectionSet, v model1.GithubProjectConflicts) graphql.Marshaler {
	return ec._GithubProjectConflicts(ctx, sel, &v)
}

func (ec *executionContext) marshalNGithubProjectConflicts2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐGithubProjectConflicts(ctx context.Context, sel ast.SelectionSet, v *model1.GithubProjectConflicts) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GithubProjectConflicts(ctx, sel, v)
}

func (ec *executionContext) marshalNGroupedBuildVariant2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐGroupedBuildVariant(ctx context.Context, sel ast.SelectionSet, v *GroupedBuildVariant) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GroupedBuildVariant(ctx, sel, v)
}

func (ec *executionContext) marshalNGroupedFiles2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐGroupedFilesᚄ(ctx context.Context, sel ast.SelectionSet, v []*GroupedFiles) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGroupedFiles2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐGroupedFiles(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNGroupedFiles2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐGroupedFiles(ctx context.Context, sel ast.SelectionSet, v *GroupedFiles) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GroupedFiles(ctx, sel, v)
}

func (ec *executionContext) marshalNGroupedProjects2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐGroupedProjectsᚄ(ctx context.Context, sel ast.SelectionSet, v []*GroupedProjects) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGroupedProjects2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐGroupedProjects(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNGroupedProjects2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐGroupedProjects(ctx context.Context, sel ast.SelectionSet, v *GroupedProjects) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GroupedProjects(ctx, sel, v)
}

func (ec *executionContext) marshalNGroupedTaskStatusCount2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋtaskᚐGroupedTaskStatusCount(ctx context.Context, sel ast.SelectionSet, v *task.GroupedTaskStatusCount) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GroupedTaskStatusCount(ctx, sel, v)
}

func (ec *executionContext) marshalNHomeVolumeSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHomeVolumeSettings(ctx context.Context, sel ast.SelectionSet, v model.APIHomeVolumeSettings) graphql.Marshaler {
	return ec._HomeVolumeSettings(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNHomeVolumeSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHomeVolumeSettings(ctx context.Context, v any) (model.APIHomeVolumeSettings, error) {
	res, err := ec.unmarshalInputHomeVolumeSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNHost2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHost(ctx context.Context, sel ast.SelectionSet, v model.APIHost) graphql.Marshaler {
	return ec._Host(ctx, sel, &v)
}

func (ec *executionContext) marshalNHost2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHostᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.APIHost) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNHost2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHost(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNHost2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHost(ctx context.Context, sel ast.SelectionSet, v *model.APIHost) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Host(ctx, sel, v)
}

func (ec *executionContext) unmarshalNHostAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐHostAccessLevel(ctx context.Context, v any) (HostAccessLevel, error) {
	var res HostAccessLevel
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNHostAccessLevel2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐHostAccessLevel(ctx context.Context, sel ast.SelectionSet, v HostAccessLevel) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNHostAllocatorSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHostAllocatorSettings(ctx context.Context, sel ast.SelectionSet, v model.APIHostAllocatorSettings) graphql.Marshaler {
	return ec._HostAllocatorSettings(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNHostAllocatorSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHostAllocatorSettings(ctx context.Context, v any) (model.APIHostAllocatorSettings, error) {
	res, err := ec.unmarshalInputHostAllocatorSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNHostAllocatorVersion2ᚖstring(ctx context.Context, v any) (*string, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalNHostAllocatorVersion2ᚖstring[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNHostAllocatorVersion2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalString(marshalNHostAllocatorVersion2ᚖstring[*v])
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

var (
	unmarshalNHostAllocatorVersion2ᚖstring = map[string]string{
		"UTILIZATION": evergreen.HostAllocatorUtilization,
	}
	marshalNHostAllocatorVersion2ᚖstring = map[string]string{
		evergreen.HostAllocatorUtilization: "UTILIZATION",
	}
)

func (ec *executionContext) marshalNHostEventLogData2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐHostAPIEventData(ctx context.Context, sel ast.SelectionSet, v *model.HostAPIEventData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._HostEventLogData(ctx, sel, v)
}

func (ec *executionContext) marshalNHostEventLogEntry2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐHostAPIEventLogEntryᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.HostAPIEventLogEntry) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNHostEventLogEntry2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐHostAPIEventLogEntry(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNHostEventLogEntry2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐHostAPIEventLogEntry(ctx context.Context, sel ast.SelectionSet, v *model.HostAPIEventLogEntry) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._HostEventLogEntry(ctx, sel, v)
}

func (ec *executionContext) unmarshalNHostEventType2string(ctx context.Context, v any) (string, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalNHostEventType2string[tmp]
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNHostEventType2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(marshalNHostEventType2string[v])
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

var (
	unmarshalNHostEventType2string = map[string]string{
		"HOST_CREATED":                                     event.EventHostCreated,
		"HOST_CREATED_ERROR":                               event.EventHostCreatedError,
		"HOST_STARTED":                                     event.EventHostStarted,
		"HOST_STOPPED":                                     event.EventHostStopped,
		"HOST_MODIFIED":                                    event.EventHostModified,
		"HOST_AGENT_DEPLOYED":                              event.EventHostAgentDeployed,
		"HOST_AGENT_DEPLOY_FAILED":                         event.EventHostAgentDeployFailed,
		"HOST_AGENT_MONITOR_DEPLOYED":                      event.EventHostAgentMonitorDeployed,
		"HOST_AGENT_MONITOR_DEPLOY_FAILED":                 event.EventHostAgentMonitorDeployFailed,
		"HOST_JASPER_RESTARTING":                           event.EventHostJasperRestarting,
		"HOST_JASPER_RESTARTED":                            event.EventHostJasperRestarted,
		"HOST_JASPER_RESTART_ERROR":                        event.EventHostJasperRestartError,
		"HOST_CONVERTING_PROVISIONING":                     event.EventHostConvertingProvisioning,
		"HOST_CONVERTED_PROVISIONING":                      event.EventHostConvertedProvisioning,
		"HOST_CONVERTING_PROVISIONING_ERROR":               event.EventHostConvertingProvisioningError,
		"HOST_STATUS_CHANGED":                              event.EventHostStatusChanged,
		"HOST_DNS_NAME_SET":                                event.EventHostDNSNameSet,
		"HOST_PROVISION_ERROR":                             event.EventHostProvisionError,
		"HOST_PROVISION_FAILED":                            event.EventHostProvisionFailed,
		"HOST_PROVISIONED":                                 event.EventHostProvisioned,
		"HOST_RUNNING_TASK_SET":                            event.EventHostRunningTaskSet,
		"HOST_RUNNING_TASK_CLEARED":                        event.EventHostRunningTaskCleared,
		"HOST_TASK_FINISHED":                               event.EventHostTaskFinished,
		"HOST_TERMINATED_EXTERNALLY":                       event.EventHostTerminatedExternally,
		"HOST_EXPIRATION_WARNING_SENT":                     event.EventHostExpirationWarningSent,
		"HOST_TEMPORARY_EXEMPTION_EXPIRATION_WARNING_SENT": event.EventHostTemporaryExemptionExpirationWarningSent,
		"HOST_IDLE_NOTIFICATION":                           event.EventSpawnHostIdleNotification,
		"HOST_ALERTABLE_INSTANCE_TYPE_WARNING_SENT":        event.EventAlertableInstanceTypeWarningSent,
		"HOST_SCRIPT_EXECUTED":                             event.EventHostScriptExecuted,
		"HOST_SCRIPT_EXECUTE_FAILED":                       event.EventHostScriptExecuteFailed,
		"SPAWN_HOST_CREATED_ERROR":                         event.EventSpawnHostCreatedError,
		"VOLUME_EXPIRATION_WARNING_SENT":                   event.EventVolumeExpirationWarningSent,
		"VOLUME_MIGRATION_FAILED":                          event.EventVolumeMigrationFailed,
	}
	marshalNHostEventType2string = map[string]string{
		event.EventHostCreated:                                 "HOST_CREATED",
		event.EventHostCreatedError:                            "HOST_CREATED_ERROR",
		event.EventHostStarted:                                 "HOST_STARTED",
		event.EventHostStopped:                                 "HOST_STOPPED",
		event.EventHostModified:                                "HOST_MODIFIED",
		event.EventHostAgentDeployed:                           "HOST_AGENT_DEPLOYED",
		event.EventHostAgentDeployFailed:                       "HOST_AGENT_DEPLOY_FAILED",
		event.EventHostAgentMonitorDeployed:                    "HOST_AGENT_MONITOR_DEPLOYED",
		event.EventHostAgentMonitorDeployFailed:                "HOST_AGENT_MONITOR_DEPLOY_FAILED",
		event.EventHostJasperRestarting:                        "HOST_JASPER_RESTARTING",
		event.EventHostJasperRestarted:                         "HOST_JASPER_RESTARTED",
		event.EventHostJasperRestartError:                      "HOST_JASPER_RESTART_ERROR",
		event.EventHostConvertingProvisioning:                  "HOST_CONVERTING_PROVISIONING",
		event.EventHostConvertedProvisioning:                   "HOST_CONVERTED_PROVISIONING",
		event.EventHostConvertingProvisioningError:             "HOST_CONVERTING_PROVISIONING_ERROR",
		event.EventHostStatusChanged:                           "HOST_STATUS_CHANGED",
		event.EventHostDNSNameSet:                              "HOST_DNS_NAME_SET",
		event.EventHostProvisionError:                          "HOST_PROVISION_ERROR",
		event.EventHostProvisionFailed:                         "HOST_PROVISION_FAILED",
		event.EventHostProvisioned:                             "HOST_PROVISIONED",
		event.EventHostRunningTaskSet:                          "HOST_RUNNING_TASK_SET",
		event.EventHostRunningTaskCleared:                      "HOST_RUNNING_TASK_CLEARED",
		event.EventHostTaskFinished:                            "HOST_TASK_FINISHED",
		event.EventHostTerminatedExternally:                    "HOST_TERMINATED_EXTERNALLY",
		event.EventHostExpirationWarningSent:                   "HOST_EXPIRATION_WARNING_SENT",
		event.EventHostTemporaryExemptionExpirationWarningSent: "HOST_TEMPORARY_EXEMPTION_EXPIRATION_WARNING_SENT",
		event.EventSpawnHostIdleNotification:                   "HOST_IDLE_NOTIFICATION",
		event.EventAlertableInstanceTypeWarningSent:            "HOST_ALERTABLE_INSTANCE_TYPE_WARNING_SENT",
		event.EventHostScriptExecuted:                          "HOST_SCRIPT_EXECUTED",
		event.EventHostScriptExecuteFailed:                     "HOST_SCRIPT_EXECUTE_FAILED",
		event.EventSpawnHostCreatedError:                       "SPAWN_HOST_CREATED_ERROR",
		event.EventVolumeExpirationWarningSent:                 "VOLUME_EXPIRATION_WARNING_SENT",
		event.EventVolumeMigrationFailed:                       "VOLUME_MIGRATION_FAILED",
	}
)

func (ec *executionContext) unmarshalNHostEventType2ᚕstringᚄ(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNHostEventType2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNHostEventType2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNHostEventType2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

var (
	unmarshalNHostEventType2ᚕstringᚄ = map[string]string{
		"HOST_CREATED":                                     event.EventHostCreated,
		"HOST_CREATED_ERROR":                               event.EventHostCreatedError,
		"HOST_STARTED":                                     event.EventHostStarted,
		"HOST_STOPPED":                                     event.EventHostStopped,
		"HOST_MODIFIED":                                    event.EventHostModified,
		"HOST_AGENT_DEPLOYED":                              event.EventHostAgentDeployed,
		"HOST_AGENT_DEPLOY_FAILED":                         event.EventHostAgentDeployFailed,
		"HOST_AGENT_MONITOR_DEPLOYED":                      event.EventHostAgentMonitorDeployed,
		"HOST_AGENT_MONITOR_DEPLOY_FAILED":                 event.EventHostAgentMonitorDeployFailed,
		"HOST_JASPER_RESTARTING":                           event.EventHostJasperRestarting,
		"HOST_JASPER_RESTARTED":                            event.EventHostJasperRestarted,
		"HOST_JASPER_RESTART_ERROR":                        event.EventHostJasperRestartError,
		"HOST_CONVERTING_PROVISIONING":                     event.EventHostConvertingProvisioning,
		"HOST_CONVERTED_PROVISIONING":                      event.EventHostConvertedProvisioning,
		"HOST_CONVERTING_PROVISIONING_ERROR":               event.EventHostConvertingProvisioningError,
		"HOST_STATUS_CHANGED":                              event.EventHostStatusChanged,
		"HOST_DNS_NAME_SET":                                event.EventHostDNSNameSet,
		"HOST_PROVISION_ERROR":                             event.EventHostProvisionError,
		"HOST_PROVISION_FAILED":                            event.EventHostProvisionFailed,
		"HOST_PROVISIONED":                                 event.EventHostProvisioned,
		"HOST_RUNNING_TASK_SET":                            event.EventHostRunningTaskSet,
		"HOST_RUNNING_TASK_CLEARED":                        event.EventHostRunningTaskCleared,
		"HOST_TASK_FINISHED":                               event.EventHostTaskFinished,
		"HOST_TERMINATED_EXTERNALLY":                       event.EventHostTerminatedExternally,
		"HOST_EXPIRATION_WARNING_SENT":                     event.EventHostExpirationWarningSent,
		"HOST_TEMPORARY_EXEMPTION_EXPIRATION_WARNING_SENT": event.EventHostTemporaryExemptionExpirationWarningSent,
		"HOST_IDLE_NOTIFICATION":                           event.EventSpawnHostIdleNotification,
		"HOST_ALERTABLE_INSTANCE_TYPE_WARNING_SENT":        event.EventAlertableInstanceTypeWarningSent,
		"HOST_SCRIPT_EXECUTED":                             event.EventHostScriptExecuted,
		"HOST_SCRIPT_EXECUTE_FAILED":                       event.EventHostScriptExecuteFailed,
		"SPAWN_HOST_CREATED_ERROR":                         event.EventSpawnHostCreatedError,
		"VOLUME_EXPIRATION_WARNING_SENT":                   event.EventVolumeExpirationWarningSent,
		"VOLUME_MIGRATION_FAILED":                          event.EventVolumeMigrationFailed,
	}
	marshalNHostEventType2ᚕstringᚄ = map[string]string{
		event.EventHostCreated:                                 "HOST_CREATED",
		event.EventHostCreatedError:                            "HOST_CREATED_ERROR",
		event.EventHostStarted:                                 "HOST_STARTED",
		event.EventHostStopped:                                 "HOST_STOPPED",
		event.EventHostModified:                                "HOST_MODIFIED",
		event.EventHostAgentDeployed:                           "HOST_AGENT_DEPLOYED",
		event.EventHostAgentDeployFailed:                       "HOST_AGENT_DEPLOY_FAILED",
		event.EventHostAgentMonitorDeployed:                    "HOST_AGENT_MONITOR_DEPLOYED",
		event.EventHostAgentMonitorDeployFailed:                "HOST_AGENT_MONITOR_DEPLOY_FAILED",
		event.EventHostJasperRestarting:                        "HOST_JASPER_RESTARTING",
		event.EventHostJasperRestarted:                         "HOST_JASPER_RESTARTED",
		event.EventHostJasperRestartError:                      "HOST_JASPER_RESTART_ERROR",
		event.EventHostConvertingProvisioning:                  "HOST_CONVERTING_PROVISIONING",
		event.EventHostConvertedProvisioning:                   "HOST_CONVERTED_PROVISIONING",
		event.EventHostConvertingProvisioningError:             "HOST_CONVERTING_PROVISIONING_ERROR",
		event.EventHostStatusChanged:                           "HOST_STATUS_CHANGED",
		event.EventHostDNSNameSet:                              "HOST_DNS_NAME_SET",
		event.EventHostProvisionError:                          "HOST_PROVISION_ERROR",
		event.EventHostProvisionFailed:                         "HOST_PROVISION_FAILED",
		event.EventHostProvisioned:                             "HOST_PROVISIONED",
		event.EventHostRunningTaskSet:                          "HOST_RUNNING_TASK_SET",
		event.EventHostRunningTaskCleared:                      "HOST_RUNNING_TASK_CLEARED",
		event.EventHostTaskFinished:                            "HOST_TASK_FINISHED",
		event.EventHostTerminatedExternally:                    "HOST_TERMINATED_EXTERNALLY",
		event.EventHostExpirationWarningSent:                   "HOST_EXPIRATION_WARNING_SENT",
		event.EventHostTemporaryExemptionExpirationWarningSent: "HOST_TEMPORARY_EXEMPTION_EXPIRATION_WARNING_SENT",
		event.EventSpawnHostIdleNotification:                   "HOST_IDLE_NOTIFICATION",
		event.EventAlertableInstanceTypeWarningSent:            "HOST_ALERTABLE_INSTANCE_TYPE_WARNING_SENT",
		event.EventHostScriptExecuted:                          "HOST_SCRIPT_EXECUTED",
		event.EventHostScriptExecuteFailed:                     "HOST_SCRIPT_EXECUTE_FAILED",
		event.EventSpawnHostCreatedError:                       "SPAWN_HOST_CREATED_ERROR",
		event.EventVolumeExpirationWarningSent:                 "VOLUME_EXPIRATION_WARNING_SENT",
		event.EventVolumeMigrationFailed:                       "VOLUME_MIGRATION_FAILED",
	}
)

func (ec *executionContext) marshalNHostEvents2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐHostEvents(ctx context.Context, sel ast.SelectionSet, v HostEvents) graphql.Marshaler {
	return ec._HostEvents(ctx, sel, &v)
}

func (ec *executionContext) marshalNHostEvents2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐHostEvents(ctx context.Context, sel ast.SelectionSet, v *HostEvents) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._HostEvents(ctx, sel, v)
}

func (ec *executionContext) unmarshalNHostEventsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐHostEventsInput(ctx context.Context, v any) (HostEventsInput, error) {
	res, err := ec.unmarshalInputHostEventsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNHostsResponse2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐHostsResponse(ctx context.Context, sel ast.SelectionSet, v HostsResponse) graphql.Marshaler {
	return ec._HostsResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNHostsResponse2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐHostsResponse(ctx context.Context, sel ast.SelectionSet, v *HostsResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._HostsResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNID2ᚖstring(ctx context.Context, v any) (*string, error) {
	res, err := graphql.UnmarshalID(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalID(*v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNIceCreamSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIIceCreamSettings(ctx context.Context, sel ast.SelectionSet, v model.APIIceCreamSettings) graphql.Marshaler {
	return ec._IceCreamSettings(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNIceCreamSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIIceCreamSettings(ctx context.Context, v any) (model.APIIceCreamSettings, error) {
	res, err := ec.unmarshalInputIceCreamSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNImageEvent2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIImageEventᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.APIImageEvent) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNImageEvent2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIImageEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNImageEvent2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIImageEvent(ctx context.Context, sel ast.SelectionSet, v *model.APIImageEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ImageEvent(ctx, sel, v)
}

func (ec *executionContext) marshalNImageEventEntry2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIImageEventEntry(ctx context.Context, sel ast.SelectionSet, v model.APIImageEventEntry) graphql.Marshaler {
	return ec._ImageEventEntry(ctx, sel, &v)
}

func (ec *executionContext) marshalNImageEventEntry2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIImageEventEntryᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIImageEventEntry) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNImageEventEntry2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIImageEventEntry(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNImageEventEntryAction2githubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐImageEventEntryAction(ctx context.Context, v any) (thirdparty.ImageEventEntryAction, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := thirdparty.ImageEventEntryAction(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNImageEventEntryAction2githubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐImageEventEntryAction(ctx context.Context, sel ast.SelectionSet, v thirdparty.ImageEventEntryAction) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNImageEventType2githubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐImageEventType(ctx context.Context, v any) (thirdparty.ImageEventType, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := thirdparty.ImageEventType(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNImageEventType2githubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐImageEventType(ctx context.Context, sel ast.SelectionSet, v thirdparty.ImageEventType) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNImageEventsPayload2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐImageEventsPayload(ctx context.Context, sel ast.SelectionSet, v ImageEventsPayload) graphql.Marshaler {
	return ec._ImageEventsPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNImageEventsPayload2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐImageEventsPayload(ctx context.Context, sel ast.SelectionSet, v *ImageEventsPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ImageEventsPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNImageOperatingSystemPayload2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐImageOperatingSystemPayload(ctx context.Context, sel ast.SelectionSet, v ImageOperatingSystemPayload) graphql.Marshaler {
	return ec._ImageOperatingSystemPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNImageOperatingSystemPayload2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐImageOperatingSystemPayload(ctx context.Context, sel ast.SelectionSet, v *ImageOperatingSystemPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ImageOperatingSystemPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNImagePackagesPayload2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐImagePackagesPayload(ctx context.Context, sel ast.SelectionSet, v ImagePackagesPayload) graphql.Marshaler {
	return ec._ImagePackagesPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNImagePackagesPayload2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐImagePackagesPayload(ctx context.Context, sel ast.SelectionSet, v *ImagePackagesPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ImagePackagesPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNImageToolchainsPayload2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐImageToolchainsPayload(ctx context.Context, sel ast.SelectionSet, v ImageToolchainsPayload) graphql.Marshaler {
	return ec._ImageToolchainsPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNImageToolchainsPayload2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐImageToolchainsPayload(ctx context.Context, sel ast.SelectionSet, v *ImageToolchainsPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ImageToolchainsPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNInstanceTag2githubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋhostᚐTag(ctx context.Context, sel ast.SelectionSet, v host.Tag) graphql.Marshaler {
	return ec._InstanceTag(ctx, sel, &v)
}

func (ec *executionContext) marshalNInstanceTag2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋhostᚐTagᚄ(ctx context.Context, sel ast.SelectionSet, v []host.Tag) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNInstanceTag2githubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋhostᚐTag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNInstanceTagInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋhostᚐTag(ctx context.Context, v any) (*host.Tag, error) {
	res, err := ec.unmarshalInputInstanceTagInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v any) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int64(ctx context.Context, v any) (int64, error) {
	res, err := graphql.UnmarshalInt64(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int64(ctx context.Context, sel ast.SelectionSet, v int64) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalInt64(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2ᚕintᚄ(ctx context.Context, v any) ([]int, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNInt2ᚕintᚄ(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNInt2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNInt2ᚖint(ctx context.Context, v any) (*int, error) {
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalInt(*v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNIssueLink2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIIssueLink(ctx context.Context, sel ast.SelectionSet, v model.APIIssueLink) graphql.Marshaler {
	return ec._IssueLink(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNIssueLinkInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIIssueLink(ctx context.Context, v any) (model.APIIssueLink, error) {
	res, err := ec.unmarshalInputIssueLinkInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNJiraStatus2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐJiraStatus(ctx context.Context, sel ast.SelectionSet, v *thirdparty.JiraStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._JiraStatus(ctx, sel, v)
}

func (ec *executionContext) marshalNJiraTicket2githubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐJiraTicket(ctx context.Context, sel ast.SelectionSet, v thirdparty.JiraTicket) graphql.Marshaler {
	return ec._JiraTicket(ctx, sel, &v)
}

func (ec *executionContext) marshalNJiraTicket2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐJiraTicketᚄ(ctx context.Context, sel ast.SelectionSet, v []thirdparty.JiraTicket) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNJiraTicket2githubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐJiraTicket(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNJiraTicket2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐJiraTicketᚄ(ctx context.Context, sel ast.SelectionSet, v []*thirdparty.JiraTicket) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNJiraTicket2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐJiraTicket(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNJiraTicket2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐJiraTicket(ctx context.Context, sel ast.SelectionSet, v *thirdparty.JiraTicket) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._JiraTicket(ctx, sel, v)
}

func (ec *executionContext) unmarshalNLogBufferingInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPILogBuffering(ctx context.Context, v any) (*model.APILogBuffering, error) {
	res, err := ec.unmarshalInputLogBufferingInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNLogMessage2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋapimodelsᚐLogMessageᚄ(ctx context.Context, sel ast.SelectionSet, v []*apimodels.LogMessage) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLogMessage2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋapimodelsᚐLogMessage(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNLogMessage2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋapimodelsᚐLogMessage(ctx context.Context, sel ast.SelectionSet, v *apimodels.LogMessage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LogMessage(ctx, sel, v)
}

func (ec *executionContext) marshalNLogkeeperBuild2githubᚗcomᚋevergreenᚑciᚋplankᚐBuild(ctx context.Context, sel ast.SelectionSet, v plank.Build) graphql.Marshaler {
	return ec._LogkeeperBuild(ctx, sel, &v)
}

func (ec *executionContext) marshalNLogkeeperBuild2ᚖgithubᚗcomᚋevergreenᚑciᚋplankᚐBuild(ctx context.Context, sel ast.SelectionSet, v *plank.Build) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LogkeeperBuild(ctx, sel, v)
}

func (ec *executionContext) marshalNLogkeeperTest2githubᚗcomᚋevergreenᚑciᚋplankᚐTest(ctx context.Context, sel ast.SelectionSet, v plank.Test) graphql.Marshaler {
	return ec._LogkeeperTest(ctx, sel, &v)
}

func (ec *executionContext) marshalNLogkeeperTest2ᚕgithubᚗcomᚋevergreenᚑciᚋplankᚐTestᚄ(ctx context.Context, sel ast.SelectionSet, v []plank.Test) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLogkeeperTest2githubᚗcomᚋevergreenᚑciᚋplankᚐTest(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMainlineCommitVersion2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐMainlineCommitVersionᚄ(ctx context.Context, sel ast.SelectionSet, v []*MainlineCommitVersion) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMainlineCommitVersion2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐMainlineCommitVersion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMainlineCommitVersion2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐMainlineCommitVersion(ctx context.Context, sel ast.SelectionSet, v *MainlineCommitVersion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MainlineCommitVersion(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMainlineCommitsOptions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐMainlineCommitsOptions(ctx context.Context, v any) (MainlineCommitsOptions, error) {
	res, err := ec.unmarshalInputMainlineCommitsOptions(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMap2map(ctx context.Context, v any) (map[string]any, error) {
	res, err := graphql.UnmarshalMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]any) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalMap(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNMap2ᚕmapᚄ(ctx context.Context, v any) ([]map[string]any, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]map[string]any, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMap2map(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNMap2ᚕmapᚄ(ctx context.Context, sel ast.SelectionSet, v []map[string]any) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNMap2map(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNMetStatus2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐMetStatus(ctx context.Context, v any) (MetStatus, error) {
	var res MetStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMetStatus2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐMetStatus(ctx context.Context, sel ast.SelectionSet, v MetStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNMetadataLink2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIMetadataLink(ctx context.Context, sel ast.SelectionSet, v model.APIMetadataLink) graphql.Marshaler {
	return ec._MetadataLink(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNMetadataLinkInput2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIMetadataLinkᚄ(ctx context.Context, v any) ([]*model.APIMetadataLink, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*model.APIMetadataLink, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMetadataLinkInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIMetadataLink(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMetadataLinkInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIMetadataLink(ctx context.Context, v any) (*model.APIMetadataLink, error) {
	res, err := ec.unmarshalInputMetadataLinkInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNModuleCodeChange2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIModulePatch(ctx context.Context, sel ast.SelectionSet, v model.APIModulePatch) graphql.Marshaler {
	return ec._ModuleCodeChange(ctx, sel, &v)
}

func (ec *executionContext) marshalNModuleCodeChange2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIModulePatchᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIModulePatch) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNModuleCodeChange2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIModulePatch(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNMoveProjectInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐMoveProjectInput(ctx context.Context, v any) (MoveProjectInput, error) {
	res, err := ec.unmarshalInputMoveProjectInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNNewDistroPayload2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐNewDistroPayload(ctx context.Context, sel ast.SelectionSet, v NewDistroPayload) graphql.Marshaler {
	return ec._NewDistroPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNNewDistroPayload2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐNewDistroPayload(ctx context.Context, sel ast.SelectionSet, v *NewDistroPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._NewDistroPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNOSInfo2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIOSInfoᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.APIOSInfo) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNOSInfo2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIOSInfo(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNOSInfo2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIOSInfo(ctx context.Context, sel ast.SelectionSet, v *model.APIOSInfo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._OSInfo(ctx, sel, v)
}

func (ec *executionContext) marshalNOomTrackerInfo2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIOomTrackerInfo(ctx context.Context, sel ast.SelectionSet, v model.APIOomTrackerInfo) graphql.Marshaler {
	return ec._OomTrackerInfo(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNOperatingSystemOpts2githubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐOSInfoFilterOptions(ctx context.Context, v any) (thirdparty.OSInfoFilterOptions, error) {
	res, err := ec.unmarshalInputOperatingSystemOpts(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNOverallocatedRule2ᚖstring(ctx context.Context, v any) (*string, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalNOverallocatedRule2ᚖstring[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNOverallocatedRule2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalString(marshalNOverallocatedRule2ᚖstring[*v])
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

var (
	unmarshalNOverallocatedRule2ᚖstring = map[string]string{
		"TERMINATE": evergreen.HostsOverallocatedTerminate,
		"IGNORE":    evergreen.HostsOverallocatedIgnore,
		"DEFAULT":   evergreen.HostsOverallocatedUseDefault,
	}
	marshalNOverallocatedRule2ᚖstring = map[string]string{
		evergreen.HostsOverallocatedTerminate:  "TERMINATE",
		evergreen.HostsOverallocatedIgnore:     "IGNORE",
		evergreen.HostsOverallocatedUseDefault: "DEFAULT",
	}
)

func (ec *executionContext) marshalNPackage2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPackageᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.APIPackage) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPackage2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPackage(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPackage2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPackage(ctx context.Context, sel ast.SelectionSet, v *model.APIPackage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Package(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPackageOpts2githubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐPackageFilterOptions(ctx context.Context, v any) (thirdparty.PackageFilterOptions, error) {
	res, err := ec.unmarshalInputPackageOpts(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNParameter2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParameter(ctx context.Context, sel ast.SelectionSet, v model.APIParameter) graphql.Marshaler {
	return ec._Parameter(ctx, sel, &v)
}

func (ec *executionContext) marshalNParameter2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParameterᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIParameter) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNParameter2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParameter(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNParameter2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParameterᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.APIParameter) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNParameter2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParameter(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNParameter2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParameter(ctx context.Context, sel ast.SelectionSet, v *model.APIParameter) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Parameter(ctx, sel, v)
}

func (ec *executionContext) unmarshalNParameterInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParameter(ctx context.Context, v any) (*model.APIParameter, error) {
	res, err := ec.unmarshalInputParameterInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNParsleyFilter2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParsleyFilter(ctx context.Context, sel ast.SelectionSet, v model.APIParsleyFilter) graphql.Marshaler {
	return ec._ParsleyFilter(ctx, sel, &v)
}

func (ec *executionContext) marshalNParsleyFilter2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParsleyFilterᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIParsleyFilter) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNParsleyFilter2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParsleyFilter(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNParsleyFilterInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParsleyFilter(ctx context.Context, v any) (model.APIParsleyFilter, error) {
	res, err := ec.unmarshalInputParsleyFilterInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNParsleySettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParsleySettings(ctx context.Context, sel ast.SelectionSet, v model.APIParsleySettings) graphql.Marshaler {
	return ec._ParsleySettings(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNParsleySettingsInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParsleySettings(ctx context.Context, v any) (*model.APIParsleySettings, error) {
	res, err := ec.unmarshalInputParsleySettingsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPatch2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatch(ctx context.Context, sel ast.SelectionSet, v model.APIPatch) graphql.Marshaler {
	return ec._Patch(ctx, sel, &v)
}

func (ec *executionContext) marshalNPatch2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatchᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.APIPatch) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPatch2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatch(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPatch2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatch(ctx context.Context, sel ast.SelectionSet, v *model.APIPatch) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Patch(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPatchConfigure2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPatchConfigure(ctx context.Context, v any) (PatchConfigure, error) {
	res, err := ec.unmarshalInputPatchConfigure(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPatchTriggerAlias2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatchTriggerDefinition(ctx context.Context, sel ast.SelectionSet, v model.APIPatchTriggerDefinition) graphql.Marshaler {
	return ec._PatchTriggerAlias(ctx, sel, &v)
}

func (ec *executionContext) marshalNPatchTriggerAlias2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatchTriggerDefinitionᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.APIPatchTriggerDefinition) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPatchTriggerAlias2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatchTriggerDefinition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPatchTriggerAlias2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatchTriggerDefinition(ctx context.Context, sel ast.SelectionSet, v *model.APIPatchTriggerDefinition) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PatchTriggerAlias(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPatchTriggerAliasInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatchTriggerDefinition(ctx context.Context, v any) (model.APIPatchTriggerDefinition, error) {
	res, err := ec.unmarshalInputPatchTriggerAliasInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPatches2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPatches(ctx context.Context, sel ast.SelectionSet, v Patches) graphql.Marshaler {
	return ec._Patches(ctx, sel, &v)
}

func (ec *executionContext) marshalNPatches2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPatches(ctx context.Context, sel ast.SelectionSet, v *Patches) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Patches(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPatchesInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPatchesInput(ctx context.Context, v any) (PatchesInput, error) {
	res, err := ec.unmarshalInputPatchesInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPeriodicBuild2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPeriodicBuildDefinition(ctx context.Context, sel ast.SelectionSet, v model.APIPeriodicBuildDefinition) graphql.Marshaler {
	return ec._PeriodicBuild(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNPeriodicBuildInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPeriodicBuildDefinition(ctx context.Context, v any) (model.APIPeriodicBuildDefinition, error) {
	res, err := ec.unmarshalInputPeriodicBuildInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPermissions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPermissions(ctx context.Context, sel ast.SelectionSet, v Permissions) graphql.Marshaler {
	return ec._Permissions(ctx, sel, &v)
}

func (ec *executionContext) marshalNPermissions2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPermissions(ctx context.Context, sel ast.SelectionSet, v *Permissions) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Permissions(ctx, sel, v)
}

func (ec *executionContext) marshalNPlannerSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPlannerSettings(ctx context.Context, sel ast.SelectionSet, v model.APIPlannerSettings) graphql.Marshaler {
	return ec._PlannerSettings(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNPlannerSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPlannerSettings(ctx context.Context, v any) (model.APIPlannerSettings, error) {
	res, err := ec.unmarshalInputPlannerSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNPlannerVersion2ᚖstring(ctx context.Context, v any) (*string, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalNPlannerVersion2ᚖstring[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPlannerVersion2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalString(marshalNPlannerVersion2ᚖstring[*v])
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

var (
	unmarshalNPlannerVersion2ᚖstring = map[string]string{
		"TUNABLE": evergreen.PlannerVersionTunable,
	}
	marshalNPlannerVersion2ᚖstring = map[string]string{
		evergreen.PlannerVersionTunable: "TUNABLE",
	}
)

func (ec *executionContext) marshalNPod2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPod(ctx context.Context, sel ast.SelectionSet, v model.APIPod) graphql.Marshaler {
	return ec._Pod(ctx, sel, &v)
}

func (ec *executionContext) marshalNPod2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPod(ctx context.Context, sel ast.SelectionSet, v *model.APIPod) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Pod(ctx, sel, v)
}

func (ec *executionContext) marshalNPodEventLogData2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐPodAPIEventData(ctx context.Context, sel ast.SelectionSet, v *model.PodAPIEventData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PodEventLogData(ctx, sel, v)
}

func (ec *executionContext) marshalNPodEventLogEntry2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐPodAPIEventLogEntryᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.PodAPIEventLogEntry) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPodEventLogEntry2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐPodAPIEventLogEntry(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPodEventLogEntry2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐPodAPIEventLogEntry(ctx context.Context, sel ast.SelectionSet, v *model.PodAPIEventLogEntry) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PodEventLogEntry(ctx, sel, v)
}

func (ec *executionContext) marshalNPodEvents2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPodEvents(ctx context.Context, sel ast.SelectionSet, v PodEvents) graphql.Marshaler {
	return ec._PodEvents(ctx, sel, &v)
}

func (ec *executionContext) marshalNPodEvents2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPodEvents(ctx context.Context, sel ast.SelectionSet, v *PodEvents) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PodEvents(ctx, sel, v)
}

func (ec *executionContext) marshalNPreconditionScript2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPreconditionScript(ctx context.Context, sel ast.SelectionSet, v model.APIPreconditionScript) graphql.Marshaler {
	return ec._PreconditionScript(ctx, sel, &v)
}

func (ec *executionContext) marshalNPreconditionScript2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPreconditionScriptᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIPreconditionScript) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPreconditionScript2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPreconditionScript(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNPreconditionScriptInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPreconditionScript(ctx context.Context, v any) (model.APIPreconditionScript, error) {
	res, err := ec.unmarshalInputPreconditionScriptInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNPreconditionScriptInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPreconditionScriptᚄ(ctx context.Context, v any) ([]model.APIPreconditionScript, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIPreconditionScript, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPreconditionScriptInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPreconditionScript(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNPriorityLevel2ᚖstring(ctx context.Context, v any) (*string, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalNPriorityLevel2ᚖstring[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPriorityLevel2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalString(marshalNPriorityLevel2ᚖstring[*v])
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

var (
	unmarshalNPriorityLevel2ᚖstring = map[string]string{
		"EMERGENCY": evergreen.PriorityLevelEmergency,
		"ALERT":     evergreen.PriorityLevelAlert,
		"CRITICAL":  evergreen.PriorityLevelCritical,
		"ERROR":     evergreen.PriorityLevelError,
		"WARNING":   evergreen.PriorityLevelWarning,
		"NOTICE":    evergreen.PriorityLevelNotice,
		"INFO":      evergreen.PriorityLevelInfo,
		"DEBUG":     evergreen.PriorityLevelDebug,
		"TRACE":     evergreen.PriorityLevelTrace,
	}
	marshalNPriorityLevel2ᚖstring = map[string]string{
		evergreen.PriorityLevelEmergency: "EMERGENCY",
		evergreen.PriorityLevelAlert:     "ALERT",
		evergreen.PriorityLevelCritical:  "CRITICAL",
		evergreen.PriorityLevelError:     "ERROR",
		evergreen.PriorityLevelWarning:   "WARNING",
		evergreen.PriorityLevelNotice:    "NOTICE",
		evergreen.PriorityLevelInfo:      "INFO",
		evergreen.PriorityLevelDebug:     "DEBUG",
		evergreen.PriorityLevelTrace:     "TRACE",
	}
)

func (ec *executionContext) marshalNProject2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx context.Context, sel ast.SelectionSet, v model.APIProjectRef) graphql.Marshaler {
	return ec._Project(ctx, sel, &v)
}

func (ec *executionContext) marshalNProject2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRefᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.APIProjectRef) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProject2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNProject2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx context.Context, sel ast.SelectionSet, v *model.APIProjectRef) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Project(ctx, sel, v)
}

func (ec *executionContext) marshalNProjectAlias2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectAlias(ctx context.Context, sel ast.SelectionSet, v model.APIProjectAlias) graphql.Marshaler {
	return ec._ProjectAlias(ctx, sel, &v)
}

func (ec *executionContext) marshalNProjectAlias2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectAlias(ctx context.Context, sel ast.SelectionSet, v *model.APIProjectAlias) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProjectAlias(ctx, sel, v)
}

func (ec *executionContext) unmarshalNProjectAliasInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectAlias(ctx context.Context, v any) (model.APIProjectAlias, error) {
	res, err := ec.unmarshalInputProjectAliasInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProjectBuildVariant2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectBuildVariantᚄ(ctx context.Context, sel ast.SelectionSet, v []*ProjectBuildVariant) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProjectBuildVariant2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectBuildVariant(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNProjectBuildVariant2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectBuildVariant(ctx context.Context, sel ast.SelectionSet, v *ProjectBuildVariant) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProjectBuildVariant(ctx, sel, v)
}

func (ec *executionContext) marshalNProjectEventLogEntry2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectEventᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.APIProjectEvent) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProjectEventLogEntry2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNProjectEventLogEntry2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectEvent(ctx context.Context, sel ast.SelectionSet, v *model.APIProjectEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProjectEventLogEntry(ctx, sel, v)
}

func (ec *executionContext) marshalNProjectEvents2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectEvents(ctx context.Context, sel ast.SelectionSet, v ProjectEvents) graphql.Marshaler {
	return ec._ProjectEvents(ctx, sel, &v)
}

func (ec *executionContext) marshalNProjectEvents2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectEvents(ctx context.Context, sel ast.SelectionSet, v *ProjectEvents) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProjectEvents(ctx, sel, v)
}

func (ec *executionContext) unmarshalNProjectHealthView2githubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐProjectHealthView(ctx context.Context, v any) (model1.ProjectHealthView, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := model1.ProjectHealthView(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProjectHealthView2githubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐProjectHealthView(ctx context.Context, sel ast.SelectionSet, v model1.ProjectHealthView) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx context.Context, v any) (ProjectPermission, error) {
	var res ProjectPermission
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProjectPermission2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermission(ctx context.Context, sel ast.SelectionSet, v ProjectPermission) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNProjectPermissions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermissions(ctx context.Context, sel ast.SelectionSet, v ProjectPermissions) graphql.Marshaler {
	return ec._ProjectPermissions(ctx, sel, &v)
}

func (ec *executionContext) marshalNProjectPermissions2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermissions(ctx context.Context, sel ast.SelectionSet, v *ProjectPermissions) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProjectPermissions(ctx, sel, v)
}

func (ec *executionContext) unmarshalNProjectPermissionsOptions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectPermissionsOptions(ctx context.Context, v any) (ProjectPermissionsOptions, error) {
	res, err := ec.unmarshalInputProjectPermissionsOptions(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProjectSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectSettings(ctx context.Context, sel ast.SelectionSet, v model.APIProjectSettings) graphql.Marshaler {
	return ec._ProjectSettings(ctx, sel, &v)
}

func (ec *executionContext) marshalNProjectSettings2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectSettings(ctx context.Context, sel ast.SelectionSet, v *model.APIProjectSettings) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProjectSettings(ctx, sel, v)
}

func (ec *executionContext) unmarshalNProjectSettingsSection2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectSettingsSection(ctx context.Context, v any) (ProjectSettingsSection, error) {
	var res ProjectSettingsSection
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProjectSettingsSection2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectSettingsSection(ctx context.Context, sel ast.SelectionSet, v ProjectSettingsSection) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNProjectTasksPair2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectTasksPair(ctx context.Context, sel ast.SelectionSet, v model.APIProjectTasksPair) graphql.Marshaler {
	return ec._ProjectTasksPair(ctx, sel, &v)
}

func (ec *executionContext) marshalNProjectTasksPair2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectTasksPairᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIProjectTasksPair) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProjectTasksPair2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectTasksPair(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNPromoteVarsToRepoInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPromoteVarsToRepoInput(ctx context.Context, v any) (PromoteVarsToRepoInput, error) {
	res, err := ec.unmarshalInputPromoteVarsToRepoInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNProvider2ᚖstring(ctx context.Context, v any) (*string, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalNProvider2ᚖstring[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProvider2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalString(marshalNProvider2ᚖstring[*v])
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

var (
	unmarshalNProvider2ᚖstring = map[string]string{
		"DOCKER":        evergreen.ProviderNameDocker,
		"EC2_FLEET":     evergreen.ProviderNameEc2Fleet,
		"EC2_ON_DEMAND": evergreen.ProviderNameEc2OnDemand,
		"STATIC":        evergreen.ProviderNameStatic,
	}
	marshalNProvider2ᚖstring = map[string]string{
		evergreen.ProviderNameDocker:      "DOCKER",
		evergreen.ProviderNameEc2Fleet:    "EC2_FLEET",
		evergreen.ProviderNameEc2OnDemand: "EC2_ON_DEMAND",
		evergreen.ProviderNameStatic:      "STATIC",
	}
)

func (ec *executionContext) marshalNPublicKey2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPubKeyᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.APIPubKey) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPublicKey2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPubKey(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPublicKey2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPubKey(ctx context.Context, sel ast.SelectionSet, v *model.APIPubKey) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PublicKey(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPublicKeyInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPublicKeyInput(ctx context.Context, v any) (PublicKeyInput, error) {
	res, err := ec.unmarshalInputPublicKeyInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNPublicKeyInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPublicKeyInput(ctx context.Context, v any) (*PublicKeyInput, error) {
	res, err := ec.unmarshalInputPublicKeyInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNRemoveFavoriteProjectInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐRemoveFavoriteProjectInput(ctx context.Context, v any) (RemoveFavoriteProjectInput, error) {
	res, err := ec.unmarshalInputRemoveFavoriteProjectInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRepoCommitQueueParams2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPICommitQueueParams(ctx context.Context, sel ast.SelectionSet, v model.APICommitQueueParams) graphql.Marshaler {
	return ec._RepoCommitQueueParams(ctx, sel, &v)
}

func (ec *executionContext) marshalNRepoPermissions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐRepoPermissions(ctx context.Context, sel ast.SelectionSet, v RepoPermissions) graphql.Marshaler {
	return ec._RepoPermissions(ctx, sel, &v)
}

func (ec *executionContext) marshalNRepoPermissions2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐRepoPermissions(ctx context.Context, sel ast.SelectionSet, v *RepoPermissions) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RepoPermissions(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRepoPermissionsOptions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐRepoPermissionsOptions(ctx context.Context, v any) (RepoPermissionsOptions, error) {
	res, err := ec.unmarshalInputRepoPermissionsOptions(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRepoSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectSettings(ctx context.Context, sel ast.SelectionSet, v model.APIProjectSettings) graphql.Marshaler {
	return ec._RepoSettings(ctx, sel, &v)
}

func (ec *executionContext) marshalNRepoSettings2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectSettings(ctx context.Context, sel ast.SelectionSet, v *model.APIProjectSettings) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RepoSettings(ctx, sel, v)
}

func (ec *executionContext) marshalNRepoWorkstationConfig2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWorkstationConfig(ctx context.Context, sel ast.SelectionSet, v model.APIWorkstationConfig) graphql.Marshaler {
	return ec._RepoWorkstationConfig(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNRequiredStatus2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐRequiredStatus(ctx context.Context, v any) (RequiredStatus, error) {
	var res RequiredStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRequiredStatus2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐRequiredStatus(ctx context.Context, sel ast.SelectionSet, v RequiredStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNResourceLimits2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIResourceLimits(ctx context.Context, sel ast.SelectionSet, v model.APIResourceLimits) graphql.Marshaler {
	return ec._ResourceLimits(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNResourceLimitsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIResourceLimits(ctx context.Context, v any) (model.APIResourceLimits, error) {
	res, err := ec.unmarshalInputResourceLimitsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNRestartAdminTasksOptions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐRestartOptions(ctx context.Context, v any) (model1.RestartOptions, error) {
	res, err := ec.unmarshalInputRestartAdminTasksOptions(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRestartAdminTasksPayload2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐRestartAdminTasksPayload(ctx context.Context, sel ast.SelectionSet, v RestartAdminTasksPayload) graphql.Marshaler {
	return ec._RestartAdminTasksPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNRestartAdminTasksPayload2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐRestartAdminTasksPayload(ctx context.Context, sel ast.SelectionSet, v *RestartAdminTasksPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RestartAdminTasksPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNRoundingRule2ᚖstring(ctx context.Context, v any) (*string, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalNRoundingRule2ᚖstring[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRoundingRule2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalString(marshalNRoundingRule2ᚖstring[*v])
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

var (
	unmarshalNRoundingRule2ᚖstring = map[string]string{
		"DOWN":    evergreen.HostAllocatorRoundDown,
		"UP":      evergreen.HostAllocatorRoundUp,
		"DEFAULT": evergreen.HostAllocatorRoundDefault,
	}
	marshalNRoundingRule2ᚖstring = map[string]string{
		evergreen.HostAllocatorRoundDown:    "DOWN",
		evergreen.HostAllocatorRoundUp:      "UP",
		evergreen.HostAllocatorRoundDefault: "DEFAULT",
	}
)

func (ec *executionContext) unmarshalNSaveDistroInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSaveDistroInput(ctx context.Context, v any) (SaveDistroInput, error) {
	res, err := ec.unmarshalInputSaveDistroInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSaveDistroPayload2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSaveDistroPayload(ctx context.Context, sel ast.SelectionSet, v SaveDistroPayload) graphql.Marshaler {
	return ec._SaveDistroPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNSaveDistroPayload2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSaveDistroPayload(ctx context.Context, sel ast.SelectionSet, v *SaveDistroPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SaveDistroPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNSelector2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISelector(ctx context.Context, sel ast.SelectionSet, v model.APISelector) graphql.Marshaler {
	return ec._Selector(ctx, sel, &v)
}

func (ec *executionContext) marshalNSelector2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISelectorᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APISelector) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSelector2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISelector(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNSelectorInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISelector(ctx context.Context, v any) (model.APISelector, error) {
	res, err := ec.unmarshalInputSelectorInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSelectorInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISelectorᚄ(ctx context.Context, v any) ([]model.APISelector, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APISelector, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSelectorInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISelector(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNSetLastRevisionInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSetLastRevisionInput(ctx context.Context, v any) (SetLastRevisionInput, error) {
	res, err := ec.unmarshalInputSetLastRevisionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSetLastRevisionPayload2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSetLastRevisionPayload(ctx context.Context, sel ast.SelectionSet, v SetLastRevisionPayload) graphql.Marshaler {
	return ec._SetLastRevisionPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNSetLastRevisionPayload2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSetLastRevisionPayload(ctx context.Context, sel ast.SelectionSet, v *SetLastRevisionPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SetLastRevisionPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSortDirection2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSortDirection(ctx context.Context, v any) (SortDirection, error) {
	var res SortDirection
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSortDirection2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSortDirection(ctx context.Context, sel ast.SelectionSet, v SortDirection) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNSortOrder2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSortOrder(ctx context.Context, v any) (*SortOrder, error) {
	res, err := ec.unmarshalInputSortOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSource2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISource(ctx context.Context, sel ast.SelectionSet, v *model.APISource) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Source(ctx, sel, v)
}

func (ec *executionContext) marshalNSpawnHostConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISpawnHostConfig(ctx context.Context, sel ast.SelectionSet, v *model.APISpawnHostConfig) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SpawnHostConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSpawnHostStatusActions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSpawnHostStatusActions(ctx context.Context, v any) (SpawnHostStatusActions, error) {
	var res SpawnHostStatusActions
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSpawnHostStatusActions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSpawnHostStatusActions(ctx context.Context, sel ast.SelectionSet, v SpawnHostStatusActions) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNSpawnVolumeInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSpawnVolumeInput(ctx context.Context, v any) (SpawnVolumeInput, error) {
	res, err := ec.unmarshalInputSpawnVolumeInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSplunkConnectionInfo2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISplunkConnectionInfo(ctx context.Context, sel ast.SelectionSet, v *model.APISplunkConnectionInfo) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SplunkConnectionInfo(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSplunkConnectionInfoInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISplunkConnectionInfo(ctx context.Context, v any) (*model.APISplunkConnectionInfo, error) {
	res, err := ec.unmarshalInputSplunkConnectionInfoInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNStatusCount2githubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋtaskᚐStatusCount(ctx context.Context, sel ast.SelectionSet, v task.StatusCount) graphql.Marshaler {
	return ec._StatusCount(ctx, sel, &v)
}

func (ec *executionContext) marshalNStatusCount2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋtaskᚐStatusCountᚄ(ctx context.Context, sel ast.SelectionSet, v []*task.StatusCount) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStatusCount2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋtaskᚐStatusCount(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNStatusCount2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋtaskᚐStatusCount(ctx context.Context, sel ast.SelectionSet, v *task.StatusCount) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._StatusCount(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2ᚕstringᚄ(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNString2ᚕᚖstringᚄ(ctx context.Context, v any) ([]*string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2ᚖstring(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2ᚕᚖstringᚄ(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2ᚖstring(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNString2ᚖstring(ctx context.Context, v any) (*string, error) {
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalString(*v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNStringMap2map(ctx context.Context, v any) (map[string]string, error) {
	res, err := UnmarshalStringMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNStringMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := MarshalStringMap(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNSubscriber2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSubscriber(ctx context.Context, sel ast.SelectionSet, v Subscriber) graphql.Marshaler {
	return ec._Subscriber(ctx, sel, &v)
}

func (ec *executionContext) marshalNSubscriber2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSubscriber(ctx context.Context, sel ast.SelectionSet, v *Subscriber) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Subscriber(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSubscriberInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISubscriber(ctx context.Context, v any) (model.APISubscriber, error) {
	res, err := ec.unmarshalInputSubscriberInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSubscriptionInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISubscription(ctx context.Context, v any) (model.APISubscription, error) {
	res, err := ec.unmarshalInputSubscriptionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTask2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITask(ctx context.Context, sel ast.SelectionSet, v model.APITask) graphql.Marshaler {
	return ec._Task(ctx, sel, &v)
}

func (ec *executionContext) marshalNTask2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.APITask) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTask2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITask(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTask2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITask(ctx context.Context, sel ast.SelectionSet, v *model.APITask) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Task(ctx, sel, v)
}

func (ec *executionContext) marshalNTaskAnnotationSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskAnnotationSettings(ctx context.Context, sel ast.SelectionSet, v model.APITaskAnnotationSettings) graphql.Marshaler {
	return ec._TaskAnnotationSettings(ctx, sel, &v)
}

func (ec *executionContext) marshalNTaskContainerCreationOpts2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPodTaskContainerCreationOptions(ctx context.Context, sel ast.SelectionSet, v model.APIPodTaskContainerCreationOptions) graphql.Marshaler {
	return ec._TaskContainerCreationOpts(ctx, sel, &v)
}

func (ec *executionContext) marshalNTaskEventLogData2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐTaskEventData(ctx context.Context, sel ast.SelectionSet, v *model.TaskEventData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskEventLogData(ctx, sel, v)
}

func (ec *executionContext) marshalNTaskEventLogEntry2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐTaskAPIEventLogEntryᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.TaskAPIEventLogEntry) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTaskEventLogEntry2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐTaskAPIEventLogEntry(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTaskEventLogEntry2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐTaskAPIEventLogEntry(ctx context.Context, sel ast.SelectionSet, v *model.TaskAPIEventLogEntry) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskEventLogEntry(ctx, sel, v)
}

func (ec *executionContext) marshalNTaskFiles2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskFiles(ctx context.Context, sel ast.SelectionSet, v TaskFiles) graphql.Marshaler {
	return ec._TaskFiles(ctx, sel, &v)
}

func (ec *executionContext) marshalNTaskFiles2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskFiles(ctx context.Context, sel ast.SelectionSet, v *TaskFiles) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskFiles(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTaskFilterOptions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskFilterOptions(ctx context.Context, v any) (TaskFilterOptions, error) {
	res, err := ec.unmarshalInputTaskFilterOptions(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTaskHistory2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskHistory(ctx context.Context, sel ast.SelectionSet, v TaskHistory) graphql.Marshaler {
	return ec._TaskHistory(ctx, sel, &v)
}

func (ec *executionContext) marshalNTaskHistory2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskHistory(ctx context.Context, sel ast.SelectionSet, v *TaskHistory) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskHistory(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTaskHistoryDirection2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskHistoryDirection(ctx context.Context, v any) (TaskHistoryDirection, error) {
	var res TaskHistoryDirection
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTaskHistoryDirection2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskHistoryDirection(ctx context.Context, sel ast.SelectionSet, v TaskHistoryDirection) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNTaskHistoryOpts2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskHistoryOpts(ctx context.Context, v any) (TaskHistoryOpts, error) {
	res, err := ec.unmarshalInputTaskHistoryOpts(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTaskHistoryPagination2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskHistoryPagination(ctx context.Context, sel ast.SelectionSet, v *TaskHistoryPagination) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskHistoryPagination(ctx, sel, v)
}

func (ec *executionContext) marshalNTaskLogLinks2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐLogLinks(ctx context.Context, sel ast.SelectionSet, v model.LogLinks) graphql.Marshaler {
	return ec._TaskLogLinks(ctx, sel, &v)
}

func (ec *executionContext) marshalNTaskLogs2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskLogs(ctx context.Context, sel ast.SelectionSet, v TaskLogs) graphql.Marshaler {
	return ec._TaskLogs(ctx, sel, &v)
}

func (ec *executionContext) marshalNTaskLogs2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskLogs(ctx context.Context, sel ast.SelectionSet, v *TaskLogs) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskLogs(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTaskPriority2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskPriorityᚄ(ctx context.Context, v any) ([]*TaskPriority, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*TaskPriority, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTaskPriority2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskPriority(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNTaskPriority2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskPriority(ctx context.Context, v any) (*TaskPriority, error) {
	res, err := ec.unmarshalInputTaskPriority(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTaskQueueDistro2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskQueueDistroᚄ(ctx context.Context, sel ast.SelectionSet, v []*TaskQueueDistro) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTaskQueueDistro2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskQueueDistro(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTaskQueueDistro2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskQueueDistro(ctx context.Context, sel ast.SelectionSet, v *TaskQueueDistro) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskQueueDistro(ctx, sel, v)
}

func (ec *executionContext) marshalNTaskQueueItem2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskQueueItemᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.APITaskQueueItem) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTaskQueueItem2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskQueueItem(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTaskQueueItem2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskQueueItem(ctx context.Context, sel ast.SelectionSet, v *model.APITaskQueueItem) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskQueueItem(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTaskQueueItemType2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskQueueItemType(ctx context.Context, v any) (TaskQueueItemType, error) {
	var res TaskQueueItemType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTaskQueueItemType2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskQueueItemType(ctx context.Context, sel ast.SelectionSet, v TaskQueueItemType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNTaskSortCategory2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskSortCategory(ctx context.Context, v any) (TaskSortCategory, error) {
	var res TaskSortCategory
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTaskSortCategory2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskSortCategory(ctx context.Context, sel ast.SelectionSet, v TaskSortCategory) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNTaskSpecifier2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskSpecifier(ctx context.Context, sel ast.SelectionSet, v model.APITaskSpecifier) graphql.Marshaler {
	return ec._TaskSpecifier(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNTaskSpecifierInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskSpecifier(ctx context.Context, v any) (model.APITaskSpecifier, error) {
	res, err := ec.unmarshalInputTaskSpecifierInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNTaskSpecifierInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskSpecifierᚄ(ctx context.Context, v any) ([]model.APITaskSpecifier, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APITaskSpecifier, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTaskSpecifierInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskSpecifier(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNTaskTestResult2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskTestResult(ctx context.Context, sel ast.SelectionSet, v TaskTestResult) graphql.Marshaler {
	return ec._TaskTestResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNTaskTestResult2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskTestResult(ctx context.Context, sel ast.SelectionSet, v *TaskTestResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskTestResult(ctx, sel, v)
}

func (ec *executionContext) marshalNTaskTestResultSample2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskTestResultSample(ctx context.Context, sel ast.SelectionSet, v *TaskTestResultSample) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskTestResultSample(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTestFilter2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTestFilterᚄ(ctx context.Context, v any) ([]*TestFilter, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*TestFilter, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTestFilter2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTestFilter(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNTestFilter2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTestFilter(ctx context.Context, v any) (*TestFilter, error) {
	res, err := ec.unmarshalInputTestFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTestLog2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐTestLogs(ctx context.Context, sel ast.SelectionSet, v model.TestLogs) graphql.Marshaler {
	return ec._TestLog(ctx, sel, &v)
}

func (ec *executionContext) marshalNTestResult2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITestᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.APITest) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTestResult2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITest(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTestResult2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITest(ctx context.Context, sel ast.SelectionSet, v *model.APITest) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TestResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTestSortCategory2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTestSortCategory(ctx context.Context, v any) (TestSortCategory, error) {
	var res TestSortCategory
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTestSortCategory2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTestSortCategory(ctx context.Context, sel ast.SelectionSet, v TestSortCategory) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNTestSortOptions2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTestSortOptions(ctx context.Context, v any) (*TestSortOptions, error) {
	res, err := ec.unmarshalInputTestSortOptions(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTicketFields2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐTicketFields(ctx context.Context, sel ast.SelectionSet, v *thirdparty.TicketFields) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TicketFields(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTime2timeᚐTime(ctx context.Context, v any) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeᚐTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNTime2ᚖtimeᚐTime(ctx context.Context, v any) (*time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2ᚖtimeᚐTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalTime(*v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNToolchain2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIToolchainᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.APIToolchain) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNToolchain2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIToolchain(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNToolchain2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIToolchain(ctx context.Context, sel ast.SelectionSet, v *model.APIToolchain) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Toolchain(ctx, sel, v)
}

func (ec *executionContext) unmarshalNToolchainOpts2githubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐToolchainFilterOptions(ctx context.Context, v any) (thirdparty.ToolchainFilterOptions, error) {
	res, err := ec.unmarshalInputToolchainOpts(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTriggerAlias2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITriggerDefinition(ctx context.Context, sel ast.SelectionSet, v model.APITriggerDefinition) graphql.Marshaler {
	return ec._TriggerAlias(ctx, sel, &v)
}

func (ec *executionContext) marshalNTriggerAlias2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITriggerDefinitionᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APITriggerDefinition) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTriggerAlias2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITriggerDefinition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNTriggerAliasInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITriggerDefinition(ctx context.Context, v any) (model.APITriggerDefinition, error) {
	res, err := ec.unmarshalInputTriggerAliasInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUIConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIUIConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIUIConfig) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._UIConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalNUpdateBetaFeaturesInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐUpdateBetaFeaturesInput(ctx context.Context, v any) (UpdateBetaFeaturesInput, error) {
	res, err := ec.unmarshalInputUpdateBetaFeaturesInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateParsleySettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐUpdateParsleySettingsInput(ctx context.Context, v any) (UpdateParsleySettingsInput, error) {
	res, err := ec.unmarshalInputUpdateParsleySettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateSpawnHostStatusInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐUpdateSpawnHostStatusInput(ctx context.Context, v any) (UpdateSpawnHostStatusInput, error) {
	res, err := ec.unmarshalInputUpdateSpawnHostStatusInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateVolumeInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐUpdateVolumeInput(ctx context.Context, v any) (UpdateVolumeInput, error) {
	res, err := ec.unmarshalInputUpdateVolumeInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUser2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDBUser(ctx context.Context, sel ast.SelectionSet, v model.APIDBUser) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalNUser2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDBUser(ctx context.Context, sel ast.SelectionSet, v *model.APIDBUser) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalNUserSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIUserSettings(ctx context.Context, sel ast.SelectionSet, v model.APIUserSettings) graphql.Marshaler {
	return ec._UserSettings(ctx, sel, &v)
}

func (ec *executionContext) marshalNVariantTask2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐVariantTask(ctx context.Context, sel ast.SelectionSet, v model.VariantTask) graphql.Marshaler {
	return ec._VariantTask(ctx, sel, &v)
}

func (ec *executionContext) marshalNVariantTask2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐVariantTaskᚄ(ctx context.Context, sel ast.SelectionSet, v []model.VariantTask) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNVariantTask2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐVariantTask(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNVariantTasks2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐVariantTasksᚄ(ctx context.Context, v any) ([]*VariantTasks, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*VariantTasks, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNVariantTasks2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐVariantTasks(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNVariantTasks2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐVariantTasks(ctx context.Context, v any) (*VariantTasks, error) {
	res, err := ec.unmarshalInputVariantTasks(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNVersion2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVersion(ctx context.Context, sel ast.SelectionSet, v model.APIVersion) graphql.Marshaler {
	return ec._Version(ctx, sel, &v)
}

func (ec *executionContext) marshalNVersion2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVersionᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.APIVersion) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNVersion2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVersion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNVersion2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVersion(ctx context.Context, sel ast.SelectionSet, v *model.APIVersion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Version(ctx, sel, v)
}

func (ec *executionContext) marshalNVersionTasks2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐVersionTasks(ctx context.Context, sel ast.SelectionSet, v VersionTasks) graphql.Marshaler {
	return ec._VersionTasks(ctx, sel, &v)
}

func (ec *executionContext) marshalNVersionTasks2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐVersionTasks(ctx context.Context, sel ast.SelectionSet, v *VersionTasks) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._VersionTasks(ctx, sel, v)
}

func (ec *executionContext) unmarshalNVersionToRestart2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐVersionToRestartᚄ(ctx context.Context, v any) ([]*model1.VersionToRestart, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*model1.VersionToRestart, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNVersionToRestart2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐVersionToRestart(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNVersionToRestart2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐVersionToRestart(ctx context.Context, v any) (*model1.VersionToRestart, error) {
	res, err := ec.unmarshalInputVersionToRestart(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNVolume2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVolumeᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.APIVolume) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNVolume2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVolume(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNVolume2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVolume(ctx context.Context, sel ast.SelectionSet, v *model.APIVolume) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Volume(ctx, sel, v)
}

func (ec *executionContext) unmarshalNVolumeHost2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐVolumeHost(ctx context.Context, v any) (VolumeHost, error) {
	res, err := ec.unmarshalInputVolumeHost(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNWaterfall2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐWaterfall(ctx context.Context, sel ast.SelectionSet, v Waterfall) graphql.Marshaler {
	return ec._Waterfall(ctx, sel, &v)
}

func (ec *executionContext) marshalNWaterfall2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐWaterfall(ctx context.Context, sel ast.SelectionSet, v *Waterfall) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Waterfall(ctx, sel, v)
}

func (ec *executionContext) marshalNWaterfallBuild2githubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐWaterfallBuild(ctx context.Context, sel ast.SelectionSet, v model1.WaterfallBuild) graphql.Marshaler {
	return ec._WaterfallBuild(ctx, sel, &v)
}

func (ec *executionContext) marshalNWaterfallBuild2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐWaterfallBuildᚄ(ctx context.Context, sel ast.SelectionSet, v []model1.WaterfallBuild) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWaterfallBuild2githubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐWaterfallBuild(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNWaterfallBuild2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐWaterfallBuild(ctx context.Context, sel ast.SelectionSet, v *model1.WaterfallBuild) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WaterfallBuild(ctx, sel, v)
}

func (ec *executionContext) unmarshalNWaterfallOptions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐWaterfallOptions(ctx context.Context, v any) (WaterfallOptions, error) {
	res, err := ec.unmarshalInputWaterfallOptions(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNWaterfallPagination2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐWaterfallPagination(ctx context.Context, sel ast.SelectionSet, v *WaterfallPagination) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._WaterfallPagination(ctx, sel, v)
}

func (ec *executionContext) marshalNWaterfallTask2githubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐWaterfallTask(ctx context.Context, sel ast.SelectionSet, v model1.WaterfallTask) graphql.Marshaler {
	return ec._WaterfallTask(ctx, sel, &v)
}

func (ec *executionContext) marshalNWaterfallTask2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐWaterfallTaskᚄ(ctx context.Context, sel ast.SelectionSet, v []model1.WaterfallTask) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWaterfallTask2githubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐWaterfallTask(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNWebhook2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWebHook(ctx context.Context, sel ast.SelectionSet, v model.APIWebHook) graphql.Marshaler {
	return ec._Webhook(ctx, sel, &v)
}

func (ec *executionContext) marshalNWebhookHeader2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWebhookHeader(ctx context.Context, sel ast.SelectionSet, v model.APIWebhookHeader) graphql.Marshaler {
	return ec._WebhookHeader(ctx, sel, &v)
}

func (ec *executionContext) marshalNWebhookHeader2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWebhookHeaderᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIWebhookHeader) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWebhookHeader2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWebhookHeader(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNWebhookHeaderInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWebhookHeader(ctx context.Context, v any) (model.APIWebhookHeader, error) {
	res, err := ec.unmarshalInputWebhookHeaderInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNWebhookHeaderInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWebhookHeaderᚄ(ctx context.Context, v any) ([]model.APIWebhookHeader, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIWebhookHeader, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNWebhookHeaderInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWebhookHeader(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNWorkstationConfig2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWorkstationConfig(ctx context.Context, sel ast.SelectionSet, v model.APIWorkstationConfig) graphql.Marshaler {
	return ec._WorkstationConfig(ctx, sel, &v)
}

func (ec *executionContext) marshalNWorkstationSetupCommand2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWorkstationSetupCommand(ctx context.Context, sel ast.SelectionSet, v model.APIWorkstationSetupCommand) graphql.Marshaler {
	return ec._WorkstationSetupCommand(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNWorkstationSetupCommandInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWorkstationSetupCommand(ctx context.Context, v any) (model.APIWorkstationSetupCommand, error) {
	res, err := ec.unmarshalInputWorkstationSetupCommandInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v any) ([]string, error) {
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalOAPIConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIapiConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIapiConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._APIConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAPIConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIapiConfig(ctx context.Context, v any) (*model.APIapiConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAPIConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAWSConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAWSConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIAWSConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AWSConfig(ctx, sel, v)
}

func (ec *executionContext) marshalOAWSPodConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAWSPodConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIAWSPodConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AWSPodConfig(ctx, sel, v)
}

func (ec *executionContext) marshalOAbortInfo2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAbortInfo(ctx context.Context, sel ast.SelectionSet, v *AbortInfo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AbortInfo(ctx, sel, v)
}

func (ec *executionContext) marshalOAdminSettings2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAdminSettings(ctx context.Context, sel ast.SelectionSet, v *model.APIAdminSettings) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AdminSettings(ctx, sel, v)
}

func (ec *executionContext) marshalOAmboyConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAmboyConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIAmboyConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AmboyConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAmboyConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAmboyConfig(ctx context.Context, v any) (*model.APIAmboyConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAmboyConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAmboyDBConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAmboyDBConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIAmboyDBConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AmboyDBConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAmboyDBConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAmboyDBConfig(ctx context.Context, v any) (*model.APIAmboyDBConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAmboyDBConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOAmboyRetryConfig2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAmboyRetryConfig(ctx context.Context, sel ast.SelectionSet, v model.APIAmboyRetryConfig) graphql.Marshaler {
	return ec._AmboyRetryConfig(ctx, sel, &v)
}

func (ec *executionContext) marshalOAnnotation2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskAnnotation(ctx context.Context, sel ast.SelectionSet, v *model.APITaskAnnotation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Annotation(ctx, sel, v)
}

func (ec *executionContext) marshalOAuthConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAuthConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIAuthConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AuthConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOAuthConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAuthConfig(ctx context.Context, v any) (*model.APIAuthConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputAuthConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOAuthUserInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAuthUserᚄ(ctx context.Context, v any) ([]model.APIAuthUser, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIAuthUser, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNAuthUserInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAuthUser(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOBannerTheme2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚐBannerTheme(ctx context.Context, v any) (*evergreen.BannerTheme, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := evergreen.BannerTheme(tmp)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBannerTheme2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚐBannerTheme(ctx context.Context, sel ast.SelectionSet, v *evergreen.BannerTheme) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(string(*v))
	return res
}

func (ec *executionContext) marshalOBetaFeatures2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIBetaFeatures(ctx context.Context, sel ast.SelectionSet, v *model.APIBetaFeatures) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._BetaFeatures(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v any) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v any) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalOBooleanMap2map(ctx context.Context, v any) (map[string]bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := UnmarshalBooleanMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBooleanMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := MarshalBooleanMap(v)
	return res
}

func (ec *executionContext) unmarshalOBuildBaronSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIBuildBaronSettings(ctx context.Context, v any) (model.APIBuildBaronSettings, error) {
	res, err := ec.unmarshalInputBuildBaronSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOBuildVariantOptions2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐBuildVariantOptions(ctx context.Context, v any) (*BuildVariantOptions, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputBuildVariantOptions(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBuildVariantTuple2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋtaskᚐBuildVariantTupleᚄ(ctx context.Context, sel ast.SelectionSet, v []*task.BuildVariantTuple) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBuildVariantTuple2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋtaskᚐBuildVariantTuple(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOCedarConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPICedarConfig(ctx context.Context, sel ast.SelectionSet, v *model.APICedarConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CedarConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCedarConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPICedarConfig(ctx context.Context, v any) (*model.APICedarConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputCedarConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOChildPatchAlias2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIChildPatchAliasᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIChildPatchAlias) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChildPatchAlias2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIChildPatchAlias(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOClientBinary2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIClientBinaryᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIClientBinary) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNClientBinary2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIClientBinary(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOClientConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIClientConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIClientConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ClientConfig(ctx, sel, v)
}

func (ec *executionContext) marshalOCloudProviderConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPICloudProviders(ctx context.Context, sel ast.SelectionSet, v *model.APICloudProviders) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CloudProviderConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOCommitQueueParamsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPICommitQueueParams(ctx context.Context, v any) (model.APICommitQueueParams, error) {
	res, err := ec.unmarshalInputCommitQueueParamsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOContainerPoolsConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIContainerPoolsConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIContainerPoolsConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ContainerPoolsConfig(ctx, sel, v)
}

func (ec *executionContext) marshalOContainerResources2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIContainerResourcesᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIContainerResources) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNContainerResources2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIContainerResources(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOContainerResourcesInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIContainerResourcesᚄ(ctx context.Context, v any) ([]model.APIContainerResources, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIContainerResources, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNContainerResourcesInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIContainerResources(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalODeleteGithubAppCredentialsPayload2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDeleteGithubAppCredentialsPayload(ctx context.Context, sel ast.SelectionSet, v *DeleteGithubAppCredentialsPayload) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._DeleteGithubAppCredentialsPayload(ctx, sel, v)
}

func (ec *executionContext) marshalODependency2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDependencyᚄ(ctx context.Context, sel ast.SelectionSet, v []*Dependency) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDependency2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDependency(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalODistro2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDistro(ctx context.Context, sel ast.SelectionSet, v *model.APIDistro) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Distro(ctx, sel, v)
}

func (ec *executionContext) marshalODistroInfo2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐDistroInfo(ctx context.Context, sel ast.SelectionSet, v model.DistroInfo) graphql.Marshaler {
	return ec._DistroInfo(ctx, sel, &v)
}

func (ec *executionContext) unmarshalODuration2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDuration(ctx context.Context, v any) (model.APIDuration, error) {
	res, err := model.UnmarshalAPIDuration(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODuration2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDuration(ctx context.Context, sel ast.SelectionSet, v model.APIDuration) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := model.MarshalAPIDuration(v)
	return res
}

func (ec *executionContext) unmarshalODuration2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDuration(ctx context.Context, v any) (*model.APIDuration, error) {
	if v == nil {
		return nil, nil
	}
	res, err := model.UnmarshalAPIDuration(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODuration2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDuration(ctx context.Context, sel ast.SelectionSet, v *model.APIDuration) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := model.MarshalAPIDuration(*v)
	return res
}

func (ec *executionContext) marshalOECSConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIECSConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIECSConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ECSConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOEditSpawnHostInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐEditSpawnHostInput(ctx context.Context, v any) (*EditSpawnHostInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputEditSpawnHostInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOExternalLink2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIExternalLinkᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIExternalLink) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNExternalLink2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIExternalLink(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOExternalLinkInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIExternalLinkᚄ(ctx context.Context, v any) ([]model.APIExternalLink, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIExternalLink, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNExternalLinkInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIExternalLink(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOFWSConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIFWSConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIFWSConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._FWSConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOFWSConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIFWSConfig(ctx context.Context, v any) (*model.APIFWSConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputFWSConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOFeedbackRule2ᚖstring(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalOFeedbackRule2ᚖstring[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFeedbackRule2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(marshalOFeedbackRule2ᚖstring[*v])
	return res
}

var (
	unmarshalOFeedbackRule2ᚖstring = map[string]string{
		"WAITS_OVER_THRESH": evergreen.HostAllocatorWaitsOverThreshFeedback,
		"NO_FEEDBACK":       evergreen.HostAllocatorNoFeedback,
		"DEFAULT":           evergreen.HostAllocatorUseDefaultFeedback,
	}
	marshalOFeedbackRule2ᚖstring = map[string]string{
		evergreen.HostAllocatorWaitsOverThreshFeedback: "WAITS_OVER_THRESH",
		evergreen.HostAllocatorNoFeedback:              "NO_FEEDBACK",
		evergreen.HostAllocatorUseDefaultFeedback:      "DEFAULT",
	}
)

func (ec *executionContext) marshalOFile2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIFileᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.APIFile) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFile2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIFile(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOFinderVersion2ᚖstring(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalOFinderVersion2ᚖstring[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFinderVersion2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(marshalOFinderVersion2ᚖstring[*v])
	return res
}

var (
	unmarshalOFinderVersion2ᚖstring = map[string]string{
		"LEGACY":    evergreen.FinderVersionLegacy,
		"PARALLEL":  evergreen.FinderVersionParallel,
		"PIPELINE":  evergreen.FinderVersionPipeline,
		"ALTERNATE": evergreen.FinderVersionAlternate,
	}
	marshalOFinderVersion2ᚖstring = map[string]string{
		evergreen.FinderVersionLegacy:    "LEGACY",
		evergreen.FinderVersionParallel:  "PARALLEL",
		evergreen.FinderVersionPipeline:  "PIPELINE",
		evergreen.FinderVersionAlternate: "ALTERNATE",
	}
)

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v any) (float64, error) {
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	_ = sel
	res := graphql.MarshalFloatContext(v)
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) unmarshalOFloat2ᚖfloat64(ctx context.Context, v any) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2ᚖfloat64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	res := graphql.MarshalFloatContext(*v)
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) marshalOGeneralSubscription2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISubscriptionᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APISubscription) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGeneralSubscription2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISubscription(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGeneralSubscription2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISubscriptionᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.APISubscription) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGeneralSubscription2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISubscription(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGitHubAuthConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGithubAuthConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIGithubAuthConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GitHubAuthConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOGitHubAuthConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGithubAuthConfig(ctx context.Context, v any) (*model.APIGithubAuthConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGitHubAuthConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOGitHubDynamicTokenPermissionGroupInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGitHubDynamicTokenPermissionGroupᚄ(ctx context.Context, v any) ([]model.APIGitHubDynamicTokenPermissionGroup, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIGitHubDynamicTokenPermissionGroup, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNGitHubDynamicTokenPermissionGroupInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGitHubDynamicTokenPermissionGroup(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOGitTag2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGitTagᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIGitTag) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGitTag2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGitTag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGithubAppAuth2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGithubAppAuth(ctx context.Context, sel ast.SelectionSet, v model.APIGithubAppAuth) graphql.Marshaler {
	return ec._GithubAppAuth(ctx, sel, &v)
}

func (ec *executionContext) marshalOGithubAppAuth2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGithubAppAuth(ctx context.Context, sel ast.SelectionSet, v *model.APIGithubAppAuth) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GithubAppAuth(ctx, sel, v)
}

func (ec *executionContext) unmarshalOGithubAppAuthInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGithubAppAuth(ctx context.Context, v any) (model.APIGithubAppAuth, error) {
	res, err := ec.unmarshalInputGithubAppAuthInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOGithubCheckSubscriber2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGithubCheckSubscriber(ctx context.Context, sel ast.SelectionSet, v *model.APIGithubCheckSubscriber) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GithubCheckSubscriber(ctx, sel, v)
}

func (ec *executionContext) marshalOGithubPRSubscriber2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGithubPRSubscriber(ctx context.Context, sel ast.SelectionSet, v *model.APIGithubPRSubscriber) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GithubPRSubscriber(ctx, sel, v)
}

func (ec *executionContext) marshalOGithubPatch2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGithubPatch(ctx context.Context, sel ast.SelectionSet, v model.APIGithubPatch) graphql.Marshaler {
	return ec._GithubPatch(ctx, sel, &v)
}

func (ec *executionContext) marshalOGithubUser2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGithubUser(ctx context.Context, sel ast.SelectionSet, v *model.APIGithubUser) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GithubUser(ctx, sel, v)
}

func (ec *executionContext) unmarshalOGithubUserInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGithubUser(ctx context.Context, v any) (*model.APIGithubUser, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGithubUserInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOGroupedBuildVariant2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐGroupedBuildVariantᚄ(ctx context.Context, sel ast.SelectionSet, v []*GroupedBuildVariant) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGroupedBuildVariant2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐGroupedBuildVariant(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGroupedTaskStatusCount2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋtaskᚐGroupedTaskStatusCountᚄ(ctx context.Context, sel ast.SelectionSet, v []*task.GroupedTaskStatusCount) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGroupedTaskStatusCount2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋtaskᚐGroupedTaskStatusCount(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOHost2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHost(ctx context.Context, sel ast.SelectionSet, v *model.APIHost) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Host(ctx, sel, v)
}

func (ec *executionContext) unmarshalOHostAllocatorVersion2ᚖstring(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalOHostAllocatorVersion2ᚖstring[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOHostAllocatorVersion2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(marshalOHostAllocatorVersion2ᚖstring[*v])
	return res
}

var (
	unmarshalOHostAllocatorVersion2ᚖstring = map[string]string{
		"UTILIZATION": evergreen.HostAllocatorUtilization,
	}
	marshalOHostAllocatorVersion2ᚖstring = map[string]string{
		evergreen.HostAllocatorUtilization: "UTILIZATION",
	}
)

func (ec *executionContext) unmarshalOHostEventType2ᚕstringᚄ(ctx context.Context, v any) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNHostEventType2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOHostEventType2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNHostEventType2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

var (
	unmarshalOHostEventType2ᚕstringᚄ = map[string]string{
		"HOST_CREATED":                                     event.EventHostCreated,
		"HOST_CREATED_ERROR":                               event.EventHostCreatedError,
		"HOST_STARTED":                                     event.EventHostStarted,
		"HOST_STOPPED":                                     event.EventHostStopped,
		"HOST_MODIFIED":                                    event.EventHostModified,
		"HOST_AGENT_DEPLOYED":                              event.EventHostAgentDeployed,
		"HOST_AGENT_DEPLOY_FAILED":                         event.EventHostAgentDeployFailed,
		"HOST_AGENT_MONITOR_DEPLOYED":                      event.EventHostAgentMonitorDeployed,
		"HOST_AGENT_MONITOR_DEPLOY_FAILED":                 event.EventHostAgentMonitorDeployFailed,
		"HOST_JASPER_RESTARTING":                           event.EventHostJasperRestarting,
		"HOST_JASPER_RESTARTED":                            event.EventHostJasperRestarted,
		"HOST_JASPER_RESTART_ERROR":                        event.EventHostJasperRestartError,
		"HOST_CONVERTING_PROVISIONING":                     event.EventHostConvertingProvisioning,
		"HOST_CONVERTED_PROVISIONING":                      event.EventHostConvertedProvisioning,
		"HOST_CONVERTING_PROVISIONING_ERROR":               event.EventHostConvertingProvisioningError,
		"HOST_STATUS_CHANGED":                              event.EventHostStatusChanged,
		"HOST_DNS_NAME_SET":                                event.EventHostDNSNameSet,
		"HOST_PROVISION_ERROR":                             event.EventHostProvisionError,
		"HOST_PROVISION_FAILED":                            event.EventHostProvisionFailed,
		"HOST_PROVISIONED":                                 event.EventHostProvisioned,
		"HOST_RUNNING_TASK_SET":                            event.EventHostRunningTaskSet,
		"HOST_RUNNING_TASK_CLEARED":                        event.EventHostRunningTaskCleared,
		"HOST_TASK_FINISHED":                               event.EventHostTaskFinished,
		"HOST_TERMINATED_EXTERNALLY":                       event.EventHostTerminatedExternally,
		"HOST_EXPIRATION_WARNING_SENT":                     event.EventHostExpirationWarningSent,
		"HOST_TEMPORARY_EXEMPTION_EXPIRATION_WARNING_SENT": event.EventHostTemporaryExemptionExpirationWarningSent,
		"HOST_IDLE_NOTIFICATION":                           event.EventSpawnHostIdleNotification,
		"HOST_ALERTABLE_INSTANCE_TYPE_WARNING_SENT":        event.EventAlertableInstanceTypeWarningSent,
		"HOST_SCRIPT_EXECUTED":                             event.EventHostScriptExecuted,
		"HOST_SCRIPT_EXECUTE_FAILED":                       event.EventHostScriptExecuteFailed,
		"SPAWN_HOST_CREATED_ERROR":                         event.EventSpawnHostCreatedError,
		"VOLUME_EXPIRATION_WARNING_SENT":                   event.EventVolumeExpirationWarningSent,
		"VOLUME_MIGRATION_FAILED":                          event.EventVolumeMigrationFailed,
	}
	marshalOHostEventType2ᚕstringᚄ = map[string]string{
		event.EventHostCreated:                                 "HOST_CREATED",
		event.EventHostCreatedError:                            "HOST_CREATED_ERROR",
		event.EventHostStarted:                                 "HOST_STARTED",
		event.EventHostStopped:                                 "HOST_STOPPED",
		event.EventHostModified:                                "HOST_MODIFIED",
		event.EventHostAgentDeployed:                           "HOST_AGENT_DEPLOYED",
		event.EventHostAgentDeployFailed:                       "HOST_AGENT_DEPLOY_FAILED",
		event.EventHostAgentMonitorDeployed:                    "HOST_AGENT_MONITOR_DEPLOYED",
		event.EventHostAgentMonitorDeployFailed:                "HOST_AGENT_MONITOR_DEPLOY_FAILED",
		event.EventHostJasperRestarting:                        "HOST_JASPER_RESTARTING",
		event.EventHostJasperRestarted:                         "HOST_JASPER_RESTARTED",
		event.EventHostJasperRestartError:                      "HOST_JASPER_RESTART_ERROR",
		event.EventHostConvertingProvisioning:                  "HOST_CONVERTING_PROVISIONING",
		event.EventHostConvertedProvisioning:                   "HOST_CONVERTED_PROVISIONING",
		event.EventHostConvertingProvisioningError:             "HOST_CONVERTING_PROVISIONING_ERROR",
		event.EventHostStatusChanged:                           "HOST_STATUS_CHANGED",
		event.EventHostDNSNameSet:                              "HOST_DNS_NAME_SET",
		event.EventHostProvisionError:                          "HOST_PROVISION_ERROR",
		event.EventHostProvisionFailed:                         "HOST_PROVISION_FAILED",
		event.EventHostProvisioned:                             "HOST_PROVISIONED",
		event.EventHostRunningTaskSet:                          "HOST_RUNNING_TASK_SET",
		event.EventHostRunningTaskCleared:                      "HOST_RUNNING_TASK_CLEARED",
		event.EventHostTaskFinished:                            "HOST_TASK_FINISHED",
		event.EventHostTerminatedExternally:                    "HOST_TERMINATED_EXTERNALLY",
		event.EventHostExpirationWarningSent:                   "HOST_EXPIRATION_WARNING_SENT",
		event.EventHostTemporaryExemptionExpirationWarningSent: "HOST_TEMPORARY_EXEMPTION_EXPIRATION_WARNING_SENT",
		event.EventSpawnHostIdleNotification:                   "HOST_IDLE_NOTIFICATION",
		event.EventAlertableInstanceTypeWarningSent:            "HOST_ALERTABLE_INSTANCE_TYPE_WARNING_SENT",
		event.EventHostScriptExecuted:                          "HOST_SCRIPT_EXECUTED",
		event.EventHostScriptExecuteFailed:                     "HOST_SCRIPT_EXECUTE_FAILED",
		event.EventSpawnHostCreatedError:                       "SPAWN_HOST_CREATED_ERROR",
		event.EventVolumeExpirationWarningSent:                 "VOLUME_EXPIRATION_WARNING_SENT",
		event.EventVolumeMigrationFailed:                       "VOLUME_MIGRATION_FAILED",
	}
)

func (ec *executionContext) unmarshalOHostEventType2ᚖstring(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalOHostEventType2ᚖstring[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOHostEventType2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(marshalOHostEventType2ᚖstring[*v])
	return res
}

var (
	unmarshalOHostEventType2ᚖstring = map[string]string{
		"HOST_CREATED":                                     event.EventHostCreated,
		"HOST_CREATED_ERROR":                               event.EventHostCreatedError,
		"HOST_STARTED":                                     event.EventHostStarted,
		"HOST_STOPPED":                                     event.EventHostStopped,
		"HOST_MODIFIED":                                    event.EventHostModified,
		"HOST_AGENT_DEPLOYED":                              event.EventHostAgentDeployed,
		"HOST_AGENT_DEPLOY_FAILED":                         event.EventHostAgentDeployFailed,
		"HOST_AGENT_MONITOR_DEPLOYED":                      event.EventHostAgentMonitorDeployed,
		"HOST_AGENT_MONITOR_DEPLOY_FAILED":                 event.EventHostAgentMonitorDeployFailed,
		"HOST_JASPER_RESTARTING":                           event.EventHostJasperRestarting,
		"HOST_JASPER_RESTARTED":                            event.EventHostJasperRestarted,
		"HOST_JASPER_RESTART_ERROR":                        event.EventHostJasperRestartError,
		"HOST_CONVERTING_PROVISIONING":                     event.EventHostConvertingProvisioning,
		"HOST_CONVERTED_PROVISIONING":                      event.EventHostConvertedProvisioning,
		"HOST_CONVERTING_PROVISIONING_ERROR":               event.EventHostConvertingProvisioningError,
		"HOST_STATUS_CHANGED":                              event.EventHostStatusChanged,
		"HOST_DNS_NAME_SET":                                event.EventHostDNSNameSet,
		"HOST_PROVISION_ERROR":                             event.EventHostProvisionError,
		"HOST_PROVISION_FAILED":                            event.EventHostProvisionFailed,
		"HOST_PROVISIONED":                                 event.EventHostProvisioned,
		"HOST_RUNNING_TASK_SET":                            event.EventHostRunningTaskSet,
		"HOST_RUNNING_TASK_CLEARED":                        event.EventHostRunningTaskCleared,
		"HOST_TASK_FINISHED":                               event.EventHostTaskFinished,
		"HOST_TERMINATED_EXTERNALLY":                       event.EventHostTerminatedExternally,
		"HOST_EXPIRATION_WARNING_SENT":                     event.EventHostExpirationWarningSent,
		"HOST_TEMPORARY_EXEMPTION_EXPIRATION_WARNING_SENT": event.EventHostTemporaryExemptionExpirationWarningSent,
		"HOST_IDLE_NOTIFICATION":                           event.EventSpawnHostIdleNotification,
		"HOST_ALERTABLE_INSTANCE_TYPE_WARNING_SENT":        event.EventAlertableInstanceTypeWarningSent,
		"HOST_SCRIPT_EXECUTED":                             event.EventHostScriptExecuted,
		"HOST_SCRIPT_EXECUTE_FAILED":                       event.EventHostScriptExecuteFailed,
		"SPAWN_HOST_CREATED_ERROR":                         event.EventSpawnHostCreatedError,
		"VOLUME_EXPIRATION_WARNING_SENT":                   event.EventVolumeExpirationWarningSent,
		"VOLUME_MIGRATION_FAILED":                          event.EventVolumeMigrationFailed,
	}
	marshalOHostEventType2ᚖstring = map[string]string{
		event.EventHostCreated:                                 "HOST_CREATED",
		event.EventHostCreatedError:                            "HOST_CREATED_ERROR",
		event.EventHostStarted:                                 "HOST_STARTED",
		event.EventHostStopped:                                 "HOST_STOPPED",
		event.EventHostModified:                                "HOST_MODIFIED",
		event.EventHostAgentDeployed:                           "HOST_AGENT_DEPLOYED",
		event.EventHostAgentDeployFailed:                       "HOST_AGENT_DEPLOY_FAILED",
		event.EventHostAgentMonitorDeployed:                    "HOST_AGENT_MONITOR_DEPLOYED",
		event.EventHostAgentMonitorDeployFailed:                "HOST_AGENT_MONITOR_DEPLOY_FAILED",
		event.EventHostJasperRestarting:                        "HOST_JASPER_RESTARTING",
		event.EventHostJasperRestarted:                         "HOST_JASPER_RESTARTED",
		event.EventHostJasperRestartError:                      "HOST_JASPER_RESTART_ERROR",
		event.EventHostConvertingProvisioning:                  "HOST_CONVERTING_PROVISIONING",
		event.EventHostConvertedProvisioning:                   "HOST_CONVERTED_PROVISIONING",
		event.EventHostConvertingProvisioningError:             "HOST_CONVERTING_PROVISIONING_ERROR",
		event.EventHostStatusChanged:                           "HOST_STATUS_CHANGED",
		event.EventHostDNSNameSet:                              "HOST_DNS_NAME_SET",
		event.EventHostProvisionError:                          "HOST_PROVISION_ERROR",
		event.EventHostProvisionFailed:                         "HOST_PROVISION_FAILED",
		event.EventHostProvisioned:                             "HOST_PROVISIONED",
		event.EventHostRunningTaskSet:                          "HOST_RUNNING_TASK_SET",
		event.EventHostRunningTaskCleared:                      "HOST_RUNNING_TASK_CLEARED",
		event.EventHostTaskFinished:                            "HOST_TASK_FINISHED",
		event.EventHostTerminatedExternally:                    "HOST_TERMINATED_EXTERNALLY",
		event.EventHostExpirationWarningSent:                   "HOST_EXPIRATION_WARNING_SENT",
		event.EventHostTemporaryExemptionExpirationWarningSent: "HOST_TEMPORARY_EXEMPTION_EXPIRATION_WARNING_SENT",
		event.EventSpawnHostIdleNotification:                   "HOST_IDLE_NOTIFICATION",
		event.EventAlertableInstanceTypeWarningSent:            "HOST_ALERTABLE_INSTANCE_TYPE_WARNING_SENT",
		event.EventHostScriptExecuted:                          "HOST_SCRIPT_EXECUTED",
		event.EventHostScriptExecuteFailed:                     "HOST_SCRIPT_EXECUTE_FAILED",
		event.EventSpawnHostCreatedError:                       "SPAWN_HOST_CREATED_ERROR",
		event.EventVolumeExpirationWarningSent:                 "VOLUME_EXPIRATION_WARNING_SENT",
		event.EventVolumeMigrationFailed:                       "VOLUME_MIGRATION_FAILED",
	}
)

func (ec *executionContext) marshalOHostInitConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHostInitConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIHostInitConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._HostInitConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOHostInitConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHostInitConfig(ctx context.Context, v any) (*model.APIHostInitConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputHostInitConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOHostSortBy2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐHostSortBy(ctx context.Context, v any) (*HostSortBy, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(HostSortBy)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOHostSortBy2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐHostSortBy(ctx context.Context, sel ast.SelectionSet, v *HostSortBy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOID2ᚖstring(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalID(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalID(*v)
	return res
}

func (ec *executionContext) marshalOImage2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIImage(ctx context.Context, sel ast.SelectionSet, v *model.APIImage) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Image(ctx, sel, v)
}

func (ec *executionContext) unmarshalOInstanceTagInput2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋhostᚐTagᚄ(ctx context.Context, v any) ([]*host.Tag, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*host.Tag, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInstanceTagInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋhostᚐTag(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v any) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalInt(v)
	return res
}

func (ec *executionContext) unmarshalOInt2int32(ctx context.Context, v any) (int32, error) {
	res, err := graphql.UnmarshalInt32(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int32(ctx context.Context, sel ast.SelectionSet, v int32) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalInt32(v)
	return res
}

func (ec *executionContext) unmarshalOInt2int64(ctx context.Context, v any) (int64, error) {
	res, err := graphql.UnmarshalInt64(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int64(ctx context.Context, sel ast.SelectionSet, v int64) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalInt64(v)
	return res
}

func (ec *executionContext) unmarshalOInt2ᚕintᚄ(ctx context.Context, v any) ([]int, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOInt2ᚕintᚄ(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNInt2int(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v any) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOIssueLink2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIIssueLinkᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIIssueLink) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNIssueLink2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIIssueLink(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOJiraConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIJiraConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIJiraConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._JiraConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOJiraConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIJiraConfig(ctx context.Context, v any) (*model.APIJiraConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputJiraConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOJiraIssueSubscriber2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIJIRAIssueSubscriber(ctx context.Context, sel ast.SelectionSet, v *model.APIJIRAIssueSubscriber) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._JiraIssueSubscriber(ctx, sel, v)
}

func (ec *executionContext) unmarshalOJiraIssueSubscriberInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIJIRAIssueSubscriber(ctx context.Context, v any) (*model.APIJIRAIssueSubscriber, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputJiraIssueSubscriberInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOJiraTicket2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐJiraTicket(ctx context.Context, sel ast.SelectionSet, v *thirdparty.JiraTicket) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._JiraTicket(ctx, sel, v)
}

func (ec *executionContext) marshalOKanopyAuthConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIKanopyAuthConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIKanopyAuthConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._KanopyAuthConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOKanopyAuthConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIKanopyAuthConfig(ctx context.Context, v any) (*model.APIKanopyAuthConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputKanopyAuthConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOLogBuffering2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPILogBuffering(ctx context.Context, sel ast.SelectionSet, v *model.APILogBuffering) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LogBuffering(ctx, sel, v)
}

func (ec *executionContext) marshalOLoggerConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPILoggerConfig(ctx context.Context, sel ast.SelectionSet, v *model.APILoggerConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._LoggerConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOLoggerConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPILoggerConfig(ctx context.Context, v any) (*model.APILoggerConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputLoggerConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMainlineCommits2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐMainlineCommits(ctx context.Context, sel ast.SelectionSet, v *MainlineCommits) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MainlineCommits(ctx, sel, v)
}

func (ec *executionContext) marshalOManifest2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐManifest(ctx context.Context, sel ast.SelectionSet, v *Manifest) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Manifest(ctx, sel, v)
}

func (ec *executionContext) unmarshalOMap2map(ctx context.Context, v any) (map[string]any, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]any) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalMap(v)
	return res
}

func (ec *executionContext) marshalOMetadataLink2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIMetadataLinkᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIMetadataLink) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMetadataLink2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIMetadataLink(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOMultiAuthConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIMultiAuthConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIMultiAuthConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MultiAuthConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOMultiAuthConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIMultiAuthConfig(ctx context.Context, v any) (*model.APIMultiAuthConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputMultiAuthConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONaiveAuthConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPINaiveAuthConfig(ctx context.Context, sel ast.SelectionSet, v *model.APINaiveAuthConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._NaiveAuthConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalONaiveAuthConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPINaiveAuthConfig(ctx context.Context, v any) (*model.APINaiveAuthConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNaiveAuthConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONote2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPINote(ctx context.Context, sel ast.SelectionSet, v *model.APINote) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Note(ctx, sel, v)
}

func (ec *executionContext) marshalONotifications2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPINotificationPreferences(ctx context.Context, sel ast.SelectionSet, v *model.APINotificationPreferences) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Notifications(ctx, sel, v)
}

func (ec *executionContext) unmarshalONotificationsInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPINotificationPreferences(ctx context.Context, v any) (*model.APINotificationPreferences, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNotificationsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalONotifyConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPINotifyConfig(ctx context.Context, sel ast.SelectionSet, v *model.APINotifyConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._NotifyConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalONotifyConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPINotifyConfig(ctx context.Context, v any) (*model.APINotifyConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNotifyConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOktaConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIOktaConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIOktaConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._OktaConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOOktaConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIOktaConfig(ctx context.Context, v any) (*model.APIOktaConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputOktaConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOOverallocatedRule2ᚖstring(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalOOverallocatedRule2ᚖstring[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOOverallocatedRule2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(marshalOOverallocatedRule2ᚖstring[*v])
	return res
}

var (
	unmarshalOOverallocatedRule2ᚖstring = map[string]string{
		"TERMINATE": evergreen.HostsOverallocatedTerminate,
		"IGNORE":    evergreen.HostsOverallocatedIgnore,
		"DEFAULT":   evergreen.HostsOverallocatedUseDefault,
	}
	marshalOOverallocatedRule2ᚖstring = map[string]string{
		evergreen.HostsOverallocatedTerminate:  "TERMINATE",
		evergreen.HostsOverallocatedIgnore:     "IGNORE",
		evergreen.HostsOverallocatedUseDefault: "DEFAULT",
	}
)

func (ec *executionContext) unmarshalOParameterInput2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParameterᚄ(ctx context.Context, v any) ([]*model.APIParameter, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*model.APIParameter, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNParameterInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParameter(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOParsleyFilter2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParsleyFilterᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIParsleyFilter) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNParsleyFilter2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParsleyFilter(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOParsleyFilterInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParsleyFilterᚄ(ctx context.Context, v any) ([]model.APIParsleyFilter, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIParsleyFilter, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNParsleyFilterInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParsleyFilter(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOParsleySettings2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParsleySettings(ctx context.Context, sel ast.SelectionSet, v *model.APIParsleySettings) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ParsleySettings(ctx, sel, v)
}

func (ec *executionContext) marshalOPatch2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatchᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIPatch) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPatch2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatch(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOPatch2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatch(ctx context.Context, sel ast.SelectionSet, v *model.APIPatch) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Patch(ctx, sel, v)
}

func (ec *executionContext) marshalOPatchDuration2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPatchDuration(ctx context.Context, sel ast.SelectionSet, v *PatchDuration) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PatchDuration(ctx, sel, v)
}

func (ec *executionContext) marshalOPatchProject2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPatchProject(ctx context.Context, sel ast.SelectionSet, v *PatchProject) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PatchProject(ctx, sel, v)
}

func (ec *executionContext) marshalOPatchTime2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPatchTime(ctx context.Context, sel ast.SelectionSet, v *PatchTime) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PatchTime(ctx, sel, v)
}

func (ec *executionContext) marshalOPatchTriggerAlias2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatchTriggerDefinitionᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIPatchTriggerDefinition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPatchTriggerAlias2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatchTriggerDefinition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOPatchTriggerAliasInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatchTriggerDefinitionᚄ(ctx context.Context, v any) ([]model.APIPatchTriggerDefinition, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIPatchTriggerDefinition, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPatchTriggerAliasInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatchTriggerDefinition(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOPeriodicBuild2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPeriodicBuildDefinitionᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIPeriodicBuildDefinition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPeriodicBuild2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPeriodicBuildDefinition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOPeriodicBuildInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPeriodicBuildDefinitionᚄ(ctx context.Context, v any) ([]model.APIPeriodicBuildDefinition, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIPeriodicBuildDefinition, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPeriodicBuildInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPeriodicBuildDefinition(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOPod2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPod(ctx context.Context, sel ast.SelectionSet, v *model.APIPod) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Pod(ctx, sel, v)
}

func (ec *executionContext) marshalOPodLifecycleConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPodLifecycleConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIPodLifecycleConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PodLifecycleConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOPodLifecycleConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPodLifecycleConfig(ctx context.Context, v any) (*model.APIPodLifecycleConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPodLifecycleConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOPreferredAuthType2ᚖstring(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalOPreferredAuthType2ᚖstring[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPreferredAuthType2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(marshalOPreferredAuthType2ᚖstring[*v])
	return res
}

var (
	unmarshalOPreferredAuthType2ᚖstring = map[string]string{
		"OKTA":   model.OktaPreferredType,
		"NAIVE":  model.NaivePreferredType,
		"GITHUB": model.GithubPreferredType,
		"MULTI":  model.MultiPreferredType,
		"KANOPY": model.KanopyPreferredType,
	}
	marshalOPreferredAuthType2ᚖstring = map[string]string{
		model.OktaPreferredType:   "OKTA",
		model.NaivePreferredType:  "NAIVE",
		model.GithubPreferredType: "GITHUB",
		model.MultiPreferredType:  "MULTI",
		model.KanopyPreferredType: "KANOPY",
	}
)

func (ec *executionContext) unmarshalOPriorityLevel2ᚖstring(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalOPriorityLevel2ᚖstring[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOPriorityLevel2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(marshalOPriorityLevel2ᚖstring[*v])
	return res
}

var (
	unmarshalOPriorityLevel2ᚖstring = map[string]string{
		"EMERGENCY": evergreen.PriorityLevelEmergency,
		"ALERT":     evergreen.PriorityLevelAlert,
		"CRITICAL":  evergreen.PriorityLevelCritical,
		"ERROR":     evergreen.PriorityLevelError,
		"WARNING":   evergreen.PriorityLevelWarning,
		"NOTICE":    evergreen.PriorityLevelNotice,
		"INFO":      evergreen.PriorityLevelInfo,
		"DEBUG":     evergreen.PriorityLevelDebug,
		"TRACE":     evergreen.PriorityLevelTrace,
	}
	marshalOPriorityLevel2ᚖstring = map[string]string{
		evergreen.PriorityLevelEmergency: "EMERGENCY",
		evergreen.PriorityLevelAlert:     "ALERT",
		evergreen.PriorityLevelCritical:  "CRITICAL",
		evergreen.PriorityLevelError:     "ERROR",
		evergreen.PriorityLevelWarning:   "WARNING",
		evergreen.PriorityLevelNotice:    "NOTICE",
		evergreen.PriorityLevelInfo:      "INFO",
		evergreen.PriorityLevelDebug:     "DEBUG",
		evergreen.PriorityLevelTrace:     "TRACE",
	}
)

func (ec *executionContext) marshalOProject2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx context.Context, sel ast.SelectionSet, v model.APIProjectRef) graphql.Marshaler {
	return ec._Project(ctx, sel, &v)
}

func (ec *executionContext) marshalOProject2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx context.Context, sel ast.SelectionSet, v *model.APIProjectRef) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Project(ctx, sel, v)
}

func (ec *executionContext) marshalOProjectAlias2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectAliasᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIProjectAlias) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProjectAlias2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectAlias(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOProjectAlias2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectAliasᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.APIProjectAlias) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProjectAlias2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectAlias(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOProjectAliasInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectAliasᚄ(ctx context.Context, v any) ([]model.APIProjectAlias, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIProjectAlias, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNProjectAliasInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectAlias(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOProjectBanner2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectBanner(ctx context.Context, sel ast.SelectionSet, v model.APIProjectBanner) graphql.Marshaler {
	return ec._ProjectBanner(ctx, sel, &v)
}

func (ec *executionContext) unmarshalOProjectBannerInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectBanner(ctx context.Context, v any) (model.APIProjectBanner, error) {
	res, err := ec.unmarshalInputProjectBannerInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOProjectEventSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectEventSettings(ctx context.Context, sel ast.SelectionSet, v model.APIProjectEventSettings) graphql.Marshaler {
	return ec._ProjectEventSettings(ctx, sel, &v)
}

func (ec *executionContext) unmarshalOProjectHealthView2githubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐProjectHealthView(ctx context.Context, v any) (model1.ProjectHealthView, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := model1.ProjectHealthView(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOProjectHealthView2githubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐProjectHealthView(ctx context.Context, sel ast.SelectionSet, v model1.ProjectHealthView) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalString(string(v))
	return res
}

func (ec *executionContext) unmarshalOProjectInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx context.Context, v any) (model.APIProjectRef, error) {
	res, err := ec.unmarshalInputProjectInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOProjectSettingsInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectSettings(ctx context.Context, v any) (*model.APIProjectSettings, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputProjectSettingsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOProjectVars2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectVars(ctx context.Context, sel ast.SelectionSet, v model.APIProjectVars) graphql.Marshaler {
	return ec._ProjectVars(ctx, sel, &v)
}

func (ec *executionContext) marshalOProjectVars2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectVars(ctx context.Context, sel ast.SelectionSet, v *model.APIProjectVars) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProjectVars(ctx, sel, v)
}

func (ec *executionContext) unmarshalOProjectVarsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectVars(ctx context.Context, v any) (model.APIProjectVars, error) {
	res, err := ec.unmarshalInputProjectVarsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOPublicKeyInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPublicKeyInput(ctx context.Context, v any) (*PublicKeyInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPublicKeyInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORepoRef2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx context.Context, sel ast.SelectionSet, v model.APIProjectRef) graphql.Marshaler {
	return ec._RepoRef(ctx, sel, &v)
}

func (ec *executionContext) marshalORepoRef2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx context.Context, sel ast.SelectionSet, v *model.APIProjectRef) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RepoRef(ctx, sel, v)
}

func (ec *executionContext) unmarshalORepoRefInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx context.Context, v any) (model.APIProjectRef, error) {
	res, err := ec.unmarshalInputRepoRefInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalORepoSettingsInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectSettings(ctx context.Context, v any) (*model.APIProjectSettings, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputRepoSettingsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORepotrackerConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIRepoTrackerConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIRepoTrackerConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RepotrackerConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalORepotrackerConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIRepoTrackerConfig(ctx context.Context, v any) (*model.APIRepoTrackerConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputRepotrackerConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORepotrackerError2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIRepositoryErrorDetails(ctx context.Context, sel ast.SelectionSet, v *model.APIRepositoryErrorDetails) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RepotrackerError(ctx, sel, v)
}

func (ec *executionContext) unmarshalORoundingRule2ᚖstring(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	tmp, err := graphql.UnmarshalString(v)
	res := unmarshalORoundingRule2ᚖstring[tmp]
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORoundingRule2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(marshalORoundingRule2ᚖstring[*v])
	return res
}

var (
	unmarshalORoundingRule2ᚖstring = map[string]string{
		"DOWN":    evergreen.HostAllocatorRoundDown,
		"UP":      evergreen.HostAllocatorRoundUp,
		"DEFAULT": evergreen.HostAllocatorRoundDefault,
	}
	marshalORoundingRule2ᚖstring = map[string]string{
		evergreen.HostAllocatorRoundDown:    "DOWN",
		evergreen.HostAllocatorRoundUp:      "UP",
		evergreen.HostAllocatorRoundDefault: "DEFAULT",
	}
)

func (ec *executionContext) marshalORuntimeEnvironmentConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIRuntimeEnvironmentsConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIRuntimeEnvironmentsConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RuntimeEnvironmentConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalORuntimeEnvironmentConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIRuntimeEnvironmentsConfig(ctx context.Context, v any) (*model.APIRuntimeEnvironmentsConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputRuntimeEnvironmentConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSESConfig2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISESConfig(ctx context.Context, sel ast.SelectionSet, v model.APISESConfig) graphql.Marshaler {
	return ec._SESConfig(ctx, sel, &v)
}

func (ec *executionContext) unmarshalOSESConfigInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISESConfig(ctx context.Context, v any) (model.APISESConfig, error) {
	res, err := ec.unmarshalInputSESConfigInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSchedulerConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISchedulerConfig(ctx context.Context, sel ast.SelectionSet, v *model.APISchedulerConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SchedulerConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSchedulerConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISchedulerConfig(ctx context.Context, v any) (*model.APISchedulerConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSchedulerConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSearchReturnInfo2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐSearchReturnInfo(ctx context.Context, sel ast.SelectionSet, v *thirdparty.SearchReturnInfo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SearchReturnInfo(ctx, sel, v)
}

func (ec *executionContext) marshalOServiceFlags2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIServiceFlags(ctx context.Context, sel ast.SelectionSet, v *model.APIServiceFlags) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ServiceFlags(ctx, sel, v)
}

func (ec *executionContext) unmarshalOServiceFlagsInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIServiceFlags(ctx context.Context, v any) (*model.APIServiceFlags, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputServiceFlagsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSingleTaskDistroConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISingleTaskDistroConfig(ctx context.Context, sel ast.SelectionSet, v *model.APISingleTaskDistroConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SingleTaskDistroConfig(ctx, sel, v)
}

func (ec *executionContext) marshalOSlackConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISlackConfig(ctx context.Context, sel ast.SelectionSet, v *model.APISlackConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SlackConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSlackConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISlackConfig(ctx context.Context, v any) (*model.APISlackConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSlackConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSlackOptions2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISlackOptions(ctx context.Context, sel ast.SelectionSet, v *model.APISlackOptions) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SlackOptions(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSlackOptionsInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISlackOptions(ctx context.Context, v any) (*model.APISlackOptions, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSlackOptionsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSleepSchedule2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋhostᚐSleepScheduleInfo(ctx context.Context, sel ast.SelectionSet, v *host.SleepScheduleInfo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SleepSchedule(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSleepScheduleInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋhostᚐSleepScheduleInfo(ctx context.Context, v any) (*host.SleepScheduleInfo, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSleepScheduleInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOSortDirection2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSortDirection(ctx context.Context, v any) (*SortDirection, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(SortDirection)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSortDirection2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSortDirection(ctx context.Context, sel ast.SelectionSet, v *SortDirection) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOSortOrder2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSortOrderᚄ(ctx context.Context, v any) ([]*SortOrder, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*SortOrder, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSortOrder2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSortOrder(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOSource2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISource(ctx context.Context, sel ast.SelectionSet, v *model.APISource) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Source(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSpawnHostInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSpawnHostInput(ctx context.Context, v any) (*SpawnHostInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSpawnHostInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSplunkConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISplunkConfig(ctx context.Context, sel ast.SelectionSet, v *model.APISplunkConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SplunkConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSplunkConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISplunkConfig(ctx context.Context, v any) (*model.APISplunkConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSplunkConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSpruceConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAdminSettings(ctx context.Context, sel ast.SelectionSet, v *model.APIAdminSettings) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SpruceConfig(ctx, sel, v)
}

func (ec *executionContext) marshalOStatusCount2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋtaskᚐStatusCountᚄ(ctx context.Context, sel ast.SelectionSet, v []task.StatusCount) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStatusCount2githubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋtaskᚐStatusCount(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOStepbackInfo2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIStepbackInfo(ctx context.Context, sel ast.SelectionSet, v *model.APIStepbackInfo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._StepbackInfo(ctx, sel, v)
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v any) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalString(v)
	return res
}

func (ec *executionContext) unmarshalOString2ᚕstringᚄ(ctx context.Context, v any) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚕᚖstringᚄ(ctx context.Context, v any) ([]*string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2ᚖstring(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕᚖstringᚄ(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2ᚖstring(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v any) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOStringMap2map(ctx context.Context, v any) (map[string]string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := UnmarshalStringMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOStringMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := MarshalStringMap(v)
	return res
}

func (ec *executionContext) marshalOSubscriberWrapper2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISubscriber(ctx context.Context, sel ast.SelectionSet, v model.APISubscriber) graphql.Marshaler {
	return ec._SubscriberWrapper(ctx, sel, &v)
}

func (ec *executionContext) unmarshalOSubscriptionInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISubscriptionᚄ(ctx context.Context, v any) ([]model.APISubscription, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APISubscription, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSubscriptionInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISubscription(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOTask2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.APITask) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTask2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITask(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOTask2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITask(ctx context.Context, sel ast.SelectionSet, v *model.APITask) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Task(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTaskAnnotationSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskAnnotationSettings(ctx context.Context, v any) (model.APITaskAnnotationSettings, error) {
	res, err := ec.unmarshalInputTaskAnnotationSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTaskCountOptions2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskCountOptions(ctx context.Context, v any) (*TaskCountOptions, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTaskCountOptions(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTaskEndDetail2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐApiTaskEndDetail(ctx context.Context, sel ast.SelectionSet, v model.ApiTaskEndDetail) graphql.Marshaler {
	return ec._TaskEndDetail(ctx, sel, &v)
}

func (ec *executionContext) marshalOTaskInfo2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐTaskInfo(ctx context.Context, sel ast.SelectionSet, v model.TaskInfo) graphql.Marshaler {
	return ec._TaskInfo(ctx, sel, &v)
}

func (ec *executionContext) marshalOTaskLimitsConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskLimitsConfig(ctx context.Context, sel ast.SelectionSet, v *model.APITaskLimitsConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TaskLimitsConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTaskLimitsConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskLimitsConfig(ctx context.Context, v any) (*model.APITaskLimitsConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTaskLimitsConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTaskOwnerTeam2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskOwnerTeam(ctx context.Context, sel ast.SelectionSet, v *TaskOwnerTeam) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TaskOwnerTeam(ctx, sel, v)
}

func (ec *executionContext) marshalOTaskSpecifier2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskSpecifierᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APITaskSpecifier) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTaskSpecifier2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskSpecifier(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOTaskStats2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋtaskᚐTaskStats(ctx context.Context, sel ast.SelectionSet, v *task.TaskStats) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TaskStats(ctx, sel, v)
}

func (ec *executionContext) marshalOTaskTestResultSample2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskTestResultSampleᚄ(ctx context.Context, sel ast.SelectionSet, v []*TaskTestResultSample) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTaskTestResultSample2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskTestResultSample(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOTestFilterOptions2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTestFilterOptions(ctx context.Context, v any) (*TestFilterOptions, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTestFilterOptions(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTestSelectionConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITestSelectionConfig(ctx context.Context, sel ast.SelectionSet, v *model.APITestSelectionConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TestSelectionConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTestSelectionConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITestSelectionConfig(ctx context.Context, v any) (*model.APITestSelectionConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTestSelectionConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTestSortOptions2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTestSortOptionsᚄ(ctx context.Context, v any) ([]*TestSortOptions, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]*TestSortOptions, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTestSortOptions2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTestSortOptions(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOTime2timeᚐTime(ctx context.Context, v any) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeᚐTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	_ = sel
	_ = ctx
	res := graphql.MarshalTime(v)
	return res
}

func (ec *executionContext) unmarshalOTime2ᚖtimeᚐTime(ctx context.Context, v any) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2ᚖtimeᚐTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	_ = sel
	_ = ctx
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) marshalOTriggerAlias2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITriggerDefinitionᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APITriggerDefinition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTriggerAlias2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITriggerDefinition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOTriggerAliasInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITriggerDefinitionᚄ(ctx context.Context, v any) ([]model.APITriggerDefinition, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APITriggerDefinition, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTriggerAliasInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITriggerDefinition(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOTriggerConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITriggerConfig(ctx context.Context, sel ast.SelectionSet, v *model.APITriggerConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TriggerConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTriggerConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITriggerConfig(ctx context.Context, v any) (*model.APITriggerConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTriggerConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUIConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIUIConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIUIConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UIConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUIConfigInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIUIConfig(ctx context.Context, v any) (*model.APIUIConfig, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUIConfigInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUpdateBetaFeaturesPayload2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐUpdateBetaFeaturesPayload(ctx context.Context, sel ast.SelectionSet, v *UpdateBetaFeaturesPayload) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UpdateBetaFeaturesPayload(ctx, sel, v)
}

func (ec *executionContext) marshalOUpdateParsleySettingsPayload2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐUpdateParsleySettingsPayload(ctx context.Context, sel ast.SelectionSet, v *UpdateParsleySettingsPayload) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UpdateParsleySettingsPayload(ctx, sel, v)
}

func (ec *executionContext) marshalOUpstreamProject2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐUpstreamProject(ctx context.Context, sel ast.SelectionSet, v *UpstreamProject) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UpstreamProject(ctx, sel, v)
}

func (ec *executionContext) marshalOUseSpruceOptions2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIUseSpruceOptions(ctx context.Context, sel ast.SelectionSet, v *model.APIUseSpruceOptions) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UseSpruceOptions(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUseSpruceOptionsInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIUseSpruceOptions(ctx context.Context, v any) (*model.APIUseSpruceOptions, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUseSpruceOptionsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUserConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐUserConfig(ctx context.Context, sel ast.SelectionSet, v *UserConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UserConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUserSettingsInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIUserSettings(ctx context.Context, v any) (*model.APIUserSettings, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUserSettingsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOVersion2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVersionᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.APIVersion) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNVersion2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVersion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOVersion2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVersion(ctx context.Context, sel ast.SelectionSet, v *model.APIVersion) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Version(ctx, sel, v)
}

func (ec *executionContext) marshalOVersionTiming2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐVersionTiming(ctx context.Context, sel ast.SelectionSet, v *VersionTiming) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._VersionTiming(ctx, sel, v)
}

func (ec *executionContext) marshalOVolume2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVolume(ctx context.Context, sel ast.SelectionSet, v *model.APIVolume) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Volume(ctx, sel, v)
}

func (ec *executionContext) marshalOWaterfallBuild2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐWaterfallBuildᚄ(ctx context.Context, sel ast.SelectionSet, v []*model1.WaterfallBuild) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWaterfallBuild2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐWaterfallBuild(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOWebhookInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWebHook(ctx context.Context, v any) (model.APIWebHook, error) {
	res, err := ec.unmarshalInputWebhookInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOWebhookSubscriber2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWebhookSubscriber(ctx context.Context, sel ast.SelectionSet, v *model.APIWebhookSubscriber) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._WebhookSubscriber(ctx, sel, v)
}

func (ec *executionContext) unmarshalOWebhookSubscriberInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWebhookSubscriber(ctx context.Context, v any) (*model.APIWebhookSubscriber, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputWebhookSubscriberInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOWorkstationConfigInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWorkstationConfig(ctx context.Context, v any) (model.APIWorkstationConfig, error) {
	res, err := ec.unmarshalInputWorkstationConfigInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOWorkstationSetupCommand2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWorkstationSetupCommandᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIWorkstationSetupCommand) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWorkstationSetupCommand2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWorkstationSetupCommand(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOWorkstationSetupCommandInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWorkstationSetupCommandᚄ(ctx context.Context, v any) ([]model.APIWorkstationSetupCommand, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []any
	vSlice = graphql.CoerceList(v)
	var err error
	res := make([]model.APIWorkstationSetupCommand, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNWorkstationSetupCommandInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWorkstationSetupCommand(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
