// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graphql

import (
	"bytes"
	"context"
	"embed"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"sync/atomic"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/evergreen-ci/evergreen"
	"github.com/evergreen-ci/evergreen/apimodels"
	model1 "github.com/evergreen-ci/evergreen/model"
	"github.com/evergreen-ci/evergreen/model/host"
	"github.com/evergreen-ci/evergreen/model/task"
	"github.com/evergreen-ci/evergreen/rest/data"
	"github.com/evergreen-ci/evergreen/rest/model"
	"github.com/evergreen-ci/evergreen/thirdparty"
	"github.com/evergreen-ci/plank"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// region    ************************** generated!.gotpl **************************

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Annotation() AnnotationResolver
	DispatcherSettings() DispatcherSettingsResolver
	Distro() DistroResolver
	FinderSettings() FinderSettingsResolver
	Host() HostResolver
	IssueLink() IssueLinkResolver
	LogkeeperBuild() LogkeeperBuildResolver
	Mutation() MutationResolver
	Patch() PatchResolver
	Permissions() PermissionsResolver
	PlannerSettings() PlannerSettingsResolver
	Pod() PodResolver
	PodEventLogData() PodEventLogDataResolver
	Project() ProjectResolver
	ProjectSettings() ProjectSettingsResolver
	ProjectVars() ProjectVarsResolver
	Query() QueryResolver
	RepoSettings() RepoSettingsResolver
	SubscriberWrapper() SubscriberWrapperResolver
	Task() TaskResolver
	TaskContainerCreationOpts() TaskContainerCreationOptsResolver
	TaskLogs() TaskLogsResolver
	TaskQueueItem() TaskQueueItemResolver
	TicketFields() TicketFieldsResolver
	User() UserResolver
	Version() VersionResolver
	Volume() VolumeResolver
	DispatcherSettingsInput() DispatcherSettingsInputResolver
	DistroInput() DistroInputResolver
	FinderSettingsInput() FinderSettingsInputResolver
	HostAllocatorSettingsInput() HostAllocatorSettingsInputResolver
	PlannerSettingsInput() PlannerSettingsInputResolver
	SubscriberInput() SubscriberInputResolver
}

type DirectiveRoot struct {
	RequireDistroAccess       func(ctx context.Context, obj interface{}, next graphql.Resolver, access DistroSettingsAccess) (res interface{}, err error)
	RequireProjectAccess      func(ctx context.Context, obj interface{}, next graphql.Resolver, access ProjectSettingsAccess) (res interface{}, err error)
	RequireProjectAdmin       func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	RequireProjectFieldAccess func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
}

type ComplexityRoot struct {
	AWSConfig struct {
		MaxVolumeSizePerUser func(childComplexity int) int
		Pod                  func(childComplexity int) int
	}

	AWSPodConfig struct {
		ECS func(childComplexity int) int
	}

	AbortInfo struct {
		BuildVariantDisplayName func(childComplexity int) int
		NewVersion              func(childComplexity int) int
		PrClosed                func(childComplexity int) int
		TaskDisplayName         func(childComplexity int) int
		TaskID                  func(childComplexity int) int
		User                    func(childComplexity int) int
	}

	Annotation struct {
		CreatedIssues     func(childComplexity int) int
		Id                func(childComplexity int) int
		Issues            func(childComplexity int) int
		MetadataLinks     func(childComplexity int) int
		Note              func(childComplexity int) int
		SuspectedIssues   func(childComplexity int) int
		TaskExecution     func(childComplexity int) int
		TaskId            func(childComplexity int) int
		WebhookConfigured func(childComplexity int) int
	}

	BootstrapSettings struct {
		ClientDir             func(childComplexity int) int
		Communication         func(childComplexity int) int
		Env                   func(childComplexity int) int
		JasperBinaryDir       func(childComplexity int) int
		JasperCredentialsPath func(childComplexity int) int
		Method                func(childComplexity int) int
		PreconditionScripts   func(childComplexity int) int
		ResourceLimits        func(childComplexity int) int
		RootDir               func(childComplexity int) int
		ServiceUser           func(childComplexity int) int
		ShellPath             func(childComplexity int) int
	}

	Build struct {
		ActualMakespan    func(childComplexity int) int
		BuildVariant      func(childComplexity int) int
		Id                func(childComplexity int) int
		PredictedMakespan func(childComplexity int) int
		Status            func(childComplexity int) int
	}

	BuildBaron struct {
		BbTicketCreationDefined func(childComplexity int) int
		BuildBaronConfigured    func(childComplexity int) int
		SearchReturnInfo        func(childComplexity int) int
	}

	BuildBaronSettings struct {
		BFSuggestionFeaturesURL func(childComplexity int) int
		BFSuggestionPassword    func(childComplexity int) int
		BFSuggestionServer      func(childComplexity int) int
		BFSuggestionTimeoutSecs func(childComplexity int) int
		BFSuggestionUsername    func(childComplexity int) int
		TicketCreateProject     func(childComplexity int) int
		TicketSearchProjects    func(childComplexity int) int
	}

	BuildVariantTuple struct {
		BuildVariant func(childComplexity int) int
		DisplayName  func(childComplexity int) int
	}

	ChildPatchAlias struct {
		Alias   func(childComplexity int) int
		PatchID func(childComplexity int) int
	}

	ClientBinary struct {
		Arch        func(childComplexity int) int
		DisplayName func(childComplexity int) int
		OS          func(childComplexity int) int
		URL         func(childComplexity int) int
	}

	ClientConfig struct {
		ClientBinaries func(childComplexity int) int
		LatestRevision func(childComplexity int) int
	}

	CloudProviderConfig struct {
		AWS func(childComplexity int) int
	}

	CommitQueue struct {
		Message   func(childComplexity int) int
		Owner     func(childComplexity int) int
		ProjectID func(childComplexity int) int
		Queue     func(childComplexity int) int
		Repo      func(childComplexity int) int
	}

	CommitQueueItem struct {
		EnqueueTime func(childComplexity int) int
		Issue       func(childComplexity int) int
		Modules     func(childComplexity int) int
		Patch       func(childComplexity int) int
		Source      func(childComplexity int) int
		Version     func(childComplexity int) int
	}

	CommitQueueParams struct {
		Enabled     func(childComplexity int) int
		MergeMethod func(childComplexity int) int
		MergeQueue  func(childComplexity int) int
		Message     func(childComplexity int) int
	}

	ContainerResources struct {
		CPU      func(childComplexity int) int
		MemoryMB func(childComplexity int) int
		Name     func(childComplexity int) int
	}

	DeleteDistroPayload struct {
		DeletedDistroID func(childComplexity int) int
	}

	Dependency struct {
		BuildVariant   func(childComplexity int) int
		MetStatus      func(childComplexity int) int
		Name           func(childComplexity int) int
		RequiredStatus func(childComplexity int) int
		TaskID         func(childComplexity int) int
	}

	DispatcherSettings struct {
		Version func(childComplexity int) int
	}

	Distro struct {
		Aliases               func(childComplexity int) int
		Arch                  func(childComplexity int) int
		AuthorizedKeysFile    func(childComplexity int) int
		BootstrapSettings     func(childComplexity int) int
		CloneMethod           func(childComplexity int) int
		ContainerPool         func(childComplexity int) int
		DisableShallowClone   func(childComplexity int) int
		Disabled              func(childComplexity int) int
		DispatcherSettings    func(childComplexity int) int
		Expansions            func(childComplexity int) int
		FinderSettings        func(childComplexity int) int
		HomeVolumeSettings    func(childComplexity int) int
		HostAllocatorSettings func(childComplexity int) int
		IcecreamSettings      func(childComplexity int) int
		IsCluster             func(childComplexity int) int
		IsVirtualWorkstation  func(childComplexity int) int
		Name                  func(childComplexity int) int
		Note                  func(childComplexity int) int
		PlannerSettings       func(childComplexity int) int
		Provider              func(childComplexity int) int
		ProviderSettingsList  func(childComplexity int) int
		SSHKey                func(childComplexity int) int
		SSHOptions            func(childComplexity int) int
		Setup                 func(childComplexity int) int
		SetupAsSudo           func(childComplexity int) int
		User                  func(childComplexity int) int
		UserSpawnAllowed      func(childComplexity int) int
		ValidProjects         func(childComplexity int) int
		WorkDir               func(childComplexity int) int
	}

	DistroEvent struct {
		After     func(childComplexity int) int
		Before    func(childComplexity int) int
		Data      func(childComplexity int) int
		Timestamp func(childComplexity int) int
		User      func(childComplexity int) int
	}

	DistroEventsPayload struct {
		Count           func(childComplexity int) int
		EventLogEntries func(childComplexity int) int
	}

	DistroInfo struct {
		BootstrapMethod      func(childComplexity int) int
		Id                   func(childComplexity int) int
		IsVirtualWorkstation func(childComplexity int) int
		IsWindows            func(childComplexity int) int
		User                 func(childComplexity int) int
		WorkDir              func(childComplexity int) int
	}

	DistroPermissions struct {
		Admin func(childComplexity int) int
		Edit  func(childComplexity int) int
		View  func(childComplexity int) int
	}

	ECSConfig struct {
		MaxCPU      func(childComplexity int) int
		MaxMemoryMB func(childComplexity int) int
	}

	EnvVar struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	Expansion struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	ExternalLink struct {
		DisplayName func(childComplexity int) int
		Requesters  func(childComplexity int) int
		URLTemplate func(childComplexity int) int
	}

	ExternalLinkForMetadata struct {
		DisplayName func(childComplexity int) int
		URL         func(childComplexity int) int
	}

	File struct {
		Link       func(childComplexity int) int
		Name       func(childComplexity int) int
		Visibility func(childComplexity int) int
	}

	FileDiff struct {
		Additions   func(childComplexity int) int
		Deletions   func(childComplexity int) int
		Description func(childComplexity int) int
		DiffLink    func(childComplexity int) int
		FileName    func(childComplexity int) int
	}

	FinderSettings struct {
		Version func(childComplexity int) int
	}

	GeneralSubscription struct {
		ID             func(childComplexity int) int
		OwnerType      func(childComplexity int) int
		RegexSelectors func(childComplexity int) int
		ResourceType   func(childComplexity int) int
		Selectors      func(childComplexity int) int
		Subscriber     func(childComplexity int) int
		Trigger        func(childComplexity int) int
		TriggerData    func(childComplexity int) int
	}

	GitTag struct {
		Pusher func(childComplexity int) int
		Tag    func(childComplexity int) int
	}

	GithubCheckSubscriber struct {
		Owner func(childComplexity int) int
		Ref   func(childComplexity int) int
		Repo  func(childComplexity int) int
	}

	GithubPRSubscriber struct {
		Owner    func(childComplexity int) int
		PRNumber func(childComplexity int) int
		Ref      func(childComplexity int) int
		Repo     func(childComplexity int) int
	}

	GithubProjectConflicts struct {
		CommitCheckIdentifiers func(childComplexity int) int
		CommitQueueIdentifiers func(childComplexity int) int
		PRTestingIdentifiers   func(childComplexity int) int
	}

	GithubUser struct {
		LastKnownAs func(childComplexity int) int
		UID         func(childComplexity int) int
	}

	GroupedBuildVariant struct {
		DisplayName func(childComplexity int) int
		Tasks       func(childComplexity int) int
		Variant     func(childComplexity int) int
	}

	GroupedFiles struct {
		Files    func(childComplexity int) int
		TaskName func(childComplexity int) int
	}

	GroupedProjects struct {
		GroupDisplayName func(childComplexity int) int
		Projects         func(childComplexity int) int
		Repo             func(childComplexity int) int
	}

	GroupedTaskStatusCount struct {
		DisplayName  func(childComplexity int) int
		StatusCounts func(childComplexity int) int
		Variant      func(childComplexity int) int
	}

	HomeVolumeSettings struct {
		FormatCommand func(childComplexity int) int
	}

	Host struct {
		Ami                   func(childComplexity int) int
		AvailabilityZone      func(childComplexity int) int
		DisplayName           func(childComplexity int) int
		Distro                func(childComplexity int) int
		DistroID              func(childComplexity int) int
		Elapsed               func(childComplexity int) int
		Expiration            func(childComplexity int) int
		HomeVolume            func(childComplexity int) int
		HomeVolumeID          func(childComplexity int) int
		HostURL               func(childComplexity int) int
		Id                    func(childComplexity int) int
		InstanceTags          func(childComplexity int) int
		InstanceType          func(childComplexity int) int
		LastCommunicationTime func(childComplexity int) int
		NoExpiration          func(childComplexity int) int
		Provider              func(childComplexity int) int
		RunningTask           func(childComplexity int) int
		StartedBy             func(childComplexity int) int
		Status                func(childComplexity int) int
		Tag                   func(childComplexity int) int
		TotalIdleTime         func(childComplexity int) int
		Uptime                func(childComplexity int) int
		User                  func(childComplexity int) int
		Volumes               func(childComplexity int) int
	}

	HostAllocatorSettings struct {
		AcceptableHostIdleTime func(childComplexity int) int
		FeedbackRule           func(childComplexity int) int
		FutureHostFraction     func(childComplexity int) int
		HostsOverallocatedRule func(childComplexity int) int
		MaximumHosts           func(childComplexity int) int
		MinimumHosts           func(childComplexity int) int
		RoundingRule           func(childComplexity int) int
		Version                func(childComplexity int) int
	}

	HostEventLogData struct {
		AgentBuild         func(childComplexity int) int
		AgentRevision      func(childComplexity int) int
		Duration           func(childComplexity int) int
		Execution          func(childComplexity int) int
		Hostname           func(childComplexity int) int
		JasperRevision     func(childComplexity int) int
		Logs               func(childComplexity int) int
		MonitorOp          func(childComplexity int) int
		NewStatus          func(childComplexity int) int
		OldStatus          func(childComplexity int) int
		ProvisioningMethod func(childComplexity int) int
		Successful         func(childComplexity int) int
		TaskId             func(childComplexity int) int
		TaskPid            func(childComplexity int) int
		TaskStatus         func(childComplexity int) int
		User               func(childComplexity int) int
	}

	HostEventLogEntry struct {
		Data         func(childComplexity int) int
		EventType    func(childComplexity int) int
		ID           func(childComplexity int) int
		ProcessedAt  func(childComplexity int) int
		ResourceId   func(childComplexity int) int
		ResourceType func(childComplexity int) int
		Timestamp    func(childComplexity int) int
	}

	HostEvents struct {
		Count           func(childComplexity int) int
		EventLogEntries func(childComplexity int) int
	}

	HostsResponse struct {
		FilteredHostsCount func(childComplexity int) int
		Hosts              func(childComplexity int) int
		TotalHostsCount    func(childComplexity int) int
	}

	IceCreamSettings struct {
		ConfigPath    func(childComplexity int) int
		SchedulerHost func(childComplexity int) int
	}

	InstanceTag struct {
		CanBeModified func(childComplexity int) int
		Key           func(childComplexity int) int
		Value         func(childComplexity int) int
	}

	IssueLink struct {
		ConfidenceScore func(childComplexity int) int
		IssueKey        func(childComplexity int) int
		JiraTicket      func(childComplexity int) int
		Source          func(childComplexity int) int
		URL             func(childComplexity int) int
	}

	JiraConfig struct {
		Host func(childComplexity int) int
	}

	JiraField struct {
		DisplayText func(childComplexity int) int
		Field       func(childComplexity int) int
	}

	JiraIssueSubscriber struct {
		IssueType func(childComplexity int) int
		Project   func(childComplexity int) int
	}

	JiraStatus struct {
		Id   func(childComplexity int) int
		Name func(childComplexity int) int
	}

	JiraTicket struct {
		Fields func(childComplexity int) int
		Key    func(childComplexity int) int
	}

	LogMessage struct {
		Message   func(childComplexity int) int
		Severity  func(childComplexity int) int
		Timestamp func(childComplexity int) int
		Type      func(childComplexity int) int
		Version   func(childComplexity int) int
	}

	LogkeeperBuild struct {
		BuildNum      func(childComplexity int) int
		Builder       func(childComplexity int) int
		ID            func(childComplexity int) int
		Task          func(childComplexity int) int
		TaskExecution func(childComplexity int) int
		TaskID        func(childComplexity int) int
		Tests         func(childComplexity int) int
	}

	LogkeeperTest struct {
		BuildID       func(childComplexity int) int
		Command       func(childComplexity int) int
		ID            func(childComplexity int) int
		Name          func(childComplexity int) int
		Phase         func(childComplexity int) int
		TaskExecution func(childComplexity int) int
		TaskID        func(childComplexity int) int
	}

	MainlineCommitVersion struct {
		RolledUpVersions func(childComplexity int) int
		Version          func(childComplexity int) int
	}

	MainlineCommits struct {
		NextPageOrderNumber func(childComplexity int) int
		PrevPageOrderNumber func(childComplexity int) int
		Versions            func(childComplexity int) int
	}

	Manifest struct {
		Branch          func(childComplexity int) int
		ID              func(childComplexity int) int
		IsBase          func(childComplexity int) int
		ModuleOverrides func(childComplexity int) int
		Modules         func(childComplexity int) int
		Project         func(childComplexity int) int
		Revision        func(childComplexity int) int
	}

	MetadataLink struct {
		Source func(childComplexity int) int
		Text   func(childComplexity int) int
		URL    func(childComplexity int) int
	}

	Module struct {
		Issue  func(childComplexity int) int
		Module func(childComplexity int) int
	}

	ModuleCodeChange struct {
		BranchName func(childComplexity int) int
		FileDiffs  func(childComplexity int) int
		HTMLLink   func(childComplexity int) int
		RawLink    func(childComplexity int) int
	}

	Mutation struct {
		AbortTask                     func(childComplexity int, taskID string) int
		AddAnnotationIssue            func(childComplexity int, taskID string, execution int, apiIssue model.APIIssueLink, isIssue bool) int
		AddFavoriteProject            func(childComplexity int, identifier string) int
		AttachProjectToNewRepo        func(childComplexity int, project MoveProjectInput) int
		AttachProjectToRepo           func(childComplexity int, projectID string) int
		AttachVolumeToHost            func(childComplexity int, volumeAndHost VolumeHost) int
		BbCreateTicket                func(childComplexity int, taskID string, execution *int) int
		ClearMySubscriptions          func(childComplexity int) int
		CopyDistro                    func(childComplexity int, opts data.CopyDistroOpts) int
		CopyProject                   func(childComplexity int, project data.CopyProjectOpts, requestS3Creds *bool) int
		CreateDistro                  func(childComplexity int, opts CreateDistroInput) int
		CreateProject                 func(childComplexity int, project model.APIProjectRef, requestS3Creds *bool) int
		CreatePublicKey               func(childComplexity int, publicKeyInput PublicKeyInput) int
		DeactivateStepbackTask        func(childComplexity int, projectID string, buildVariantName string, taskName string) int
		DefaultSectionToRepo          func(childComplexity int, projectID string, section ProjectSettingsSection) int
		DeleteDistro                  func(childComplexity int, opts DeleteDistroInput) int
		DeleteProject                 func(childComplexity int, projectID string) int
		DeleteSubscriptions           func(childComplexity int, subscriptionIds []string) int
		DetachProjectFromRepo         func(childComplexity int, projectID string) int
		DetachVolumeFromHost          func(childComplexity int, volumeID string) int
		EditAnnotationNote            func(childComplexity int, taskID string, execution int, originalMessage string, newMessage string) int
		EditSpawnHost                 func(childComplexity int, spawnHost *EditSpawnHostInput) int
		EnqueuePatch                  func(childComplexity int, patchID string, commitMessage *string) int
		ForceRepotrackerRun           func(childComplexity int, projectID string) int
		MigrateVolume                 func(childComplexity int, volumeID string, spawnHostInput *SpawnHostInput) int
		MoveAnnotationIssue           func(childComplexity int, taskID string, execution int, apiIssue model.APIIssueLink, isIssue bool) int
		OverrideTaskDependencies      func(childComplexity int, taskID string) int
		PromoteVarsToRepo             func(childComplexity int, projectID string, varNames []string) int
		RemoveAnnotationIssue         func(childComplexity int, taskID string, execution int, apiIssue model.APIIssueLink, isIssue bool) int
		RemoveFavoriteProject         func(childComplexity int, identifier string) int
		RemoveItemFromCommitQueue     func(childComplexity int, commitQueueID string, issue string) int
		RemovePublicKey               func(childComplexity int, keyName string) int
		RemoveVolume                  func(childComplexity int, volumeID string) int
		ReprovisionToNew              func(childComplexity int, hostIds []string) int
		RestartJasper                 func(childComplexity int, hostIds []string) int
		RestartTask                   func(childComplexity int, taskID string, failedOnly bool) int
		RestartVersions               func(childComplexity int, versionID string, abort bool, versionsToRestart []*model1.VersionToRestart) int
		SaveDistro                    func(childComplexity int, opts SaveDistroInput) int
		SaveProjectSettingsForSection func(childComplexity int, projectSettings *model.APIProjectSettings, section ProjectSettingsSection) int
		SaveRepoSettingsForSection    func(childComplexity int, repoSettings *model.APIProjectSettings, section ProjectSettingsSection) int
		SaveSubscription              func(childComplexity int, subscription model.APISubscription) int
		SchedulePatch                 func(childComplexity int, patchID string, configure PatchConfigure) int
		SchedulePatchTasks            func(childComplexity int, patchID string) int
		ScheduleTasks                 func(childComplexity int, taskIds []string) int
		ScheduleUndispatchedBaseTasks func(childComplexity int, patchID string) int
		SetAnnotationMetadataLinks    func(childComplexity int, taskID string, execution int, metadataLinks []*model.APIMetadataLink) int
		SetPatchPriority              func(childComplexity int, patchID string, priority int) int
		SetPatchVisibility            func(childComplexity int, patchIds []string, hidden bool) int
		SetTaskPriority               func(childComplexity int, taskID string, priority int) int
		SpawnHost                     func(childComplexity int, spawnHostInput *SpawnHostInput) int
		SpawnVolume                   func(childComplexity int, spawnVolumeInput SpawnVolumeInput) int
		UnschedulePatchTasks          func(childComplexity int, patchID string, abort bool) int
		UnscheduleTask                func(childComplexity int, taskID string) int
		UpdateHostStatus              func(childComplexity int, hostIds []string, status string, notes *string) int
		UpdatePublicKey               func(childComplexity int, targetKeyName string, updateInfo PublicKeyInput) int
		UpdateSpawnHostStatus         func(childComplexity int, hostID string, action SpawnHostStatusActions) int
		UpdateUserSettings            func(childComplexity int, userSettings *model.APIUserSettings) int
		UpdateVolume                  func(childComplexity int, updateVolumeInput UpdateVolumeInput) int
	}

	NewDistroPayload struct {
		NewDistroID func(childComplexity int) int
	}

	Note struct {
		Message func(childComplexity int) int
		Source  func(childComplexity int) int
	}

	Notifications struct {
		BuildBreak            func(childComplexity int) int
		BuildBreakID          func(childComplexity int) int
		CommitQueue           func(childComplexity int) int
		CommitQueueID         func(childComplexity int) int
		PatchFinish           func(childComplexity int) int
		PatchFinishID         func(childComplexity int) int
		PatchFirstFailure     func(childComplexity int) int
		PatchFirstFailureID   func(childComplexity int) int
		SpawnHostExpiration   func(childComplexity int) int
		SpawnHostExpirationID func(childComplexity int) int
		SpawnHostOutcome      func(childComplexity int) int
		SpawnHostOutcomeID    func(childComplexity int) int
	}

	OomTrackerInfo struct {
		Detected func(childComplexity int) int
		Pids     func(childComplexity int) int
	}

	Parameter struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	ParsleyFilter struct {
		CaseSensitive func(childComplexity int) int
		ExactMatch    func(childComplexity int) int
		Expression    func(childComplexity int) int
	}

	Patch struct {
		Activated               func(childComplexity int) int
		Alias                   func(childComplexity int) int
		Author                  func(childComplexity int) int
		AuthorDisplayName       func(childComplexity int) int
		BaseTaskStatuses        func(childComplexity int) int
		Builds                  func(childComplexity int) int
		CanEnqueueToCommitQueue func(childComplexity int) int
		ChildPatchAliases       func(childComplexity int) int
		ChildPatches            func(childComplexity int) int
		CommitQueuePosition     func(childComplexity int) int
		CreateTime              func(childComplexity int) int
		Description             func(childComplexity int) int
		Duration                func(childComplexity int) int
		Githash                 func(childComplexity int) int
		Hidden                  func(childComplexity int) int
		Id                      func(childComplexity int) int
		ModuleCodeChanges       func(childComplexity int) int
		Parameters              func(childComplexity int) int
		PatchNumber             func(childComplexity int) int
		PatchTriggerAliases     func(childComplexity int) int
		Project                 func(childComplexity int) int
		ProjectId               func(childComplexity int) int
		ProjectIdentifier       func(childComplexity int) int
		ProjectMetadata         func(childComplexity int) int
		Status                  func(childComplexity int) int
		TaskCount               func(childComplexity int) int
		TaskStatuses            func(childComplexity int) int
		Tasks                   func(childComplexity int) int
		Time                    func(childComplexity int) int
		Variants                func(childComplexity int) int
		VariantsTasks           func(childComplexity int) int
		VersionFull             func(childComplexity int) int
	}

	PatchDuration struct {
		Makespan  func(childComplexity int) int
		Time      func(childComplexity int) int
		TimeTaken func(childComplexity int) int
	}

	PatchProject struct {
		Variants func(childComplexity int) int
	}

	PatchTime struct {
		Finished    func(childComplexity int) int
		Started     func(childComplexity int) int
		SubmittedAt func(childComplexity int) int
	}

	PatchTriggerAlias struct {
		Alias                  func(childComplexity int) int
		ChildProjectId         func(childComplexity int) int
		ChildProjectIdentifier func(childComplexity int) int
		ParentAsModule         func(childComplexity int) int
		Status                 func(childComplexity int) int
		TaskSpecifiers         func(childComplexity int) int
		VariantsTasks          func(childComplexity int) int
	}

	Patches struct {
		FilteredPatchCount func(childComplexity int) int
		Patches            func(childComplexity int) int
	}

	PeriodicBuild struct {
		Alias         func(childComplexity int) int
		ConfigFile    func(childComplexity int) int
		Cron          func(childComplexity int) int
		ID            func(childComplexity int) int
		IntervalHours func(childComplexity int) int
		Message       func(childComplexity int) int
		NextRunTime   func(childComplexity int) int
	}

	Permissions struct {
		CanCreateDistro   func(childComplexity int) int
		CanCreateProject  func(childComplexity int) int
		DistroPermissions func(childComplexity int, options DistroPermissionsOptions) int
		UserID            func(childComplexity int) int
	}

	PlannerSettings struct {
		CommitQueueFactor         func(childComplexity int) int
		ExpectedRuntimeFactor     func(childComplexity int) int
		GenerateTaskFactor        func(childComplexity int) int
		GroupVersions             func(childComplexity int) int
		MainlineTimeInQueueFactor func(childComplexity int) int
		PatchFactor               func(childComplexity int) int
		PatchTimeInQueueFactor    func(childComplexity int) int
		TargetTime                func(childComplexity int) int
		Version                   func(childComplexity int) int
	}

	Pod struct {
		Events                    func(childComplexity int, limit *int, page *int) int
		ID                        func(childComplexity int) int
		Status                    func(childComplexity int) int
		Task                      func(childComplexity int) int
		TaskContainerCreationOpts func(childComplexity int) int
		Type                      func(childComplexity int) int
	}

	PodEventLogData struct {
		NewStatus     func(childComplexity int) int
		OldStatus     func(childComplexity int) int
		Reason        func(childComplexity int) int
		Task          func(childComplexity int) int
		TaskExecution func(childComplexity int) int
		TaskID        func(childComplexity int) int
		TaskStatus    func(childComplexity int) int
	}

	PodEventLogEntry struct {
		Data         func(childComplexity int) int
		EventType    func(childComplexity int) int
		ID           func(childComplexity int) int
		ProcessedAt  func(childComplexity int) int
		ResourceId   func(childComplexity int) int
		ResourceType func(childComplexity int) int
		Timestamp    func(childComplexity int) int
	}

	PodEvents struct {
		Count           func(childComplexity int) int
		EventLogEntries func(childComplexity int) int
	}

	PreconditionScript struct {
		Path   func(childComplexity int) int
		Script func(childComplexity int) int
	}

	Project struct {
		Admins                   func(childComplexity int) int
		Banner                   func(childComplexity int) int
		BatchTime                func(childComplexity int) int
		Branch                   func(childComplexity int) int
		BuildBaronSettings       func(childComplexity int) int
		CommitQueue              func(childComplexity int) int
		ContainerSizeDefinitions func(childComplexity int) int
		DeactivatePrevious       func(childComplexity int) int
		DisabledStatsCache       func(childComplexity int) int
		DispatchingDisabled      func(childComplexity int) int
		DisplayName              func(childComplexity int) int
		Enabled                  func(childComplexity int) int
		ExternalLinks            func(childComplexity int) int
		GitTagAuthorizedTeams    func(childComplexity int) int
		GitTagAuthorizedUsers    func(childComplexity int) int
		GitTagVersionsEnabled    func(childComplexity int) int
		GithubChecksEnabled      func(childComplexity int) int
		GithubTriggerAliases     func(childComplexity int) int
		Hidden                   func(childComplexity int) int
		Id                       func(childComplexity int) int
		Identifier               func(childComplexity int) int
		IsFavorite               func(childComplexity int) int
		ManualPRTestingEnabled   func(childComplexity int) int
		NotifyOnBuildFailure     func(childComplexity int) int
		Owner                    func(childComplexity int) int
		PRTestingEnabled         func(childComplexity int) int
		ParsleyFilters           func(childComplexity int) int
		PatchTriggerAliases      func(childComplexity int) int
		Patches                  func(childComplexity int, patchesInput PatchesInput) int
		PatchingDisabled         func(childComplexity int) int
		PerfEnabled              func(childComplexity int) int
		PeriodicBuilds           func(childComplexity int) int
		Private                  func(childComplexity int) int
		ProjectHealthView        func(childComplexity int) int
		RemotePath               func(childComplexity int) int
		Repo                     func(childComplexity int) int
		RepoRefId                func(childComplexity int) int
		RepotrackerDisabled      func(childComplexity int) int
		Restricted               func(childComplexity int) int
		SpawnHostScriptPath      func(childComplexity int) int
		StepbackDisabled         func(childComplexity int) int
		TaskAnnotationSettings   func(childComplexity int) int
		TaskSync                 func(childComplexity int) int
		TracksPushEvents         func(childComplexity int) int
		Triggers                 func(childComplexity int) int
		VersionControlEnabled    func(childComplexity int) int
		WorkstationConfig        func(childComplexity int) int
	}

	ProjectAlias struct {
		Alias       func(childComplexity int) int
		Description func(childComplexity int) int
		GitTag      func(childComplexity int) int
		ID          func(childComplexity int) int
		Parameters  func(childComplexity int) int
		RemotePath  func(childComplexity int) int
		Task        func(childComplexity int) int
		TaskTags    func(childComplexity int) int
		Variant     func(childComplexity int) int
		VariantTags func(childComplexity int) int
	}

	ProjectBanner struct {
		Text  func(childComplexity int) int
		Theme func(childComplexity int) int
	}

	ProjectBuildVariant struct {
		DisplayName func(childComplexity int) int
		Name        func(childComplexity int) int
		Tasks       func(childComplexity int) int
	}

	ProjectEventLogEntry struct {
		After     func(childComplexity int) int
		Before    func(childComplexity int) int
		Timestamp func(childComplexity int) int
		User      func(childComplexity int) int
	}

	ProjectEventSettings struct {
		Aliases               func(childComplexity int) int
		GithubWebhooksEnabled func(childComplexity int) int
		ProjectRef            func(childComplexity int) int
		Subscriptions         func(childComplexity int) int
		Vars                  func(childComplexity int) int
	}

	ProjectEvents struct {
		Count           func(childComplexity int) int
		EventLogEntries func(childComplexity int) int
	}

	ProjectSettings struct {
		Aliases               func(childComplexity int) int
		GithubWebhooksEnabled func(childComplexity int) int
		ProjectRef            func(childComplexity int) int
		Subscriptions         func(childComplexity int) int
		Vars                  func(childComplexity int) int
	}

	ProjectVars struct {
		AdminOnlyVars func(childComplexity int) int
		PrivateVars   func(childComplexity int) int
		Vars          func(childComplexity int) int
	}

	PublicKey struct {
		Key  func(childComplexity int) int
		Name func(childComplexity int) int
	}

	Query struct {
		AwsRegions               func(childComplexity int) int
		BbGetCreatedTickets      func(childComplexity int, taskID string) int
		BuildBaron               func(childComplexity int, taskID string, execution int) int
		BuildVariantsForTaskName func(childComplexity int, projectIdentifier string, taskName string) int
		ClientConfig             func(childComplexity int) int
		CommitQueue              func(childComplexity int, projectIdentifier string) int
		Distro                   func(childComplexity int, distroID string) int
		DistroEvents             func(childComplexity int, opts DistroEventsInput) int
		DistroTaskQueue          func(childComplexity int, distroID string) int
		Distros                  func(childComplexity int, onlySpawnable bool) int
		GithubProjectConflicts   func(childComplexity int, projectID string) int
		HasVersion               func(childComplexity int, id string) int
		Host                     func(childComplexity int, hostID string) int
		HostEvents               func(childComplexity int, hostID string, hostTag *string, limit *int, page *int) int
		Hosts                    func(childComplexity int, hostID *string, distroID *string, currentTaskID *string, statuses []string, startedBy *string, sortBy *HostSortBy, sortDir *SortDirection, page *int, limit *int) int
		InstanceTypes            func(childComplexity int) int
		LogkeeperBuildMetadata   func(childComplexity int, buildID string) int
		MainlineCommits          func(childComplexity int, options MainlineCommitsOptions, buildVariantOptions *BuildVariantOptions) int
		MyHosts                  func(childComplexity int) int
		MyPublicKeys             func(childComplexity int) int
		MyVolumes                func(childComplexity int) int
		Patch                    func(childComplexity int, id string) int
		Pod                      func(childComplexity int, podID string) int
		Project                  func(childComplexity int, projectIdentifier string) int
		ProjectEvents            func(childComplexity int, identifier string, limit *int, before *time.Time) int
		ProjectSettings          func(childComplexity int, identifier string) int
		Projects                 func(childComplexity int) int
		RepoEvents               func(childComplexity int, id string, limit *int, before *time.Time) int
		RepoSettings             func(childComplexity int, id string) int
		SpruceConfig             func(childComplexity int) int
		SubnetAvailabilityZones  func(childComplexity int) int
		Task                     func(childComplexity int, taskID string, execution *int) int
		TaskAllExecutions        func(childComplexity int, taskID string) int
		TaskNamesForBuildVariant func(childComplexity int, projectIdentifier string, buildVariant string) int
		TaskQueueDistros         func(childComplexity int) int
		TaskTestSample           func(childComplexity int, tasks []string, filters []*TestFilter) int
		User                     func(childComplexity int, userID *string) int
		UserConfig               func(childComplexity int) int
		UserSettings             func(childComplexity int) int
		Version                  func(childComplexity int, id string) int
		ViewableProjectRefs      func(childComplexity int) int
	}

	RepoCommitQueueParams struct {
		Enabled     func(childComplexity int) int
		MergeMethod func(childComplexity int) int
		MergeQueue  func(childComplexity int) int
		Message     func(childComplexity int) int
	}

	RepoRef struct {
		Admins                   func(childComplexity int) int
		BatchTime                func(childComplexity int) int
		BuildBaronSettings       func(childComplexity int) int
		CommitQueue              func(childComplexity int) int
		ContainerSizeDefinitions func(childComplexity int) int
		DeactivatePrevious       func(childComplexity int) int
		DisabledStatsCache       func(childComplexity int) int
		DispatchingDisabled      func(childComplexity int) int
		DisplayName              func(childComplexity int) int
		Enabled                  func(childComplexity int) int
		ExternalLinks            func(childComplexity int) int
		GitTagAuthorizedTeams    func(childComplexity int) int
		GitTagAuthorizedUsers    func(childComplexity int) int
		GitTagVersionsEnabled    func(childComplexity int) int
		GithubChecksEnabled      func(childComplexity int) int
		GithubTriggerAliases     func(childComplexity int) int
		Id                       func(childComplexity int) int
		ManualPRTestingEnabled   func(childComplexity int) int
		NotifyOnBuildFailure     func(childComplexity int) int
		Owner                    func(childComplexity int) int
		PRTestingEnabled         func(childComplexity int) int
		PatchTriggerAliases      func(childComplexity int) int
		PatchingDisabled         func(childComplexity int) int
		PerfEnabled              func(childComplexity int) int
		PeriodicBuilds           func(childComplexity int) int
		Private                  func(childComplexity int) int
		RemotePath               func(childComplexity int) int
		Repo                     func(childComplexity int) int
		RepotrackerDisabled      func(childComplexity int) int
		Restricted               func(childComplexity int) int
		SpawnHostScriptPath      func(childComplexity int) int
		StepbackDisabled         func(childComplexity int) int
		TaskAnnotationSettings   func(childComplexity int) int
		TaskSync                 func(childComplexity int) int
		TracksPushEvents         func(childComplexity int) int
		Triggers                 func(childComplexity int) int
		VersionControlEnabled    func(childComplexity int) int
		WorkstationConfig        func(childComplexity int) int
	}

	RepoSettings struct {
		Aliases               func(childComplexity int) int
		GithubWebhooksEnabled func(childComplexity int) int
		ProjectRef            func(childComplexity int) int
		Subscriptions         func(childComplexity int) int
		Vars                  func(childComplexity int) int
	}

	RepoTaskSyncOptions struct {
		ConfigEnabled func(childComplexity int) int
		PatchEnabled  func(childComplexity int) int
	}

	RepoWorkstationConfig struct {
		GitClone      func(childComplexity int) int
		SetupCommands func(childComplexity int) int
	}

	ResourceLimits struct {
		LockedMemoryKB  func(childComplexity int) int
		NumFiles        func(childComplexity int) int
		NumProcesses    func(childComplexity int) int
		NumTasks        func(childComplexity int) int
		VirtualMemoryKB func(childComplexity int) int
	}

	SaveDistroPayload struct {
		Distro    func(childComplexity int) int
		HostCount func(childComplexity int) int
	}

	SearchReturnInfo struct {
		FeaturesURL func(childComplexity int) int
		Issues      func(childComplexity int) int
		Search      func(childComplexity int) int
		Source      func(childComplexity int) int
	}

	Selector struct {
		Data func(childComplexity int) int
		Type func(childComplexity int) int
	}

	SlackConfig struct {
		Name func(childComplexity int) int
	}

	Source struct {
		Author    func(childComplexity int) int
		Requester func(childComplexity int) int
		Time      func(childComplexity int) int
	}

	SpawnHostConfig struct {
		SpawnHostsPerUser         func(childComplexity int) int
		UnexpirableHostsPerUser   func(childComplexity int) int
		UnexpirableVolumesPerUser func(childComplexity int) int
	}

	SpruceConfig struct {
		Banner      func(childComplexity int) int
		BannerTheme func(childComplexity int) int
		GithubOrgs  func(childComplexity int) int
		Jira        func(childComplexity int) int
		Providers   func(childComplexity int) int
		Slack       func(childComplexity int) int
		Spawnhost   func(childComplexity int) int
		Ui          func(childComplexity int) int
	}

	StatusCount struct {
		Count  func(childComplexity int) int
		Status func(childComplexity int) int
	}

	Subscriber struct {
		EmailSubscriber       func(childComplexity int) int
		GithubCheckSubscriber func(childComplexity int) int
		GithubPRSubscriber    func(childComplexity int) int
		JiraCommentSubscriber func(childComplexity int) int
		JiraIssueSubscriber   func(childComplexity int) int
		SlackSubscriber       func(childComplexity int) int
		WebhookSubscriber     func(childComplexity int) int
	}

	SubscriberWrapper struct {
		Subscriber func(childComplexity int) int
		Type       func(childComplexity int) int
	}

	Task struct {
		AbortInfo               func(childComplexity int) int
		Aborted                 func(childComplexity int) int
		Activated               func(childComplexity int) int
		ActivatedBy             func(childComplexity int) int
		ActivatedTime           func(childComplexity int) int
		Ami                     func(childComplexity int) int
		Annotation              func(childComplexity int) int
		BaseStatus              func(childComplexity int) int
		BaseTask                func(childComplexity int) int
		Blocked                 func(childComplexity int) int
		BuildId                 func(childComplexity int) int
		BuildVariant            func(childComplexity int) int
		BuildVariantDisplayName func(childComplexity int) int
		CanAbort                func(childComplexity int) int
		CanDisable              func(childComplexity int) int
		CanModifyAnnotation     func(childComplexity int) int
		CanOverrideDependencies func(childComplexity int) int
		CanRestart              func(childComplexity int) int
		CanSchedule             func(childComplexity int) int
		CanSetPriority          func(childComplexity int) int
		CanSync                 func(childComplexity int) int
		CanUnschedule           func(childComplexity int) int
		ContainerAllocatedTime  func(childComplexity int) int
		CreateTime              func(childComplexity int) int
		DependsOn               func(childComplexity int) int
		Details                 func(childComplexity int) int
		DispatchTime            func(childComplexity int) int
		DisplayName             func(childComplexity int) int
		DisplayOnly             func(childComplexity int) int
		DisplayTask             func(childComplexity int) int
		DistroId                func(childComplexity int) int
		EstimatedStart          func(childComplexity int) int
		Execution               func(childComplexity int) int
		ExecutionTasks          func(childComplexity int) int
		ExecutionTasksFull      func(childComplexity int) int
		ExpectedDuration        func(childComplexity int) int
		FailedTestCount         func(childComplexity int) int
		FinishTime              func(childComplexity int) int
		GenerateTask            func(childComplexity int) int
		GeneratedBy             func(childComplexity int) int
		GeneratedByName         func(childComplexity int) int
		HostId                  func(childComplexity int) int
		Id                      func(childComplexity int) int
		IngestTime              func(childComplexity int) int
		IsPerfPluginEnabled     func(childComplexity int) int
		LatestExecution         func(childComplexity int) int
		Logs                    func(childComplexity int) int
		MinQueuePosition        func(childComplexity int) int
		Order                   func(childComplexity int) int
		Patch                   func(childComplexity int) int
		PatchNumber             func(childComplexity int) int
		Pod                     func(childComplexity int) int
		Priority                func(childComplexity int) int
		Project                 func(childComplexity int) int
		ProjectId               func(childComplexity int) int
		ProjectIdentifier       func(childComplexity int) int
		Requester               func(childComplexity int) int
		ResetWhenFinished       func(childComplexity int) int
		Revision                func(childComplexity int) int
		ScheduledTime           func(childComplexity int) int
		SpawnHostLink           func(childComplexity int) int
		StartTime               func(childComplexity int) int
		Status                  func(childComplexity int) int
		TaskFiles               func(childComplexity int) int
		TaskGroup               func(childComplexity int) int
		TaskGroupMaxHosts       func(childComplexity int) int
		TaskLogs                func(childComplexity int) int
		Tests                   func(childComplexity int, opts *TestFilterOptions) int
		TimeTaken               func(childComplexity int) int
		TotalTestCount          func(childComplexity int) int
		VersionMetadata         func(childComplexity int) int
	}

	TaskAnnotationSettings struct {
		FileTicketWebhook func(childComplexity int) int
		JiraCustomFields  func(childComplexity int) int
	}

	TaskContainerCreationOpts struct {
		Arch       func(childComplexity int) int
		CPU        func(childComplexity int) int
		Image      func(childComplexity int) int
		MemoryMB   func(childComplexity int) int
		Os         func(childComplexity int) int
		WorkingDir func(childComplexity int) int
	}

	TaskEndDetail struct {
		Description func(childComplexity int) int
		OOMTracker  func(childComplexity int) int
		Status      func(childComplexity int) int
		TimedOut    func(childComplexity int) int
		TimeoutType func(childComplexity int) int
		TraceID     func(childComplexity int) int
		Type        func(childComplexity int) int
	}

	TaskEventLogData struct {
		HostId    func(childComplexity int) int
		JiraIssue func(childComplexity int) int
		JiraLink  func(childComplexity int) int
		PodId     func(childComplexity int) int
		Priority  func(childComplexity int) int
		Status    func(childComplexity int) int
		Timestamp func(childComplexity int) int
		UserId    func(childComplexity int) int
	}

	TaskEventLogEntry struct {
		Data         func(childComplexity int) int
		EventType    func(childComplexity int) int
		ID           func(childComplexity int) int
		ProcessedAt  func(childComplexity int) int
		ResourceId   func(childComplexity int) int
		ResourceType func(childComplexity int) int
		Timestamp    func(childComplexity int) int
	}

	TaskFiles struct {
		FileCount    func(childComplexity int) int
		GroupedFiles func(childComplexity int) int
	}

	TaskInfo struct {
		Id   func(childComplexity int) int
		Name func(childComplexity int) int
	}

	TaskLogLinks struct {
		AgentLogLink  func(childComplexity int) int
		AllLogLink    func(childComplexity int) int
		EventLogLink  func(childComplexity int) int
		SystemLogLink func(childComplexity int) int
		TaskLogLink   func(childComplexity int) int
	}

	TaskLogs struct {
		AgentLogs     func(childComplexity int) int
		AllLogs       func(childComplexity int) int
		DefaultLogger func(childComplexity int) int
		EventLogs     func(childComplexity int) int
		Execution     func(childComplexity int) int
		SystemLogs    func(childComplexity int) int
		TaskID        func(childComplexity int) int
		TaskLogs      func(childComplexity int) int
	}

	TaskQueueDistro struct {
		HostCount func(childComplexity int) int
		ID        func(childComplexity int) int
		TaskCount func(childComplexity int) int
	}

	TaskQueueItem struct {
		ActivatedBy      func(childComplexity int) int
		BuildVariant     func(childComplexity int) int
		DisplayName      func(childComplexity int) int
		ExpectedDuration func(childComplexity int) int
		Id               func(childComplexity int) int
		Priority         func(childComplexity int) int
		Project          func(childComplexity int) int
		Requester        func(childComplexity int) int
		Revision         func(childComplexity int) int
		Version          func(childComplexity int) int
	}

	TaskSpecifier struct {
		PatchAlias   func(childComplexity int) int
		TaskRegex    func(childComplexity int) int
		VariantRegex func(childComplexity int) int
	}

	TaskStats struct {
		Counts func(childComplexity int) int
		ETA    func(childComplexity int) int
	}

	TaskSyncOptions struct {
		ConfigEnabled func(childComplexity int) int
		PatchEnabled  func(childComplexity int) int
	}

	TaskTestResult struct {
		FilteredTestCount func(childComplexity int) int
		TestResults       func(childComplexity int) int
		TotalTestCount    func(childComplexity int) int
	}

	TaskTestResultSample struct {
		Execution               func(childComplexity int) int
		MatchingFailedTestNames func(childComplexity int) int
		TaskID                  func(childComplexity int) int
		TotalTestCount          func(childComplexity int) int
	}

	TestLog struct {
		LineNum    func(childComplexity int) int
		URL        func(childComplexity int) int
		URLLobster func(childComplexity int) int
		URLParsley func(childComplexity int) int
		URLRaw     func(childComplexity int) int
	}

	TestResult struct {
		BaseStatus func(childComplexity int) int
		Duration   func(childComplexity int) int
		EndTime    func(childComplexity int) int
		Execution  func(childComplexity int) int
		ExitCode   func(childComplexity int) int
		GroupID    func(childComplexity int) int
		ID         func(childComplexity int) int
		Logs       func(childComplexity int) int
		StartTime  func(childComplexity int) int
		Status     func(childComplexity int) int
		TaskID     func(childComplexity int) int
		TestFile   func(childComplexity int) int
	}

	TicketFields struct {
		AssignedTeam        func(childComplexity int) int
		AssigneeDisplayName func(childComplexity int) int
		Created             func(childComplexity int) int
		ResolutionName      func(childComplexity int) int
		Status              func(childComplexity int) int
		Summary             func(childComplexity int) int
		Updated             func(childComplexity int) int
	}

	TriggerAlias struct {
		Alias             func(childComplexity int) int
		BuildVariantRegex func(childComplexity int) int
		ConfigFile        func(childComplexity int) int
		DateCutoff        func(childComplexity int) int
		Level             func(childComplexity int) int
		Project           func(childComplexity int) int
		Status            func(childComplexity int) int
		TaskRegex         func(childComplexity int) int
	}

	UIConfig struct {
		DefaultProject func(childComplexity int) int
		UserVoice      func(childComplexity int) int
	}

	UpstreamProject struct {
		Owner       func(childComplexity int) int
		Project     func(childComplexity int) int
		Repo        func(childComplexity int) int
		ResourceID  func(childComplexity int) int
		Revision    func(childComplexity int) int
		Task        func(childComplexity int) int
		TriggerID   func(childComplexity int) int
		TriggerType func(childComplexity int) int
		Version     func(childComplexity int) int
	}

	UseSpruceOptions struct {
		HasUsedMainlineCommitsBefore func(childComplexity int) int
		HasUsedSpruceBefore          func(childComplexity int) int
		SpruceV1                     func(childComplexity int) int
	}

	User struct {
		DisplayName   func(childComplexity int) int
		EmailAddress  func(childComplexity int) int
		Patches       func(childComplexity int, patchesInput PatchesInput) int
		Permissions   func(childComplexity int) int
		Subscriptions func(childComplexity int) int
		UserID        func(childComplexity int) int
	}

	UserConfig struct {
		APIKey        func(childComplexity int) int
		APIServerHost func(childComplexity int) int
		UIServerHost  func(childComplexity int) int
		User          func(childComplexity int) int
	}

	UserSettings struct {
		DateFormat       func(childComplexity int) int
		GithubUser       func(childComplexity int) int
		Notifications    func(childComplexity int) int
		Region           func(childComplexity int) int
		SlackMemberId    func(childComplexity int) int
		SlackUsername    func(childComplexity int) int
		Timezone         func(childComplexity int) int
		UseSpruceOptions func(childComplexity int) int
	}

	VariantTask struct {
		Name  func(childComplexity int) int
		Tasks func(childComplexity int) int
	}

	Version struct {
		Activated                func(childComplexity int) int
		Author                   func(childComplexity int) int
		BaseTaskStatuses         func(childComplexity int) int
		BaseVersion              func(childComplexity int) int
		Branch                   func(childComplexity int) int
		BuildVariantStats        func(childComplexity int, options BuildVariantOptions) int
		BuildVariants            func(childComplexity int, options BuildVariantOptions) int
		ChildVersions            func(childComplexity int) int
		CreateTime               func(childComplexity int) int
		Errors                   func(childComplexity int) int
		ExternalLinksForMetadata func(childComplexity int) int
		FinishTime               func(childComplexity int) int
		GitTags                  func(childComplexity int) int
		Id                       func(childComplexity int) int
		IsPatch                  func(childComplexity int) int
		Manifest                 func(childComplexity int) int
		Message                  func(childComplexity int) int
		Order                    func(childComplexity int) int
		Parameters               func(childComplexity int) int
		Patch                    func(childComplexity int) int
		PreviousVersion          func(childComplexity int) int
		Project                  func(childComplexity int) int
		ProjectIdentifier        func(childComplexity int) int
		ProjectMetadata          func(childComplexity int) int
		Repo                     func(childComplexity int) int
		Requester                func(childComplexity int) int
		Revision                 func(childComplexity int) int
		StartTime                func(childComplexity int) int
		Status                   func(childComplexity int) int
		TaskCount                func(childComplexity int) int
		TaskStatusStats          func(childComplexity int, options BuildVariantOptions) int
		TaskStatuses             func(childComplexity int) int
		Tasks                    func(childComplexity int, options TaskFilterOptions) int
		UpstreamProject          func(childComplexity int) int
		VersionTiming            func(childComplexity int) int
		Warnings                 func(childComplexity int) int
	}

	VersionTasks struct {
		Count func(childComplexity int) int
		Data  func(childComplexity int) int
	}

	VersionTiming struct {
		Makespan  func(childComplexity int) int
		TimeTaken func(childComplexity int) int
	}

	Volume struct {
		AvailabilityZone func(childComplexity int) int
		CreatedBy        func(childComplexity int) int
		CreationTime     func(childComplexity int) int
		DeviceName       func(childComplexity int) int
		DisplayName      func(childComplexity int) int
		Expiration       func(childComplexity int) int
		HomeVolume       func(childComplexity int) int
		Host             func(childComplexity int) int
		HostID           func(childComplexity int) int
		ID               func(childComplexity int) int
		Migrating        func(childComplexity int) int
		NoExpiration     func(childComplexity int) int
		Size             func(childComplexity int) int
		Type             func(childComplexity int) int
	}

	Webhook struct {
		Endpoint func(childComplexity int) int
		Secret   func(childComplexity int) int
	}

	WebhookHeader struct {
		Key   func(childComplexity int) int
		Value func(childComplexity int) int
	}

	WebhookSubscriber struct {
		Headers    func(childComplexity int) int
		MinDelayMS func(childComplexity int) int
		Retries    func(childComplexity int) int
		Secret     func(childComplexity int) int
		TimeoutMS  func(childComplexity int) int
		URL        func(childComplexity int) int
	}

	WorkstationConfig struct {
		GitClone      func(childComplexity int) int
		SetupCommands func(childComplexity int) int
	}

	WorkstationSetupCommand struct {
		Command   func(childComplexity int) int
		Directory func(childComplexity int) int
	}
}

type AnnotationResolver interface {
	WebhookConfigured(ctx context.Context, obj *model.APITaskAnnotation) (bool, error)
}
type DispatcherSettingsResolver interface {
	Version(ctx context.Context, obj *model.APIDispatcherSettings) (DispatcherVersion, error)
}
type DistroResolver interface {
	CloneMethod(ctx context.Context, obj *model.APIDistro) (CloneMethod, error)

	Provider(ctx context.Context, obj *model.APIDistro) (Provider, error)
	ProviderSettingsList(ctx context.Context, obj *model.APIDistro) ([]map[string]interface{}, error)
}
type FinderSettingsResolver interface {
	Version(ctx context.Context, obj *model.APIFinderSettings) (FinderVersion, error)
}
type HostResolver interface {
	Ami(ctx context.Context, obj *model.APIHost) (*string, error)

	DistroID(ctx context.Context, obj *model.APIHost) (*string, error)
	Elapsed(ctx context.Context, obj *model.APIHost) (*time.Time, error)

	HomeVolume(ctx context.Context, obj *model.APIHost) (*model.APIVolume, error)

	Uptime(ctx context.Context, obj *model.APIHost) (*time.Time, error)

	Volumes(ctx context.Context, obj *model.APIHost) ([]*model.APIVolume, error)
}
type IssueLinkResolver interface {
	JiraTicket(ctx context.Context, obj *model.APIIssueLink) (*thirdparty.JiraTicket, error)
}
type LogkeeperBuildResolver interface {
	Task(ctx context.Context, obj *plank.Build) (*model.APITask, error)
}
type MutationResolver interface {
	BbCreateTicket(ctx context.Context, taskID string, execution *int) (bool, error)
	AddAnnotationIssue(ctx context.Context, taskID string, execution int, apiIssue model.APIIssueLink, isIssue bool) (bool, error)
	EditAnnotationNote(ctx context.Context, taskID string, execution int, originalMessage string, newMessage string) (bool, error)
	MoveAnnotationIssue(ctx context.Context, taskID string, execution int, apiIssue model.APIIssueLink, isIssue bool) (bool, error)
	RemoveAnnotationIssue(ctx context.Context, taskID string, execution int, apiIssue model.APIIssueLink, isIssue bool) (bool, error)
	SetAnnotationMetadataLinks(ctx context.Context, taskID string, execution int, metadataLinks []*model.APIMetadataLink) (bool, error)
	DeleteDistro(ctx context.Context, opts DeleteDistroInput) (*DeleteDistroPayload, error)
	CopyDistro(ctx context.Context, opts data.CopyDistroOpts) (*NewDistroPayload, error)
	CreateDistro(ctx context.Context, opts CreateDistroInput) (*NewDistroPayload, error)
	SaveDistro(ctx context.Context, opts SaveDistroInput) (*SaveDistroPayload, error)
	ReprovisionToNew(ctx context.Context, hostIds []string) (int, error)
	RestartJasper(ctx context.Context, hostIds []string) (int, error)
	UpdateHostStatus(ctx context.Context, hostIds []string, status string, notes *string) (int, error)
	EnqueuePatch(ctx context.Context, patchID string, commitMessage *string) (*model.APIPatch, error)
	SetPatchVisibility(ctx context.Context, patchIds []string, hidden bool) ([]*model.APIPatch, error)
	SchedulePatch(ctx context.Context, patchID string, configure PatchConfigure) (*model.APIPatch, error)
	SchedulePatchTasks(ctx context.Context, patchID string) (*string, error)
	ScheduleUndispatchedBaseTasks(ctx context.Context, patchID string) ([]*model.APITask, error)
	SetPatchPriority(ctx context.Context, patchID string, priority int) (*string, error)
	UnschedulePatchTasks(ctx context.Context, patchID string, abort bool) (*string, error)
	AddFavoriteProject(ctx context.Context, identifier string) (*model.APIProjectRef, error)
	AttachProjectToNewRepo(ctx context.Context, project MoveProjectInput) (*model.APIProjectRef, error)
	AttachProjectToRepo(ctx context.Context, projectID string) (*model.APIProjectRef, error)
	CreateProject(ctx context.Context, project model.APIProjectRef, requestS3Creds *bool) (*model.APIProjectRef, error)
	CopyProject(ctx context.Context, project data.CopyProjectOpts, requestS3Creds *bool) (*model.APIProjectRef, error)
	DeactivateStepbackTask(ctx context.Context, projectID string, buildVariantName string, taskName string) (bool, error)
	DefaultSectionToRepo(ctx context.Context, projectID string, section ProjectSettingsSection) (*string, error)
	DeleteProject(ctx context.Context, projectID string) (bool, error)
	DetachProjectFromRepo(ctx context.Context, projectID string) (*model.APIProjectRef, error)
	ForceRepotrackerRun(ctx context.Context, projectID string) (bool, error)
	PromoteVarsToRepo(ctx context.Context, projectID string, varNames []string) (bool, error)
	RemoveFavoriteProject(ctx context.Context, identifier string) (*model.APIProjectRef, error)
	SaveProjectSettingsForSection(ctx context.Context, projectSettings *model.APIProjectSettings, section ProjectSettingsSection) (*model.APIProjectSettings, error)
	SaveRepoSettingsForSection(ctx context.Context, repoSettings *model.APIProjectSettings, section ProjectSettingsSection) (*model.APIProjectSettings, error)
	AttachVolumeToHost(ctx context.Context, volumeAndHost VolumeHost) (bool, error)
	DetachVolumeFromHost(ctx context.Context, volumeID string) (bool, error)
	EditSpawnHost(ctx context.Context, spawnHost *EditSpawnHostInput) (*model.APIHost, error)
	MigrateVolume(ctx context.Context, volumeID string, spawnHostInput *SpawnHostInput) (bool, error)
	SpawnHost(ctx context.Context, spawnHostInput *SpawnHostInput) (*model.APIHost, error)
	SpawnVolume(ctx context.Context, spawnVolumeInput SpawnVolumeInput) (bool, error)
	RemoveVolume(ctx context.Context, volumeID string) (bool, error)
	UpdateSpawnHostStatus(ctx context.Context, hostID string, action SpawnHostStatusActions) (*model.APIHost, error)
	UpdateVolume(ctx context.Context, updateVolumeInput UpdateVolumeInput) (bool, error)
	AbortTask(ctx context.Context, taskID string) (*model.APITask, error)
	OverrideTaskDependencies(ctx context.Context, taskID string) (*model.APITask, error)
	RestartTask(ctx context.Context, taskID string, failedOnly bool) (*model.APITask, error)
	ScheduleTasks(ctx context.Context, taskIds []string) ([]*model.APITask, error)
	SetTaskPriority(ctx context.Context, taskID string, priority int) (*model.APITask, error)
	UnscheduleTask(ctx context.Context, taskID string) (*model.APITask, error)
	ClearMySubscriptions(ctx context.Context) (int, error)
	CreatePublicKey(ctx context.Context, publicKeyInput PublicKeyInput) ([]*model.APIPubKey, error)
	DeleteSubscriptions(ctx context.Context, subscriptionIds []string) (int, error)
	RemovePublicKey(ctx context.Context, keyName string) ([]*model.APIPubKey, error)
	SaveSubscription(ctx context.Context, subscription model.APISubscription) (bool, error)
	UpdatePublicKey(ctx context.Context, targetKeyName string, updateInfo PublicKeyInput) ([]*model.APIPubKey, error)
	UpdateUserSettings(ctx context.Context, userSettings *model.APIUserSettings) (bool, error)
	RemoveItemFromCommitQueue(ctx context.Context, commitQueueID string, issue string) (*string, error)
	RestartVersions(ctx context.Context, versionID string, abort bool, versionsToRestart []*model1.VersionToRestart) ([]*model.APIVersion, error)
}
type PatchResolver interface {
	AuthorDisplayName(ctx context.Context, obj *model.APIPatch) (string, error)
	BaseTaskStatuses(ctx context.Context, obj *model.APIPatch) ([]string, error)
	Builds(ctx context.Context, obj *model.APIPatch) ([]*model.APIBuild, error)

	CommitQueuePosition(ctx context.Context, obj *model.APIPatch) (*int, error)

	Duration(ctx context.Context, obj *model.APIPatch) (*PatchDuration, error)

	PatchTriggerAliases(ctx context.Context, obj *model.APIPatch) ([]*model.APIPatchTriggerDefinition, error)
	Project(ctx context.Context, obj *model.APIPatch) (*PatchProject, error)

	ProjectIdentifier(ctx context.Context, obj *model.APIPatch) (string, error)
	ProjectMetadata(ctx context.Context, obj *model.APIPatch) (*model.APIProjectRef, error)

	TaskCount(ctx context.Context, obj *model.APIPatch) (*int, error)

	TaskStatuses(ctx context.Context, obj *model.APIPatch) ([]string, error)
	Time(ctx context.Context, obj *model.APIPatch) (*PatchTime, error)

	VersionFull(ctx context.Context, obj *model.APIPatch) (*model.APIVersion, error)
}
type PermissionsResolver interface {
	CanCreateDistro(ctx context.Context, obj *Permissions) (bool, error)
	CanCreateProject(ctx context.Context, obj *Permissions) (bool, error)
	DistroPermissions(ctx context.Context, obj *Permissions, options DistroPermissionsOptions) (*DistroPermissions, error)
}
type PlannerSettingsResolver interface {
	Version(ctx context.Context, obj *model.APIPlannerSettings) (PlannerVersion, error)
}
type PodResolver interface {
	Events(ctx context.Context, obj *model.APIPod, limit *int, page *int) (*PodEvents, error)

	Status(ctx context.Context, obj *model.APIPod) (string, error)
	Task(ctx context.Context, obj *model.APIPod) (*model.APITask, error)

	Type(ctx context.Context, obj *model.APIPod) (string, error)
}
type PodEventLogDataResolver interface {
	Task(ctx context.Context, obj *model.PodAPIEventData) (*model.APITask, error)
}
type ProjectResolver interface {
	IsFavorite(ctx context.Context, obj *model.APIProjectRef) (bool, error)

	Patches(ctx context.Context, obj *model.APIProjectRef, patchesInput PatchesInput) (*Patches, error)
}
type ProjectSettingsResolver interface {
	Aliases(ctx context.Context, obj *model.APIProjectSettings) ([]*model.APIProjectAlias, error)
	GithubWebhooksEnabled(ctx context.Context, obj *model.APIProjectSettings) (bool, error)

	Subscriptions(ctx context.Context, obj *model.APIProjectSettings) ([]*model.APISubscription, error)
	Vars(ctx context.Context, obj *model.APIProjectSettings) (*model.APIProjectVars, error)
}
type ProjectVarsResolver interface {
	AdminOnlyVars(ctx context.Context, obj *model.APIProjectVars) ([]string, error)
	PrivateVars(ctx context.Context, obj *model.APIProjectVars) ([]string, error)
}
type QueryResolver interface {
	BbGetCreatedTickets(ctx context.Context, taskID string) ([]*thirdparty.JiraTicket, error)
	BuildBaron(ctx context.Context, taskID string, execution int) (*BuildBaron, error)
	AwsRegions(ctx context.Context) ([]string, error)
	ClientConfig(ctx context.Context) (*model.APIClientConfig, error)
	InstanceTypes(ctx context.Context) ([]string, error)
	SpruceConfig(ctx context.Context) (*model.APIAdminSettings, error)
	SubnetAvailabilityZones(ctx context.Context) ([]string, error)
	Distro(ctx context.Context, distroID string) (*model.APIDistro, error)
	DistroEvents(ctx context.Context, opts DistroEventsInput) (*DistroEventsPayload, error)
	Distros(ctx context.Context, onlySpawnable bool) ([]*model.APIDistro, error)
	DistroTaskQueue(ctx context.Context, distroID string) ([]*model.APITaskQueueItem, error)
	Host(ctx context.Context, hostID string) (*model.APIHost, error)
	HostEvents(ctx context.Context, hostID string, hostTag *string, limit *int, page *int) (*HostEvents, error)
	Hosts(ctx context.Context, hostID *string, distroID *string, currentTaskID *string, statuses []string, startedBy *string, sortBy *HostSortBy, sortDir *SortDirection, page *int, limit *int) (*HostsResponse, error)
	TaskQueueDistros(ctx context.Context) ([]*TaskQueueDistro, error)
	Pod(ctx context.Context, podID string) (*model.APIPod, error)
	Patch(ctx context.Context, id string) (*model.APIPatch, error)
	GithubProjectConflicts(ctx context.Context, projectID string) (*model1.GithubProjectConflicts, error)
	Project(ctx context.Context, projectIdentifier string) (*model.APIProjectRef, error)
	Projects(ctx context.Context) ([]*GroupedProjects, error)
	ProjectEvents(ctx context.Context, identifier string, limit *int, before *time.Time) (*ProjectEvents, error)
	ProjectSettings(ctx context.Context, identifier string) (*model.APIProjectSettings, error)
	RepoEvents(ctx context.Context, id string, limit *int, before *time.Time) (*ProjectEvents, error)
	RepoSettings(ctx context.Context, id string) (*model.APIProjectSettings, error)
	ViewableProjectRefs(ctx context.Context) ([]*GroupedProjects, error)
	MyHosts(ctx context.Context) ([]*model.APIHost, error)
	MyVolumes(ctx context.Context) ([]*model.APIVolume, error)
	LogkeeperBuildMetadata(ctx context.Context, buildID string) (*plank.Build, error)
	Task(ctx context.Context, taskID string, execution *int) (*model.APITask, error)
	TaskAllExecutions(ctx context.Context, taskID string) ([]*model.APITask, error)
	TaskTestSample(ctx context.Context, tasks []string, filters []*TestFilter) ([]*TaskTestResultSample, error)
	MyPublicKeys(ctx context.Context) ([]*model.APIPubKey, error)
	User(ctx context.Context, userID *string) (*model.APIDBUser, error)
	UserConfig(ctx context.Context) (*UserConfig, error)
	UserSettings(ctx context.Context) (*model.APIUserSettings, error)
	CommitQueue(ctx context.Context, projectIdentifier string) (*model.APICommitQueue, error)
	BuildVariantsForTaskName(ctx context.Context, projectIdentifier string, taskName string) ([]*task.BuildVariantTuple, error)
	MainlineCommits(ctx context.Context, options MainlineCommitsOptions, buildVariantOptions *BuildVariantOptions) (*MainlineCommits, error)
	TaskNamesForBuildVariant(ctx context.Context, projectIdentifier string, buildVariant string) ([]string, error)
	HasVersion(ctx context.Context, id string) (bool, error)
	Version(ctx context.Context, id string) (*model.APIVersion, error)
}
type RepoSettingsResolver interface {
	Aliases(ctx context.Context, obj *model.APIProjectSettings) ([]*model.APIProjectAlias, error)
	GithubWebhooksEnabled(ctx context.Context, obj *model.APIProjectSettings) (bool, error)

	Subscriptions(ctx context.Context, obj *model.APIProjectSettings) ([]*model.APISubscription, error)
	Vars(ctx context.Context, obj *model.APIProjectSettings) (*model.APIProjectVars, error)
}
type SubscriberWrapperResolver interface {
	Subscriber(ctx context.Context, obj *model.APISubscriber) (*Subscriber, error)
}
type TaskResolver interface {
	AbortInfo(ctx context.Context, obj *model.APITask) (*AbortInfo, error)

	Ami(ctx context.Context, obj *model.APITask) (*string, error)
	Annotation(ctx context.Context, obj *model.APITask) (*model.APITaskAnnotation, error)
	BaseStatus(ctx context.Context, obj *model.APITask) (*string, error)
	BaseTask(ctx context.Context, obj *model.APITask) (*model.APITask, error)

	BuildVariantDisplayName(ctx context.Context, obj *model.APITask) (*string, error)
	CanAbort(ctx context.Context, obj *model.APITask) (bool, error)
	CanDisable(ctx context.Context, obj *model.APITask) (bool, error)
	CanModifyAnnotation(ctx context.Context, obj *model.APITask) (bool, error)
	CanOverrideDependencies(ctx context.Context, obj *model.APITask) (bool, error)
	CanRestart(ctx context.Context, obj *model.APITask) (bool, error)
	CanSchedule(ctx context.Context, obj *model.APITask) (bool, error)
	CanSetPriority(ctx context.Context, obj *model.APITask) (bool, error)

	CanUnschedule(ctx context.Context, obj *model.APITask) (bool, error)

	DependsOn(ctx context.Context, obj *model.APITask) ([]*Dependency, error)

	DisplayTask(ctx context.Context, obj *model.APITask) (*model.APITask, error)

	EstimatedStart(ctx context.Context, obj *model.APITask) (*model.APIDuration, error)

	ExecutionTasksFull(ctx context.Context, obj *model.APITask) ([]*model.APITask, error)

	FailedTestCount(ctx context.Context, obj *model.APITask) (int, error)

	GeneratedByName(ctx context.Context, obj *model.APITask) (*string, error)

	IsPerfPluginEnabled(ctx context.Context, obj *model.APITask) (bool, error)
	LatestExecution(ctx context.Context, obj *model.APITask) (int, error)

	MinQueuePosition(ctx context.Context, obj *model.APITask) (int, error)

	Patch(ctx context.Context, obj *model.APITask) (*model.APIPatch, error)
	PatchNumber(ctx context.Context, obj *model.APITask) (*int, error)
	Pod(ctx context.Context, obj *model.APITask) (*model.APIPod, error)

	Project(ctx context.Context, obj *model.APITask) (*model.APIProjectRef, error)

	ProjectIdentifier(ctx context.Context, obj *model.APITask) (*string, error)

	SpawnHostLink(ctx context.Context, obj *model.APITask) (*string, error)

	Status(ctx context.Context, obj *model.APITask) (string, error)
	TaskFiles(ctx context.Context, obj *model.APITask) (*TaskFiles, error)

	TaskLogs(ctx context.Context, obj *model.APITask) (*TaskLogs, error)
	Tests(ctx context.Context, obj *model.APITask, opts *TestFilterOptions) (*TaskTestResult, error)

	TotalTestCount(ctx context.Context, obj *model.APITask) (int, error)
	VersionMetadata(ctx context.Context, obj *model.APITask) (*model.APIVersion, error)
}
type TaskContainerCreationOptsResolver interface {
	Os(ctx context.Context, obj *model.APIPodTaskContainerCreationOptions) (string, error)
	Arch(ctx context.Context, obj *model.APIPodTaskContainerCreationOptions) (string, error)
}
type TaskLogsResolver interface {
	AgentLogs(ctx context.Context, obj *TaskLogs) ([]*apimodels.LogMessage, error)
	AllLogs(ctx context.Context, obj *TaskLogs) ([]*apimodels.LogMessage, error)

	EventLogs(ctx context.Context, obj *TaskLogs) ([]*model.TaskAPIEventLogEntry, error)

	SystemLogs(ctx context.Context, obj *TaskLogs) ([]*apimodels.LogMessage, error)

	TaskLogs(ctx context.Context, obj *TaskLogs) ([]*apimodels.LogMessage, error)
}
type TaskQueueItemResolver interface {
	Requester(ctx context.Context, obj *model.APITaskQueueItem) (TaskQueueItemType, error)
}
type TicketFieldsResolver interface {
	AssignedTeam(ctx context.Context, obj *thirdparty.TicketFields) (*string, error)
	AssigneeDisplayName(ctx context.Context, obj *thirdparty.TicketFields) (*string, error)

	ResolutionName(ctx context.Context, obj *thirdparty.TicketFields) (*string, error)
}
type UserResolver interface {
	Patches(ctx context.Context, obj *model.APIDBUser, patchesInput PatchesInput) (*Patches, error)
	Permissions(ctx context.Context, obj *model.APIDBUser) (*Permissions, error)
	Subscriptions(ctx context.Context, obj *model.APIDBUser) ([]*model.APISubscription, error)
}
type VersionResolver interface {
	BaseTaskStatuses(ctx context.Context, obj *model.APIVersion) ([]string, error)
	BaseVersion(ctx context.Context, obj *model.APIVersion) (*model.APIVersion, error)

	BuildVariants(ctx context.Context, obj *model.APIVersion, options BuildVariantOptions) ([]*GroupedBuildVariant, error)
	BuildVariantStats(ctx context.Context, obj *model.APIVersion, options BuildVariantOptions) ([]*task.GroupedTaskStatusCount, error)
	ChildVersions(ctx context.Context, obj *model.APIVersion) ([]*model.APIVersion, error)

	ExternalLinksForMetadata(ctx context.Context, obj *model.APIVersion) ([]*ExternalLinkForMetadata, error)

	IsPatch(ctx context.Context, obj *model.APIVersion) (bool, error)
	Manifest(ctx context.Context, obj *model.APIVersion) (*Manifest, error)

	Patch(ctx context.Context, obj *model.APIVersion) (*model.APIPatch, error)
	PreviousVersion(ctx context.Context, obj *model.APIVersion) (*model.APIVersion, error)

	ProjectMetadata(ctx context.Context, obj *model.APIVersion) (*model.APIProjectRef, error)

	Status(ctx context.Context, obj *model.APIVersion) (string, error)
	TaskCount(ctx context.Context, obj *model.APIVersion) (*int, error)
	Tasks(ctx context.Context, obj *model.APIVersion, options TaskFilterOptions) (*VersionTasks, error)
	TaskStatuses(ctx context.Context, obj *model.APIVersion) ([]string, error)
	TaskStatusStats(ctx context.Context, obj *model.APIVersion, options BuildVariantOptions) (*task.TaskStats, error)
	UpstreamProject(ctx context.Context, obj *model.APIVersion) (*UpstreamProject, error)
	VersionTiming(ctx context.Context, obj *model.APIVersion) (*VersionTiming, error)
	Warnings(ctx context.Context, obj *model.APIVersion) ([]string, error)
}
type VolumeResolver interface {
	Host(ctx context.Context, obj *model.APIVolume) (*model.APIHost, error)
}

type DispatcherSettingsInputResolver interface {
	Version(ctx context.Context, obj *model.APIDispatcherSettings, data DispatcherVersion) error
}
type DistroInputResolver interface {
	CloneMethod(ctx context.Context, obj *model.APIDistro, data CloneMethod) error

	Provider(ctx context.Context, obj *model.APIDistro, data Provider) error
	ProviderSettingsList(ctx context.Context, obj *model.APIDistro, data []map[string]interface{}) error
}
type FinderSettingsInputResolver interface {
	Version(ctx context.Context, obj *model.APIFinderSettings, data FinderVersion) error
}
type HostAllocatorSettingsInputResolver interface {
	AcceptableHostIdleTime(ctx context.Context, obj *model.APIHostAllocatorSettings, data int) error
}
type PlannerSettingsInputResolver interface {
	TargetTime(ctx context.Context, obj *model.APIPlannerSettings, data int) error
	Version(ctx context.Context, obj *model.APIPlannerSettings, data PlannerVersion) error
}
type SubscriberInputResolver interface {
	Target(ctx context.Context, obj *model.APISubscriber, data string) error
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e}
	_ = ec
	switch typeName + "." + field {

	case "AWSConfig.maxVolumeSizePerUser":
		if e.complexity.AWSConfig.MaxVolumeSizePerUser == nil {
			break
		}

		return e.complexity.AWSConfig.MaxVolumeSizePerUser(childComplexity), true

	case "AWSConfig.pod":
		if e.complexity.AWSConfig.Pod == nil {
			break
		}

		return e.complexity.AWSConfig.Pod(childComplexity), true

	case "AWSPodConfig.ecs":
		if e.complexity.AWSPodConfig.ECS == nil {
			break
		}

		return e.complexity.AWSPodConfig.ECS(childComplexity), true

	case "AbortInfo.buildVariantDisplayName":
		if e.complexity.AbortInfo.BuildVariantDisplayName == nil {
			break
		}

		return e.complexity.AbortInfo.BuildVariantDisplayName(childComplexity), true

	case "AbortInfo.newVersion":
		if e.complexity.AbortInfo.NewVersion == nil {
			break
		}

		return e.complexity.AbortInfo.NewVersion(childComplexity), true

	case "AbortInfo.prClosed":
		if e.complexity.AbortInfo.PrClosed == nil {
			break
		}

		return e.complexity.AbortInfo.PrClosed(childComplexity), true

	case "AbortInfo.taskDisplayName":
		if e.complexity.AbortInfo.TaskDisplayName == nil {
			break
		}

		return e.complexity.AbortInfo.TaskDisplayName(childComplexity), true

	case "AbortInfo.taskID":
		if e.complexity.AbortInfo.TaskID == nil {
			break
		}

		return e.complexity.AbortInfo.TaskID(childComplexity), true

	case "AbortInfo.user":
		if e.complexity.AbortInfo.User == nil {
			break
		}

		return e.complexity.AbortInfo.User(childComplexity), true

	case "Annotation.createdIssues":
		if e.complexity.Annotation.CreatedIssues == nil {
			break
		}

		return e.complexity.Annotation.CreatedIssues(childComplexity), true

	case "Annotation.id":
		if e.complexity.Annotation.Id == nil {
			break
		}

		return e.complexity.Annotation.Id(childComplexity), true

	case "Annotation.issues":
		if e.complexity.Annotation.Issues == nil {
			break
		}

		return e.complexity.Annotation.Issues(childComplexity), true

	case "Annotation.metadataLinks":
		if e.complexity.Annotation.MetadataLinks == nil {
			break
		}

		return e.complexity.Annotation.MetadataLinks(childComplexity), true

	case "Annotation.note":
		if e.complexity.Annotation.Note == nil {
			break
		}

		return e.complexity.Annotation.Note(childComplexity), true

	case "Annotation.suspectedIssues":
		if e.complexity.Annotation.SuspectedIssues == nil {
			break
		}

		return e.complexity.Annotation.SuspectedIssues(childComplexity), true

	case "Annotation.taskExecution":
		if e.complexity.Annotation.TaskExecution == nil {
			break
		}

		return e.complexity.Annotation.TaskExecution(childComplexity), true

	case "Annotation.taskId":
		if e.complexity.Annotation.TaskId == nil {
			break
		}

		return e.complexity.Annotation.TaskId(childComplexity), true

	case "Annotation.webhookConfigured":
		if e.complexity.Annotation.WebhookConfigured == nil {
			break
		}

		return e.complexity.Annotation.WebhookConfigured(childComplexity), true

	case "BootstrapSettings.clientDir":
		if e.complexity.BootstrapSettings.ClientDir == nil {
			break
		}

		return e.complexity.BootstrapSettings.ClientDir(childComplexity), true

	case "BootstrapSettings.communication":
		if e.complexity.BootstrapSettings.Communication == nil {
			break
		}

		return e.complexity.BootstrapSettings.Communication(childComplexity), true

	case "BootstrapSettings.env":
		if e.complexity.BootstrapSettings.Env == nil {
			break
		}

		return e.complexity.BootstrapSettings.Env(childComplexity), true

	case "BootstrapSettings.jasperBinaryDir":
		if e.complexity.BootstrapSettings.JasperBinaryDir == nil {
			break
		}

		return e.complexity.BootstrapSettings.JasperBinaryDir(childComplexity), true

	case "BootstrapSettings.jasperCredentialsPath":
		if e.complexity.BootstrapSettings.JasperCredentialsPath == nil {
			break
		}

		return e.complexity.BootstrapSettings.JasperCredentialsPath(childComplexity), true

	case "BootstrapSettings.method":
		if e.complexity.BootstrapSettings.Method == nil {
			break
		}

		return e.complexity.BootstrapSettings.Method(childComplexity), true

	case "BootstrapSettings.preconditionScripts":
		if e.complexity.BootstrapSettings.PreconditionScripts == nil {
			break
		}

		return e.complexity.BootstrapSettings.PreconditionScripts(childComplexity), true

	case "BootstrapSettings.resourceLimits":
		if e.complexity.BootstrapSettings.ResourceLimits == nil {
			break
		}

		return e.complexity.BootstrapSettings.ResourceLimits(childComplexity), true

	case "BootstrapSettings.rootDir":
		if e.complexity.BootstrapSettings.RootDir == nil {
			break
		}

		return e.complexity.BootstrapSettings.RootDir(childComplexity), true

	case "BootstrapSettings.serviceUser":
		if e.complexity.BootstrapSettings.ServiceUser == nil {
			break
		}

		return e.complexity.BootstrapSettings.ServiceUser(childComplexity), true

	case "BootstrapSettings.shellPath":
		if e.complexity.BootstrapSettings.ShellPath == nil {
			break
		}

		return e.complexity.BootstrapSettings.ShellPath(childComplexity), true

	case "Build.actualMakespan":
		if e.complexity.Build.ActualMakespan == nil {
			break
		}

		return e.complexity.Build.ActualMakespan(childComplexity), true

	case "Build.buildVariant":
		if e.complexity.Build.BuildVariant == nil {
			break
		}

		return e.complexity.Build.BuildVariant(childComplexity), true

	case "Build.id":
		if e.complexity.Build.Id == nil {
			break
		}

		return e.complexity.Build.Id(childComplexity), true

	case "Build.predictedMakespan":
		if e.complexity.Build.PredictedMakespan == nil {
			break
		}

		return e.complexity.Build.PredictedMakespan(childComplexity), true

	case "Build.status":
		if e.complexity.Build.Status == nil {
			break
		}

		return e.complexity.Build.Status(childComplexity), true

	case "BuildBaron.bbTicketCreationDefined":
		if e.complexity.BuildBaron.BbTicketCreationDefined == nil {
			break
		}

		return e.complexity.BuildBaron.BbTicketCreationDefined(childComplexity), true

	case "BuildBaron.buildBaronConfigured":
		if e.complexity.BuildBaron.BuildBaronConfigured == nil {
			break
		}

		return e.complexity.BuildBaron.BuildBaronConfigured(childComplexity), true

	case "BuildBaron.searchReturnInfo":
		if e.complexity.BuildBaron.SearchReturnInfo == nil {
			break
		}

		return e.complexity.BuildBaron.SearchReturnInfo(childComplexity), true

	case "BuildBaronSettings.bfSuggestionFeaturesURL":
		if e.complexity.BuildBaronSettings.BFSuggestionFeaturesURL == nil {
			break
		}

		return e.complexity.BuildBaronSettings.BFSuggestionFeaturesURL(childComplexity), true

	case "BuildBaronSettings.bfSuggestionPassword":
		if e.complexity.BuildBaronSettings.BFSuggestionPassword == nil {
			break
		}

		return e.complexity.BuildBaronSettings.BFSuggestionPassword(childComplexity), true

	case "BuildBaronSettings.bfSuggestionServer":
		if e.complexity.BuildBaronSettings.BFSuggestionServer == nil {
			break
		}

		return e.complexity.BuildBaronSettings.BFSuggestionServer(childComplexity), true

	case "BuildBaronSettings.bfSuggestionTimeoutSecs":
		if e.complexity.BuildBaronSettings.BFSuggestionTimeoutSecs == nil {
			break
		}

		return e.complexity.BuildBaronSettings.BFSuggestionTimeoutSecs(childComplexity), true

	case "BuildBaronSettings.bfSuggestionUsername":
		if e.complexity.BuildBaronSettings.BFSuggestionUsername == nil {
			break
		}

		return e.complexity.BuildBaronSettings.BFSuggestionUsername(childComplexity), true

	case "BuildBaronSettings.ticketCreateProject":
		if e.complexity.BuildBaronSettings.TicketCreateProject == nil {
			break
		}

		return e.complexity.BuildBaronSettings.TicketCreateProject(childComplexity), true

	case "BuildBaronSettings.ticketSearchProjects":
		if e.complexity.BuildBaronSettings.TicketSearchProjects == nil {
			break
		}

		return e.complexity.BuildBaronSettings.TicketSearchProjects(childComplexity), true

	case "BuildVariantTuple.buildVariant":
		if e.complexity.BuildVariantTuple.BuildVariant == nil {
			break
		}

		return e.complexity.BuildVariantTuple.BuildVariant(childComplexity), true

	case "BuildVariantTuple.displayName":
		if e.complexity.BuildVariantTuple.DisplayName == nil {
			break
		}

		return e.complexity.BuildVariantTuple.DisplayName(childComplexity), true

	case "ChildPatchAlias.alias":
		if e.complexity.ChildPatchAlias.Alias == nil {
			break
		}

		return e.complexity.ChildPatchAlias.Alias(childComplexity), true

	case "ChildPatchAlias.patchId":
		if e.complexity.ChildPatchAlias.PatchID == nil {
			break
		}

		return e.complexity.ChildPatchAlias.PatchID(childComplexity), true

	case "ClientBinary.arch":
		if e.complexity.ClientBinary.Arch == nil {
			break
		}

		return e.complexity.ClientBinary.Arch(childComplexity), true

	case "ClientBinary.displayName":
		if e.complexity.ClientBinary.DisplayName == nil {
			break
		}

		return e.complexity.ClientBinary.DisplayName(childComplexity), true

	case "ClientBinary.os":
		if e.complexity.ClientBinary.OS == nil {
			break
		}

		return e.complexity.ClientBinary.OS(childComplexity), true

	case "ClientBinary.url":
		if e.complexity.ClientBinary.URL == nil {
			break
		}

		return e.complexity.ClientBinary.URL(childComplexity), true

	case "ClientConfig.clientBinaries":
		if e.complexity.ClientConfig.ClientBinaries == nil {
			break
		}

		return e.complexity.ClientConfig.ClientBinaries(childComplexity), true

	case "ClientConfig.latestRevision":
		if e.complexity.ClientConfig.LatestRevision == nil {
			break
		}

		return e.complexity.ClientConfig.LatestRevision(childComplexity), true

	case "CloudProviderConfig.aws":
		if e.complexity.CloudProviderConfig.AWS == nil {
			break
		}

		return e.complexity.CloudProviderConfig.AWS(childComplexity), true

	case "CommitQueue.message":
		if e.complexity.CommitQueue.Message == nil {
			break
		}

		return e.complexity.CommitQueue.Message(childComplexity), true

	case "CommitQueue.owner":
		if e.complexity.CommitQueue.Owner == nil {
			break
		}

		return e.complexity.CommitQueue.Owner(childComplexity), true

	case "CommitQueue.projectId":
		if e.complexity.CommitQueue.ProjectID == nil {
			break
		}

		return e.complexity.CommitQueue.ProjectID(childComplexity), true

	case "CommitQueue.queue":
		if e.complexity.CommitQueue.Queue == nil {
			break
		}

		return e.complexity.CommitQueue.Queue(childComplexity), true

	case "CommitQueue.repo":
		if e.complexity.CommitQueue.Repo == nil {
			break
		}

		return e.complexity.CommitQueue.Repo(childComplexity), true

	case "CommitQueueItem.enqueueTime":
		if e.complexity.CommitQueueItem.EnqueueTime == nil {
			break
		}

		return e.complexity.CommitQueueItem.EnqueueTime(childComplexity), true

	case "CommitQueueItem.issue":
		if e.complexity.CommitQueueItem.Issue == nil {
			break
		}

		return e.complexity.CommitQueueItem.Issue(childComplexity), true

	case "CommitQueueItem.modules":
		if e.complexity.CommitQueueItem.Modules == nil {
			break
		}

		return e.complexity.CommitQueueItem.Modules(childComplexity), true

	case "CommitQueueItem.patch":
		if e.complexity.CommitQueueItem.Patch == nil {
			break
		}

		return e.complexity.CommitQueueItem.Patch(childComplexity), true

	case "CommitQueueItem.source":
		if e.complexity.CommitQueueItem.Source == nil {
			break
		}

		return e.complexity.CommitQueueItem.Source(childComplexity), true

	case "CommitQueueItem.version":
		if e.complexity.CommitQueueItem.Version == nil {
			break
		}

		return e.complexity.CommitQueueItem.Version(childComplexity), true

	case "CommitQueueParams.enabled":
		if e.complexity.CommitQueueParams.Enabled == nil {
			break
		}

		return e.complexity.CommitQueueParams.Enabled(childComplexity), true

	case "CommitQueueParams.mergeMethod":
		if e.complexity.CommitQueueParams.MergeMethod == nil {
			break
		}

		return e.complexity.CommitQueueParams.MergeMethod(childComplexity), true

	case "CommitQueueParams.mergeQueue":
		if e.complexity.CommitQueueParams.MergeQueue == nil {
			break
		}

		return e.complexity.CommitQueueParams.MergeQueue(childComplexity), true

	case "CommitQueueParams.message":
		if e.complexity.CommitQueueParams.Message == nil {
			break
		}

		return e.complexity.CommitQueueParams.Message(childComplexity), true

	case "ContainerResources.cpu":
		if e.complexity.ContainerResources.CPU == nil {
			break
		}

		return e.complexity.ContainerResources.CPU(childComplexity), true

	case "ContainerResources.memoryMb":
		if e.complexity.ContainerResources.MemoryMB == nil {
			break
		}

		return e.complexity.ContainerResources.MemoryMB(childComplexity), true

	case "ContainerResources.name":
		if e.complexity.ContainerResources.Name == nil {
			break
		}

		return e.complexity.ContainerResources.Name(childComplexity), true

	case "DeleteDistroPayload.deletedDistroId":
		if e.complexity.DeleteDistroPayload.DeletedDistroID == nil {
			break
		}

		return e.complexity.DeleteDistroPayload.DeletedDistroID(childComplexity), true

	case "Dependency.buildVariant":
		if e.complexity.Dependency.BuildVariant == nil {
			break
		}

		return e.complexity.Dependency.BuildVariant(childComplexity), true

	case "Dependency.metStatus":
		if e.complexity.Dependency.MetStatus == nil {
			break
		}

		return e.complexity.Dependency.MetStatus(childComplexity), true

	case "Dependency.name":
		if e.complexity.Dependency.Name == nil {
			break
		}

		return e.complexity.Dependency.Name(childComplexity), true

	case "Dependency.requiredStatus":
		if e.complexity.Dependency.RequiredStatus == nil {
			break
		}

		return e.complexity.Dependency.RequiredStatus(childComplexity), true

	case "Dependency.taskId":
		if e.complexity.Dependency.TaskID == nil {
			break
		}

		return e.complexity.Dependency.TaskID(childComplexity), true

	case "DispatcherSettings.version":
		if e.complexity.DispatcherSettings.Version == nil {
			break
		}

		return e.complexity.DispatcherSettings.Version(childComplexity), true

	case "Distro.aliases":
		if e.complexity.Distro.Aliases == nil {
			break
		}

		return e.complexity.Distro.Aliases(childComplexity), true

	case "Distro.arch":
		if e.complexity.Distro.Arch == nil {
			break
		}

		return e.complexity.Distro.Arch(childComplexity), true

	case "Distro.authorizedKeysFile":
		if e.complexity.Distro.AuthorizedKeysFile == nil {
			break
		}

		return e.complexity.Distro.AuthorizedKeysFile(childComplexity), true

	case "Distro.bootstrapSettings":
		if e.complexity.Distro.BootstrapSettings == nil {
			break
		}

		return e.complexity.Distro.BootstrapSettings(childComplexity), true

	case "Distro.cloneMethod":
		if e.complexity.Distro.CloneMethod == nil {
			break
		}

		return e.complexity.Distro.CloneMethod(childComplexity), true

	case "Distro.containerPool":
		if e.complexity.Distro.ContainerPool == nil {
			break
		}

		return e.complexity.Distro.ContainerPool(childComplexity), true

	case "Distro.disableShallowClone":
		if e.complexity.Distro.DisableShallowClone == nil {
			break
		}

		return e.complexity.Distro.DisableShallowClone(childComplexity), true

	case "Distro.disabled":
		if e.complexity.Distro.Disabled == nil {
			break
		}

		return e.complexity.Distro.Disabled(childComplexity), true

	case "Distro.dispatcherSettings":
		if e.complexity.Distro.DispatcherSettings == nil {
			break
		}

		return e.complexity.Distro.DispatcherSettings(childComplexity), true

	case "Distro.expansions":
		if e.complexity.Distro.Expansions == nil {
			break
		}

		return e.complexity.Distro.Expansions(childComplexity), true

	case "Distro.finderSettings":
		if e.complexity.Distro.FinderSettings == nil {
			break
		}

		return e.complexity.Distro.FinderSettings(childComplexity), true

	case "Distro.homeVolumeSettings":
		if e.complexity.Distro.HomeVolumeSettings == nil {
			break
		}

		return e.complexity.Distro.HomeVolumeSettings(childComplexity), true

	case "Distro.hostAllocatorSettings":
		if e.complexity.Distro.HostAllocatorSettings == nil {
			break
		}

		return e.complexity.Distro.HostAllocatorSettings(childComplexity), true

	case "Distro.iceCreamSettings":
		if e.complexity.Distro.IcecreamSettings == nil {
			break
		}

		return e.complexity.Distro.IcecreamSettings(childComplexity), true

	case "Distro.isCluster":
		if e.complexity.Distro.IsCluster == nil {
			break
		}

		return e.complexity.Distro.IsCluster(childComplexity), true

	case "Distro.isVirtualWorkStation":
		if e.complexity.Distro.IsVirtualWorkstation == nil {
			break
		}

		return e.complexity.Distro.IsVirtualWorkstation(childComplexity), true

	case "Distro.name":
		if e.complexity.Distro.Name == nil {
			break
		}

		return e.complexity.Distro.Name(childComplexity), true

	case "Distro.note":
		if e.complexity.Distro.Note == nil {
			break
		}

		return e.complexity.Distro.Note(childComplexity), true

	case "Distro.plannerSettings":
		if e.complexity.Distro.PlannerSettings == nil {
			break
		}

		return e.complexity.Distro.PlannerSettings(childComplexity), true

	case "Distro.provider":
		if e.complexity.Distro.Provider == nil {
			break
		}

		return e.complexity.Distro.Provider(childComplexity), true

	case "Distro.providerSettingsList":
		if e.complexity.Distro.ProviderSettingsList == nil {
			break
		}

		return e.complexity.Distro.ProviderSettingsList(childComplexity), true

	case "Distro.sshKey":
		if e.complexity.Distro.SSHKey == nil {
			break
		}

		return e.complexity.Distro.SSHKey(childComplexity), true

	case "Distro.sshOptions":
		if e.complexity.Distro.SSHOptions == nil {
			break
		}

		return e.complexity.Distro.SSHOptions(childComplexity), true

	case "Distro.setup":
		if e.complexity.Distro.Setup == nil {
			break
		}

		return e.complexity.Distro.Setup(childComplexity), true

	case "Distro.setupAsSudo":
		if e.complexity.Distro.SetupAsSudo == nil {
			break
		}

		return e.complexity.Distro.SetupAsSudo(childComplexity), true

	case "Distro.user":
		if e.complexity.Distro.User == nil {
			break
		}

		return e.complexity.Distro.User(childComplexity), true

	case "Distro.userSpawnAllowed":
		if e.complexity.Distro.UserSpawnAllowed == nil {
			break
		}

		return e.complexity.Distro.UserSpawnAllowed(childComplexity), true

	case "Distro.validProjects":
		if e.complexity.Distro.ValidProjects == nil {
			break
		}

		return e.complexity.Distro.ValidProjects(childComplexity), true

	case "Distro.workDir":
		if e.complexity.Distro.WorkDir == nil {
			break
		}

		return e.complexity.Distro.WorkDir(childComplexity), true

	case "DistroEvent.after":
		if e.complexity.DistroEvent.After == nil {
			break
		}

		return e.complexity.DistroEvent.After(childComplexity), true

	case "DistroEvent.before":
		if e.complexity.DistroEvent.Before == nil {
			break
		}

		return e.complexity.DistroEvent.Before(childComplexity), true

	case "DistroEvent.data":
		if e.complexity.DistroEvent.Data == nil {
			break
		}

		return e.complexity.DistroEvent.Data(childComplexity), true

	case "DistroEvent.timestamp":
		if e.complexity.DistroEvent.Timestamp == nil {
			break
		}

		return e.complexity.DistroEvent.Timestamp(childComplexity), true

	case "DistroEvent.user":
		if e.complexity.DistroEvent.User == nil {
			break
		}

		return e.complexity.DistroEvent.User(childComplexity), true

	case "DistroEventsPayload.count":
		if e.complexity.DistroEventsPayload.Count == nil {
			break
		}

		return e.complexity.DistroEventsPayload.Count(childComplexity), true

	case "DistroEventsPayload.eventLogEntries":
		if e.complexity.DistroEventsPayload.EventLogEntries == nil {
			break
		}

		return e.complexity.DistroEventsPayload.EventLogEntries(childComplexity), true

	case "DistroInfo.bootstrapMethod":
		if e.complexity.DistroInfo.BootstrapMethod == nil {
			break
		}

		return e.complexity.DistroInfo.BootstrapMethod(childComplexity), true

	case "DistroInfo.id":
		if e.complexity.DistroInfo.Id == nil {
			break
		}

		return e.complexity.DistroInfo.Id(childComplexity), true

	case "DistroInfo.isVirtualWorkStation":
		if e.complexity.DistroInfo.IsVirtualWorkstation == nil {
			break
		}

		return e.complexity.DistroInfo.IsVirtualWorkstation(childComplexity), true

	case "DistroInfo.isWindows":
		if e.complexity.DistroInfo.IsWindows == nil {
			break
		}

		return e.complexity.DistroInfo.IsWindows(childComplexity), true

	case "DistroInfo.user":
		if e.complexity.DistroInfo.User == nil {
			break
		}

		return e.complexity.DistroInfo.User(childComplexity), true

	case "DistroInfo.workDir":
		if e.complexity.DistroInfo.WorkDir == nil {
			break
		}

		return e.complexity.DistroInfo.WorkDir(childComplexity), true

	case "DistroPermissions.admin":
		if e.complexity.DistroPermissions.Admin == nil {
			break
		}

		return e.complexity.DistroPermissions.Admin(childComplexity), true

	case "DistroPermissions.edit":
		if e.complexity.DistroPermissions.Edit == nil {
			break
		}

		return e.complexity.DistroPermissions.Edit(childComplexity), true

	case "DistroPermissions.view":
		if e.complexity.DistroPermissions.View == nil {
			break
		}

		return e.complexity.DistroPermissions.View(childComplexity), true

	case "ECSConfig.maxCPU":
		if e.complexity.ECSConfig.MaxCPU == nil {
			break
		}

		return e.complexity.ECSConfig.MaxCPU(childComplexity), true

	case "ECSConfig.maxMemoryMb":
		if e.complexity.ECSConfig.MaxMemoryMB == nil {
			break
		}

		return e.complexity.ECSConfig.MaxMemoryMB(childComplexity), true

	case "EnvVar.key":
		if e.complexity.EnvVar.Key == nil {
			break
		}

		return e.complexity.EnvVar.Key(childComplexity), true

	case "EnvVar.value":
		if e.complexity.EnvVar.Value == nil {
			break
		}

		return e.complexity.EnvVar.Value(childComplexity), true

	case "Expansion.key":
		if e.complexity.Expansion.Key == nil {
			break
		}

		return e.complexity.Expansion.Key(childComplexity), true

	case "Expansion.value":
		if e.complexity.Expansion.Value == nil {
			break
		}

		return e.complexity.Expansion.Value(childComplexity), true

	case "ExternalLink.displayName":
		if e.complexity.ExternalLink.DisplayName == nil {
			break
		}

		return e.complexity.ExternalLink.DisplayName(childComplexity), true

	case "ExternalLink.requesters":
		if e.complexity.ExternalLink.Requesters == nil {
			break
		}

		return e.complexity.ExternalLink.Requesters(childComplexity), true

	case "ExternalLink.urlTemplate":
		if e.complexity.ExternalLink.URLTemplate == nil {
			break
		}

		return e.complexity.ExternalLink.URLTemplate(childComplexity), true

	case "ExternalLinkForMetadata.displayName":
		if e.complexity.ExternalLinkForMetadata.DisplayName == nil {
			break
		}

		return e.complexity.ExternalLinkForMetadata.DisplayName(childComplexity), true

	case "ExternalLinkForMetadata.url":
		if e.complexity.ExternalLinkForMetadata.URL == nil {
			break
		}

		return e.complexity.ExternalLinkForMetadata.URL(childComplexity), true

	case "File.link":
		if e.complexity.File.Link == nil {
			break
		}

		return e.complexity.File.Link(childComplexity), true

	case "File.name":
		if e.complexity.File.Name == nil {
			break
		}

		return e.complexity.File.Name(childComplexity), true

	case "File.visibility":
		if e.complexity.File.Visibility == nil {
			break
		}

		return e.complexity.File.Visibility(childComplexity), true

	case "FileDiff.additions":
		if e.complexity.FileDiff.Additions == nil {
			break
		}

		return e.complexity.FileDiff.Additions(childComplexity), true

	case "FileDiff.deletions":
		if e.complexity.FileDiff.Deletions == nil {
			break
		}

		return e.complexity.FileDiff.Deletions(childComplexity), true

	case "FileDiff.description":
		if e.complexity.FileDiff.Description == nil {
			break
		}

		return e.complexity.FileDiff.Description(childComplexity), true

	case "FileDiff.diffLink":
		if e.complexity.FileDiff.DiffLink == nil {
			break
		}

		return e.complexity.FileDiff.DiffLink(childComplexity), true

	case "FileDiff.fileName":
		if e.complexity.FileDiff.FileName == nil {
			break
		}

		return e.complexity.FileDiff.FileName(childComplexity), true

	case "FinderSettings.version":
		if e.complexity.FinderSettings.Version == nil {
			break
		}

		return e.complexity.FinderSettings.Version(childComplexity), true

	case "GeneralSubscription.id":
		if e.complexity.GeneralSubscription.ID == nil {
			break
		}

		return e.complexity.GeneralSubscription.ID(childComplexity), true

	case "GeneralSubscription.ownerType":
		if e.complexity.GeneralSubscription.OwnerType == nil {
			break
		}

		return e.complexity.GeneralSubscription.OwnerType(childComplexity), true

	case "GeneralSubscription.regexSelectors":
		if e.complexity.GeneralSubscription.RegexSelectors == nil {
			break
		}

		return e.complexity.GeneralSubscription.RegexSelectors(childComplexity), true

	case "GeneralSubscription.resourceType":
		if e.complexity.GeneralSubscription.ResourceType == nil {
			break
		}

		return e.complexity.GeneralSubscription.ResourceType(childComplexity), true

	case "GeneralSubscription.selectors":
		if e.complexity.GeneralSubscription.Selectors == nil {
			break
		}

		return e.complexity.GeneralSubscription.Selectors(childComplexity), true

	case "GeneralSubscription.subscriber":
		if e.complexity.GeneralSubscription.Subscriber == nil {
			break
		}

		return e.complexity.GeneralSubscription.Subscriber(childComplexity), true

	case "GeneralSubscription.trigger":
		if e.complexity.GeneralSubscription.Trigger == nil {
			break
		}

		return e.complexity.GeneralSubscription.Trigger(childComplexity), true

	case "GeneralSubscription.triggerData":
		if e.complexity.GeneralSubscription.TriggerData == nil {
			break
		}

		return e.complexity.GeneralSubscription.TriggerData(childComplexity), true

	case "GitTag.pusher":
		if e.complexity.GitTag.Pusher == nil {
			break
		}

		return e.complexity.GitTag.Pusher(childComplexity), true

	case "GitTag.tag":
		if e.complexity.GitTag.Tag == nil {
			break
		}

		return e.complexity.GitTag.Tag(childComplexity), true

	case "GithubCheckSubscriber.owner":
		if e.complexity.GithubCheckSubscriber.Owner == nil {
			break
		}

		return e.complexity.GithubCheckSubscriber.Owner(childComplexity), true

	case "GithubCheckSubscriber.ref":
		if e.complexity.GithubCheckSubscriber.Ref == nil {
			break
		}

		return e.complexity.GithubCheckSubscriber.Ref(childComplexity), true

	case "GithubCheckSubscriber.repo":
		if e.complexity.GithubCheckSubscriber.Repo == nil {
			break
		}

		return e.complexity.GithubCheckSubscriber.Repo(childComplexity), true

	case "GithubPRSubscriber.owner":
		if e.complexity.GithubPRSubscriber.Owner == nil {
			break
		}

		return e.complexity.GithubPRSubscriber.Owner(childComplexity), true

	case "GithubPRSubscriber.prNumber":
		if e.complexity.GithubPRSubscriber.PRNumber == nil {
			break
		}

		return e.complexity.GithubPRSubscriber.PRNumber(childComplexity), true

	case "GithubPRSubscriber.ref":
		if e.complexity.GithubPRSubscriber.Ref == nil {
			break
		}

		return e.complexity.GithubPRSubscriber.Ref(childComplexity), true

	case "GithubPRSubscriber.repo":
		if e.complexity.GithubPRSubscriber.Repo == nil {
			break
		}

		return e.complexity.GithubPRSubscriber.Repo(childComplexity), true

	case "GithubProjectConflicts.commitCheckIdentifiers":
		if e.complexity.GithubProjectConflicts.CommitCheckIdentifiers == nil {
			break
		}

		return e.complexity.GithubProjectConflicts.CommitCheckIdentifiers(childComplexity), true

	case "GithubProjectConflicts.commitQueueIdentifiers":
		if e.complexity.GithubProjectConflicts.CommitQueueIdentifiers == nil {
			break
		}

		return e.complexity.GithubProjectConflicts.CommitQueueIdentifiers(childComplexity), true

	case "GithubProjectConflicts.prTestingIdentifiers":
		if e.complexity.GithubProjectConflicts.PRTestingIdentifiers == nil {
			break
		}

		return e.complexity.GithubProjectConflicts.PRTestingIdentifiers(childComplexity), true

	case "GithubUser.lastKnownAs":
		if e.complexity.GithubUser.LastKnownAs == nil {
			break
		}

		return e.complexity.GithubUser.LastKnownAs(childComplexity), true

	case "GithubUser.uid":
		if e.complexity.GithubUser.UID == nil {
			break
		}

		return e.complexity.GithubUser.UID(childComplexity), true

	case "GroupedBuildVariant.displayName":
		if e.complexity.GroupedBuildVariant.DisplayName == nil {
			break
		}

		return e.complexity.GroupedBuildVariant.DisplayName(childComplexity), true

	case "GroupedBuildVariant.tasks":
		if e.complexity.GroupedBuildVariant.Tasks == nil {
			break
		}

		return e.complexity.GroupedBuildVariant.Tasks(childComplexity), true

	case "GroupedBuildVariant.variant":
		if e.complexity.GroupedBuildVariant.Variant == nil {
			break
		}

		return e.complexity.GroupedBuildVariant.Variant(childComplexity), true

	case "GroupedFiles.files":
		if e.complexity.GroupedFiles.Files == nil {
			break
		}

		return e.complexity.GroupedFiles.Files(childComplexity), true

	case "GroupedFiles.taskName":
		if e.complexity.GroupedFiles.TaskName == nil {
			break
		}

		return e.complexity.GroupedFiles.TaskName(childComplexity), true

	case "GroupedProjects.groupDisplayName":
		if e.complexity.GroupedProjects.GroupDisplayName == nil {
			break
		}

		return e.complexity.GroupedProjects.GroupDisplayName(childComplexity), true

	case "GroupedProjects.projects":
		if e.complexity.GroupedProjects.Projects == nil {
			break
		}

		return e.complexity.GroupedProjects.Projects(childComplexity), true

	case "GroupedProjects.repo":
		if e.complexity.GroupedProjects.Repo == nil {
			break
		}

		return e.complexity.GroupedProjects.Repo(childComplexity), true

	case "GroupedTaskStatusCount.displayName":
		if e.complexity.GroupedTaskStatusCount.DisplayName == nil {
			break
		}

		return e.complexity.GroupedTaskStatusCount.DisplayName(childComplexity), true

	case "GroupedTaskStatusCount.statusCounts":
		if e.complexity.GroupedTaskStatusCount.StatusCounts == nil {
			break
		}

		return e.complexity.GroupedTaskStatusCount.StatusCounts(childComplexity), true

	case "GroupedTaskStatusCount.variant":
		if e.complexity.GroupedTaskStatusCount.Variant == nil {
			break
		}

		return e.complexity.GroupedTaskStatusCount.Variant(childComplexity), true

	case "HomeVolumeSettings.formatCommand":
		if e.complexity.HomeVolumeSettings.FormatCommand == nil {
			break
		}

		return e.complexity.HomeVolumeSettings.FormatCommand(childComplexity), true

	case "Host.ami":
		if e.complexity.Host.Ami == nil {
			break
		}

		return e.complexity.Host.Ami(childComplexity), true

	case "Host.availabilityZone":
		if e.complexity.Host.AvailabilityZone == nil {
			break
		}

		return e.complexity.Host.AvailabilityZone(childComplexity), true

	case "Host.displayName":
		if e.complexity.Host.DisplayName == nil {
			break
		}

		return e.complexity.Host.DisplayName(childComplexity), true

	case "Host.distro":
		if e.complexity.Host.Distro == nil {
			break
		}

		return e.complexity.Host.Distro(childComplexity), true

	case "Host.distroId":
		if e.complexity.Host.DistroID == nil {
			break
		}

		return e.complexity.Host.DistroID(childComplexity), true

	case "Host.elapsed":
		if e.complexity.Host.Elapsed == nil {
			break
		}

		return e.complexity.Host.Elapsed(childComplexity), true

	case "Host.expiration":
		if e.complexity.Host.Expiration == nil {
			break
		}

		return e.complexity.Host.Expiration(childComplexity), true

	case "Host.homeVolume":
		if e.complexity.Host.HomeVolume == nil {
			break
		}

		return e.complexity.Host.HomeVolume(childComplexity), true

	case "Host.homeVolumeID":
		if e.complexity.Host.HomeVolumeID == nil {
			break
		}

		return e.complexity.Host.HomeVolumeID(childComplexity), true

	case "Host.hostUrl":
		if e.complexity.Host.HostURL == nil {
			break
		}

		return e.complexity.Host.HostURL(childComplexity), true

	case "Host.id":
		if e.complexity.Host.Id == nil {
			break
		}

		return e.complexity.Host.Id(childComplexity), true

	case "Host.instanceTags":
		if e.complexity.Host.InstanceTags == nil {
			break
		}

		return e.complexity.Host.InstanceTags(childComplexity), true

	case "Host.instanceType":
		if e.complexity.Host.InstanceType == nil {
			break
		}

		return e.complexity.Host.InstanceType(childComplexity), true

	case "Host.lastCommunicationTime":
		if e.complexity.Host.LastCommunicationTime == nil {
			break
		}

		return e.complexity.Host.LastCommunicationTime(childComplexity), true

	case "Host.noExpiration":
		if e.complexity.Host.NoExpiration == nil {
			break
		}

		return e.complexity.Host.NoExpiration(childComplexity), true

	case "Host.provider":
		if e.complexity.Host.Provider == nil {
			break
		}

		return e.complexity.Host.Provider(childComplexity), true

	case "Host.runningTask":
		if e.complexity.Host.RunningTask == nil {
			break
		}

		return e.complexity.Host.RunningTask(childComplexity), true

	case "Host.startedBy":
		if e.complexity.Host.StartedBy == nil {
			break
		}

		return e.complexity.Host.StartedBy(childComplexity), true

	case "Host.status":
		if e.complexity.Host.Status == nil {
			break
		}

		return e.complexity.Host.Status(childComplexity), true

	case "Host.tag":
		if e.complexity.Host.Tag == nil {
			break
		}

		return e.complexity.Host.Tag(childComplexity), true

	case "Host.totalIdleTime":
		if e.complexity.Host.TotalIdleTime == nil {
			break
		}

		return e.complexity.Host.TotalIdleTime(childComplexity), true

	case "Host.uptime":
		if e.complexity.Host.Uptime == nil {
			break
		}

		return e.complexity.Host.Uptime(childComplexity), true

	case "Host.user":
		if e.complexity.Host.User == nil {
			break
		}

		return e.complexity.Host.User(childComplexity), true

	case "Host.volumes":
		if e.complexity.Host.Volumes == nil {
			break
		}

		return e.complexity.Host.Volumes(childComplexity), true

	case "HostAllocatorSettings.acceptableHostIdleTime":
		if e.complexity.HostAllocatorSettings.AcceptableHostIdleTime == nil {
			break
		}

		return e.complexity.HostAllocatorSettings.AcceptableHostIdleTime(childComplexity), true

	case "HostAllocatorSettings.feedbackRule":
		if e.complexity.HostAllocatorSettings.FeedbackRule == nil {
			break
		}

		return e.complexity.HostAllocatorSettings.FeedbackRule(childComplexity), true

	case "HostAllocatorSettings.futureHostFraction":
		if e.complexity.HostAllocatorSettings.FutureHostFraction == nil {
			break
		}

		return e.complexity.HostAllocatorSettings.FutureHostFraction(childComplexity), true

	case "HostAllocatorSettings.hostsOverallocatedRule":
		if e.complexity.HostAllocatorSettings.HostsOverallocatedRule == nil {
			break
		}

		return e.complexity.HostAllocatorSettings.HostsOverallocatedRule(childComplexity), true

	case "HostAllocatorSettings.maximumHosts":
		if e.complexity.HostAllocatorSettings.MaximumHosts == nil {
			break
		}

		return e.complexity.HostAllocatorSettings.MaximumHosts(childComplexity), true

	case "HostAllocatorSettings.minimumHosts":
		if e.complexity.HostAllocatorSettings.MinimumHosts == nil {
			break
		}

		return e.complexity.HostAllocatorSettings.MinimumHosts(childComplexity), true

	case "HostAllocatorSettings.roundingRule":
		if e.complexity.HostAllocatorSettings.RoundingRule == nil {
			break
		}

		return e.complexity.HostAllocatorSettings.RoundingRule(childComplexity), true

	case "HostAllocatorSettings.version":
		if e.complexity.HostAllocatorSettings.Version == nil {
			break
		}

		return e.complexity.HostAllocatorSettings.Version(childComplexity), true

	case "HostEventLogData.agentBuild":
		if e.complexity.HostEventLogData.AgentBuild == nil {
			break
		}

		return e.complexity.HostEventLogData.AgentBuild(childComplexity), true

	case "HostEventLogData.agentRevision":
		if e.complexity.HostEventLogData.AgentRevision == nil {
			break
		}

		return e.complexity.HostEventLogData.AgentRevision(childComplexity), true

	case "HostEventLogData.duration":
		if e.complexity.HostEventLogData.Duration == nil {
			break
		}

		return e.complexity.HostEventLogData.Duration(childComplexity), true

	case "HostEventLogData.execution":
		if e.complexity.HostEventLogData.Execution == nil {
			break
		}

		return e.complexity.HostEventLogData.Execution(childComplexity), true

	case "HostEventLogData.hostname":
		if e.complexity.HostEventLogData.Hostname == nil {
			break
		}

		return e.complexity.HostEventLogData.Hostname(childComplexity), true

	case "HostEventLogData.jasperRevision":
		if e.complexity.HostEventLogData.JasperRevision == nil {
			break
		}

		return e.complexity.HostEventLogData.JasperRevision(childComplexity), true

	case "HostEventLogData.logs":
		if e.complexity.HostEventLogData.Logs == nil {
			break
		}

		return e.complexity.HostEventLogData.Logs(childComplexity), true

	case "HostEventLogData.monitorOp":
		if e.complexity.HostEventLogData.MonitorOp == nil {
			break
		}

		return e.complexity.HostEventLogData.MonitorOp(childComplexity), true

	case "HostEventLogData.newStatus":
		if e.complexity.HostEventLogData.NewStatus == nil {
			break
		}

		return e.complexity.HostEventLogData.NewStatus(childComplexity), true

	case "HostEventLogData.oldStatus":
		if e.complexity.HostEventLogData.OldStatus == nil {
			break
		}

		return e.complexity.HostEventLogData.OldStatus(childComplexity), true

	case "HostEventLogData.provisioningMethod":
		if e.complexity.HostEventLogData.ProvisioningMethod == nil {
			break
		}

		return e.complexity.HostEventLogData.ProvisioningMethod(childComplexity), true

	case "HostEventLogData.successful":
		if e.complexity.HostEventLogData.Successful == nil {
			break
		}

		return e.complexity.HostEventLogData.Successful(childComplexity), true

	case "HostEventLogData.taskId":
		if e.complexity.HostEventLogData.TaskId == nil {
			break
		}

		return e.complexity.HostEventLogData.TaskId(childComplexity), true

	case "HostEventLogData.taskPid":
		if e.complexity.HostEventLogData.TaskPid == nil {
			break
		}

		return e.complexity.HostEventLogData.TaskPid(childComplexity), true

	case "HostEventLogData.taskStatus":
		if e.complexity.HostEventLogData.TaskStatus == nil {
			break
		}

		return e.complexity.HostEventLogData.TaskStatus(childComplexity), true

	case "HostEventLogData.user":
		if e.complexity.HostEventLogData.User == nil {
			break
		}

		return e.complexity.HostEventLogData.User(childComplexity), true

	case "HostEventLogEntry.data":
		if e.complexity.HostEventLogEntry.Data == nil {
			break
		}

		return e.complexity.HostEventLogEntry.Data(childComplexity), true

	case "HostEventLogEntry.eventType":
		if e.complexity.HostEventLogEntry.EventType == nil {
			break
		}

		return e.complexity.HostEventLogEntry.EventType(childComplexity), true

	case "HostEventLogEntry.id":
		if e.complexity.HostEventLogEntry.ID == nil {
			break
		}

		return e.complexity.HostEventLogEntry.ID(childComplexity), true

	case "HostEventLogEntry.processedAt":
		if e.complexity.HostEventLogEntry.ProcessedAt == nil {
			break
		}

		return e.complexity.HostEventLogEntry.ProcessedAt(childComplexity), true

	case "HostEventLogEntry.resourceId":
		if e.complexity.HostEventLogEntry.ResourceId == nil {
			break
		}

		return e.complexity.HostEventLogEntry.ResourceId(childComplexity), true

	case "HostEventLogEntry.resourceType":
		if e.complexity.HostEventLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.HostEventLogEntry.ResourceType(childComplexity), true

	case "HostEventLogEntry.timestamp":
		if e.complexity.HostEventLogEntry.Timestamp == nil {
			break
		}

		return e.complexity.HostEventLogEntry.Timestamp(childComplexity), true

	case "HostEvents.count":
		if e.complexity.HostEvents.Count == nil {
			break
		}

		return e.complexity.HostEvents.Count(childComplexity), true

	case "HostEvents.eventLogEntries":
		if e.complexity.HostEvents.EventLogEntries == nil {
			break
		}

		return e.complexity.HostEvents.EventLogEntries(childComplexity), true

	case "HostsResponse.filteredHostsCount":
		if e.complexity.HostsResponse.FilteredHostsCount == nil {
			break
		}

		return e.complexity.HostsResponse.FilteredHostsCount(childComplexity), true

	case "HostsResponse.hosts":
		if e.complexity.HostsResponse.Hosts == nil {
			break
		}

		return e.complexity.HostsResponse.Hosts(childComplexity), true

	case "HostsResponse.totalHostsCount":
		if e.complexity.HostsResponse.TotalHostsCount == nil {
			break
		}

		return e.complexity.HostsResponse.TotalHostsCount(childComplexity), true

	case "IceCreamSettings.configPath":
		if e.complexity.IceCreamSettings.ConfigPath == nil {
			break
		}

		return e.complexity.IceCreamSettings.ConfigPath(childComplexity), true

	case "IceCreamSettings.schedulerHost":
		if e.complexity.IceCreamSettings.SchedulerHost == nil {
			break
		}

		return e.complexity.IceCreamSettings.SchedulerHost(childComplexity), true

	case "InstanceTag.canBeModified":
		if e.complexity.InstanceTag.CanBeModified == nil {
			break
		}

		return e.complexity.InstanceTag.CanBeModified(childComplexity), true

	case "InstanceTag.key":
		if e.complexity.InstanceTag.Key == nil {
			break
		}

		return e.complexity.InstanceTag.Key(childComplexity), true

	case "InstanceTag.value":
		if e.complexity.InstanceTag.Value == nil {
			break
		}

		return e.complexity.InstanceTag.Value(childComplexity), true

	case "IssueLink.confidenceScore":
		if e.complexity.IssueLink.ConfidenceScore == nil {
			break
		}

		return e.complexity.IssueLink.ConfidenceScore(childComplexity), true

	case "IssueLink.issueKey":
		if e.complexity.IssueLink.IssueKey == nil {
			break
		}

		return e.complexity.IssueLink.IssueKey(childComplexity), true

	case "IssueLink.jiraTicket":
		if e.complexity.IssueLink.JiraTicket == nil {
			break
		}

		return e.complexity.IssueLink.JiraTicket(childComplexity), true

	case "IssueLink.source":
		if e.complexity.IssueLink.Source == nil {
			break
		}

		return e.complexity.IssueLink.Source(childComplexity), true

	case "IssueLink.url":
		if e.complexity.IssueLink.URL == nil {
			break
		}

		return e.complexity.IssueLink.URL(childComplexity), true

	case "JiraConfig.host":
		if e.complexity.JiraConfig.Host == nil {
			break
		}

		return e.complexity.JiraConfig.Host(childComplexity), true

	case "JiraField.displayText":
		if e.complexity.JiraField.DisplayText == nil {
			break
		}

		return e.complexity.JiraField.DisplayText(childComplexity), true

	case "JiraField.field":
		if e.complexity.JiraField.Field == nil {
			break
		}

		return e.complexity.JiraField.Field(childComplexity), true

	case "JiraIssueSubscriber.issueType":
		if e.complexity.JiraIssueSubscriber.IssueType == nil {
			break
		}

		return e.complexity.JiraIssueSubscriber.IssueType(childComplexity), true

	case "JiraIssueSubscriber.project":
		if e.complexity.JiraIssueSubscriber.Project == nil {
			break
		}

		return e.complexity.JiraIssueSubscriber.Project(childComplexity), true

	case "JiraStatus.id":
		if e.complexity.JiraStatus.Id == nil {
			break
		}

		return e.complexity.JiraStatus.Id(childComplexity), true

	case "JiraStatus.name":
		if e.complexity.JiraStatus.Name == nil {
			break
		}

		return e.complexity.JiraStatus.Name(childComplexity), true

	case "JiraTicket.fields":
		if e.complexity.JiraTicket.Fields == nil {
			break
		}

		return e.complexity.JiraTicket.Fields(childComplexity), true

	case "JiraTicket.key":
		if e.complexity.JiraTicket.Key == nil {
			break
		}

		return e.complexity.JiraTicket.Key(childComplexity), true

	case "LogMessage.message":
		if e.complexity.LogMessage.Message == nil {
			break
		}

		return e.complexity.LogMessage.Message(childComplexity), true

	case "LogMessage.severity":
		if e.complexity.LogMessage.Severity == nil {
			break
		}

		return e.complexity.LogMessage.Severity(childComplexity), true

	case "LogMessage.timestamp":
		if e.complexity.LogMessage.Timestamp == nil {
			break
		}

		return e.complexity.LogMessage.Timestamp(childComplexity), true

	case "LogMessage.type":
		if e.complexity.LogMessage.Type == nil {
			break
		}

		return e.complexity.LogMessage.Type(childComplexity), true

	case "LogMessage.version":
		if e.complexity.LogMessage.Version == nil {
			break
		}

		return e.complexity.LogMessage.Version(childComplexity), true

	case "LogkeeperBuild.buildNum":
		if e.complexity.LogkeeperBuild.BuildNum == nil {
			break
		}

		return e.complexity.LogkeeperBuild.BuildNum(childComplexity), true

	case "LogkeeperBuild.builder":
		if e.complexity.LogkeeperBuild.Builder == nil {
			break
		}

		return e.complexity.LogkeeperBuild.Builder(childComplexity), true

	case "LogkeeperBuild.id":
		if e.complexity.LogkeeperBuild.ID == nil {
			break
		}

		return e.complexity.LogkeeperBuild.ID(childComplexity), true

	case "LogkeeperBuild.task":
		if e.complexity.LogkeeperBuild.Task == nil {
			break
		}

		return e.complexity.LogkeeperBuild.Task(childComplexity), true

	case "LogkeeperBuild.taskExecution":
		if e.complexity.LogkeeperBuild.TaskExecution == nil {
			break
		}

		return e.complexity.LogkeeperBuild.TaskExecution(childComplexity), true

	case "LogkeeperBuild.taskId":
		if e.complexity.LogkeeperBuild.TaskID == nil {
			break
		}

		return e.complexity.LogkeeperBuild.TaskID(childComplexity), true

	case "LogkeeperBuild.tests":
		if e.complexity.LogkeeperBuild.Tests == nil {
			break
		}

		return e.complexity.LogkeeperBuild.Tests(childComplexity), true

	case "LogkeeperTest.buildId":
		if e.complexity.LogkeeperTest.BuildID == nil {
			break
		}

		return e.complexity.LogkeeperTest.BuildID(childComplexity), true

	case "LogkeeperTest.command":
		if e.complexity.LogkeeperTest.Command == nil {
			break
		}

		return e.complexity.LogkeeperTest.Command(childComplexity), true

	case "LogkeeperTest.id":
		if e.complexity.LogkeeperTest.ID == nil {
			break
		}

		return e.complexity.LogkeeperTest.ID(childComplexity), true

	case "LogkeeperTest.name":
		if e.complexity.LogkeeperTest.Name == nil {
			break
		}

		return e.complexity.LogkeeperTest.Name(childComplexity), true

	case "LogkeeperTest.phase":
		if e.complexity.LogkeeperTest.Phase == nil {
			break
		}

		return e.complexity.LogkeeperTest.Phase(childComplexity), true

	case "LogkeeperTest.taskExecution":
		if e.complexity.LogkeeperTest.TaskExecution == nil {
			break
		}

		return e.complexity.LogkeeperTest.TaskExecution(childComplexity), true

	case "LogkeeperTest.taskId":
		if e.complexity.LogkeeperTest.TaskID == nil {
			break
		}

		return e.complexity.LogkeeperTest.TaskID(childComplexity), true

	case "MainlineCommitVersion.rolledUpVersions":
		if e.complexity.MainlineCommitVersion.RolledUpVersions == nil {
			break
		}

		return e.complexity.MainlineCommitVersion.RolledUpVersions(childComplexity), true

	case "MainlineCommitVersion.version":
		if e.complexity.MainlineCommitVersion.Version == nil {
			break
		}

		return e.complexity.MainlineCommitVersion.Version(childComplexity), true

	case "MainlineCommits.nextPageOrderNumber":
		if e.complexity.MainlineCommits.NextPageOrderNumber == nil {
			break
		}

		return e.complexity.MainlineCommits.NextPageOrderNumber(childComplexity), true

	case "MainlineCommits.prevPageOrderNumber":
		if e.complexity.MainlineCommits.PrevPageOrderNumber == nil {
			break
		}

		return e.complexity.MainlineCommits.PrevPageOrderNumber(childComplexity), true

	case "MainlineCommits.versions":
		if e.complexity.MainlineCommits.Versions == nil {
			break
		}

		return e.complexity.MainlineCommits.Versions(childComplexity), true

	case "Manifest.branch":
		if e.complexity.Manifest.Branch == nil {
			break
		}

		return e.complexity.Manifest.Branch(childComplexity), true

	case "Manifest.id":
		if e.complexity.Manifest.ID == nil {
			break
		}

		return e.complexity.Manifest.ID(childComplexity), true

	case "Manifest.isBase":
		if e.complexity.Manifest.IsBase == nil {
			break
		}

		return e.complexity.Manifest.IsBase(childComplexity), true

	case "Manifest.moduleOverrides":
		if e.complexity.Manifest.ModuleOverrides == nil {
			break
		}

		return e.complexity.Manifest.ModuleOverrides(childComplexity), true

	case "Manifest.modules":
		if e.complexity.Manifest.Modules == nil {
			break
		}

		return e.complexity.Manifest.Modules(childComplexity), true

	case "Manifest.project":
		if e.complexity.Manifest.Project == nil {
			break
		}

		return e.complexity.Manifest.Project(childComplexity), true

	case "Manifest.revision":
		if e.complexity.Manifest.Revision == nil {
			break
		}

		return e.complexity.Manifest.Revision(childComplexity), true

	case "MetadataLink.source":
		if e.complexity.MetadataLink.Source == nil {
			break
		}

		return e.complexity.MetadataLink.Source(childComplexity), true

	case "MetadataLink.text":
		if e.complexity.MetadataLink.Text == nil {
			break
		}

		return e.complexity.MetadataLink.Text(childComplexity), true

	case "MetadataLink.url":
		if e.complexity.MetadataLink.URL == nil {
			break
		}

		return e.complexity.MetadataLink.URL(childComplexity), true

	case "Module.issue":
		if e.complexity.Module.Issue == nil {
			break
		}

		return e.complexity.Module.Issue(childComplexity), true

	case "Module.module":
		if e.complexity.Module.Module == nil {
			break
		}

		return e.complexity.Module.Module(childComplexity), true

	case "ModuleCodeChange.branchName":
		if e.complexity.ModuleCodeChange.BranchName == nil {
			break
		}

		return e.complexity.ModuleCodeChange.BranchName(childComplexity), true

	case "ModuleCodeChange.fileDiffs":
		if e.complexity.ModuleCodeChange.FileDiffs == nil {
			break
		}

		return e.complexity.ModuleCodeChange.FileDiffs(childComplexity), true

	case "ModuleCodeChange.htmlLink":
		if e.complexity.ModuleCodeChange.HTMLLink == nil {
			break
		}

		return e.complexity.ModuleCodeChange.HTMLLink(childComplexity), true

	case "ModuleCodeChange.rawLink":
		if e.complexity.ModuleCodeChange.RawLink == nil {
			break
		}

		return e.complexity.ModuleCodeChange.RawLink(childComplexity), true

	case "Mutation.abortTask":
		if e.complexity.Mutation.AbortTask == nil {
			break
		}

		args, err := ec.field_Mutation_abortTask_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AbortTask(childComplexity, args["taskId"].(string)), true

	case "Mutation.addAnnotationIssue":
		if e.complexity.Mutation.AddAnnotationIssue == nil {
			break
		}

		args, err := ec.field_Mutation_addAnnotationIssue_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddAnnotationIssue(childComplexity, args["taskId"].(string), args["execution"].(int), args["apiIssue"].(model.APIIssueLink), args["isIssue"].(bool)), true

	case "Mutation.addFavoriteProject":
		if e.complexity.Mutation.AddFavoriteProject == nil {
			break
		}

		args, err := ec.field_Mutation_addFavoriteProject_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AddFavoriteProject(childComplexity, args["identifier"].(string)), true

	case "Mutation.attachProjectToNewRepo":
		if e.complexity.Mutation.AttachProjectToNewRepo == nil {
			break
		}

		args, err := ec.field_Mutation_attachProjectToNewRepo_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AttachProjectToNewRepo(childComplexity, args["project"].(MoveProjectInput)), true

	case "Mutation.attachProjectToRepo":
		if e.complexity.Mutation.AttachProjectToRepo == nil {
			break
		}

		args, err := ec.field_Mutation_attachProjectToRepo_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AttachProjectToRepo(childComplexity, args["projectId"].(string)), true

	case "Mutation.attachVolumeToHost":
		if e.complexity.Mutation.AttachVolumeToHost == nil {
			break
		}

		args, err := ec.field_Mutation_attachVolumeToHost_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.AttachVolumeToHost(childComplexity, args["volumeAndHost"].(VolumeHost)), true

	case "Mutation.bbCreateTicket":
		if e.complexity.Mutation.BbCreateTicket == nil {
			break
		}

		args, err := ec.field_Mutation_bbCreateTicket_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.BbCreateTicket(childComplexity, args["taskId"].(string), args["execution"].(*int)), true

	case "Mutation.clearMySubscriptions":
		if e.complexity.Mutation.ClearMySubscriptions == nil {
			break
		}

		return e.complexity.Mutation.ClearMySubscriptions(childComplexity), true

	case "Mutation.copyDistro":
		if e.complexity.Mutation.CopyDistro == nil {
			break
		}

		args, err := ec.field_Mutation_copyDistro_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CopyDistro(childComplexity, args["opts"].(data.CopyDistroOpts)), true

	case "Mutation.copyProject":
		if e.complexity.Mutation.CopyProject == nil {
			break
		}

		args, err := ec.field_Mutation_copyProject_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CopyProject(childComplexity, args["project"].(data.CopyProjectOpts), args["requestS3Creds"].(*bool)), true

	case "Mutation.createDistro":
		if e.complexity.Mutation.CreateDistro == nil {
			break
		}

		args, err := ec.field_Mutation_createDistro_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateDistro(childComplexity, args["opts"].(CreateDistroInput)), true

	case "Mutation.createProject":
		if e.complexity.Mutation.CreateProject == nil {
			break
		}

		args, err := ec.field_Mutation_createProject_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateProject(childComplexity, args["project"].(model.APIProjectRef), args["requestS3Creds"].(*bool)), true

	case "Mutation.createPublicKey":
		if e.complexity.Mutation.CreatePublicKey == nil {
			break
		}

		args, err := ec.field_Mutation_createPublicKey_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreatePublicKey(childComplexity, args["publicKeyInput"].(PublicKeyInput)), true

	case "Mutation.deactivateStepbackTask":
		if e.complexity.Mutation.DeactivateStepbackTask == nil {
			break
		}

		args, err := ec.field_Mutation_deactivateStepbackTask_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeactivateStepbackTask(childComplexity, args["projectId"].(string), args["buildVariantName"].(string), args["taskName"].(string)), true

	case "Mutation.defaultSectionToRepo":
		if e.complexity.Mutation.DefaultSectionToRepo == nil {
			break
		}

		args, err := ec.field_Mutation_defaultSectionToRepo_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DefaultSectionToRepo(childComplexity, args["projectId"].(string), args["section"].(ProjectSettingsSection)), true

	case "Mutation.deleteDistro":
		if e.complexity.Mutation.DeleteDistro == nil {
			break
		}

		args, err := ec.field_Mutation_deleteDistro_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteDistro(childComplexity, args["opts"].(DeleteDistroInput)), true

	case "Mutation.deleteProject":
		if e.complexity.Mutation.DeleteProject == nil {
			break
		}

		args, err := ec.field_Mutation_deleteProject_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteProject(childComplexity, args["projectId"].(string)), true

	case "Mutation.deleteSubscriptions":
		if e.complexity.Mutation.DeleteSubscriptions == nil {
			break
		}

		args, err := ec.field_Mutation_deleteSubscriptions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteSubscriptions(childComplexity, args["subscriptionIds"].([]string)), true

	case "Mutation.detachProjectFromRepo":
		if e.complexity.Mutation.DetachProjectFromRepo == nil {
			break
		}

		args, err := ec.field_Mutation_detachProjectFromRepo_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DetachProjectFromRepo(childComplexity, args["projectId"].(string)), true

	case "Mutation.detachVolumeFromHost":
		if e.complexity.Mutation.DetachVolumeFromHost == nil {
			break
		}

		args, err := ec.field_Mutation_detachVolumeFromHost_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DetachVolumeFromHost(childComplexity, args["volumeId"].(string)), true

	case "Mutation.editAnnotationNote":
		if e.complexity.Mutation.EditAnnotationNote == nil {
			break
		}

		args, err := ec.field_Mutation_editAnnotationNote_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.EditAnnotationNote(childComplexity, args["taskId"].(string), args["execution"].(int), args["originalMessage"].(string), args["newMessage"].(string)), true

	case "Mutation.editSpawnHost":
		if e.complexity.Mutation.EditSpawnHost == nil {
			break
		}

		args, err := ec.field_Mutation_editSpawnHost_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.EditSpawnHost(childComplexity, args["spawnHost"].(*EditSpawnHostInput)), true

	case "Mutation.enqueuePatch":
		if e.complexity.Mutation.EnqueuePatch == nil {
			break
		}

		args, err := ec.field_Mutation_enqueuePatch_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.EnqueuePatch(childComplexity, args["patchId"].(string), args["commitMessage"].(*string)), true

	case "Mutation.forceRepotrackerRun":
		if e.complexity.Mutation.ForceRepotrackerRun == nil {
			break
		}

		args, err := ec.field_Mutation_forceRepotrackerRun_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ForceRepotrackerRun(childComplexity, args["projectId"].(string)), true

	case "Mutation.migrateVolume":
		if e.complexity.Mutation.MigrateVolume == nil {
			break
		}

		args, err := ec.field_Mutation_migrateVolume_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MigrateVolume(childComplexity, args["volumeId"].(string), args["spawnHostInput"].(*SpawnHostInput)), true

	case "Mutation.moveAnnotationIssue":
		if e.complexity.Mutation.MoveAnnotationIssue == nil {
			break
		}

		args, err := ec.field_Mutation_moveAnnotationIssue_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.MoveAnnotationIssue(childComplexity, args["taskId"].(string), args["execution"].(int), args["apiIssue"].(model.APIIssueLink), args["isIssue"].(bool)), true

	case "Mutation.overrideTaskDependencies":
		if e.complexity.Mutation.OverrideTaskDependencies == nil {
			break
		}

		args, err := ec.field_Mutation_overrideTaskDependencies_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.OverrideTaskDependencies(childComplexity, args["taskId"].(string)), true

	case "Mutation.promoteVarsToRepo":
		if e.complexity.Mutation.PromoteVarsToRepo == nil {
			break
		}

		args, err := ec.field_Mutation_promoteVarsToRepo_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.PromoteVarsToRepo(childComplexity, args["projectId"].(string), args["varNames"].([]string)), true

	case "Mutation.removeAnnotationIssue":
		if e.complexity.Mutation.RemoveAnnotationIssue == nil {
			break
		}

		args, err := ec.field_Mutation_removeAnnotationIssue_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveAnnotationIssue(childComplexity, args["taskId"].(string), args["execution"].(int), args["apiIssue"].(model.APIIssueLink), args["isIssue"].(bool)), true

	case "Mutation.removeFavoriteProject":
		if e.complexity.Mutation.RemoveFavoriteProject == nil {
			break
		}

		args, err := ec.field_Mutation_removeFavoriteProject_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveFavoriteProject(childComplexity, args["identifier"].(string)), true

	case "Mutation.removeItemFromCommitQueue":
		if e.complexity.Mutation.RemoveItemFromCommitQueue == nil {
			break
		}

		args, err := ec.field_Mutation_removeItemFromCommitQueue_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveItemFromCommitQueue(childComplexity, args["commitQueueId"].(string), args["issue"].(string)), true

	case "Mutation.removePublicKey":
		if e.complexity.Mutation.RemovePublicKey == nil {
			break
		}

		args, err := ec.field_Mutation_removePublicKey_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemovePublicKey(childComplexity, args["keyName"].(string)), true

	case "Mutation.removeVolume":
		if e.complexity.Mutation.RemoveVolume == nil {
			break
		}

		args, err := ec.field_Mutation_removeVolume_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RemoveVolume(childComplexity, args["volumeId"].(string)), true

	case "Mutation.reprovisionToNew":
		if e.complexity.Mutation.ReprovisionToNew == nil {
			break
		}

		args, err := ec.field_Mutation_reprovisionToNew_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ReprovisionToNew(childComplexity, args["hostIds"].([]string)), true

	case "Mutation.restartJasper":
		if e.complexity.Mutation.RestartJasper == nil {
			break
		}

		args, err := ec.field_Mutation_restartJasper_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RestartJasper(childComplexity, args["hostIds"].([]string)), true

	case "Mutation.restartTask":
		if e.complexity.Mutation.RestartTask == nil {
			break
		}

		args, err := ec.field_Mutation_restartTask_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RestartTask(childComplexity, args["taskId"].(string), args["failedOnly"].(bool)), true

	case "Mutation.restartVersions":
		if e.complexity.Mutation.RestartVersions == nil {
			break
		}

		args, err := ec.field_Mutation_restartVersions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RestartVersions(childComplexity, args["versionId"].(string), args["abort"].(bool), args["versionsToRestart"].([]*model1.VersionToRestart)), true

	case "Mutation.saveDistro":
		if e.complexity.Mutation.SaveDistro == nil {
			break
		}

		args, err := ec.field_Mutation_saveDistro_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SaveDistro(childComplexity, args["opts"].(SaveDistroInput)), true

	case "Mutation.saveProjectSettingsForSection":
		if e.complexity.Mutation.SaveProjectSettingsForSection == nil {
			break
		}

		args, err := ec.field_Mutation_saveProjectSettingsForSection_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SaveProjectSettingsForSection(childComplexity, args["projectSettings"].(*model.APIProjectSettings), args["section"].(ProjectSettingsSection)), true

	case "Mutation.saveRepoSettingsForSection":
		if e.complexity.Mutation.SaveRepoSettingsForSection == nil {
			break
		}

		args, err := ec.field_Mutation_saveRepoSettingsForSection_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SaveRepoSettingsForSection(childComplexity, args["repoSettings"].(*model.APIProjectSettings), args["section"].(ProjectSettingsSection)), true

	case "Mutation.saveSubscription":
		if e.complexity.Mutation.SaveSubscription == nil {
			break
		}

		args, err := ec.field_Mutation_saveSubscription_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SaveSubscription(childComplexity, args["subscription"].(model.APISubscription)), true

	case "Mutation.schedulePatch":
		if e.complexity.Mutation.SchedulePatch == nil {
			break
		}

		args, err := ec.field_Mutation_schedulePatch_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SchedulePatch(childComplexity, args["patchId"].(string), args["configure"].(PatchConfigure)), true

	case "Mutation.schedulePatchTasks":
		if e.complexity.Mutation.SchedulePatchTasks == nil {
			break
		}

		args, err := ec.field_Mutation_schedulePatchTasks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SchedulePatchTasks(childComplexity, args["patchId"].(string)), true

	case "Mutation.scheduleTasks":
		if e.complexity.Mutation.ScheduleTasks == nil {
			break
		}

		args, err := ec.field_Mutation_scheduleTasks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ScheduleTasks(childComplexity, args["taskIds"].([]string)), true

	case "Mutation.scheduleUndispatchedBaseTasks":
		if e.complexity.Mutation.ScheduleUndispatchedBaseTasks == nil {
			break
		}

		args, err := ec.field_Mutation_scheduleUndispatchedBaseTasks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.ScheduleUndispatchedBaseTasks(childComplexity, args["patchId"].(string)), true

	case "Mutation.setAnnotationMetadataLinks":
		if e.complexity.Mutation.SetAnnotationMetadataLinks == nil {
			break
		}

		args, err := ec.field_Mutation_setAnnotationMetadataLinks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetAnnotationMetadataLinks(childComplexity, args["taskId"].(string), args["execution"].(int), args["metadataLinks"].([]*model.APIMetadataLink)), true

	case "Mutation.setPatchPriority":
		if e.complexity.Mutation.SetPatchPriority == nil {
			break
		}

		args, err := ec.field_Mutation_setPatchPriority_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetPatchPriority(childComplexity, args["patchId"].(string), args["priority"].(int)), true

	case "Mutation.setPatchVisibility":
		if e.complexity.Mutation.SetPatchVisibility == nil {
			break
		}

		args, err := ec.field_Mutation_setPatchVisibility_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetPatchVisibility(childComplexity, args["patchIds"].([]string), args["hidden"].(bool)), true

	case "Mutation.setTaskPriority":
		if e.complexity.Mutation.SetTaskPriority == nil {
			break
		}

		args, err := ec.field_Mutation_setTaskPriority_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SetTaskPriority(childComplexity, args["taskId"].(string), args["priority"].(int)), true

	case "Mutation.spawnHost":
		if e.complexity.Mutation.SpawnHost == nil {
			break
		}

		args, err := ec.field_Mutation_spawnHost_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SpawnHost(childComplexity, args["spawnHostInput"].(*SpawnHostInput)), true

	case "Mutation.spawnVolume":
		if e.complexity.Mutation.SpawnVolume == nil {
			break
		}

		args, err := ec.field_Mutation_spawnVolume_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.SpawnVolume(childComplexity, args["spawnVolumeInput"].(SpawnVolumeInput)), true

	case "Mutation.unschedulePatchTasks":
		if e.complexity.Mutation.UnschedulePatchTasks == nil {
			break
		}

		args, err := ec.field_Mutation_unschedulePatchTasks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UnschedulePatchTasks(childComplexity, args["patchId"].(string), args["abort"].(bool)), true

	case "Mutation.unscheduleTask":
		if e.complexity.Mutation.UnscheduleTask == nil {
			break
		}

		args, err := ec.field_Mutation_unscheduleTask_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UnscheduleTask(childComplexity, args["taskId"].(string)), true

	case "Mutation.updateHostStatus":
		if e.complexity.Mutation.UpdateHostStatus == nil {
			break
		}

		args, err := ec.field_Mutation_updateHostStatus_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateHostStatus(childComplexity, args["hostIds"].([]string), args["status"].(string), args["notes"].(*string)), true

	case "Mutation.updatePublicKey":
		if e.complexity.Mutation.UpdatePublicKey == nil {
			break
		}

		args, err := ec.field_Mutation_updatePublicKey_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdatePublicKey(childComplexity, args["targetKeyName"].(string), args["updateInfo"].(PublicKeyInput)), true

	case "Mutation.updateSpawnHostStatus":
		if e.complexity.Mutation.UpdateSpawnHostStatus == nil {
			break
		}

		args, err := ec.field_Mutation_updateSpawnHostStatus_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateSpawnHostStatus(childComplexity, args["hostId"].(string), args["action"].(SpawnHostStatusActions)), true

	case "Mutation.updateUserSettings":
		if e.complexity.Mutation.UpdateUserSettings == nil {
			break
		}

		args, err := ec.field_Mutation_updateUserSettings_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUserSettings(childComplexity, args["userSettings"].(*model.APIUserSettings)), true

	case "Mutation.updateVolume":
		if e.complexity.Mutation.UpdateVolume == nil {
			break
		}

		args, err := ec.field_Mutation_updateVolume_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateVolume(childComplexity, args["updateVolumeInput"].(UpdateVolumeInput)), true

	case "NewDistroPayload.newDistroId":
		if e.complexity.NewDistroPayload.NewDistroID == nil {
			break
		}

		return e.complexity.NewDistroPayload.NewDistroID(childComplexity), true

	case "Note.message":
		if e.complexity.Note.Message == nil {
			break
		}

		return e.complexity.Note.Message(childComplexity), true

	case "Note.source":
		if e.complexity.Note.Source == nil {
			break
		}

		return e.complexity.Note.Source(childComplexity), true

	case "Notifications.buildBreak":
		if e.complexity.Notifications.BuildBreak == nil {
			break
		}

		return e.complexity.Notifications.BuildBreak(childComplexity), true

	case "Notifications.buildBreakId":
		if e.complexity.Notifications.BuildBreakID == nil {
			break
		}

		return e.complexity.Notifications.BuildBreakID(childComplexity), true

	case "Notifications.commitQueue":
		if e.complexity.Notifications.CommitQueue == nil {
			break
		}

		return e.complexity.Notifications.CommitQueue(childComplexity), true

	case "Notifications.commitQueueId":
		if e.complexity.Notifications.CommitQueueID == nil {
			break
		}

		return e.complexity.Notifications.CommitQueueID(childComplexity), true

	case "Notifications.patchFinish":
		if e.complexity.Notifications.PatchFinish == nil {
			break
		}

		return e.complexity.Notifications.PatchFinish(childComplexity), true

	case "Notifications.patchFinishId":
		if e.complexity.Notifications.PatchFinishID == nil {
			break
		}

		return e.complexity.Notifications.PatchFinishID(childComplexity), true

	case "Notifications.patchFirstFailure":
		if e.complexity.Notifications.PatchFirstFailure == nil {
			break
		}

		return e.complexity.Notifications.PatchFirstFailure(childComplexity), true

	case "Notifications.patchFirstFailureId":
		if e.complexity.Notifications.PatchFirstFailureID == nil {
			break
		}

		return e.complexity.Notifications.PatchFirstFailureID(childComplexity), true

	case "Notifications.spawnHostExpiration":
		if e.complexity.Notifications.SpawnHostExpiration == nil {
			break
		}

		return e.complexity.Notifications.SpawnHostExpiration(childComplexity), true

	case "Notifications.spawnHostExpirationId":
		if e.complexity.Notifications.SpawnHostExpirationID == nil {
			break
		}

		return e.complexity.Notifications.SpawnHostExpirationID(childComplexity), true

	case "Notifications.spawnHostOutcome":
		if e.complexity.Notifications.SpawnHostOutcome == nil {
			break
		}

		return e.complexity.Notifications.SpawnHostOutcome(childComplexity), true

	case "Notifications.spawnHostOutcomeId":
		if e.complexity.Notifications.SpawnHostOutcomeID == nil {
			break
		}

		return e.complexity.Notifications.SpawnHostOutcomeID(childComplexity), true

	case "OomTrackerInfo.detected":
		if e.complexity.OomTrackerInfo.Detected == nil {
			break
		}

		return e.complexity.OomTrackerInfo.Detected(childComplexity), true

	case "OomTrackerInfo.pids":
		if e.complexity.OomTrackerInfo.Pids == nil {
			break
		}

		return e.complexity.OomTrackerInfo.Pids(childComplexity), true

	case "Parameter.key":
		if e.complexity.Parameter.Key == nil {
			break
		}

		return e.complexity.Parameter.Key(childComplexity), true

	case "Parameter.value":
		if e.complexity.Parameter.Value == nil {
			break
		}

		return e.complexity.Parameter.Value(childComplexity), true

	case "ParsleyFilter.caseSensitive":
		if e.complexity.ParsleyFilter.CaseSensitive == nil {
			break
		}

		return e.complexity.ParsleyFilter.CaseSensitive(childComplexity), true

	case "ParsleyFilter.exactMatch":
		if e.complexity.ParsleyFilter.ExactMatch == nil {
			break
		}

		return e.complexity.ParsleyFilter.ExactMatch(childComplexity), true

	case "ParsleyFilter.expression":
		if e.complexity.ParsleyFilter.Expression == nil {
			break
		}

		return e.complexity.ParsleyFilter.Expression(childComplexity), true

	case "Patch.activated":
		if e.complexity.Patch.Activated == nil {
			break
		}

		return e.complexity.Patch.Activated(childComplexity), true

	case "Patch.alias":
		if e.complexity.Patch.Alias == nil {
			break
		}

		return e.complexity.Patch.Alias(childComplexity), true

	case "Patch.author":
		if e.complexity.Patch.Author == nil {
			break
		}

		return e.complexity.Patch.Author(childComplexity), true

	case "Patch.authorDisplayName":
		if e.complexity.Patch.AuthorDisplayName == nil {
			break
		}

		return e.complexity.Patch.AuthorDisplayName(childComplexity), true

	case "Patch.baseTaskStatuses":
		if e.complexity.Patch.BaseTaskStatuses == nil {
			break
		}

		return e.complexity.Patch.BaseTaskStatuses(childComplexity), true

	case "Patch.builds":
		if e.complexity.Patch.Builds == nil {
			break
		}

		return e.complexity.Patch.Builds(childComplexity), true

	case "Patch.canEnqueueToCommitQueue":
		if e.complexity.Patch.CanEnqueueToCommitQueue == nil {
			break
		}

		return e.complexity.Patch.CanEnqueueToCommitQueue(childComplexity), true

	case "Patch.childPatchAliases":
		if e.complexity.Patch.ChildPatchAliases == nil {
			break
		}

		return e.complexity.Patch.ChildPatchAliases(childComplexity), true

	case "Patch.childPatches":
		if e.complexity.Patch.ChildPatches == nil {
			break
		}

		return e.complexity.Patch.ChildPatches(childComplexity), true

	case "Patch.commitQueuePosition":
		if e.complexity.Patch.CommitQueuePosition == nil {
			break
		}

		return e.complexity.Patch.CommitQueuePosition(childComplexity), true

	case "Patch.createTime":
		if e.complexity.Patch.CreateTime == nil {
			break
		}

		return e.complexity.Patch.CreateTime(childComplexity), true

	case "Patch.description":
		if e.complexity.Patch.Description == nil {
			break
		}

		return e.complexity.Patch.Description(childComplexity), true

	case "Patch.duration":
		if e.complexity.Patch.Duration == nil {
			break
		}

		return e.complexity.Patch.Duration(childComplexity), true

	case "Patch.githash":
		if e.complexity.Patch.Githash == nil {
			break
		}

		return e.complexity.Patch.Githash(childComplexity), true

	case "Patch.hidden":
		if e.complexity.Patch.Hidden == nil {
			break
		}

		return e.complexity.Patch.Hidden(childComplexity), true

	case "Patch.id":
		if e.complexity.Patch.Id == nil {
			break
		}

		return e.complexity.Patch.Id(childComplexity), true

	case "Patch.moduleCodeChanges":
		if e.complexity.Patch.ModuleCodeChanges == nil {
			break
		}

		return e.complexity.Patch.ModuleCodeChanges(childComplexity), true

	case "Patch.parameters":
		if e.complexity.Patch.Parameters == nil {
			break
		}

		return e.complexity.Patch.Parameters(childComplexity), true

	case "Patch.patchNumber":
		if e.complexity.Patch.PatchNumber == nil {
			break
		}

		return e.complexity.Patch.PatchNumber(childComplexity), true

	case "Patch.patchTriggerAliases":
		if e.complexity.Patch.PatchTriggerAliases == nil {
			break
		}

		return e.complexity.Patch.PatchTriggerAliases(childComplexity), true

	case "Patch.project":
		if e.complexity.Patch.Project == nil {
			break
		}

		return e.complexity.Patch.Project(childComplexity), true

	case "Patch.projectID":
		if e.complexity.Patch.ProjectId == nil {
			break
		}

		return e.complexity.Patch.ProjectId(childComplexity), true

	case "Patch.projectIdentifier":
		if e.complexity.Patch.ProjectIdentifier == nil {
			break
		}

		return e.complexity.Patch.ProjectIdentifier(childComplexity), true

	case "Patch.projectMetadata":
		if e.complexity.Patch.ProjectMetadata == nil {
			break
		}

		return e.complexity.Patch.ProjectMetadata(childComplexity), true

	case "Patch.status":
		if e.complexity.Patch.Status == nil {
			break
		}

		return e.complexity.Patch.Status(childComplexity), true

	case "Patch.taskCount":
		if e.complexity.Patch.TaskCount == nil {
			break
		}

		return e.complexity.Patch.TaskCount(childComplexity), true

	case "Patch.taskStatuses":
		if e.complexity.Patch.TaskStatuses == nil {
			break
		}

		return e.complexity.Patch.TaskStatuses(childComplexity), true

	case "Patch.tasks":
		if e.complexity.Patch.Tasks == nil {
			break
		}

		return e.complexity.Patch.Tasks(childComplexity), true

	case "Patch.time":
		if e.complexity.Patch.Time == nil {
			break
		}

		return e.complexity.Patch.Time(childComplexity), true

	case "Patch.variants":
		if e.complexity.Patch.Variants == nil {
			break
		}

		return e.complexity.Patch.Variants(childComplexity), true

	case "Patch.variantsTasks":
		if e.complexity.Patch.VariantsTasks == nil {
			break
		}

		return e.complexity.Patch.VariantsTasks(childComplexity), true

	case "Patch.versionFull":
		if e.complexity.Patch.VersionFull == nil {
			break
		}

		return e.complexity.Patch.VersionFull(childComplexity), true

	case "PatchDuration.makespan":
		if e.complexity.PatchDuration.Makespan == nil {
			break
		}

		return e.complexity.PatchDuration.Makespan(childComplexity), true

	case "PatchDuration.time":
		if e.complexity.PatchDuration.Time == nil {
			break
		}

		return e.complexity.PatchDuration.Time(childComplexity), true

	case "PatchDuration.timeTaken":
		if e.complexity.PatchDuration.TimeTaken == nil {
			break
		}

		return e.complexity.PatchDuration.TimeTaken(childComplexity), true

	case "PatchProject.variants":
		if e.complexity.PatchProject.Variants == nil {
			break
		}

		return e.complexity.PatchProject.Variants(childComplexity), true

	case "PatchTime.finished":
		if e.complexity.PatchTime.Finished == nil {
			break
		}

		return e.complexity.PatchTime.Finished(childComplexity), true

	case "PatchTime.started":
		if e.complexity.PatchTime.Started == nil {
			break
		}

		return e.complexity.PatchTime.Started(childComplexity), true

	case "PatchTime.submittedAt":
		if e.complexity.PatchTime.SubmittedAt == nil {
			break
		}

		return e.complexity.PatchTime.SubmittedAt(childComplexity), true

	case "PatchTriggerAlias.alias":
		if e.complexity.PatchTriggerAlias.Alias == nil {
			break
		}

		return e.complexity.PatchTriggerAlias.Alias(childComplexity), true

	case "PatchTriggerAlias.childProjectId":
		if e.complexity.PatchTriggerAlias.ChildProjectId == nil {
			break
		}

		return e.complexity.PatchTriggerAlias.ChildProjectId(childComplexity), true

	case "PatchTriggerAlias.childProjectIdentifier":
		if e.complexity.PatchTriggerAlias.ChildProjectIdentifier == nil {
			break
		}

		return e.complexity.PatchTriggerAlias.ChildProjectIdentifier(childComplexity), true

	case "PatchTriggerAlias.parentAsModule":
		if e.complexity.PatchTriggerAlias.ParentAsModule == nil {
			break
		}

		return e.complexity.PatchTriggerAlias.ParentAsModule(childComplexity), true

	case "PatchTriggerAlias.status":
		if e.complexity.PatchTriggerAlias.Status == nil {
			break
		}

		return e.complexity.PatchTriggerAlias.Status(childComplexity), true

	case "PatchTriggerAlias.taskSpecifiers":
		if e.complexity.PatchTriggerAlias.TaskSpecifiers == nil {
			break
		}

		return e.complexity.PatchTriggerAlias.TaskSpecifiers(childComplexity), true

	case "PatchTriggerAlias.variantsTasks":
		if e.complexity.PatchTriggerAlias.VariantsTasks == nil {
			break
		}

		return e.complexity.PatchTriggerAlias.VariantsTasks(childComplexity), true

	case "Patches.filteredPatchCount":
		if e.complexity.Patches.FilteredPatchCount == nil {
			break
		}

		return e.complexity.Patches.FilteredPatchCount(childComplexity), true

	case "Patches.patches":
		if e.complexity.Patches.Patches == nil {
			break
		}

		return e.complexity.Patches.Patches(childComplexity), true

	case "PeriodicBuild.alias":
		if e.complexity.PeriodicBuild.Alias == nil {
			break
		}

		return e.complexity.PeriodicBuild.Alias(childComplexity), true

	case "PeriodicBuild.configFile":
		if e.complexity.PeriodicBuild.ConfigFile == nil {
			break
		}

		return e.complexity.PeriodicBuild.ConfigFile(childComplexity), true

	case "PeriodicBuild.cron":
		if e.complexity.PeriodicBuild.Cron == nil {
			break
		}

		return e.complexity.PeriodicBuild.Cron(childComplexity), true

	case "PeriodicBuild.id":
		if e.complexity.PeriodicBuild.ID == nil {
			break
		}

		return e.complexity.PeriodicBuild.ID(childComplexity), true

	case "PeriodicBuild.intervalHours":
		if e.complexity.PeriodicBuild.IntervalHours == nil {
			break
		}

		return e.complexity.PeriodicBuild.IntervalHours(childComplexity), true

	case "PeriodicBuild.message":
		if e.complexity.PeriodicBuild.Message == nil {
			break
		}

		return e.complexity.PeriodicBuild.Message(childComplexity), true

	case "PeriodicBuild.nextRunTime":
		if e.complexity.PeriodicBuild.NextRunTime == nil {
			break
		}

		return e.complexity.PeriodicBuild.NextRunTime(childComplexity), true

	case "Permissions.canCreateDistro":
		if e.complexity.Permissions.CanCreateDistro == nil {
			break
		}

		return e.complexity.Permissions.CanCreateDistro(childComplexity), true

	case "Permissions.canCreateProject":
		if e.complexity.Permissions.CanCreateProject == nil {
			break
		}

		return e.complexity.Permissions.CanCreateProject(childComplexity), true

	case "Permissions.distroPermissions":
		if e.complexity.Permissions.DistroPermissions == nil {
			break
		}

		args, err := ec.field_Permissions_distroPermissions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Permissions.DistroPermissions(childComplexity, args["options"].(DistroPermissionsOptions)), true

	case "Permissions.userId":
		if e.complexity.Permissions.UserID == nil {
			break
		}

		return e.complexity.Permissions.UserID(childComplexity), true

	case "PlannerSettings.commitQueueFactor":
		if e.complexity.PlannerSettings.CommitQueueFactor == nil {
			break
		}

		return e.complexity.PlannerSettings.CommitQueueFactor(childComplexity), true

	case "PlannerSettings.expectedRuntimeFactor":
		if e.complexity.PlannerSettings.ExpectedRuntimeFactor == nil {
			break
		}

		return e.complexity.PlannerSettings.ExpectedRuntimeFactor(childComplexity), true

	case "PlannerSettings.generateTaskFactor":
		if e.complexity.PlannerSettings.GenerateTaskFactor == nil {
			break
		}

		return e.complexity.PlannerSettings.GenerateTaskFactor(childComplexity), true

	case "PlannerSettings.groupVersions":
		if e.complexity.PlannerSettings.GroupVersions == nil {
			break
		}

		return e.complexity.PlannerSettings.GroupVersions(childComplexity), true

	case "PlannerSettings.mainlineTimeInQueueFactor":
		if e.complexity.PlannerSettings.MainlineTimeInQueueFactor == nil {
			break
		}

		return e.complexity.PlannerSettings.MainlineTimeInQueueFactor(childComplexity), true

	case "PlannerSettings.patchFactor":
		if e.complexity.PlannerSettings.PatchFactor == nil {
			break
		}

		return e.complexity.PlannerSettings.PatchFactor(childComplexity), true

	case "PlannerSettings.patchTimeInQueueFactor":
		if e.complexity.PlannerSettings.PatchTimeInQueueFactor == nil {
			break
		}

		return e.complexity.PlannerSettings.PatchTimeInQueueFactor(childComplexity), true

	case "PlannerSettings.targetTime":
		if e.complexity.PlannerSettings.TargetTime == nil {
			break
		}

		return e.complexity.PlannerSettings.TargetTime(childComplexity), true

	case "PlannerSettings.version":
		if e.complexity.PlannerSettings.Version == nil {
			break
		}

		return e.complexity.PlannerSettings.Version(childComplexity), true

	case "Pod.events":
		if e.complexity.Pod.Events == nil {
			break
		}

		args, err := ec.field_Pod_events_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Pod.Events(childComplexity, args["limit"].(*int), args["page"].(*int)), true

	case "Pod.id":
		if e.complexity.Pod.ID == nil {
			break
		}

		return e.complexity.Pod.ID(childComplexity), true

	case "Pod.status":
		if e.complexity.Pod.Status == nil {
			break
		}

		return e.complexity.Pod.Status(childComplexity), true

	case "Pod.task":
		if e.complexity.Pod.Task == nil {
			break
		}

		return e.complexity.Pod.Task(childComplexity), true

	case "Pod.taskContainerCreationOpts":
		if e.complexity.Pod.TaskContainerCreationOpts == nil {
			break
		}

		return e.complexity.Pod.TaskContainerCreationOpts(childComplexity), true

	case "Pod.type":
		if e.complexity.Pod.Type == nil {
			break
		}

		return e.complexity.Pod.Type(childComplexity), true

	case "PodEventLogData.newStatus":
		if e.complexity.PodEventLogData.NewStatus == nil {
			break
		}

		return e.complexity.PodEventLogData.NewStatus(childComplexity), true

	case "PodEventLogData.oldStatus":
		if e.complexity.PodEventLogData.OldStatus == nil {
			break
		}

		return e.complexity.PodEventLogData.OldStatus(childComplexity), true

	case "PodEventLogData.reason":
		if e.complexity.PodEventLogData.Reason == nil {
			break
		}

		return e.complexity.PodEventLogData.Reason(childComplexity), true

	case "PodEventLogData.task":
		if e.complexity.PodEventLogData.Task == nil {
			break
		}

		return e.complexity.PodEventLogData.Task(childComplexity), true

	case "PodEventLogData.taskExecution":
		if e.complexity.PodEventLogData.TaskExecution == nil {
			break
		}

		return e.complexity.PodEventLogData.TaskExecution(childComplexity), true

	case "PodEventLogData.taskID":
		if e.complexity.PodEventLogData.TaskID == nil {
			break
		}

		return e.complexity.PodEventLogData.TaskID(childComplexity), true

	case "PodEventLogData.taskStatus":
		if e.complexity.PodEventLogData.TaskStatus == nil {
			break
		}

		return e.complexity.PodEventLogData.TaskStatus(childComplexity), true

	case "PodEventLogEntry.data":
		if e.complexity.PodEventLogEntry.Data == nil {
			break
		}

		return e.complexity.PodEventLogEntry.Data(childComplexity), true

	case "PodEventLogEntry.eventType":
		if e.complexity.PodEventLogEntry.EventType == nil {
			break
		}

		return e.complexity.PodEventLogEntry.EventType(childComplexity), true

	case "PodEventLogEntry.id":
		if e.complexity.PodEventLogEntry.ID == nil {
			break
		}

		return e.complexity.PodEventLogEntry.ID(childComplexity), true

	case "PodEventLogEntry.processedAt":
		if e.complexity.PodEventLogEntry.ProcessedAt == nil {
			break
		}

		return e.complexity.PodEventLogEntry.ProcessedAt(childComplexity), true

	case "PodEventLogEntry.resourceId":
		if e.complexity.PodEventLogEntry.ResourceId == nil {
			break
		}

		return e.complexity.PodEventLogEntry.ResourceId(childComplexity), true

	case "PodEventLogEntry.resourceType":
		if e.complexity.PodEventLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.PodEventLogEntry.ResourceType(childComplexity), true

	case "PodEventLogEntry.timestamp":
		if e.complexity.PodEventLogEntry.Timestamp == nil {
			break
		}

		return e.complexity.PodEventLogEntry.Timestamp(childComplexity), true

	case "PodEvents.count":
		if e.complexity.PodEvents.Count == nil {
			break
		}

		return e.complexity.PodEvents.Count(childComplexity), true

	case "PodEvents.eventLogEntries":
		if e.complexity.PodEvents.EventLogEntries == nil {
			break
		}

		return e.complexity.PodEvents.EventLogEntries(childComplexity), true

	case "PreconditionScript.path":
		if e.complexity.PreconditionScript.Path == nil {
			break
		}

		return e.complexity.PreconditionScript.Path(childComplexity), true

	case "PreconditionScript.script":
		if e.complexity.PreconditionScript.Script == nil {
			break
		}

		return e.complexity.PreconditionScript.Script(childComplexity), true

	case "Project.admins":
		if e.complexity.Project.Admins == nil {
			break
		}

		return e.complexity.Project.Admins(childComplexity), true

	case "Project.banner":
		if e.complexity.Project.Banner == nil {
			break
		}

		return e.complexity.Project.Banner(childComplexity), true

	case "Project.batchTime":
		if e.complexity.Project.BatchTime == nil {
			break
		}

		return e.complexity.Project.BatchTime(childComplexity), true

	case "Project.branch":
		if e.complexity.Project.Branch == nil {
			break
		}

		return e.complexity.Project.Branch(childComplexity), true

	case "Project.buildBaronSettings":
		if e.complexity.Project.BuildBaronSettings == nil {
			break
		}

		return e.complexity.Project.BuildBaronSettings(childComplexity), true

	case "Project.commitQueue":
		if e.complexity.Project.CommitQueue == nil {
			break
		}

		return e.complexity.Project.CommitQueue(childComplexity), true

	case "Project.containerSizeDefinitions":
		if e.complexity.Project.ContainerSizeDefinitions == nil {
			break
		}

		return e.complexity.Project.ContainerSizeDefinitions(childComplexity), true

	case "Project.deactivatePrevious":
		if e.complexity.Project.DeactivatePrevious == nil {
			break
		}

		return e.complexity.Project.DeactivatePrevious(childComplexity), true

	case "Project.disabledStatsCache":
		if e.complexity.Project.DisabledStatsCache == nil {
			break
		}

		return e.complexity.Project.DisabledStatsCache(childComplexity), true

	case "Project.dispatchingDisabled":
		if e.complexity.Project.DispatchingDisabled == nil {
			break
		}

		return e.complexity.Project.DispatchingDisabled(childComplexity), true

	case "Project.displayName":
		if e.complexity.Project.DisplayName == nil {
			break
		}

		return e.complexity.Project.DisplayName(childComplexity), true

	case "Project.enabled":
		if e.complexity.Project.Enabled == nil {
			break
		}

		return e.complexity.Project.Enabled(childComplexity), true

	case "Project.externalLinks":
		if e.complexity.Project.ExternalLinks == nil {
			break
		}

		return e.complexity.Project.ExternalLinks(childComplexity), true

	case "Project.gitTagAuthorizedTeams":
		if e.complexity.Project.GitTagAuthorizedTeams == nil {
			break
		}

		return e.complexity.Project.GitTagAuthorizedTeams(childComplexity), true

	case "Project.gitTagAuthorizedUsers":
		if e.complexity.Project.GitTagAuthorizedUsers == nil {
			break
		}

		return e.complexity.Project.GitTagAuthorizedUsers(childComplexity), true

	case "Project.gitTagVersionsEnabled":
		if e.complexity.Project.GitTagVersionsEnabled == nil {
			break
		}

		return e.complexity.Project.GitTagVersionsEnabled(childComplexity), true

	case "Project.githubChecksEnabled":
		if e.complexity.Project.GithubChecksEnabled == nil {
			break
		}

		return e.complexity.Project.GithubChecksEnabled(childComplexity), true

	case "Project.githubTriggerAliases":
		if e.complexity.Project.GithubTriggerAliases == nil {
			break
		}

		return e.complexity.Project.GithubTriggerAliases(childComplexity), true

	case "Project.hidden":
		if e.complexity.Project.Hidden == nil {
			break
		}

		return e.complexity.Project.Hidden(childComplexity), true

	case "Project.id":
		if e.complexity.Project.Id == nil {
			break
		}

		return e.complexity.Project.Id(childComplexity), true

	case "Project.identifier":
		if e.complexity.Project.Identifier == nil {
			break
		}

		return e.complexity.Project.Identifier(childComplexity), true

	case "Project.isFavorite":
		if e.complexity.Project.IsFavorite == nil {
			break
		}

		return e.complexity.Project.IsFavorite(childComplexity), true

	case "Project.manualPrTestingEnabled":
		if e.complexity.Project.ManualPRTestingEnabled == nil {
			break
		}

		return e.complexity.Project.ManualPRTestingEnabled(childComplexity), true

	case "Project.notifyOnBuildFailure":
		if e.complexity.Project.NotifyOnBuildFailure == nil {
			break
		}

		return e.complexity.Project.NotifyOnBuildFailure(childComplexity), true

	case "Project.owner":
		if e.complexity.Project.Owner == nil {
			break
		}

		return e.complexity.Project.Owner(childComplexity), true

	case "Project.prTestingEnabled":
		if e.complexity.Project.PRTestingEnabled == nil {
			break
		}

		return e.complexity.Project.PRTestingEnabled(childComplexity), true

	case "Project.parsleyFilters":
		if e.complexity.Project.ParsleyFilters == nil {
			break
		}

		return e.complexity.Project.ParsleyFilters(childComplexity), true

	case "Project.patchTriggerAliases":
		if e.complexity.Project.PatchTriggerAliases == nil {
			break
		}

		return e.complexity.Project.PatchTriggerAliases(childComplexity), true

	case "Project.patches":
		if e.complexity.Project.Patches == nil {
			break
		}

		args, err := ec.field_Project_patches_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Project.Patches(childComplexity, args["patchesInput"].(PatchesInput)), true

	case "Project.patchingDisabled":
		if e.complexity.Project.PatchingDisabled == nil {
			break
		}

		return e.complexity.Project.PatchingDisabled(childComplexity), true

	case "Project.perfEnabled":
		if e.complexity.Project.PerfEnabled == nil {
			break
		}

		return e.complexity.Project.PerfEnabled(childComplexity), true

	case "Project.periodicBuilds":
		if e.complexity.Project.PeriodicBuilds == nil {
			break
		}

		return e.complexity.Project.PeriodicBuilds(childComplexity), true

	case "Project.private":
		if e.complexity.Project.Private == nil {
			break
		}

		return e.complexity.Project.Private(childComplexity), true

	case "Project.projectHealthView":
		if e.complexity.Project.ProjectHealthView == nil {
			break
		}

		return e.complexity.Project.ProjectHealthView(childComplexity), true

	case "Project.remotePath":
		if e.complexity.Project.RemotePath == nil {
			break
		}

		return e.complexity.Project.RemotePath(childComplexity), true

	case "Project.repo":
		if e.complexity.Project.Repo == nil {
			break
		}

		return e.complexity.Project.Repo(childComplexity), true

	case "Project.repoRefId":
		if e.complexity.Project.RepoRefId == nil {
			break
		}

		return e.complexity.Project.RepoRefId(childComplexity), true

	case "Project.repotrackerDisabled":
		if e.complexity.Project.RepotrackerDisabled == nil {
			break
		}

		return e.complexity.Project.RepotrackerDisabled(childComplexity), true

	case "Project.restricted":
		if e.complexity.Project.Restricted == nil {
			break
		}

		return e.complexity.Project.Restricted(childComplexity), true

	case "Project.spawnHostScriptPath":
		if e.complexity.Project.SpawnHostScriptPath == nil {
			break
		}

		return e.complexity.Project.SpawnHostScriptPath(childComplexity), true

	case "Project.stepbackDisabled":
		if e.complexity.Project.StepbackDisabled == nil {
			break
		}

		return e.complexity.Project.StepbackDisabled(childComplexity), true

	case "Project.taskAnnotationSettings":
		if e.complexity.Project.TaskAnnotationSettings == nil {
			break
		}

		return e.complexity.Project.TaskAnnotationSettings(childComplexity), true

	case "Project.taskSync":
		if e.complexity.Project.TaskSync == nil {
			break
		}

		return e.complexity.Project.TaskSync(childComplexity), true

	case "Project.tracksPushEvents":
		if e.complexity.Project.TracksPushEvents == nil {
			break
		}

		return e.complexity.Project.TracksPushEvents(childComplexity), true

	case "Project.triggers":
		if e.complexity.Project.Triggers == nil {
			break
		}

		return e.complexity.Project.Triggers(childComplexity), true

	case "Project.versionControlEnabled":
		if e.complexity.Project.VersionControlEnabled == nil {
			break
		}

		return e.complexity.Project.VersionControlEnabled(childComplexity), true

	case "Project.workstationConfig":
		if e.complexity.Project.WorkstationConfig == nil {
			break
		}

		return e.complexity.Project.WorkstationConfig(childComplexity), true

	case "ProjectAlias.alias":
		if e.complexity.ProjectAlias.Alias == nil {
			break
		}

		return e.complexity.ProjectAlias.Alias(childComplexity), true

	case "ProjectAlias.description":
		if e.complexity.ProjectAlias.Description == nil {
			break
		}

		return e.complexity.ProjectAlias.Description(childComplexity), true

	case "ProjectAlias.gitTag":
		if e.complexity.ProjectAlias.GitTag == nil {
			break
		}

		return e.complexity.ProjectAlias.GitTag(childComplexity), true

	case "ProjectAlias.id":
		if e.complexity.ProjectAlias.ID == nil {
			break
		}

		return e.complexity.ProjectAlias.ID(childComplexity), true

	case "ProjectAlias.parameters":
		if e.complexity.ProjectAlias.Parameters == nil {
			break
		}

		return e.complexity.ProjectAlias.Parameters(childComplexity), true

	case "ProjectAlias.remotePath":
		if e.complexity.ProjectAlias.RemotePath == nil {
			break
		}

		return e.complexity.ProjectAlias.RemotePath(childComplexity), true

	case "ProjectAlias.task":
		if e.complexity.ProjectAlias.Task == nil {
			break
		}

		return e.complexity.ProjectAlias.Task(childComplexity), true

	case "ProjectAlias.taskTags":
		if e.complexity.ProjectAlias.TaskTags == nil {
			break
		}

		return e.complexity.ProjectAlias.TaskTags(childComplexity), true

	case "ProjectAlias.variant":
		if e.complexity.ProjectAlias.Variant == nil {
			break
		}

		return e.complexity.ProjectAlias.Variant(childComplexity), true

	case "ProjectAlias.variantTags":
		if e.complexity.ProjectAlias.VariantTags == nil {
			break
		}

		return e.complexity.ProjectAlias.VariantTags(childComplexity), true

	case "ProjectBanner.text":
		if e.complexity.ProjectBanner.Text == nil {
			break
		}

		return e.complexity.ProjectBanner.Text(childComplexity), true

	case "ProjectBanner.theme":
		if e.complexity.ProjectBanner.Theme == nil {
			break
		}

		return e.complexity.ProjectBanner.Theme(childComplexity), true

	case "ProjectBuildVariant.displayName":
		if e.complexity.ProjectBuildVariant.DisplayName == nil {
			break
		}

		return e.complexity.ProjectBuildVariant.DisplayName(childComplexity), true

	case "ProjectBuildVariant.name":
		if e.complexity.ProjectBuildVariant.Name == nil {
			break
		}

		return e.complexity.ProjectBuildVariant.Name(childComplexity), true

	case "ProjectBuildVariant.tasks":
		if e.complexity.ProjectBuildVariant.Tasks == nil {
			break
		}

		return e.complexity.ProjectBuildVariant.Tasks(childComplexity), true

	case "ProjectEventLogEntry.after":
		if e.complexity.ProjectEventLogEntry.After == nil {
			break
		}

		return e.complexity.ProjectEventLogEntry.After(childComplexity), true

	case "ProjectEventLogEntry.before":
		if e.complexity.ProjectEventLogEntry.Before == nil {
			break
		}

		return e.complexity.ProjectEventLogEntry.Before(childComplexity), true

	case "ProjectEventLogEntry.timestamp":
		if e.complexity.ProjectEventLogEntry.Timestamp == nil {
			break
		}

		return e.complexity.ProjectEventLogEntry.Timestamp(childComplexity), true

	case "ProjectEventLogEntry.user":
		if e.complexity.ProjectEventLogEntry.User == nil {
			break
		}

		return e.complexity.ProjectEventLogEntry.User(childComplexity), true

	case "ProjectEventSettings.aliases":
		if e.complexity.ProjectEventSettings.Aliases == nil {
			break
		}

		return e.complexity.ProjectEventSettings.Aliases(childComplexity), true

	case "ProjectEventSettings.githubWebhooksEnabled":
		if e.complexity.ProjectEventSettings.GithubWebhooksEnabled == nil {
			break
		}

		return e.complexity.ProjectEventSettings.GithubWebhooksEnabled(childComplexity), true

	case "ProjectEventSettings.projectRef":
		if e.complexity.ProjectEventSettings.ProjectRef == nil {
			break
		}

		return e.complexity.ProjectEventSettings.ProjectRef(childComplexity), true

	case "ProjectEventSettings.subscriptions":
		if e.complexity.ProjectEventSettings.Subscriptions == nil {
			break
		}

		return e.complexity.ProjectEventSettings.Subscriptions(childComplexity), true

	case "ProjectEventSettings.vars":
		if e.complexity.ProjectEventSettings.Vars == nil {
			break
		}

		return e.complexity.ProjectEventSettings.Vars(childComplexity), true

	case "ProjectEvents.count":
		if e.complexity.ProjectEvents.Count == nil {
			break
		}

		return e.complexity.ProjectEvents.Count(childComplexity), true

	case "ProjectEvents.eventLogEntries":
		if e.complexity.ProjectEvents.EventLogEntries == nil {
			break
		}

		return e.complexity.ProjectEvents.EventLogEntries(childComplexity), true

	case "ProjectSettings.aliases":
		if e.complexity.ProjectSettings.Aliases == nil {
			break
		}

		return e.complexity.ProjectSettings.Aliases(childComplexity), true

	case "ProjectSettings.githubWebhooksEnabled":
		if e.complexity.ProjectSettings.GithubWebhooksEnabled == nil {
			break
		}

		return e.complexity.ProjectSettings.GithubWebhooksEnabled(childComplexity), true

	case "ProjectSettings.projectRef":
		if e.complexity.ProjectSettings.ProjectRef == nil {
			break
		}

		return e.complexity.ProjectSettings.ProjectRef(childComplexity), true

	case "ProjectSettings.subscriptions":
		if e.complexity.ProjectSettings.Subscriptions == nil {
			break
		}

		return e.complexity.ProjectSettings.Subscriptions(childComplexity), true

	case "ProjectSettings.vars":
		if e.complexity.ProjectSettings.Vars == nil {
			break
		}

		return e.complexity.ProjectSettings.Vars(childComplexity), true

	case "ProjectVars.adminOnlyVars":
		if e.complexity.ProjectVars.AdminOnlyVars == nil {
			break
		}

		return e.complexity.ProjectVars.AdminOnlyVars(childComplexity), true

	case "ProjectVars.privateVars":
		if e.complexity.ProjectVars.PrivateVars == nil {
			break
		}

		return e.complexity.ProjectVars.PrivateVars(childComplexity), true

	case "ProjectVars.vars":
		if e.complexity.ProjectVars.Vars == nil {
			break
		}

		return e.complexity.ProjectVars.Vars(childComplexity), true

	case "PublicKey.key":
		if e.complexity.PublicKey.Key == nil {
			break
		}

		return e.complexity.PublicKey.Key(childComplexity), true

	case "PublicKey.name":
		if e.complexity.PublicKey.Name == nil {
			break
		}

		return e.complexity.PublicKey.Name(childComplexity), true

	case "Query.awsRegions":
		if e.complexity.Query.AwsRegions == nil {
			break
		}

		return e.complexity.Query.AwsRegions(childComplexity), true

	case "Query.bbGetCreatedTickets":
		if e.complexity.Query.BbGetCreatedTickets == nil {
			break
		}

		args, err := ec.field_Query_bbGetCreatedTickets_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BbGetCreatedTickets(childComplexity, args["taskId"].(string)), true

	case "Query.buildBaron":
		if e.complexity.Query.BuildBaron == nil {
			break
		}

		args, err := ec.field_Query_buildBaron_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BuildBaron(childComplexity, args["taskId"].(string), args["execution"].(int)), true

	case "Query.buildVariantsForTaskName":
		if e.complexity.Query.BuildVariantsForTaskName == nil {
			break
		}

		args, err := ec.field_Query_buildVariantsForTaskName_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.BuildVariantsForTaskName(childComplexity, args["projectIdentifier"].(string), args["taskName"].(string)), true

	case "Query.clientConfig":
		if e.complexity.Query.ClientConfig == nil {
			break
		}

		return e.complexity.Query.ClientConfig(childComplexity), true

	case "Query.commitQueue":
		if e.complexity.Query.CommitQueue == nil {
			break
		}

		args, err := ec.field_Query_commitQueue_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CommitQueue(childComplexity, args["projectIdentifier"].(string)), true

	case "Query.distro":
		if e.complexity.Query.Distro == nil {
			break
		}

		args, err := ec.field_Query_distro_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Distro(childComplexity, args["distroId"].(string)), true

	case "Query.distroEvents":
		if e.complexity.Query.DistroEvents == nil {
			break
		}

		args, err := ec.field_Query_distroEvents_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.DistroEvents(childComplexity, args["opts"].(DistroEventsInput)), true

	case "Query.distroTaskQueue":
		if e.complexity.Query.DistroTaskQueue == nil {
			break
		}

		args, err := ec.field_Query_distroTaskQueue_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.DistroTaskQueue(childComplexity, args["distroId"].(string)), true

	case "Query.distros":
		if e.complexity.Query.Distros == nil {
			break
		}

		args, err := ec.field_Query_distros_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Distros(childComplexity, args["onlySpawnable"].(bool)), true

	case "Query.githubProjectConflicts":
		if e.complexity.Query.GithubProjectConflicts == nil {
			break
		}

		args, err := ec.field_Query_githubProjectConflicts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GithubProjectConflicts(childComplexity, args["projectId"].(string)), true

	case "Query.hasVersion":
		if e.complexity.Query.HasVersion == nil {
			break
		}

		args, err := ec.field_Query_hasVersion_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.HasVersion(childComplexity, args["id"].(string)), true

	case "Query.host":
		if e.complexity.Query.Host == nil {
			break
		}

		args, err := ec.field_Query_host_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Host(childComplexity, args["hostId"].(string)), true

	case "Query.hostEvents":
		if e.complexity.Query.HostEvents == nil {
			break
		}

		args, err := ec.field_Query_hostEvents_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.HostEvents(childComplexity, args["hostId"].(string), args["hostTag"].(*string), args["limit"].(*int), args["page"].(*int)), true

	case "Query.hosts":
		if e.complexity.Query.Hosts == nil {
			break
		}

		args, err := ec.field_Query_hosts_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Hosts(childComplexity, args["hostId"].(*string), args["distroId"].(*string), args["currentTaskId"].(*string), args["statuses"].([]string), args["startedBy"].(*string), args["sortBy"].(*HostSortBy), args["sortDir"].(*SortDirection), args["page"].(*int), args["limit"].(*int)), true

	case "Query.instanceTypes":
		if e.complexity.Query.InstanceTypes == nil {
			break
		}

		return e.complexity.Query.InstanceTypes(childComplexity), true

	case "Query.logkeeperBuildMetadata":
		if e.complexity.Query.LogkeeperBuildMetadata == nil {
			break
		}

		args, err := ec.field_Query_logkeeperBuildMetadata_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.LogkeeperBuildMetadata(childComplexity, args["buildId"].(string)), true

	case "Query.mainlineCommits":
		if e.complexity.Query.MainlineCommits == nil {
			break
		}

		args, err := ec.field_Query_mainlineCommits_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.MainlineCommits(childComplexity, args["options"].(MainlineCommitsOptions), args["buildVariantOptions"].(*BuildVariantOptions)), true

	case "Query.myHosts":
		if e.complexity.Query.MyHosts == nil {
			break
		}

		return e.complexity.Query.MyHosts(childComplexity), true

	case "Query.myPublicKeys":
		if e.complexity.Query.MyPublicKeys == nil {
			break
		}

		return e.complexity.Query.MyPublicKeys(childComplexity), true

	case "Query.myVolumes":
		if e.complexity.Query.MyVolumes == nil {
			break
		}

		return e.complexity.Query.MyVolumes(childComplexity), true

	case "Query.patch":
		if e.complexity.Query.Patch == nil {
			break
		}

		args, err := ec.field_Query_patch_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Patch(childComplexity, args["id"].(string)), true

	case "Query.pod":
		if e.complexity.Query.Pod == nil {
			break
		}

		args, err := ec.field_Query_pod_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Pod(childComplexity, args["podId"].(string)), true

	case "Query.project":
		if e.complexity.Query.Project == nil {
			break
		}

		args, err := ec.field_Query_project_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Project(childComplexity, args["projectIdentifier"].(string)), true

	case "Query.projectEvents":
		if e.complexity.Query.ProjectEvents == nil {
			break
		}

		args, err := ec.field_Query_projectEvents_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ProjectEvents(childComplexity, args["identifier"].(string), args["limit"].(*int), args["before"].(*time.Time)), true

	case "Query.projectSettings":
		if e.complexity.Query.ProjectSettings == nil {
			break
		}

		args, err := ec.field_Query_projectSettings_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ProjectSettings(childComplexity, args["identifier"].(string)), true

	case "Query.projects":
		if e.complexity.Query.Projects == nil {
			break
		}

		return e.complexity.Query.Projects(childComplexity), true

	case "Query.repoEvents":
		if e.complexity.Query.RepoEvents == nil {
			break
		}

		args, err := ec.field_Query_repoEvents_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.RepoEvents(childComplexity, args["id"].(string), args["limit"].(*int), args["before"].(*time.Time)), true

	case "Query.repoSettings":
		if e.complexity.Query.RepoSettings == nil {
			break
		}

		args, err := ec.field_Query_repoSettings_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.RepoSettings(childComplexity, args["id"].(string)), true

	case "Query.spruceConfig":
		if e.complexity.Query.SpruceConfig == nil {
			break
		}

		return e.complexity.Query.SpruceConfig(childComplexity), true

	case "Query.subnetAvailabilityZones":
		if e.complexity.Query.SubnetAvailabilityZones == nil {
			break
		}

		return e.complexity.Query.SubnetAvailabilityZones(childComplexity), true

	case "Query.task":
		if e.complexity.Query.Task == nil {
			break
		}

		args, err := ec.field_Query_task_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Task(childComplexity, args["taskId"].(string), args["execution"].(*int)), true

	case "Query.taskAllExecutions":
		if e.complexity.Query.TaskAllExecutions == nil {
			break
		}

		args, err := ec.field_Query_taskAllExecutions_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TaskAllExecutions(childComplexity, args["taskId"].(string)), true

	case "Query.taskNamesForBuildVariant":
		if e.complexity.Query.TaskNamesForBuildVariant == nil {
			break
		}

		args, err := ec.field_Query_taskNamesForBuildVariant_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TaskNamesForBuildVariant(childComplexity, args["projectIdentifier"].(string), args["buildVariant"].(string)), true

	case "Query.taskQueueDistros":
		if e.complexity.Query.TaskQueueDistros == nil {
			break
		}

		return e.complexity.Query.TaskQueueDistros(childComplexity), true

	case "Query.taskTestSample":
		if e.complexity.Query.TaskTestSample == nil {
			break
		}

		args, err := ec.field_Query_taskTestSample_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.TaskTestSample(childComplexity, args["tasks"].([]string), args["filters"].([]*TestFilter)), true

	case "Query.user":
		if e.complexity.Query.User == nil {
			break
		}

		args, err := ec.field_Query_user_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.User(childComplexity, args["userId"].(*string)), true

	case "Query.userConfig":
		if e.complexity.Query.UserConfig == nil {
			break
		}

		return e.complexity.Query.UserConfig(childComplexity), true

	case "Query.userSettings":
		if e.complexity.Query.UserSettings == nil {
			break
		}

		return e.complexity.Query.UserSettings(childComplexity), true

	case "Query.version":
		if e.complexity.Query.Version == nil {
			break
		}

		args, err := ec.field_Query_version_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Version(childComplexity, args["id"].(string)), true

	case "Query.viewableProjectRefs":
		if e.complexity.Query.ViewableProjectRefs == nil {
			break
		}

		return e.complexity.Query.ViewableProjectRefs(childComplexity), true

	case "RepoCommitQueueParams.enabled":
		if e.complexity.RepoCommitQueueParams.Enabled == nil {
			break
		}

		return e.complexity.RepoCommitQueueParams.Enabled(childComplexity), true

	case "RepoCommitQueueParams.mergeMethod":
		if e.complexity.RepoCommitQueueParams.MergeMethod == nil {
			break
		}

		return e.complexity.RepoCommitQueueParams.MergeMethod(childComplexity), true

	case "RepoCommitQueueParams.mergeQueue":
		if e.complexity.RepoCommitQueueParams.MergeQueue == nil {
			break
		}

		return e.complexity.RepoCommitQueueParams.MergeQueue(childComplexity), true

	case "RepoCommitQueueParams.message":
		if e.complexity.RepoCommitQueueParams.Message == nil {
			break
		}

		return e.complexity.RepoCommitQueueParams.Message(childComplexity), true

	case "RepoRef.admins":
		if e.complexity.RepoRef.Admins == nil {
			break
		}

		return e.complexity.RepoRef.Admins(childComplexity), true

	case "RepoRef.batchTime":
		if e.complexity.RepoRef.BatchTime == nil {
			break
		}

		return e.complexity.RepoRef.BatchTime(childComplexity), true

	case "RepoRef.buildBaronSettings":
		if e.complexity.RepoRef.BuildBaronSettings == nil {
			break
		}

		return e.complexity.RepoRef.BuildBaronSettings(childComplexity), true

	case "RepoRef.commitQueue":
		if e.complexity.RepoRef.CommitQueue == nil {
			break
		}

		return e.complexity.RepoRef.CommitQueue(childComplexity), true

	case "RepoRef.containerSizeDefinitions":
		if e.complexity.RepoRef.ContainerSizeDefinitions == nil {
			break
		}

		return e.complexity.RepoRef.ContainerSizeDefinitions(childComplexity), true

	case "RepoRef.deactivatePrevious":
		if e.complexity.RepoRef.DeactivatePrevious == nil {
			break
		}

		return e.complexity.RepoRef.DeactivatePrevious(childComplexity), true

	case "RepoRef.disabledStatsCache":
		if e.complexity.RepoRef.DisabledStatsCache == nil {
			break
		}

		return e.complexity.RepoRef.DisabledStatsCache(childComplexity), true

	case "RepoRef.dispatchingDisabled":
		if e.complexity.RepoRef.DispatchingDisabled == nil {
			break
		}

		return e.complexity.RepoRef.DispatchingDisabled(childComplexity), true

	case "RepoRef.displayName":
		if e.complexity.RepoRef.DisplayName == nil {
			break
		}

		return e.complexity.RepoRef.DisplayName(childComplexity), true

	case "RepoRef.enabled":
		if e.complexity.RepoRef.Enabled == nil {
			break
		}

		return e.complexity.RepoRef.Enabled(childComplexity), true

	case "RepoRef.externalLinks":
		if e.complexity.RepoRef.ExternalLinks == nil {
			break
		}

		return e.complexity.RepoRef.ExternalLinks(childComplexity), true

	case "RepoRef.gitTagAuthorizedTeams":
		if e.complexity.RepoRef.GitTagAuthorizedTeams == nil {
			break
		}

		return e.complexity.RepoRef.GitTagAuthorizedTeams(childComplexity), true

	case "RepoRef.gitTagAuthorizedUsers":
		if e.complexity.RepoRef.GitTagAuthorizedUsers == nil {
			break
		}

		return e.complexity.RepoRef.GitTagAuthorizedUsers(childComplexity), true

	case "RepoRef.gitTagVersionsEnabled":
		if e.complexity.RepoRef.GitTagVersionsEnabled == nil {
			break
		}

		return e.complexity.RepoRef.GitTagVersionsEnabled(childComplexity), true

	case "RepoRef.githubChecksEnabled":
		if e.complexity.RepoRef.GithubChecksEnabled == nil {
			break
		}

		return e.complexity.RepoRef.GithubChecksEnabled(childComplexity), true

	case "RepoRef.githubTriggerAliases":
		if e.complexity.RepoRef.GithubTriggerAliases == nil {
			break
		}

		return e.complexity.RepoRef.GithubTriggerAliases(childComplexity), true

	case "RepoRef.id":
		if e.complexity.RepoRef.Id == nil {
			break
		}

		return e.complexity.RepoRef.Id(childComplexity), true

	case "RepoRef.manualPrTestingEnabled":
		if e.complexity.RepoRef.ManualPRTestingEnabled == nil {
			break
		}

		return e.complexity.RepoRef.ManualPRTestingEnabled(childComplexity), true

	case "RepoRef.notifyOnBuildFailure":
		if e.complexity.RepoRef.NotifyOnBuildFailure == nil {
			break
		}

		return e.complexity.RepoRef.NotifyOnBuildFailure(childComplexity), true

	case "RepoRef.owner":
		if e.complexity.RepoRef.Owner == nil {
			break
		}

		return e.complexity.RepoRef.Owner(childComplexity), true

	case "RepoRef.prTestingEnabled":
		if e.complexity.RepoRef.PRTestingEnabled == nil {
			break
		}

		return e.complexity.RepoRef.PRTestingEnabled(childComplexity), true

	case "RepoRef.patchTriggerAliases":
		if e.complexity.RepoRef.PatchTriggerAliases == nil {
			break
		}

		return e.complexity.RepoRef.PatchTriggerAliases(childComplexity), true

	case "RepoRef.patchingDisabled":
		if e.complexity.RepoRef.PatchingDisabled == nil {
			break
		}

		return e.complexity.RepoRef.PatchingDisabled(childComplexity), true

	case "RepoRef.perfEnabled":
		if e.complexity.RepoRef.PerfEnabled == nil {
			break
		}

		return e.complexity.RepoRef.PerfEnabled(childComplexity), true

	case "RepoRef.periodicBuilds":
		if e.complexity.RepoRef.PeriodicBuilds == nil {
			break
		}

		return e.complexity.RepoRef.PeriodicBuilds(childComplexity), true

	case "RepoRef.private":
		if e.complexity.RepoRef.Private == nil {
			break
		}

		return e.complexity.RepoRef.Private(childComplexity), true

	case "RepoRef.remotePath":
		if e.complexity.RepoRef.RemotePath == nil {
			break
		}

		return e.complexity.RepoRef.RemotePath(childComplexity), true

	case "RepoRef.repo":
		if e.complexity.RepoRef.Repo == nil {
			break
		}

		return e.complexity.RepoRef.Repo(childComplexity), true

	case "RepoRef.repotrackerDisabled":
		if e.complexity.RepoRef.RepotrackerDisabled == nil {
			break
		}

		return e.complexity.RepoRef.RepotrackerDisabled(childComplexity), true

	case "RepoRef.restricted":
		if e.complexity.RepoRef.Restricted == nil {
			break
		}

		return e.complexity.RepoRef.Restricted(childComplexity), true

	case "RepoRef.spawnHostScriptPath":
		if e.complexity.RepoRef.SpawnHostScriptPath == nil {
			break
		}

		return e.complexity.RepoRef.SpawnHostScriptPath(childComplexity), true

	case "RepoRef.stepbackDisabled":
		if e.complexity.RepoRef.StepbackDisabled == nil {
			break
		}

		return e.complexity.RepoRef.StepbackDisabled(childComplexity), true

	case "RepoRef.taskAnnotationSettings":
		if e.complexity.RepoRef.TaskAnnotationSettings == nil {
			break
		}

		return e.complexity.RepoRef.TaskAnnotationSettings(childComplexity), true

	case "RepoRef.taskSync":
		if e.complexity.RepoRef.TaskSync == nil {
			break
		}

		return e.complexity.RepoRef.TaskSync(childComplexity), true

	case "RepoRef.tracksPushEvents":
		if e.complexity.RepoRef.TracksPushEvents == nil {
			break
		}

		return e.complexity.RepoRef.TracksPushEvents(childComplexity), true

	case "RepoRef.triggers":
		if e.complexity.RepoRef.Triggers == nil {
			break
		}

		return e.complexity.RepoRef.Triggers(childComplexity), true

	case "RepoRef.versionControlEnabled":
		if e.complexity.RepoRef.VersionControlEnabled == nil {
			break
		}

		return e.complexity.RepoRef.VersionControlEnabled(childComplexity), true

	case "RepoRef.workstationConfig":
		if e.complexity.RepoRef.WorkstationConfig == nil {
			break
		}

		return e.complexity.RepoRef.WorkstationConfig(childComplexity), true

	case "RepoSettings.aliases":
		if e.complexity.RepoSettings.Aliases == nil {
			break
		}

		return e.complexity.RepoSettings.Aliases(childComplexity), true

	case "RepoSettings.githubWebhooksEnabled":
		if e.complexity.RepoSettings.GithubWebhooksEnabled == nil {
			break
		}

		return e.complexity.RepoSettings.GithubWebhooksEnabled(childComplexity), true

	case "RepoSettings.projectRef":
		if e.complexity.RepoSettings.ProjectRef == nil {
			break
		}

		return e.complexity.RepoSettings.ProjectRef(childComplexity), true

	case "RepoSettings.subscriptions":
		if e.complexity.RepoSettings.Subscriptions == nil {
			break
		}

		return e.complexity.RepoSettings.Subscriptions(childComplexity), true

	case "RepoSettings.vars":
		if e.complexity.RepoSettings.Vars == nil {
			break
		}

		return e.complexity.RepoSettings.Vars(childComplexity), true

	case "RepoTaskSyncOptions.configEnabled":
		if e.complexity.RepoTaskSyncOptions.ConfigEnabled == nil {
			break
		}

		return e.complexity.RepoTaskSyncOptions.ConfigEnabled(childComplexity), true

	case "RepoTaskSyncOptions.patchEnabled":
		if e.complexity.RepoTaskSyncOptions.PatchEnabled == nil {
			break
		}

		return e.complexity.RepoTaskSyncOptions.PatchEnabled(childComplexity), true

	case "RepoWorkstationConfig.gitClone":
		if e.complexity.RepoWorkstationConfig.GitClone == nil {
			break
		}

		return e.complexity.RepoWorkstationConfig.GitClone(childComplexity), true

	case "RepoWorkstationConfig.setupCommands":
		if e.complexity.RepoWorkstationConfig.SetupCommands == nil {
			break
		}

		return e.complexity.RepoWorkstationConfig.SetupCommands(childComplexity), true

	case "ResourceLimits.lockedMemoryKb":
		if e.complexity.ResourceLimits.LockedMemoryKB == nil {
			break
		}

		return e.complexity.ResourceLimits.LockedMemoryKB(childComplexity), true

	case "ResourceLimits.numFiles":
		if e.complexity.ResourceLimits.NumFiles == nil {
			break
		}

		return e.complexity.ResourceLimits.NumFiles(childComplexity), true

	case "ResourceLimits.numProcesses":
		if e.complexity.ResourceLimits.NumProcesses == nil {
			break
		}

		return e.complexity.ResourceLimits.NumProcesses(childComplexity), true

	case "ResourceLimits.numTasks":
		if e.complexity.ResourceLimits.NumTasks == nil {
			break
		}

		return e.complexity.ResourceLimits.NumTasks(childComplexity), true

	case "ResourceLimits.virtualMemoryKb":
		if e.complexity.ResourceLimits.VirtualMemoryKB == nil {
			break
		}

		return e.complexity.ResourceLimits.VirtualMemoryKB(childComplexity), true

	case "SaveDistroPayload.distro":
		if e.complexity.SaveDistroPayload.Distro == nil {
			break
		}

		return e.complexity.SaveDistroPayload.Distro(childComplexity), true

	case "SaveDistroPayload.hostCount":
		if e.complexity.SaveDistroPayload.HostCount == nil {
			break
		}

		return e.complexity.SaveDistroPayload.HostCount(childComplexity), true

	case "SearchReturnInfo.featuresURL":
		if e.complexity.SearchReturnInfo.FeaturesURL == nil {
			break
		}

		return e.complexity.SearchReturnInfo.FeaturesURL(childComplexity), true

	case "SearchReturnInfo.issues":
		if e.complexity.SearchReturnInfo.Issues == nil {
			break
		}

		return e.complexity.SearchReturnInfo.Issues(childComplexity), true

	case "SearchReturnInfo.search":
		if e.complexity.SearchReturnInfo.Search == nil {
			break
		}

		return e.complexity.SearchReturnInfo.Search(childComplexity), true

	case "SearchReturnInfo.source":
		if e.complexity.SearchReturnInfo.Source == nil {
			break
		}

		return e.complexity.SearchReturnInfo.Source(childComplexity), true

	case "Selector.data":
		if e.complexity.Selector.Data == nil {
			break
		}

		return e.complexity.Selector.Data(childComplexity), true

	case "Selector.type":
		if e.complexity.Selector.Type == nil {
			break
		}

		return e.complexity.Selector.Type(childComplexity), true

	case "SlackConfig.name":
		if e.complexity.SlackConfig.Name == nil {
			break
		}

		return e.complexity.SlackConfig.Name(childComplexity), true

	case "Source.author":
		if e.complexity.Source.Author == nil {
			break
		}

		return e.complexity.Source.Author(childComplexity), true

	case "Source.requester":
		if e.complexity.Source.Requester == nil {
			break
		}

		return e.complexity.Source.Requester(childComplexity), true

	case "Source.time":
		if e.complexity.Source.Time == nil {
			break
		}

		return e.complexity.Source.Time(childComplexity), true

	case "SpawnHostConfig.spawnHostsPerUser":
		if e.complexity.SpawnHostConfig.SpawnHostsPerUser == nil {
			break
		}

		return e.complexity.SpawnHostConfig.SpawnHostsPerUser(childComplexity), true

	case "SpawnHostConfig.unexpirableHostsPerUser":
		if e.complexity.SpawnHostConfig.UnexpirableHostsPerUser == nil {
			break
		}

		return e.complexity.SpawnHostConfig.UnexpirableHostsPerUser(childComplexity), true

	case "SpawnHostConfig.unexpirableVolumesPerUser":
		if e.complexity.SpawnHostConfig.UnexpirableVolumesPerUser == nil {
			break
		}

		return e.complexity.SpawnHostConfig.UnexpirableVolumesPerUser(childComplexity), true

	case "SpruceConfig.banner":
		if e.complexity.SpruceConfig.Banner == nil {
			break
		}

		return e.complexity.SpruceConfig.Banner(childComplexity), true

	case "SpruceConfig.bannerTheme":
		if e.complexity.SpruceConfig.BannerTheme == nil {
			break
		}

		return e.complexity.SpruceConfig.BannerTheme(childComplexity), true

	case "SpruceConfig.githubOrgs":
		if e.complexity.SpruceConfig.GithubOrgs == nil {
			break
		}

		return e.complexity.SpruceConfig.GithubOrgs(childComplexity), true

	case "SpruceConfig.jira":
		if e.complexity.SpruceConfig.Jira == nil {
			break
		}

		return e.complexity.SpruceConfig.Jira(childComplexity), true

	case "SpruceConfig.providers":
		if e.complexity.SpruceConfig.Providers == nil {
			break
		}

		return e.complexity.SpruceConfig.Providers(childComplexity), true

	case "SpruceConfig.slack":
		if e.complexity.SpruceConfig.Slack == nil {
			break
		}

		return e.complexity.SpruceConfig.Slack(childComplexity), true

	case "SpruceConfig.spawnHost":
		if e.complexity.SpruceConfig.Spawnhost == nil {
			break
		}

		return e.complexity.SpruceConfig.Spawnhost(childComplexity), true

	case "SpruceConfig.ui":
		if e.complexity.SpruceConfig.Ui == nil {
			break
		}

		return e.complexity.SpruceConfig.Ui(childComplexity), true

	case "StatusCount.count":
		if e.complexity.StatusCount.Count == nil {
			break
		}

		return e.complexity.StatusCount.Count(childComplexity), true

	case "StatusCount.status":
		if e.complexity.StatusCount.Status == nil {
			break
		}

		return e.complexity.StatusCount.Status(childComplexity), true

	case "Subscriber.emailSubscriber":
		if e.complexity.Subscriber.EmailSubscriber == nil {
			break
		}

		return e.complexity.Subscriber.EmailSubscriber(childComplexity), true

	case "Subscriber.githubCheckSubscriber":
		if e.complexity.Subscriber.GithubCheckSubscriber == nil {
			break
		}

		return e.complexity.Subscriber.GithubCheckSubscriber(childComplexity), true

	case "Subscriber.githubPRSubscriber":
		if e.complexity.Subscriber.GithubPRSubscriber == nil {
			break
		}

		return e.complexity.Subscriber.GithubPRSubscriber(childComplexity), true

	case "Subscriber.jiraCommentSubscriber":
		if e.complexity.Subscriber.JiraCommentSubscriber == nil {
			break
		}

		return e.complexity.Subscriber.JiraCommentSubscriber(childComplexity), true

	case "Subscriber.jiraIssueSubscriber":
		if e.complexity.Subscriber.JiraIssueSubscriber == nil {
			break
		}

		return e.complexity.Subscriber.JiraIssueSubscriber(childComplexity), true

	case "Subscriber.slackSubscriber":
		if e.complexity.Subscriber.SlackSubscriber == nil {
			break
		}

		return e.complexity.Subscriber.SlackSubscriber(childComplexity), true

	case "Subscriber.webhookSubscriber":
		if e.complexity.Subscriber.WebhookSubscriber == nil {
			break
		}

		return e.complexity.Subscriber.WebhookSubscriber(childComplexity), true

	case "SubscriberWrapper.subscriber":
		if e.complexity.SubscriberWrapper.Subscriber == nil {
			break
		}

		return e.complexity.SubscriberWrapper.Subscriber(childComplexity), true

	case "SubscriberWrapper.type":
		if e.complexity.SubscriberWrapper.Type == nil {
			break
		}

		return e.complexity.SubscriberWrapper.Type(childComplexity), true

	case "Task.abortInfo":
		if e.complexity.Task.AbortInfo == nil {
			break
		}

		return e.complexity.Task.AbortInfo(childComplexity), true

	case "Task.aborted":
		if e.complexity.Task.Aborted == nil {
			break
		}

		return e.complexity.Task.Aborted(childComplexity), true

	case "Task.activated":
		if e.complexity.Task.Activated == nil {
			break
		}

		return e.complexity.Task.Activated(childComplexity), true

	case "Task.activatedBy":
		if e.complexity.Task.ActivatedBy == nil {
			break
		}

		return e.complexity.Task.ActivatedBy(childComplexity), true

	case "Task.activatedTime":
		if e.complexity.Task.ActivatedTime == nil {
			break
		}

		return e.complexity.Task.ActivatedTime(childComplexity), true

	case "Task.ami":
		if e.complexity.Task.Ami == nil {
			break
		}

		return e.complexity.Task.Ami(childComplexity), true

	case "Task.annotation":
		if e.complexity.Task.Annotation == nil {
			break
		}

		return e.complexity.Task.Annotation(childComplexity), true

	case "Task.baseStatus":
		if e.complexity.Task.BaseStatus == nil {
			break
		}

		return e.complexity.Task.BaseStatus(childComplexity), true

	case "Task.baseTask":
		if e.complexity.Task.BaseTask == nil {
			break
		}

		return e.complexity.Task.BaseTask(childComplexity), true

	case "Task.blocked":
		if e.complexity.Task.Blocked == nil {
			break
		}

		return e.complexity.Task.Blocked(childComplexity), true

	case "Task.buildId":
		if e.complexity.Task.BuildId == nil {
			break
		}

		return e.complexity.Task.BuildId(childComplexity), true

	case "Task.buildVariant":
		if e.complexity.Task.BuildVariant == nil {
			break
		}

		return e.complexity.Task.BuildVariant(childComplexity), true

	case "Task.buildVariantDisplayName":
		if e.complexity.Task.BuildVariantDisplayName == nil {
			break
		}

		return e.complexity.Task.BuildVariantDisplayName(childComplexity), true

	case "Task.canAbort":
		if e.complexity.Task.CanAbort == nil {
			break
		}

		return e.complexity.Task.CanAbort(childComplexity), true

	case "Task.canDisable":
		if e.complexity.Task.CanDisable == nil {
			break
		}

		return e.complexity.Task.CanDisable(childComplexity), true

	case "Task.canModifyAnnotation":
		if e.complexity.Task.CanModifyAnnotation == nil {
			break
		}

		return e.complexity.Task.CanModifyAnnotation(childComplexity), true

	case "Task.canOverrideDependencies":
		if e.complexity.Task.CanOverrideDependencies == nil {
			break
		}

		return e.complexity.Task.CanOverrideDependencies(childComplexity), true

	case "Task.canRestart":
		if e.complexity.Task.CanRestart == nil {
			break
		}

		return e.complexity.Task.CanRestart(childComplexity), true

	case "Task.canSchedule":
		if e.complexity.Task.CanSchedule == nil {
			break
		}

		return e.complexity.Task.CanSchedule(childComplexity), true

	case "Task.canSetPriority":
		if e.complexity.Task.CanSetPriority == nil {
			break
		}

		return e.complexity.Task.CanSetPriority(childComplexity), true

	case "Task.canSync":
		if e.complexity.Task.CanSync == nil {
			break
		}

		return e.complexity.Task.CanSync(childComplexity), true

	case "Task.canUnschedule":
		if e.complexity.Task.CanUnschedule == nil {
			break
		}

		return e.complexity.Task.CanUnschedule(childComplexity), true

	case "Task.containerAllocatedTime":
		if e.complexity.Task.ContainerAllocatedTime == nil {
			break
		}

		return e.complexity.Task.ContainerAllocatedTime(childComplexity), true

	case "Task.createTime":
		if e.complexity.Task.CreateTime == nil {
			break
		}

		return e.complexity.Task.CreateTime(childComplexity), true

	case "Task.dependsOn":
		if e.complexity.Task.DependsOn == nil {
			break
		}

		return e.complexity.Task.DependsOn(childComplexity), true

	case "Task.details":
		if e.complexity.Task.Details == nil {
			break
		}

		return e.complexity.Task.Details(childComplexity), true

	case "Task.dispatchTime":
		if e.complexity.Task.DispatchTime == nil {
			break
		}

		return e.complexity.Task.DispatchTime(childComplexity), true

	case "Task.displayName":
		if e.complexity.Task.DisplayName == nil {
			break
		}

		return e.complexity.Task.DisplayName(childComplexity), true

	case "Task.displayOnly":
		if e.complexity.Task.DisplayOnly == nil {
			break
		}

		return e.complexity.Task.DisplayOnly(childComplexity), true

	case "Task.displayTask":
		if e.complexity.Task.DisplayTask == nil {
			break
		}

		return e.complexity.Task.DisplayTask(childComplexity), true

	case "Task.distroId":
		if e.complexity.Task.DistroId == nil {
			break
		}

		return e.complexity.Task.DistroId(childComplexity), true

	case "Task.estimatedStart":
		if e.complexity.Task.EstimatedStart == nil {
			break
		}

		return e.complexity.Task.EstimatedStart(childComplexity), true

	case "Task.execution":
		if e.complexity.Task.Execution == nil {
			break
		}

		return e.complexity.Task.Execution(childComplexity), true

	case "Task.executionTasks":
		if e.complexity.Task.ExecutionTasks == nil {
			break
		}

		return e.complexity.Task.ExecutionTasks(childComplexity), true

	case "Task.executionTasksFull":
		if e.complexity.Task.ExecutionTasksFull == nil {
			break
		}

		return e.complexity.Task.ExecutionTasksFull(childComplexity), true

	case "Task.expectedDuration":
		if e.complexity.Task.ExpectedDuration == nil {
			break
		}

		return e.complexity.Task.ExpectedDuration(childComplexity), true

	case "Task.failedTestCount":
		if e.complexity.Task.FailedTestCount == nil {
			break
		}

		return e.complexity.Task.FailedTestCount(childComplexity), true

	case "Task.finishTime":
		if e.complexity.Task.FinishTime == nil {
			break
		}

		return e.complexity.Task.FinishTime(childComplexity), true

	case "Task.generateTask":
		if e.complexity.Task.GenerateTask == nil {
			break
		}

		return e.complexity.Task.GenerateTask(childComplexity), true

	case "Task.generatedBy":
		if e.complexity.Task.GeneratedBy == nil {
			break
		}

		return e.complexity.Task.GeneratedBy(childComplexity), true

	case "Task.generatedByName":
		if e.complexity.Task.GeneratedByName == nil {
			break
		}

		return e.complexity.Task.GeneratedByName(childComplexity), true

	case "Task.hostId":
		if e.complexity.Task.HostId == nil {
			break
		}

		return e.complexity.Task.HostId(childComplexity), true

	case "Task.id":
		if e.complexity.Task.Id == nil {
			break
		}

		return e.complexity.Task.Id(childComplexity), true

	case "Task.ingestTime":
		if e.complexity.Task.IngestTime == nil {
			break
		}

		return e.complexity.Task.IngestTime(childComplexity), true

	case "Task.isPerfPluginEnabled":
		if e.complexity.Task.IsPerfPluginEnabled == nil {
			break
		}

		return e.complexity.Task.IsPerfPluginEnabled(childComplexity), true

	case "Task.latestExecution":
		if e.complexity.Task.LatestExecution == nil {
			break
		}

		return e.complexity.Task.LatestExecution(childComplexity), true

	case "Task.logs":
		if e.complexity.Task.Logs == nil {
			break
		}

		return e.complexity.Task.Logs(childComplexity), true

	case "Task.minQueuePosition":
		if e.complexity.Task.MinQueuePosition == nil {
			break
		}

		return e.complexity.Task.MinQueuePosition(childComplexity), true

	case "Task.order":
		if e.complexity.Task.Order == nil {
			break
		}

		return e.complexity.Task.Order(childComplexity), true

	case "Task.patch":
		if e.complexity.Task.Patch == nil {
			break
		}

		return e.complexity.Task.Patch(childComplexity), true

	case "Task.patchNumber":
		if e.complexity.Task.PatchNumber == nil {
			break
		}

		return e.complexity.Task.PatchNumber(childComplexity), true

	case "Task.pod":
		if e.complexity.Task.Pod == nil {
			break
		}

		return e.complexity.Task.Pod(childComplexity), true

	case "Task.priority":
		if e.complexity.Task.Priority == nil {
			break
		}

		return e.complexity.Task.Priority(childComplexity), true

	case "Task.project":
		if e.complexity.Task.Project == nil {
			break
		}

		return e.complexity.Task.Project(childComplexity), true

	case "Task.projectId":
		if e.complexity.Task.ProjectId == nil {
			break
		}

		return e.complexity.Task.ProjectId(childComplexity), true

	case "Task.projectIdentifier":
		if e.complexity.Task.ProjectIdentifier == nil {
			break
		}

		return e.complexity.Task.ProjectIdentifier(childComplexity), true

	case "Task.requester":
		if e.complexity.Task.Requester == nil {
			break
		}

		return e.complexity.Task.Requester(childComplexity), true

	case "Task.resetWhenFinished":
		if e.complexity.Task.ResetWhenFinished == nil {
			break
		}

		return e.complexity.Task.ResetWhenFinished(childComplexity), true

	case "Task.revision":
		if e.complexity.Task.Revision == nil {
			break
		}

		return e.complexity.Task.Revision(childComplexity), true

	case "Task.scheduledTime":
		if e.complexity.Task.ScheduledTime == nil {
			break
		}

		return e.complexity.Task.ScheduledTime(childComplexity), true

	case "Task.spawnHostLink":
		if e.complexity.Task.SpawnHostLink == nil {
			break
		}

		return e.complexity.Task.SpawnHostLink(childComplexity), true

	case "Task.startTime":
		if e.complexity.Task.StartTime == nil {
			break
		}

		return e.complexity.Task.StartTime(childComplexity), true

	case "Task.status":
		if e.complexity.Task.Status == nil {
			break
		}

		return e.complexity.Task.Status(childComplexity), true

	case "Task.taskFiles":
		if e.complexity.Task.TaskFiles == nil {
			break
		}

		return e.complexity.Task.TaskFiles(childComplexity), true

	case "Task.taskGroup":
		if e.complexity.Task.TaskGroup == nil {
			break
		}

		return e.complexity.Task.TaskGroup(childComplexity), true

	case "Task.taskGroupMaxHosts":
		if e.complexity.Task.TaskGroupMaxHosts == nil {
			break
		}

		return e.complexity.Task.TaskGroupMaxHosts(childComplexity), true

	case "Task.taskLogs":
		if e.complexity.Task.TaskLogs == nil {
			break
		}

		return e.complexity.Task.TaskLogs(childComplexity), true

	case "Task.tests":
		if e.complexity.Task.Tests == nil {
			break
		}

		args, err := ec.field_Task_tests_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Task.Tests(childComplexity, args["opts"].(*TestFilterOptions)), true

	case "Task.timeTaken":
		if e.complexity.Task.TimeTaken == nil {
			break
		}

		return e.complexity.Task.TimeTaken(childComplexity), true

	case "Task.totalTestCount":
		if e.complexity.Task.TotalTestCount == nil {
			break
		}

		return e.complexity.Task.TotalTestCount(childComplexity), true

	case "Task.versionMetadata":
		if e.complexity.Task.VersionMetadata == nil {
			break
		}

		return e.complexity.Task.VersionMetadata(childComplexity), true

	case "TaskAnnotationSettings.fileTicketWebhook":
		if e.complexity.TaskAnnotationSettings.FileTicketWebhook == nil {
			break
		}

		return e.complexity.TaskAnnotationSettings.FileTicketWebhook(childComplexity), true

	case "TaskAnnotationSettings.jiraCustomFields":
		if e.complexity.TaskAnnotationSettings.JiraCustomFields == nil {
			break
		}

		return e.complexity.TaskAnnotationSettings.JiraCustomFields(childComplexity), true

	case "TaskContainerCreationOpts.arch":
		if e.complexity.TaskContainerCreationOpts.Arch == nil {
			break
		}

		return e.complexity.TaskContainerCreationOpts.Arch(childComplexity), true

	case "TaskContainerCreationOpts.cpu":
		if e.complexity.TaskContainerCreationOpts.CPU == nil {
			break
		}

		return e.complexity.TaskContainerCreationOpts.CPU(childComplexity), true

	case "TaskContainerCreationOpts.image":
		if e.complexity.TaskContainerCreationOpts.Image == nil {
			break
		}

		return e.complexity.TaskContainerCreationOpts.Image(childComplexity), true

	case "TaskContainerCreationOpts.memoryMB":
		if e.complexity.TaskContainerCreationOpts.MemoryMB == nil {
			break
		}

		return e.complexity.TaskContainerCreationOpts.MemoryMB(childComplexity), true

	case "TaskContainerCreationOpts.os":
		if e.complexity.TaskContainerCreationOpts.Os == nil {
			break
		}

		return e.complexity.TaskContainerCreationOpts.Os(childComplexity), true

	case "TaskContainerCreationOpts.workingDir":
		if e.complexity.TaskContainerCreationOpts.WorkingDir == nil {
			break
		}

		return e.complexity.TaskContainerCreationOpts.WorkingDir(childComplexity), true

	case "TaskEndDetail.description":
		if e.complexity.TaskEndDetail.Description == nil {
			break
		}

		return e.complexity.TaskEndDetail.Description(childComplexity), true

	case "TaskEndDetail.oomTracker":
		if e.complexity.TaskEndDetail.OOMTracker == nil {
			break
		}

		return e.complexity.TaskEndDetail.OOMTracker(childComplexity), true

	case "TaskEndDetail.status":
		if e.complexity.TaskEndDetail.Status == nil {
			break
		}

		return e.complexity.TaskEndDetail.Status(childComplexity), true

	case "TaskEndDetail.timedOut":
		if e.complexity.TaskEndDetail.TimedOut == nil {
			break
		}

		return e.complexity.TaskEndDetail.TimedOut(childComplexity), true

	case "TaskEndDetail.timeoutType":
		if e.complexity.TaskEndDetail.TimeoutType == nil {
			break
		}

		return e.complexity.TaskEndDetail.TimeoutType(childComplexity), true

	case "TaskEndDetail.traceID":
		if e.complexity.TaskEndDetail.TraceID == nil {
			break
		}

		return e.complexity.TaskEndDetail.TraceID(childComplexity), true

	case "TaskEndDetail.type":
		if e.complexity.TaskEndDetail.Type == nil {
			break
		}

		return e.complexity.TaskEndDetail.Type(childComplexity), true

	case "TaskEventLogData.hostId":
		if e.complexity.TaskEventLogData.HostId == nil {
			break
		}

		return e.complexity.TaskEventLogData.HostId(childComplexity), true

	case "TaskEventLogData.jiraIssue":
		if e.complexity.TaskEventLogData.JiraIssue == nil {
			break
		}

		return e.complexity.TaskEventLogData.JiraIssue(childComplexity), true

	case "TaskEventLogData.jiraLink":
		if e.complexity.TaskEventLogData.JiraLink == nil {
			break
		}

		return e.complexity.TaskEventLogData.JiraLink(childComplexity), true

	case "TaskEventLogData.podId":
		if e.complexity.TaskEventLogData.PodId == nil {
			break
		}

		return e.complexity.TaskEventLogData.PodId(childComplexity), true

	case "TaskEventLogData.priority":
		if e.complexity.TaskEventLogData.Priority == nil {
			break
		}

		return e.complexity.TaskEventLogData.Priority(childComplexity), true

	case "TaskEventLogData.status":
		if e.complexity.TaskEventLogData.Status == nil {
			break
		}

		return e.complexity.TaskEventLogData.Status(childComplexity), true

	case "TaskEventLogData.timestamp":
		if e.complexity.TaskEventLogData.Timestamp == nil {
			break
		}

		return e.complexity.TaskEventLogData.Timestamp(childComplexity), true

	case "TaskEventLogData.userId":
		if e.complexity.TaskEventLogData.UserId == nil {
			break
		}

		return e.complexity.TaskEventLogData.UserId(childComplexity), true

	case "TaskEventLogEntry.data":
		if e.complexity.TaskEventLogEntry.Data == nil {
			break
		}

		return e.complexity.TaskEventLogEntry.Data(childComplexity), true

	case "TaskEventLogEntry.eventType":
		if e.complexity.TaskEventLogEntry.EventType == nil {
			break
		}

		return e.complexity.TaskEventLogEntry.EventType(childComplexity), true

	case "TaskEventLogEntry.id":
		if e.complexity.TaskEventLogEntry.ID == nil {
			break
		}

		return e.complexity.TaskEventLogEntry.ID(childComplexity), true

	case "TaskEventLogEntry.processedAt":
		if e.complexity.TaskEventLogEntry.ProcessedAt == nil {
			break
		}

		return e.complexity.TaskEventLogEntry.ProcessedAt(childComplexity), true

	case "TaskEventLogEntry.resourceId":
		if e.complexity.TaskEventLogEntry.ResourceId == nil {
			break
		}

		return e.complexity.TaskEventLogEntry.ResourceId(childComplexity), true

	case "TaskEventLogEntry.resourceType":
		if e.complexity.TaskEventLogEntry.ResourceType == nil {
			break
		}

		return e.complexity.TaskEventLogEntry.ResourceType(childComplexity), true

	case "TaskEventLogEntry.timestamp":
		if e.complexity.TaskEventLogEntry.Timestamp == nil {
			break
		}

		return e.complexity.TaskEventLogEntry.Timestamp(childComplexity), true

	case "TaskFiles.fileCount":
		if e.complexity.TaskFiles.FileCount == nil {
			break
		}

		return e.complexity.TaskFiles.FileCount(childComplexity), true

	case "TaskFiles.groupedFiles":
		if e.complexity.TaskFiles.GroupedFiles == nil {
			break
		}

		return e.complexity.TaskFiles.GroupedFiles(childComplexity), true

	case "TaskInfo.id":
		if e.complexity.TaskInfo.Id == nil {
			break
		}

		return e.complexity.TaskInfo.Id(childComplexity), true

	case "TaskInfo.name":
		if e.complexity.TaskInfo.Name == nil {
			break
		}

		return e.complexity.TaskInfo.Name(childComplexity), true

	case "TaskLogLinks.agentLogLink":
		if e.complexity.TaskLogLinks.AgentLogLink == nil {
			break
		}

		return e.complexity.TaskLogLinks.AgentLogLink(childComplexity), true

	case "TaskLogLinks.allLogLink":
		if e.complexity.TaskLogLinks.AllLogLink == nil {
			break
		}

		return e.complexity.TaskLogLinks.AllLogLink(childComplexity), true

	case "TaskLogLinks.eventLogLink":
		if e.complexity.TaskLogLinks.EventLogLink == nil {
			break
		}

		return e.complexity.TaskLogLinks.EventLogLink(childComplexity), true

	case "TaskLogLinks.systemLogLink":
		if e.complexity.TaskLogLinks.SystemLogLink == nil {
			break
		}

		return e.complexity.TaskLogLinks.SystemLogLink(childComplexity), true

	case "TaskLogLinks.taskLogLink":
		if e.complexity.TaskLogLinks.TaskLogLink == nil {
			break
		}

		return e.complexity.TaskLogLinks.TaskLogLink(childComplexity), true

	case "TaskLogs.agentLogs":
		if e.complexity.TaskLogs.AgentLogs == nil {
			break
		}

		return e.complexity.TaskLogs.AgentLogs(childComplexity), true

	case "TaskLogs.allLogs":
		if e.complexity.TaskLogs.AllLogs == nil {
			break
		}

		return e.complexity.TaskLogs.AllLogs(childComplexity), true

	case "TaskLogs.defaultLogger":
		if e.complexity.TaskLogs.DefaultLogger == nil {
			break
		}

		return e.complexity.TaskLogs.DefaultLogger(childComplexity), true

	case "TaskLogs.eventLogs":
		if e.complexity.TaskLogs.EventLogs == nil {
			break
		}

		return e.complexity.TaskLogs.EventLogs(childComplexity), true

	case "TaskLogs.execution":
		if e.complexity.TaskLogs.Execution == nil {
			break
		}

		return e.complexity.TaskLogs.Execution(childComplexity), true

	case "TaskLogs.systemLogs":
		if e.complexity.TaskLogs.SystemLogs == nil {
			break
		}

		return e.complexity.TaskLogs.SystemLogs(childComplexity), true

	case "TaskLogs.taskId":
		if e.complexity.TaskLogs.TaskID == nil {
			break
		}

		return e.complexity.TaskLogs.TaskID(childComplexity), true

	case "TaskLogs.taskLogs":
		if e.complexity.TaskLogs.TaskLogs == nil {
			break
		}

		return e.complexity.TaskLogs.TaskLogs(childComplexity), true

	case "TaskQueueDistro.hostCount":
		if e.complexity.TaskQueueDistro.HostCount == nil {
			break
		}

		return e.complexity.TaskQueueDistro.HostCount(childComplexity), true

	case "TaskQueueDistro.id":
		if e.complexity.TaskQueueDistro.ID == nil {
			break
		}

		return e.complexity.TaskQueueDistro.ID(childComplexity), true

	case "TaskQueueDistro.taskCount":
		if e.complexity.TaskQueueDistro.TaskCount == nil {
			break
		}

		return e.complexity.TaskQueueDistro.TaskCount(childComplexity), true

	case "TaskQueueItem.activatedBy":
		if e.complexity.TaskQueueItem.ActivatedBy == nil {
			break
		}

		return e.complexity.TaskQueueItem.ActivatedBy(childComplexity), true

	case "TaskQueueItem.buildVariant":
		if e.complexity.TaskQueueItem.BuildVariant == nil {
			break
		}

		return e.complexity.TaskQueueItem.BuildVariant(childComplexity), true

	case "TaskQueueItem.displayName":
		if e.complexity.TaskQueueItem.DisplayName == nil {
			break
		}

		return e.complexity.TaskQueueItem.DisplayName(childComplexity), true

	case "TaskQueueItem.expectedDuration":
		if e.complexity.TaskQueueItem.ExpectedDuration == nil {
			break
		}

		return e.complexity.TaskQueueItem.ExpectedDuration(childComplexity), true

	case "TaskQueueItem.id":
		if e.complexity.TaskQueueItem.Id == nil {
			break
		}

		return e.complexity.TaskQueueItem.Id(childComplexity), true

	case "TaskQueueItem.priority":
		if e.complexity.TaskQueueItem.Priority == nil {
			break
		}

		return e.complexity.TaskQueueItem.Priority(childComplexity), true

	case "TaskQueueItem.project":
		if e.complexity.TaskQueueItem.Project == nil {
			break
		}

		return e.complexity.TaskQueueItem.Project(childComplexity), true

	case "TaskQueueItem.requester":
		if e.complexity.TaskQueueItem.Requester == nil {
			break
		}

		return e.complexity.TaskQueueItem.Requester(childComplexity), true

	case "TaskQueueItem.revision":
		if e.complexity.TaskQueueItem.Revision == nil {
			break
		}

		return e.complexity.TaskQueueItem.Revision(childComplexity), true

	case "TaskQueueItem.version":
		if e.complexity.TaskQueueItem.Version == nil {
			break
		}

		return e.complexity.TaskQueueItem.Version(childComplexity), true

	case "TaskSpecifier.patchAlias":
		if e.complexity.TaskSpecifier.PatchAlias == nil {
			break
		}

		return e.complexity.TaskSpecifier.PatchAlias(childComplexity), true

	case "TaskSpecifier.taskRegex":
		if e.complexity.TaskSpecifier.TaskRegex == nil {
			break
		}

		return e.complexity.TaskSpecifier.TaskRegex(childComplexity), true

	case "TaskSpecifier.variantRegex":
		if e.complexity.TaskSpecifier.VariantRegex == nil {
			break
		}

		return e.complexity.TaskSpecifier.VariantRegex(childComplexity), true

	case "TaskStats.counts":
		if e.complexity.TaskStats.Counts == nil {
			break
		}

		return e.complexity.TaskStats.Counts(childComplexity), true

	case "TaskStats.eta":
		if e.complexity.TaskStats.ETA == nil {
			break
		}

		return e.complexity.TaskStats.ETA(childComplexity), true

	case "TaskSyncOptions.configEnabled":
		if e.complexity.TaskSyncOptions.ConfigEnabled == nil {
			break
		}

		return e.complexity.TaskSyncOptions.ConfigEnabled(childComplexity), true

	case "TaskSyncOptions.patchEnabled":
		if e.complexity.TaskSyncOptions.PatchEnabled == nil {
			break
		}

		return e.complexity.TaskSyncOptions.PatchEnabled(childComplexity), true

	case "TaskTestResult.filteredTestCount":
		if e.complexity.TaskTestResult.FilteredTestCount == nil {
			break
		}

		return e.complexity.TaskTestResult.FilteredTestCount(childComplexity), true

	case "TaskTestResult.testResults":
		if e.complexity.TaskTestResult.TestResults == nil {
			break
		}

		return e.complexity.TaskTestResult.TestResults(childComplexity), true

	case "TaskTestResult.totalTestCount":
		if e.complexity.TaskTestResult.TotalTestCount == nil {
			break
		}

		return e.complexity.TaskTestResult.TotalTestCount(childComplexity), true

	case "TaskTestResultSample.execution":
		if e.complexity.TaskTestResultSample.Execution == nil {
			break
		}

		return e.complexity.TaskTestResultSample.Execution(childComplexity), true

	case "TaskTestResultSample.matchingFailedTestNames":
		if e.complexity.TaskTestResultSample.MatchingFailedTestNames == nil {
			break
		}

		return e.complexity.TaskTestResultSample.MatchingFailedTestNames(childComplexity), true

	case "TaskTestResultSample.taskId":
		if e.complexity.TaskTestResultSample.TaskID == nil {
			break
		}

		return e.complexity.TaskTestResultSample.TaskID(childComplexity), true

	case "TaskTestResultSample.totalTestCount":
		if e.complexity.TaskTestResultSample.TotalTestCount == nil {
			break
		}

		return e.complexity.TaskTestResultSample.TotalTestCount(childComplexity), true

	case "TestLog.lineNum":
		if e.complexity.TestLog.LineNum == nil {
			break
		}

		return e.complexity.TestLog.LineNum(childComplexity), true

	case "TestLog.url":
		if e.complexity.TestLog.URL == nil {
			break
		}

		return e.complexity.TestLog.URL(childComplexity), true

	case "TestLog.urlLobster":
		if e.complexity.TestLog.URLLobster == nil {
			break
		}

		return e.complexity.TestLog.URLLobster(childComplexity), true

	case "TestLog.urlParsley":
		if e.complexity.TestLog.URLParsley == nil {
			break
		}

		return e.complexity.TestLog.URLParsley(childComplexity), true

	case "TestLog.urlRaw":
		if e.complexity.TestLog.URLRaw == nil {
			break
		}

		return e.complexity.TestLog.URLRaw(childComplexity), true

	case "TestResult.baseStatus":
		if e.complexity.TestResult.BaseStatus == nil {
			break
		}

		return e.complexity.TestResult.BaseStatus(childComplexity), true

	case "TestResult.duration":
		if e.complexity.TestResult.Duration == nil {
			break
		}

		return e.complexity.TestResult.Duration(childComplexity), true

	case "TestResult.endTime":
		if e.complexity.TestResult.EndTime == nil {
			break
		}

		return e.complexity.TestResult.EndTime(childComplexity), true

	case "TestResult.execution":
		if e.complexity.TestResult.Execution == nil {
			break
		}

		return e.complexity.TestResult.Execution(childComplexity), true

	case "TestResult.exitCode":
		if e.complexity.TestResult.ExitCode == nil {
			break
		}

		return e.complexity.TestResult.ExitCode(childComplexity), true

	case "TestResult.groupID":
		if e.complexity.TestResult.GroupID == nil {
			break
		}

		return e.complexity.TestResult.GroupID(childComplexity), true

	case "TestResult.id":
		if e.complexity.TestResult.ID == nil {
			break
		}

		return e.complexity.TestResult.ID(childComplexity), true

	case "TestResult.logs":
		if e.complexity.TestResult.Logs == nil {
			break
		}

		return e.complexity.TestResult.Logs(childComplexity), true

	case "TestResult.startTime":
		if e.complexity.TestResult.StartTime == nil {
			break
		}

		return e.complexity.TestResult.StartTime(childComplexity), true

	case "TestResult.status":
		if e.complexity.TestResult.Status == nil {
			break
		}

		return e.complexity.TestResult.Status(childComplexity), true

	case "TestResult.taskId":
		if e.complexity.TestResult.TaskID == nil {
			break
		}

		return e.complexity.TestResult.TaskID(childComplexity), true

	case "TestResult.testFile":
		if e.complexity.TestResult.TestFile == nil {
			break
		}

		return e.complexity.TestResult.TestFile(childComplexity), true

	case "TicketFields.assignedTeam":
		if e.complexity.TicketFields.AssignedTeam == nil {
			break
		}

		return e.complexity.TicketFields.AssignedTeam(childComplexity), true

	case "TicketFields.assigneeDisplayName":
		if e.complexity.TicketFields.AssigneeDisplayName == nil {
			break
		}

		return e.complexity.TicketFields.AssigneeDisplayName(childComplexity), true

	case "TicketFields.created":
		if e.complexity.TicketFields.Created == nil {
			break
		}

		return e.complexity.TicketFields.Created(childComplexity), true

	case "TicketFields.resolutionName":
		if e.complexity.TicketFields.ResolutionName == nil {
			break
		}

		return e.complexity.TicketFields.ResolutionName(childComplexity), true

	case "TicketFields.status":
		if e.complexity.TicketFields.Status == nil {
			break
		}

		return e.complexity.TicketFields.Status(childComplexity), true

	case "TicketFields.summary":
		if e.complexity.TicketFields.Summary == nil {
			break
		}

		return e.complexity.TicketFields.Summary(childComplexity), true

	case "TicketFields.updated":
		if e.complexity.TicketFields.Updated == nil {
			break
		}

		return e.complexity.TicketFields.Updated(childComplexity), true

	case "TriggerAlias.alias":
		if e.complexity.TriggerAlias.Alias == nil {
			break
		}

		return e.complexity.TriggerAlias.Alias(childComplexity), true

	case "TriggerAlias.buildVariantRegex":
		if e.complexity.TriggerAlias.BuildVariantRegex == nil {
			break
		}

		return e.complexity.TriggerAlias.BuildVariantRegex(childComplexity), true

	case "TriggerAlias.configFile":
		if e.complexity.TriggerAlias.ConfigFile == nil {
			break
		}

		return e.complexity.TriggerAlias.ConfigFile(childComplexity), true

	case "TriggerAlias.dateCutoff":
		if e.complexity.TriggerAlias.DateCutoff == nil {
			break
		}

		return e.complexity.TriggerAlias.DateCutoff(childComplexity), true

	case "TriggerAlias.level":
		if e.complexity.TriggerAlias.Level == nil {
			break
		}

		return e.complexity.TriggerAlias.Level(childComplexity), true

	case "TriggerAlias.project":
		if e.complexity.TriggerAlias.Project == nil {
			break
		}

		return e.complexity.TriggerAlias.Project(childComplexity), true

	case "TriggerAlias.status":
		if e.complexity.TriggerAlias.Status == nil {
			break
		}

		return e.complexity.TriggerAlias.Status(childComplexity), true

	case "TriggerAlias.taskRegex":
		if e.complexity.TriggerAlias.TaskRegex == nil {
			break
		}

		return e.complexity.TriggerAlias.TaskRegex(childComplexity), true

	case "UIConfig.defaultProject":
		if e.complexity.UIConfig.DefaultProject == nil {
			break
		}

		return e.complexity.UIConfig.DefaultProject(childComplexity), true

	case "UIConfig.userVoice":
		if e.complexity.UIConfig.UserVoice == nil {
			break
		}

		return e.complexity.UIConfig.UserVoice(childComplexity), true

	case "UpstreamProject.owner":
		if e.complexity.UpstreamProject.Owner == nil {
			break
		}

		return e.complexity.UpstreamProject.Owner(childComplexity), true

	case "UpstreamProject.project":
		if e.complexity.UpstreamProject.Project == nil {
			break
		}

		return e.complexity.UpstreamProject.Project(childComplexity), true

	case "UpstreamProject.repo":
		if e.complexity.UpstreamProject.Repo == nil {
			break
		}

		return e.complexity.UpstreamProject.Repo(childComplexity), true

	case "UpstreamProject.resourceID":
		if e.complexity.UpstreamProject.ResourceID == nil {
			break
		}

		return e.complexity.UpstreamProject.ResourceID(childComplexity), true

	case "UpstreamProject.revision":
		if e.complexity.UpstreamProject.Revision == nil {
			break
		}

		return e.complexity.UpstreamProject.Revision(childComplexity), true

	case "UpstreamProject.task":
		if e.complexity.UpstreamProject.Task == nil {
			break
		}

		return e.complexity.UpstreamProject.Task(childComplexity), true

	case "UpstreamProject.triggerID":
		if e.complexity.UpstreamProject.TriggerID == nil {
			break
		}

		return e.complexity.UpstreamProject.TriggerID(childComplexity), true

	case "UpstreamProject.triggerType":
		if e.complexity.UpstreamProject.TriggerType == nil {
			break
		}

		return e.complexity.UpstreamProject.TriggerType(childComplexity), true

	case "UpstreamProject.version":
		if e.complexity.UpstreamProject.Version == nil {
			break
		}

		return e.complexity.UpstreamProject.Version(childComplexity), true

	case "UseSpruceOptions.hasUsedMainlineCommitsBefore":
		if e.complexity.UseSpruceOptions.HasUsedMainlineCommitsBefore == nil {
			break
		}

		return e.complexity.UseSpruceOptions.HasUsedMainlineCommitsBefore(childComplexity), true

	case "UseSpruceOptions.hasUsedSpruceBefore":
		if e.complexity.UseSpruceOptions.HasUsedSpruceBefore == nil {
			break
		}

		return e.complexity.UseSpruceOptions.HasUsedSpruceBefore(childComplexity), true

	case "UseSpruceOptions.spruceV1":
		if e.complexity.UseSpruceOptions.SpruceV1 == nil {
			break
		}

		return e.complexity.UseSpruceOptions.SpruceV1(childComplexity), true

	case "User.displayName":
		if e.complexity.User.DisplayName == nil {
			break
		}

		return e.complexity.User.DisplayName(childComplexity), true

	case "User.emailAddress":
		if e.complexity.User.EmailAddress == nil {
			break
		}

		return e.complexity.User.EmailAddress(childComplexity), true

	case "User.patches":
		if e.complexity.User.Patches == nil {
			break
		}

		args, err := ec.field_User_patches_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Patches(childComplexity, args["patchesInput"].(PatchesInput)), true

	case "User.permissions":
		if e.complexity.User.Permissions == nil {
			break
		}

		return e.complexity.User.Permissions(childComplexity), true

	case "User.subscriptions":
		if e.complexity.User.Subscriptions == nil {
			break
		}

		return e.complexity.User.Subscriptions(childComplexity), true

	case "User.userId":
		if e.complexity.User.UserID == nil {
			break
		}

		return e.complexity.User.UserID(childComplexity), true

	case "UserConfig.api_key":
		if e.complexity.UserConfig.APIKey == nil {
			break
		}

		return e.complexity.UserConfig.APIKey(childComplexity), true

	case "UserConfig.api_server_host":
		if e.complexity.UserConfig.APIServerHost == nil {
			break
		}

		return e.complexity.UserConfig.APIServerHost(childComplexity), true

	case "UserConfig.ui_server_host":
		if e.complexity.UserConfig.UIServerHost == nil {
			break
		}

		return e.complexity.UserConfig.UIServerHost(childComplexity), true

	case "UserConfig.user":
		if e.complexity.UserConfig.User == nil {
			break
		}

		return e.complexity.UserConfig.User(childComplexity), true

	case "UserSettings.dateFormat":
		if e.complexity.UserSettings.DateFormat == nil {
			break
		}

		return e.complexity.UserSettings.DateFormat(childComplexity), true

	case "UserSettings.githubUser":
		if e.complexity.UserSettings.GithubUser == nil {
			break
		}

		return e.complexity.UserSettings.GithubUser(childComplexity), true

	case "UserSettings.notifications":
		if e.complexity.UserSettings.Notifications == nil {
			break
		}

		return e.complexity.UserSettings.Notifications(childComplexity), true

	case "UserSettings.region":
		if e.complexity.UserSettings.Region == nil {
			break
		}

		return e.complexity.UserSettings.Region(childComplexity), true

	case "UserSettings.slackMemberId":
		if e.complexity.UserSettings.SlackMemberId == nil {
			break
		}

		return e.complexity.UserSettings.SlackMemberId(childComplexity), true

	case "UserSettings.slackUsername":
		if e.complexity.UserSettings.SlackUsername == nil {
			break
		}

		return e.complexity.UserSettings.SlackUsername(childComplexity), true

	case "UserSettings.timezone":
		if e.complexity.UserSettings.Timezone == nil {
			break
		}

		return e.complexity.UserSettings.Timezone(childComplexity), true

	case "UserSettings.useSpruceOptions":
		if e.complexity.UserSettings.UseSpruceOptions == nil {
			break
		}

		return e.complexity.UserSettings.UseSpruceOptions(childComplexity), true

	case "VariantTask.name":
		if e.complexity.VariantTask.Name == nil {
			break
		}

		return e.complexity.VariantTask.Name(childComplexity), true

	case "VariantTask.tasks":
		if e.complexity.VariantTask.Tasks == nil {
			break
		}

		return e.complexity.VariantTask.Tasks(childComplexity), true

	case "Version.activated":
		if e.complexity.Version.Activated == nil {
			break
		}

		return e.complexity.Version.Activated(childComplexity), true

	case "Version.author":
		if e.complexity.Version.Author == nil {
			break
		}

		return e.complexity.Version.Author(childComplexity), true

	case "Version.baseTaskStatuses":
		if e.complexity.Version.BaseTaskStatuses == nil {
			break
		}

		return e.complexity.Version.BaseTaskStatuses(childComplexity), true

	case "Version.baseVersion":
		if e.complexity.Version.BaseVersion == nil {
			break
		}

		return e.complexity.Version.BaseVersion(childComplexity), true

	case "Version.branch":
		if e.complexity.Version.Branch == nil {
			break
		}

		return e.complexity.Version.Branch(childComplexity), true

	case "Version.buildVariantStats":
		if e.complexity.Version.BuildVariantStats == nil {
			break
		}

		args, err := ec.field_Version_buildVariantStats_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Version.BuildVariantStats(childComplexity, args["options"].(BuildVariantOptions)), true

	case "Version.buildVariants":
		if e.complexity.Version.BuildVariants == nil {
			break
		}

		args, err := ec.field_Version_buildVariants_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Version.BuildVariants(childComplexity, args["options"].(BuildVariantOptions)), true

	case "Version.childVersions":
		if e.complexity.Version.ChildVersions == nil {
			break
		}

		return e.complexity.Version.ChildVersions(childComplexity), true

	case "Version.createTime":
		if e.complexity.Version.CreateTime == nil {
			break
		}

		return e.complexity.Version.CreateTime(childComplexity), true

	case "Version.errors":
		if e.complexity.Version.Errors == nil {
			break
		}

		return e.complexity.Version.Errors(childComplexity), true

	case "Version.externalLinksForMetadata":
		if e.complexity.Version.ExternalLinksForMetadata == nil {
			break
		}

		return e.complexity.Version.ExternalLinksForMetadata(childComplexity), true

	case "Version.finishTime":
		if e.complexity.Version.FinishTime == nil {
			break
		}

		return e.complexity.Version.FinishTime(childComplexity), true

	case "Version.gitTags":
		if e.complexity.Version.GitTags == nil {
			break
		}

		return e.complexity.Version.GitTags(childComplexity), true

	case "Version.id":
		if e.complexity.Version.Id == nil {
			break
		}

		return e.complexity.Version.Id(childComplexity), true

	case "Version.isPatch":
		if e.complexity.Version.IsPatch == nil {
			break
		}

		return e.complexity.Version.IsPatch(childComplexity), true

	case "Version.manifest":
		if e.complexity.Version.Manifest == nil {
			break
		}

		return e.complexity.Version.Manifest(childComplexity), true

	case "Version.message":
		if e.complexity.Version.Message == nil {
			break
		}

		return e.complexity.Version.Message(childComplexity), true

	case "Version.order":
		if e.complexity.Version.Order == nil {
			break
		}

		return e.complexity.Version.Order(childComplexity), true

	case "Version.parameters":
		if e.complexity.Version.Parameters == nil {
			break
		}

		return e.complexity.Version.Parameters(childComplexity), true

	case "Version.patch":
		if e.complexity.Version.Patch == nil {
			break
		}

		return e.complexity.Version.Patch(childComplexity), true

	case "Version.previousVersion":
		if e.complexity.Version.PreviousVersion == nil {
			break
		}

		return e.complexity.Version.PreviousVersion(childComplexity), true

	case "Version.project":
		if e.complexity.Version.Project == nil {
			break
		}

		return e.complexity.Version.Project(childComplexity), true

	case "Version.projectIdentifier":
		if e.complexity.Version.ProjectIdentifier == nil {
			break
		}

		return e.complexity.Version.ProjectIdentifier(childComplexity), true

	case "Version.projectMetadata":
		if e.complexity.Version.ProjectMetadata == nil {
			break
		}

		return e.complexity.Version.ProjectMetadata(childComplexity), true

	case "Version.repo":
		if e.complexity.Version.Repo == nil {
			break
		}

		return e.complexity.Version.Repo(childComplexity), true

	case "Version.requester":
		if e.complexity.Version.Requester == nil {
			break
		}

		return e.complexity.Version.Requester(childComplexity), true

	case "Version.revision":
		if e.complexity.Version.Revision == nil {
			break
		}

		return e.complexity.Version.Revision(childComplexity), true

	case "Version.startTime":
		if e.complexity.Version.StartTime == nil {
			break
		}

		return e.complexity.Version.StartTime(childComplexity), true

	case "Version.status":
		if e.complexity.Version.Status == nil {
			break
		}

		return e.complexity.Version.Status(childComplexity), true

	case "Version.taskCount":
		if e.complexity.Version.TaskCount == nil {
			break
		}

		return e.complexity.Version.TaskCount(childComplexity), true

	case "Version.taskStatusStats":
		if e.complexity.Version.TaskStatusStats == nil {
			break
		}

		args, err := ec.field_Version_taskStatusStats_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Version.TaskStatusStats(childComplexity, args["options"].(BuildVariantOptions)), true

	case "Version.taskStatuses":
		if e.complexity.Version.TaskStatuses == nil {
			break
		}

		return e.complexity.Version.TaskStatuses(childComplexity), true

	case "Version.tasks":
		if e.complexity.Version.Tasks == nil {
			break
		}

		args, err := ec.field_Version_tasks_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Version.Tasks(childComplexity, args["options"].(TaskFilterOptions)), true

	case "Version.upstreamProject":
		if e.complexity.Version.UpstreamProject == nil {
			break
		}

		return e.complexity.Version.UpstreamProject(childComplexity), true

	case "Version.versionTiming":
		if e.complexity.Version.VersionTiming == nil {
			break
		}

		return e.complexity.Version.VersionTiming(childComplexity), true

	case "Version.warnings":
		if e.complexity.Version.Warnings == nil {
			break
		}

		return e.complexity.Version.Warnings(childComplexity), true

	case "VersionTasks.count":
		if e.complexity.VersionTasks.Count == nil {
			break
		}

		return e.complexity.VersionTasks.Count(childComplexity), true

	case "VersionTasks.data":
		if e.complexity.VersionTasks.Data == nil {
			break
		}

		return e.complexity.VersionTasks.Data(childComplexity), true

	case "VersionTiming.makespan":
		if e.complexity.VersionTiming.Makespan == nil {
			break
		}

		return e.complexity.VersionTiming.Makespan(childComplexity), true

	case "VersionTiming.timeTaken":
		if e.complexity.VersionTiming.TimeTaken == nil {
			break
		}

		return e.complexity.VersionTiming.TimeTaken(childComplexity), true

	case "Volume.availabilityZone":
		if e.complexity.Volume.AvailabilityZone == nil {
			break
		}

		return e.complexity.Volume.AvailabilityZone(childComplexity), true

	case "Volume.createdBy":
		if e.complexity.Volume.CreatedBy == nil {
			break
		}

		return e.complexity.Volume.CreatedBy(childComplexity), true

	case "Volume.creationTime":
		if e.complexity.Volume.CreationTime == nil {
			break
		}

		return e.complexity.Volume.CreationTime(childComplexity), true

	case "Volume.deviceName":
		if e.complexity.Volume.DeviceName == nil {
			break
		}

		return e.complexity.Volume.DeviceName(childComplexity), true

	case "Volume.displayName":
		if e.complexity.Volume.DisplayName == nil {
			break
		}

		return e.complexity.Volume.DisplayName(childComplexity), true

	case "Volume.expiration":
		if e.complexity.Volume.Expiration == nil {
			break
		}

		return e.complexity.Volume.Expiration(childComplexity), true

	case "Volume.homeVolume":
		if e.complexity.Volume.HomeVolume == nil {
			break
		}

		return e.complexity.Volume.HomeVolume(childComplexity), true

	case "Volume.host":
		if e.complexity.Volume.Host == nil {
			break
		}

		return e.complexity.Volume.Host(childComplexity), true

	case "Volume.hostID":
		if e.complexity.Volume.HostID == nil {
			break
		}

		return e.complexity.Volume.HostID(childComplexity), true

	case "Volume.id":
		if e.complexity.Volume.ID == nil {
			break
		}

		return e.complexity.Volume.ID(childComplexity), true

	case "Volume.migrating":
		if e.complexity.Volume.Migrating == nil {
			break
		}

		return e.complexity.Volume.Migrating(childComplexity), true

	case "Volume.noExpiration":
		if e.complexity.Volume.NoExpiration == nil {
			break
		}

		return e.complexity.Volume.NoExpiration(childComplexity), true

	case "Volume.size":
		if e.complexity.Volume.Size == nil {
			break
		}

		return e.complexity.Volume.Size(childComplexity), true

	case "Volume.type":
		if e.complexity.Volume.Type == nil {
			break
		}

		return e.complexity.Volume.Type(childComplexity), true

	case "Webhook.endpoint":
		if e.complexity.Webhook.Endpoint == nil {
			break
		}

		return e.complexity.Webhook.Endpoint(childComplexity), true

	case "Webhook.secret":
		if e.complexity.Webhook.Secret == nil {
			break
		}

		return e.complexity.Webhook.Secret(childComplexity), true

	case "WebhookHeader.key":
		if e.complexity.WebhookHeader.Key == nil {
			break
		}

		return e.complexity.WebhookHeader.Key(childComplexity), true

	case "WebhookHeader.value":
		if e.complexity.WebhookHeader.Value == nil {
			break
		}

		return e.complexity.WebhookHeader.Value(childComplexity), true

	case "WebhookSubscriber.headers":
		if e.complexity.WebhookSubscriber.Headers == nil {
			break
		}

		return e.complexity.WebhookSubscriber.Headers(childComplexity), true

	case "WebhookSubscriber.minDelayMs":
		if e.complexity.WebhookSubscriber.MinDelayMS == nil {
			break
		}

		return e.complexity.WebhookSubscriber.MinDelayMS(childComplexity), true

	case "WebhookSubscriber.retries":
		if e.complexity.WebhookSubscriber.Retries == nil {
			break
		}

		return e.complexity.WebhookSubscriber.Retries(childComplexity), true

	case "WebhookSubscriber.secret":
		if e.complexity.WebhookSubscriber.Secret == nil {
			break
		}

		return e.complexity.WebhookSubscriber.Secret(childComplexity), true

	case "WebhookSubscriber.timeoutMs":
		if e.complexity.WebhookSubscriber.TimeoutMS == nil {
			break
		}

		return e.complexity.WebhookSubscriber.TimeoutMS(childComplexity), true

	case "WebhookSubscriber.url":
		if e.complexity.WebhookSubscriber.URL == nil {
			break
		}

		return e.complexity.WebhookSubscriber.URL(childComplexity), true

	case "WorkstationConfig.gitClone":
		if e.complexity.WorkstationConfig.GitClone == nil {
			break
		}

		return e.complexity.WorkstationConfig.GitClone(childComplexity), true

	case "WorkstationConfig.setupCommands":
		if e.complexity.WorkstationConfig.SetupCommands == nil {
			break
		}

		return e.complexity.WorkstationConfig.SetupCommands(childComplexity), true

	case "WorkstationSetupCommand.command":
		if e.complexity.WorkstationSetupCommand.Command == nil {
			break
		}

		return e.complexity.WorkstationSetupCommand.Command(childComplexity), true

	case "WorkstationSetupCommand.directory":
		if e.complexity.WorkstationSetupCommand.Directory == nil {
			break
		}

		return e.complexity.WorkstationSetupCommand.Directory(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputBootstrapSettingsInput,
		ec.unmarshalInputBuildBaronSettingsInput,
		ec.unmarshalInputBuildVariantOptions,
		ec.unmarshalInputCommitQueueParamsInput,
		ec.unmarshalInputContainerResourcesInput,
		ec.unmarshalInputCopyDistroInput,
		ec.unmarshalInputCopyProjectInput,
		ec.unmarshalInputCreateDistroInput,
		ec.unmarshalInputCreateProjectInput,
		ec.unmarshalInputDeleteDistroInput,
		ec.unmarshalInputDispatcherSettingsInput,
		ec.unmarshalInputDisplayTask,
		ec.unmarshalInputDistroEventsInput,
		ec.unmarshalInputDistroInput,
		ec.unmarshalInputDistroPermissionsOptions,
		ec.unmarshalInputEditSpawnHostInput,
		ec.unmarshalInputEnvVarInput,
		ec.unmarshalInputExpansionInput,
		ec.unmarshalInputExternalLinkInput,
		ec.unmarshalInputFinderSettingsInput,
		ec.unmarshalInputGithubUserInput,
		ec.unmarshalInputHomeVolumeSettingsInput,
		ec.unmarshalInputHostAllocatorSettingsInput,
		ec.unmarshalInputIceCreamSettingsInput,
		ec.unmarshalInputInstanceTagInput,
		ec.unmarshalInputIssueLinkInput,
		ec.unmarshalInputJiraFieldInput,
		ec.unmarshalInputJiraIssueSubscriberInput,
		ec.unmarshalInputMainlineCommitsOptions,
		ec.unmarshalInputMetadataLinkInput,
		ec.unmarshalInputMoveProjectInput,
		ec.unmarshalInputNotificationsInput,
		ec.unmarshalInputParameterInput,
		ec.unmarshalInputParsleyFilterInput,
		ec.unmarshalInputPatchConfigure,
		ec.unmarshalInputPatchTriggerAliasInput,
		ec.unmarshalInputPatchesInput,
		ec.unmarshalInputPeriodicBuildInput,
		ec.unmarshalInputPlannerSettingsInput,
		ec.unmarshalInputPreconditionScriptInput,
		ec.unmarshalInputProjectAliasInput,
		ec.unmarshalInputProjectBannerInput,
		ec.unmarshalInputProjectInput,
		ec.unmarshalInputProjectSettingsInput,
		ec.unmarshalInputProjectVarsInput,
		ec.unmarshalInputPublicKeyInput,
		ec.unmarshalInputRepoRefInput,
		ec.unmarshalInputRepoSettingsInput,
		ec.unmarshalInputResourceLimitsInput,
		ec.unmarshalInputSaveDistroInput,
		ec.unmarshalInputSelectorInput,
		ec.unmarshalInputSortOrder,
		ec.unmarshalInputSpawnHostInput,
		ec.unmarshalInputSpawnVolumeInput,
		ec.unmarshalInputSubscriberInput,
		ec.unmarshalInputSubscriptionInput,
		ec.unmarshalInputTaskAnnotationSettingsInput,
		ec.unmarshalInputTaskFilterOptions,
		ec.unmarshalInputTaskSpecifierInput,
		ec.unmarshalInputTaskSyncOptionsInput,
		ec.unmarshalInputTestFilter,
		ec.unmarshalInputTestFilterOptions,
		ec.unmarshalInputTestSortOptions,
		ec.unmarshalInputTriggerAliasInput,
		ec.unmarshalInputUpdateVolumeInput,
		ec.unmarshalInputUseSpruceOptionsInput,
		ec.unmarshalInputUserSettingsInput,
		ec.unmarshalInputVariantTasks,
		ec.unmarshalInputVersionToRestart,
		ec.unmarshalInputVolumeHost,
		ec.unmarshalInputWebhookHeaderInput,
		ec.unmarshalInputWebhookInput,
		ec.unmarshalInputWebhookSubscriberInput,
		ec.unmarshalInputWorkstationConfigInput,
		ec.unmarshalInputWorkstationSetupCommandInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Query(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

//go:embed "schema/directives.graphql" "schema/mutation.graphql" "schema/query.graphql" "schema/scalars.graphql" "schema/types/annotation.graphql" "schema/types/commit_queue.graphql" "schema/types/config.graphql" "schema/types/distro.graphql" "schema/types/host.graphql" "schema/types/issue_link.graphql" "schema/types/logkeeper.graphql" "schema/types/mainline_commits.graphql" "schema/types/patch.graphql" "schema/types/permissions.graphql" "schema/types/pod.graphql" "schema/types/project.graphql" "schema/types/project_settings.graphql" "schema/types/project_subscriber.graphql" "schema/types/project_vars.graphql" "schema/types/repo_ref.graphql" "schema/types/repo_settings.graphql" "schema/types/spawn.graphql" "schema/types/subscriptions.graphql" "schema/types/task.graphql" "schema/types/task_logs.graphql" "schema/types/task_queue_item.graphql" "schema/types/ticket_fields.graphql" "schema/types/user.graphql" "schema/types/version.graphql" "schema/types/volume.graphql"
var sourcesFS embed.FS

func sourceData(filename string) string {
	data, err := sourcesFS.ReadFile(filename)
	if err != nil {
		panic(fmt.Sprintf("codegen problem: %s not available", filename))
	}
	return string(data)
}

var sources = []*ast.Source{
	{Name: "schema/directives.graphql", Input: sourceData("schema/directives.graphql"), BuiltIn: false},
	{Name: "schema/mutation.graphql", Input: sourceData("schema/mutation.graphql"), BuiltIn: false},
	{Name: "schema/query.graphql", Input: sourceData("schema/query.graphql"), BuiltIn: false},
	{Name: "schema/scalars.graphql", Input: sourceData("schema/scalars.graphql"), BuiltIn: false},
	{Name: "schema/types/annotation.graphql", Input: sourceData("schema/types/annotation.graphql"), BuiltIn: false},
	{Name: "schema/types/commit_queue.graphql", Input: sourceData("schema/types/commit_queue.graphql"), BuiltIn: false},
	{Name: "schema/types/config.graphql", Input: sourceData("schema/types/config.graphql"), BuiltIn: false},
	{Name: "schema/types/distro.graphql", Input: sourceData("schema/types/distro.graphql"), BuiltIn: false},
	{Name: "schema/types/host.graphql", Input: sourceData("schema/types/host.graphql"), BuiltIn: false},
	{Name: "schema/types/issue_link.graphql", Input: sourceData("schema/types/issue_link.graphql"), BuiltIn: false},
	{Name: "schema/types/logkeeper.graphql", Input: sourceData("schema/types/logkeeper.graphql"), BuiltIn: false},
	{Name: "schema/types/mainline_commits.graphql", Input: sourceData("schema/types/mainline_commits.graphql"), BuiltIn: false},
	{Name: "schema/types/patch.graphql", Input: sourceData("schema/types/patch.graphql"), BuiltIn: false},
	{Name: "schema/types/permissions.graphql", Input: sourceData("schema/types/permissions.graphql"), BuiltIn: false},
	{Name: "schema/types/pod.graphql", Input: sourceData("schema/types/pod.graphql"), BuiltIn: false},
	{Name: "schema/types/project.graphql", Input: sourceData("schema/types/project.graphql"), BuiltIn: false},
	{Name: "schema/types/project_settings.graphql", Input: sourceData("schema/types/project_settings.graphql"), BuiltIn: false},
	{Name: "schema/types/project_subscriber.graphql", Input: sourceData("schema/types/project_subscriber.graphql"), BuiltIn: false},
	{Name: "schema/types/project_vars.graphql", Input: sourceData("schema/types/project_vars.graphql"), BuiltIn: false},
	{Name: "schema/types/repo_ref.graphql", Input: sourceData("schema/types/repo_ref.graphql"), BuiltIn: false},
	{Name: "schema/types/repo_settings.graphql", Input: sourceData("schema/types/repo_settings.graphql"), BuiltIn: false},
	{Name: "schema/types/spawn.graphql", Input: sourceData("schema/types/spawn.graphql"), BuiltIn: false},
	{Name: "schema/types/subscriptions.graphql", Input: sourceData("schema/types/subscriptions.graphql"), BuiltIn: false},
	{Name: "schema/types/task.graphql", Input: sourceData("schema/types/task.graphql"), BuiltIn: false},
	{Name: "schema/types/task_logs.graphql", Input: sourceData("schema/types/task_logs.graphql"), BuiltIn: false},
	{Name: "schema/types/task_queue_item.graphql", Input: sourceData("schema/types/task_queue_item.graphql"), BuiltIn: false},
	{Name: "schema/types/ticket_fields.graphql", Input: sourceData("schema/types/ticket_fields.graphql"), BuiltIn: false},
	{Name: "schema/types/user.graphql", Input: sourceData("schema/types/user.graphql"), BuiltIn: false},
	{Name: "schema/types/version.graphql", Input: sourceData("schema/types/version.graphql"), BuiltIn: false},
	{Name: "schema/types/volume.graphql", Input: sourceData("schema/types/volume.graphql"), BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)

// endregion ************************** generated!.gotpl **************************

// region    ***************************** args.gotpl *****************************

func (ec *executionContext) dir_requireDistroAccess_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 DistroSettingsAccess
	if tmp, ok := rawArgs["access"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("access"))
		arg0, err = ec.unmarshalNDistroSettingsAccess2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroSettingsAccess(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["access"] = arg0
	return args, nil
}

func (ec *executionContext) dir_requireProjectAccess_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 ProjectSettingsAccess
	if tmp, ok := rawArgs["access"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("access"))
		arg0, err = ec.unmarshalNProjectSettingsAccess2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectSettingsAccess(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["access"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_abortTask_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["taskId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["taskId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_addAnnotationIssue_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["taskId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["taskId"] = arg0
	var arg1 int
	if tmp, ok := rawArgs["execution"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("execution"))
		arg1, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["execution"] = arg1
	var arg2 model.APIIssueLink
	if tmp, ok := rawArgs["apiIssue"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("apiIssue"))
		arg2, err = ec.unmarshalNIssueLinkInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIIssueLink(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["apiIssue"] = arg2
	var arg3 bool
	if tmp, ok := rawArgs["isIssue"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isIssue"))
		arg3, err = ec.unmarshalNBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["isIssue"] = arg3
	return args, nil
}

func (ec *executionContext) field_Mutation_addFavoriteProject_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["identifier"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("identifier"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["identifier"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_attachProjectToNewRepo_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 MoveProjectInput
	if tmp, ok := rawArgs["project"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("project"))
		arg0, err = ec.unmarshalNMoveProjectInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐMoveProjectInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["project"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_attachProjectToRepo_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
		directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, tmp) }
		directive1 := func(ctx context.Context) (interface{}, error) {
			access, err := ec.unmarshalNProjectSettingsAccess2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectSettingsAccess(ctx, "EDIT")
			if err != nil {
				return nil, err
			}
			if ec.directives.RequireProjectAccess == nil {
				return nil, errors.New("directive requireProjectAccess is not implemented")
			}
			return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, access)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(string); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
		}
	}
	args["projectId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_attachVolumeToHost_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 VolumeHost
	if tmp, ok := rawArgs["volumeAndHost"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("volumeAndHost"))
		arg0, err = ec.unmarshalNVolumeHost2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐVolumeHost(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["volumeAndHost"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_bbCreateTicket_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["taskId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["taskId"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["execution"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("execution"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["execution"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_copyDistro_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 data.CopyDistroOpts
	if tmp, ok := rawArgs["opts"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNCopyDistroInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋdataᚐCopyDistroOpts(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			access, err := ec.unmarshalNDistroSettingsAccess2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroSettingsAccess(ctx, "CREATE")
			if err != nil {
				return nil, err
			}
			if ec.directives.RequireDistroAccess == nil {
				return nil, errors.New("directive requireDistroAccess is not implemented")
			}
			return ec.directives.RequireDistroAccess(ctx, rawArgs, directive0, access)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(data.CopyDistroOpts); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/rest/data.CopyDistroOpts`, tmp))
		}
	}
	args["opts"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_copyProject_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 data.CopyProjectOpts
	if tmp, ok := rawArgs["project"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("project"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNCopyProjectInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋdataᚐCopyProjectOpts(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectAdmin == nil {
				return nil, errors.New("directive requireProjectAdmin is not implemented")
			}
			return ec.directives.RequireProjectAdmin(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(data.CopyProjectOpts); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/rest/data.CopyProjectOpts`, tmp))
		}
	}
	args["project"] = arg0
	var arg1 *bool
	if tmp, ok := rawArgs["requestS3Creds"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requestS3Creds"))
		arg1, err = ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["requestS3Creds"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_createDistro_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 CreateDistroInput
	if tmp, ok := rawArgs["opts"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNCreateDistroInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐCreateDistroInput(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			access, err := ec.unmarshalNDistroSettingsAccess2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroSettingsAccess(ctx, "CREATE")
			if err != nil {
				return nil, err
			}
			if ec.directives.RequireDistroAccess == nil {
				return nil, errors.New("directive requireDistroAccess is not implemented")
			}
			return ec.directives.RequireDistroAccess(ctx, rawArgs, directive0, access)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(CreateDistroInput); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/graphql.CreateDistroInput`, tmp))
		}
	}
	args["opts"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_createProject_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.APIProjectRef
	if tmp, ok := rawArgs["project"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("project"))
		directive0 := func(ctx context.Context) (interface{}, error) {
			return ec.unmarshalNCreateProjectInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx, tmp)
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectAdmin == nil {
				return nil, errors.New("directive requireProjectAdmin is not implemented")
			}
			return ec.directives.RequireProjectAdmin(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(model.APIProjectRef); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/rest/model.APIProjectRef`, tmp))
		}
	}
	args["project"] = arg0
	var arg1 *bool
	if tmp, ok := rawArgs["requestS3Creds"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requestS3Creds"))
		arg1, err = ec.unmarshalOBoolean2ᚖbool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["requestS3Creds"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_createPublicKey_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 PublicKeyInput
	if tmp, ok := rawArgs["publicKeyInput"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publicKeyInput"))
		arg0, err = ec.unmarshalNPublicKeyInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPublicKeyInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["publicKeyInput"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deactivateStepbackTask_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["buildVariantName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildVariantName"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["buildVariantName"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["taskName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskName"))
		directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, tmp) }
		directive1 := func(ctx context.Context) (interface{}, error) {
			access, err := ec.unmarshalNProjectSettingsAccess2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectSettingsAccess(ctx, "EDIT")
			if err != nil {
				return nil, err
			}
			if ec.directives.RequireProjectAccess == nil {
				return nil, errors.New("directive requireProjectAccess is not implemented")
			}
			return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, access)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(string); ok {
			arg2 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
		}
	}
	args["taskName"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_defaultSectionToRepo_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
		directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, tmp) }
		directive1 := func(ctx context.Context) (interface{}, error) {
			access, err := ec.unmarshalNProjectSettingsAccess2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectSettingsAccess(ctx, "EDIT")
			if err != nil {
				return nil, err
			}
			if ec.directives.RequireProjectAccess == nil {
				return nil, errors.New("directive requireProjectAccess is not implemented")
			}
			return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, access)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(string); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
		}
	}
	args["projectId"] = arg0
	var arg1 ProjectSettingsSection
	if tmp, ok := rawArgs["section"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("section"))
		arg1, err = ec.unmarshalNProjectSettingsSection2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectSettingsSection(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["section"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteDistro_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 DeleteDistroInput
	if tmp, ok := rawArgs["opts"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
		arg0, err = ec.unmarshalNDeleteDistroInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDeleteDistroInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["opts"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteProject_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
		directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, tmp) }
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectAdmin == nil {
				return nil, errors.New("directive requireProjectAdmin is not implemented")
			}
			return ec.directives.RequireProjectAdmin(ctx, rawArgs, directive0)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(string); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
		}
	}
	args["projectId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_deleteSubscriptions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["subscriptionIds"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subscriptionIds"))
		arg0, err = ec.unmarshalNString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["subscriptionIds"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_detachProjectFromRepo_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
		directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, tmp) }
		directive1 := func(ctx context.Context) (interface{}, error) {
			access, err := ec.unmarshalNProjectSettingsAccess2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectSettingsAccess(ctx, "EDIT")
			if err != nil {
				return nil, err
			}
			if ec.directives.RequireProjectAccess == nil {
				return nil, errors.New("directive requireProjectAccess is not implemented")
			}
			return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, access)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(string); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
		}
	}
	args["projectId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_detachVolumeFromHost_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["volumeId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("volumeId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["volumeId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_editAnnotationNote_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["taskId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["taskId"] = arg0
	var arg1 int
	if tmp, ok := rawArgs["execution"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("execution"))
		arg1, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["execution"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["originalMessage"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("originalMessage"))
		arg2, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["originalMessage"] = arg2
	var arg3 string
	if tmp, ok := rawArgs["newMessage"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("newMessage"))
		arg3, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["newMessage"] = arg3
	return args, nil
}

func (ec *executionContext) field_Mutation_editSpawnHost_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *EditSpawnHostInput
	if tmp, ok := rawArgs["spawnHost"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spawnHost"))
		arg0, err = ec.unmarshalOEditSpawnHostInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐEditSpawnHostInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["spawnHost"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_enqueuePatch_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["patchId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["patchId"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["commitMessage"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("commitMessage"))
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["commitMessage"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_forceRepotrackerRun_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
		directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, tmp) }
		directive1 := func(ctx context.Context) (interface{}, error) {
			access, err := ec.unmarshalNProjectSettingsAccess2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectSettingsAccess(ctx, "EDIT")
			if err != nil {
				return nil, err
			}
			if ec.directives.RequireProjectAccess == nil {
				return nil, errors.New("directive requireProjectAccess is not implemented")
			}
			return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, access)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(string); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
		}
	}
	args["projectId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_migrateVolume_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["volumeId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("volumeId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["volumeId"] = arg0
	var arg1 *SpawnHostInput
	if tmp, ok := rawArgs["spawnHostInput"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spawnHostInput"))
		arg1, err = ec.unmarshalOSpawnHostInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSpawnHostInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["spawnHostInput"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_moveAnnotationIssue_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["taskId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["taskId"] = arg0
	var arg1 int
	if tmp, ok := rawArgs["execution"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("execution"))
		arg1, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["execution"] = arg1
	var arg2 model.APIIssueLink
	if tmp, ok := rawArgs["apiIssue"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("apiIssue"))
		arg2, err = ec.unmarshalNIssueLinkInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIIssueLink(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["apiIssue"] = arg2
	var arg3 bool
	if tmp, ok := rawArgs["isIssue"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isIssue"))
		arg3, err = ec.unmarshalNBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["isIssue"] = arg3
	return args, nil
}

func (ec *executionContext) field_Mutation_overrideTaskDependencies_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["taskId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["taskId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_promoteVarsToRepo_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
		directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, tmp) }
		directive1 := func(ctx context.Context) (interface{}, error) {
			access, err := ec.unmarshalNProjectSettingsAccess2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectSettingsAccess(ctx, "EDIT")
			if err != nil {
				return nil, err
			}
			if ec.directives.RequireProjectAccess == nil {
				return nil, errors.New("directive requireProjectAccess is not implemented")
			}
			return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, access)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(string); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
		}
	}
	args["projectId"] = arg0
	var arg1 []string
	if tmp, ok := rawArgs["varNames"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("varNames"))
		arg1, err = ec.unmarshalNString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["varNames"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_removeAnnotationIssue_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["taskId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["taskId"] = arg0
	var arg1 int
	if tmp, ok := rawArgs["execution"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("execution"))
		arg1, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["execution"] = arg1
	var arg2 model.APIIssueLink
	if tmp, ok := rawArgs["apiIssue"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("apiIssue"))
		arg2, err = ec.unmarshalNIssueLinkInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIIssueLink(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["apiIssue"] = arg2
	var arg3 bool
	if tmp, ok := rawArgs["isIssue"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isIssue"))
		arg3, err = ec.unmarshalNBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["isIssue"] = arg3
	return args, nil
}

func (ec *executionContext) field_Mutation_removeFavoriteProject_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["identifier"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("identifier"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["identifier"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_removeItemFromCommitQueue_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["commitQueueId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("commitQueueId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["commitQueueId"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["issue"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("issue"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["issue"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_removePublicKey_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["keyName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("keyName"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["keyName"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_removeVolume_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["volumeId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("volumeId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["volumeId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_reprovisionToNew_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["hostIds"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostIds"))
		arg0, err = ec.unmarshalNString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hostIds"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_restartJasper_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["hostIds"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostIds"))
		arg0, err = ec.unmarshalNString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hostIds"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_restartTask_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["taskId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["taskId"] = arg0
	var arg1 bool
	if tmp, ok := rawArgs["failedOnly"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("failedOnly"))
		arg1, err = ec.unmarshalNBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["failedOnly"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_restartVersions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["versionId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["versionId"] = arg0
	var arg1 bool
	if tmp, ok := rawArgs["abort"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("abort"))
		arg1, err = ec.unmarshalNBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["abort"] = arg1
	var arg2 []*model1.VersionToRestart
	if tmp, ok := rawArgs["versionsToRestart"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionsToRestart"))
		arg2, err = ec.unmarshalNVersionToRestart2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐVersionToRestartᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["versionsToRestart"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_saveDistro_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 SaveDistroInput
	if tmp, ok := rawArgs["opts"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
		arg0, err = ec.unmarshalNSaveDistroInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSaveDistroInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["opts"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_saveProjectSettingsForSection_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.APIProjectSettings
	if tmp, ok := rawArgs["projectSettings"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectSettings"))
		arg0, err = ec.unmarshalOProjectSettingsInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectSettings(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectSettings"] = arg0
	var arg1 ProjectSettingsSection
	if tmp, ok := rawArgs["section"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("section"))
		arg1, err = ec.unmarshalNProjectSettingsSection2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectSettingsSection(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["section"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_saveRepoSettingsForSection_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.APIProjectSettings
	if tmp, ok := rawArgs["repoSettings"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repoSettings"))
		arg0, err = ec.unmarshalORepoSettingsInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectSettings(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["repoSettings"] = arg0
	var arg1 ProjectSettingsSection
	if tmp, ok := rawArgs["section"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("section"))
		arg1, err = ec.unmarshalNProjectSettingsSection2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectSettingsSection(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["section"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_saveSubscription_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 model.APISubscription
	if tmp, ok := rawArgs["subscription"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subscription"))
		arg0, err = ec.unmarshalNSubscriptionInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISubscription(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["subscription"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_schedulePatchTasks_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["patchId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["patchId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_schedulePatch_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["patchId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["patchId"] = arg0
	var arg1 PatchConfigure
	if tmp, ok := rawArgs["configure"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("configure"))
		arg1, err = ec.unmarshalNPatchConfigure2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPatchConfigure(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["configure"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_scheduleTasks_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["taskIds"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskIds"))
		arg0, err = ec.unmarshalNString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["taskIds"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_scheduleUndispatchedBaseTasks_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["patchId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["patchId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_setAnnotationMetadataLinks_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["taskId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["taskId"] = arg0
	var arg1 int
	if tmp, ok := rawArgs["execution"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("execution"))
		arg1, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["execution"] = arg1
	var arg2 []*model.APIMetadataLink
	if tmp, ok := rawArgs["metadataLinks"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("metadataLinks"))
		arg2, err = ec.unmarshalNMetadataLinkInput2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIMetadataLinkᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["metadataLinks"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_setPatchPriority_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["patchId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["patchId"] = arg0
	var arg1 int
	if tmp, ok := rawArgs["priority"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("priority"))
		arg1, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["priority"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_setPatchVisibility_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["patchIds"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchIds"))
		arg0, err = ec.unmarshalNString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["patchIds"] = arg0
	var arg1 bool
	if tmp, ok := rawArgs["hidden"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hidden"))
		arg1, err = ec.unmarshalNBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hidden"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_setTaskPriority_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["taskId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["taskId"] = arg0
	var arg1 int
	if tmp, ok := rawArgs["priority"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("priority"))
		arg1, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["priority"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_spawnHost_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *SpawnHostInput
	if tmp, ok := rawArgs["spawnHostInput"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spawnHostInput"))
		arg0, err = ec.unmarshalOSpawnHostInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSpawnHostInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["spawnHostInput"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_spawnVolume_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 SpawnVolumeInput
	if tmp, ok := rawArgs["spawnVolumeInput"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spawnVolumeInput"))
		arg0, err = ec.unmarshalNSpawnVolumeInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSpawnVolumeInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["spawnVolumeInput"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_unschedulePatchTasks_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["patchId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["patchId"] = arg0
	var arg1 bool
	if tmp, ok := rawArgs["abort"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("abort"))
		arg1, err = ec.unmarshalNBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["abort"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_unscheduleTask_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["taskId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["taskId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateHostStatus_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["hostIds"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostIds"))
		arg0, err = ec.unmarshalNString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hostIds"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["status"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["status"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["notes"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("notes"))
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["notes"] = arg2
	return args, nil
}

func (ec *executionContext) field_Mutation_updatePublicKey_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["targetKeyName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetKeyName"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["targetKeyName"] = arg0
	var arg1 PublicKeyInput
	if tmp, ok := rawArgs["updateInfo"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateInfo"))
		arg1, err = ec.unmarshalNPublicKeyInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPublicKeyInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["updateInfo"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateSpawnHostStatus_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["hostId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hostId"] = arg0
	var arg1 SpawnHostStatusActions
	if tmp, ok := rawArgs["action"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("action"))
		arg1, err = ec.unmarshalNSpawnHostStatusActions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSpawnHostStatusActions(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["action"] = arg1
	return args, nil
}

func (ec *executionContext) field_Mutation_updateUserSettings_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *model.APIUserSettings
	if tmp, ok := rawArgs["userSettings"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userSettings"))
		arg0, err = ec.unmarshalOUserSettingsInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIUserSettings(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userSettings"] = arg0
	return args, nil
}

func (ec *executionContext) field_Mutation_updateVolume_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 UpdateVolumeInput
	if tmp, ok := rawArgs["updateVolumeInput"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("updateVolumeInput"))
		arg0, err = ec.unmarshalNUpdateVolumeInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐUpdateVolumeInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["updateVolumeInput"] = arg0
	return args, nil
}

func (ec *executionContext) field_Permissions_distroPermissions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 DistroPermissionsOptions
	if tmp, ok := rawArgs["options"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("options"))
		arg0, err = ec.unmarshalNDistroPermissionsOptions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroPermissionsOptions(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["options"] = arg0
	return args, nil
}

func (ec *executionContext) field_Pod_events_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg0, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["page"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg1
	return args, nil
}

func (ec *executionContext) field_Project_patches_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 PatchesInput
	if tmp, ok := rawArgs["patchesInput"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchesInput"))
		arg0, err = ec.unmarshalNPatchesInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPatchesInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["patchesInput"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query___type_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["name"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_bbGetCreatedTickets_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["taskId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["taskId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_buildBaron_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["taskId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["taskId"] = arg0
	var arg1 int
	if tmp, ok := rawArgs["execution"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("execution"))
		arg1, err = ec.unmarshalNInt2int(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["execution"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_buildVariantsForTaskName_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectIdentifier"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdentifier"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectIdentifier"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["taskName"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskName"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["taskName"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_commitQueue_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectIdentifier"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdentifier"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectIdentifier"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_distroEvents_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 DistroEventsInput
	if tmp, ok := rawArgs["opts"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
		arg0, err = ec.unmarshalNDistroEventsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroEventsInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["opts"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_distroTaskQueue_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["distroId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("distroId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distroId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_distro_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["distroId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("distroId"))
		directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, tmp) }
		directive1 := func(ctx context.Context) (interface{}, error) {
			access, err := ec.unmarshalNDistroSettingsAccess2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroSettingsAccess(ctx, "VIEW")
			if err != nil {
				return nil, err
			}
			if ec.directives.RequireDistroAccess == nil {
				return nil, errors.New("directive requireDistroAccess is not implemented")
			}
			return ec.directives.RequireDistroAccess(ctx, rawArgs, directive0, access)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(string); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
		}
	}
	args["distroId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_distros_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["onlySpawnable"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("onlySpawnable"))
		arg0, err = ec.unmarshalNBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["onlySpawnable"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_githubProjectConflicts_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_hasVersion_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_hostEvents_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["hostId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hostId"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["hostTag"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostTag"))
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hostTag"] = arg1
	var arg2 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg2, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg2
	var arg3 *int
	if tmp, ok := rawArgs["page"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
		arg3, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg3
	return args, nil
}

func (ec *executionContext) field_Query_host_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["hostId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hostId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_hosts_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["hostId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["hostId"] = arg0
	var arg1 *string
	if tmp, ok := rawArgs["distroId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("distroId"))
		arg1, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["distroId"] = arg1
	var arg2 *string
	if tmp, ok := rawArgs["currentTaskId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("currentTaskId"))
		arg2, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["currentTaskId"] = arg2
	var arg3 []string
	if tmp, ok := rawArgs["statuses"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statuses"))
		arg3, err = ec.unmarshalOString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["statuses"] = arg3
	var arg4 *string
	if tmp, ok := rawArgs["startedBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("startedBy"))
		arg4, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["startedBy"] = arg4
	var arg5 *HostSortBy
	if tmp, ok := rawArgs["sortBy"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortBy"))
		arg5, err = ec.unmarshalOHostSortBy2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐHostSortBy(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortBy"] = arg5
	var arg6 *SortDirection
	if tmp, ok := rawArgs["sortDir"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortDir"))
		arg6, err = ec.unmarshalOSortDirection2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSortDirection(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["sortDir"] = arg6
	var arg7 *int
	if tmp, ok := rawArgs["page"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
		arg7, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["page"] = arg7
	var arg8 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg8, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg8
	return args, nil
}

func (ec *executionContext) field_Query_logkeeperBuildMetadata_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["buildId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["buildId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_mainlineCommits_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 MainlineCommitsOptions
	if tmp, ok := rawArgs["options"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("options"))
		arg0, err = ec.unmarshalNMainlineCommitsOptions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐMainlineCommitsOptions(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["options"] = arg0
	var arg1 *BuildVariantOptions
	if tmp, ok := rawArgs["buildVariantOptions"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildVariantOptions"))
		arg1, err = ec.unmarshalOBuildVariantOptions2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐBuildVariantOptions(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["buildVariantOptions"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_patch_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_pod_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["podId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("podId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["podId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_projectEvents_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["identifier"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("identifier"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["identifier"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	var arg2 *time.Time
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOTime2ᚖtimeᚐTime(ctx, tmp) }
		directive1 := func(ctx context.Context) (interface{}, error) {
			access, err := ec.unmarshalNProjectSettingsAccess2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectSettingsAccess(ctx, "VIEW")
			if err != nil {
				return nil, err
			}
			if ec.directives.RequireProjectAccess == nil {
				return nil, errors.New("directive requireProjectAccess is not implemented")
			}
			return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, access)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(*time.Time); ok {
			arg2 = data
		} else if tmp == nil {
			arg2 = nil
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be *time.Time`, tmp))
		}
	}
	args["before"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_projectSettings_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["identifier"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("identifier"))
		directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, tmp) }
		directive1 := func(ctx context.Context) (interface{}, error) {
			access, err := ec.unmarshalNProjectSettingsAccess2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectSettingsAccess(ctx, "VIEW")
			if err != nil {
				return nil, err
			}
			if ec.directives.RequireProjectAccess == nil {
				return nil, errors.New("directive requireProjectAccess is not implemented")
			}
			return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, access)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(string); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
		}
	}
	args["identifier"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_project_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectIdentifier"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdentifier"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectIdentifier"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_repoEvents_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["limit"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["limit"] = arg1
	var arg2 *time.Time
	if tmp, ok := rawArgs["before"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
		directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalOTime2ᚖtimeᚐTime(ctx, tmp) }
		directive1 := func(ctx context.Context) (interface{}, error) {
			access, err := ec.unmarshalNProjectSettingsAccess2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectSettingsAccess(ctx, "VIEW")
			if err != nil {
				return nil, err
			}
			if ec.directives.RequireProjectAccess == nil {
				return nil, errors.New("directive requireProjectAccess is not implemented")
			}
			return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, access)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(*time.Time); ok {
			arg2 = data
		} else if tmp == nil {
			arg2 = nil
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be *time.Time`, tmp))
		}
	}
	args["before"] = arg2
	return args, nil
}

func (ec *executionContext) field_Query_repoSettings_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, tmp) }
		directive1 := func(ctx context.Context) (interface{}, error) {
			access, err := ec.unmarshalNProjectSettingsAccess2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectSettingsAccess(ctx, "VIEW")
			if err != nil {
				return nil, err
			}
			if ec.directives.RequireProjectAccess == nil {
				return nil, errors.New("directive requireProjectAccess is not implemented")
			}
			return ec.directives.RequireProjectAccess(ctx, rawArgs, directive0, access)
		}

		tmp, err = directive1(ctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if data, ok := tmp.(string); ok {
			arg0 = data
		} else {
			return nil, graphql.ErrorOnPath(ctx, fmt.Errorf(`unexpected type %T from directive, should be string`, tmp))
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_taskAllExecutions_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["taskId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["taskId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_taskNamesForBuildVariant_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["projectIdentifier"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdentifier"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["projectIdentifier"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["buildVariant"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildVariant"))
		arg1, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["buildVariant"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_taskTestSample_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 []string
	if tmp, ok := rawArgs["tasks"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tasks"))
		arg0, err = ec.unmarshalNString2ᚕstringᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["tasks"] = arg0
	var arg1 []*TestFilter
	if tmp, ok := rawArgs["filters"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("filters"))
		arg1, err = ec.unmarshalNTestFilter2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTestFilterᚄ(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["filters"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_task_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["taskId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["taskId"] = arg0
	var arg1 *int
	if tmp, ok := rawArgs["execution"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("execution"))
		arg1, err = ec.unmarshalOInt2ᚖint(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["execution"] = arg1
	return args, nil
}

func (ec *executionContext) field_Query_user_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := rawArgs["userId"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userId"))
		arg0, err = ec.unmarshalOString2ᚖstring(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["userId"] = arg0
	return args, nil
}

func (ec *executionContext) field_Query_version_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["id"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
		arg0, err = ec.unmarshalNString2string(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["id"] = arg0
	return args, nil
}

func (ec *executionContext) field_Task_tests_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 *TestFilterOptions
	if tmp, ok := rawArgs["opts"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("opts"))
		arg0, err = ec.unmarshalOTestFilterOptions2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTestFilterOptions(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["opts"] = arg0
	return args, nil
}

func (ec *executionContext) field_User_patches_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 PatchesInput
	if tmp, ok := rawArgs["patchesInput"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchesInput"))
		arg0, err = ec.unmarshalNPatchesInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPatchesInput(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["patchesInput"] = arg0
	return args, nil
}

func (ec *executionContext) field_Version_buildVariantStats_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 BuildVariantOptions
	if tmp, ok := rawArgs["options"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("options"))
		arg0, err = ec.unmarshalNBuildVariantOptions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐBuildVariantOptions(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["options"] = arg0
	return args, nil
}

func (ec *executionContext) field_Version_buildVariants_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 BuildVariantOptions
	if tmp, ok := rawArgs["options"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("options"))
		arg0, err = ec.unmarshalNBuildVariantOptions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐBuildVariantOptions(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["options"] = arg0
	return args, nil
}

func (ec *executionContext) field_Version_taskStatusStats_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 BuildVariantOptions
	if tmp, ok := rawArgs["options"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("options"))
		arg0, err = ec.unmarshalNBuildVariantOptions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐBuildVariantOptions(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["options"] = arg0
	return args, nil
}

func (ec *executionContext) field_Version_tasks_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 TaskFilterOptions
	if tmp, ok := rawArgs["options"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("options"))
		arg0, err = ec.unmarshalNTaskFilterOptions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskFilterOptions(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["options"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_enumValues_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

func (ec *executionContext) field___Type_fields_args(ctx context.Context, rawArgs map[string]interface{}) (map[string]interface{}, error) {
	var err error
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeDeprecated"))
		arg0, err = ec.unmarshalOBoolean2bool(ctx, tmp)
		if err != nil {
			return nil, err
		}
	}
	args["includeDeprecated"] = arg0
	return args, nil
}

// endregion ***************************** args.gotpl *****************************

// region    ************************** directives.gotpl **************************

// endregion ************************** directives.gotpl **************************

// region    **************************** field.gotpl *****************************

func (ec *executionContext) _AWSConfig_maxVolumeSizePerUser(ctx context.Context, field graphql.CollectedField, obj *model.APIAWSConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AWSConfig_maxVolumeSizePerUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxVolumeSizePerUser, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AWSConfig_maxVolumeSizePerUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AWSConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AWSConfig_pod(ctx context.Context, field graphql.CollectedField, obj *model.APIAWSConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AWSConfig_pod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pod, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIAWSPodConfig)
	fc.Result = res
	return ec.marshalOAWSPodConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAWSPodConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AWSConfig_pod(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AWSConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "ecs":
				return ec.fieldContext_AWSPodConfig_ecs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AWSPodConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AWSPodConfig_ecs(ctx context.Context, field graphql.CollectedField, obj *model.APIAWSPodConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AWSPodConfig_ecs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ECS, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIECSConfig)
	fc.Result = res
	return ec.marshalOECSConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIECSConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AWSPodConfig_ecs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AWSPodConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "maxCPU":
				return ec.fieldContext_ECSConfig_maxCPU(ctx, field)
			case "maxMemoryMb":
				return ec.fieldContext_ECSConfig_maxMemoryMb(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ECSConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _AbortInfo_buildVariantDisplayName(ctx context.Context, field graphql.CollectedField, obj *AbortInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AbortInfo_buildVariantDisplayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildVariantDisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AbortInfo_buildVariantDisplayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbortInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AbortInfo_newVersion(ctx context.Context, field graphql.CollectedField, obj *AbortInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AbortInfo_newVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewVersion, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AbortInfo_newVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbortInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AbortInfo_prClosed(ctx context.Context, field graphql.CollectedField, obj *AbortInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AbortInfo_prClosed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrClosed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AbortInfo_prClosed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbortInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AbortInfo_taskDisplayName(ctx context.Context, field graphql.CollectedField, obj *AbortInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AbortInfo_taskDisplayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskDisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AbortInfo_taskDisplayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbortInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AbortInfo_taskID(ctx context.Context, field graphql.CollectedField, obj *AbortInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AbortInfo_taskID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AbortInfo_taskID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbortInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _AbortInfo_user(ctx context.Context, field graphql.CollectedField, obj *AbortInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_AbortInfo_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_AbortInfo_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "AbortInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Annotation_id(ctx context.Context, field graphql.CollectedField, obj *model.APITaskAnnotation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Annotation_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Annotation_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Annotation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Annotation_createdIssues(ctx context.Context, field graphql.CollectedField, obj *model.APITaskAnnotation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Annotation_createdIssues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedIssues, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIIssueLink)
	fc.Result = res
	return ec.marshalOIssueLink2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIIssueLink(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Annotation_createdIssues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Annotation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "confidenceScore":
				return ec.fieldContext_IssueLink_confidenceScore(ctx, field)
			case "issueKey":
				return ec.fieldContext_IssueLink_issueKey(ctx, field)
			case "jiraTicket":
				return ec.fieldContext_IssueLink_jiraTicket(ctx, field)
			case "source":
				return ec.fieldContext_IssueLink_source(ctx, field)
			case "url":
				return ec.fieldContext_IssueLink_url(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IssueLink", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Annotation_issues(ctx context.Context, field graphql.CollectedField, obj *model.APITaskAnnotation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Annotation_issues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Issues, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIIssueLink)
	fc.Result = res
	return ec.marshalOIssueLink2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIIssueLink(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Annotation_issues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Annotation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "confidenceScore":
				return ec.fieldContext_IssueLink_confidenceScore(ctx, field)
			case "issueKey":
				return ec.fieldContext_IssueLink_issueKey(ctx, field)
			case "jiraTicket":
				return ec.fieldContext_IssueLink_jiraTicket(ctx, field)
			case "source":
				return ec.fieldContext_IssueLink_source(ctx, field)
			case "url":
				return ec.fieldContext_IssueLink_url(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IssueLink", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Annotation_note(ctx context.Context, field graphql.CollectedField, obj *model.APITaskAnnotation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Annotation_note(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Note, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APINote)
	fc.Result = res
	return ec.marshalONote2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPINote(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Annotation_note(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Annotation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "message":
				return ec.fieldContext_Note_message(ctx, field)
			case "source":
				return ec.fieldContext_Note_source(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Note", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Annotation_suspectedIssues(ctx context.Context, field graphql.CollectedField, obj *model.APITaskAnnotation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Annotation_suspectedIssues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SuspectedIssues, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIIssueLink)
	fc.Result = res
	return ec.marshalOIssueLink2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIIssueLink(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Annotation_suspectedIssues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Annotation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "confidenceScore":
				return ec.fieldContext_IssueLink_confidenceScore(ctx, field)
			case "issueKey":
				return ec.fieldContext_IssueLink_issueKey(ctx, field)
			case "jiraTicket":
				return ec.fieldContext_IssueLink_jiraTicket(ctx, field)
			case "source":
				return ec.fieldContext_IssueLink_source(ctx, field)
			case "url":
				return ec.fieldContext_IssueLink_url(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IssueLink", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Annotation_metadataLinks(ctx context.Context, field graphql.CollectedField, obj *model.APITaskAnnotation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Annotation_metadataLinks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MetadataLinks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIMetadataLink)
	fc.Result = res
	return ec.marshalOMetadataLink2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIMetadataLink(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Annotation_metadataLinks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Annotation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "url":
				return ec.fieldContext_MetadataLink_url(ctx, field)
			case "text":
				return ec.fieldContext_MetadataLink_text(ctx, field)
			case "source":
				return ec.fieldContext_MetadataLink_source(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MetadataLink", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Annotation_taskId(ctx context.Context, field graphql.CollectedField, obj *model.APITaskAnnotation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Annotation_taskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Annotation_taskId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Annotation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Annotation_taskExecution(ctx context.Context, field graphql.CollectedField, obj *model.APITaskAnnotation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Annotation_taskExecution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskExecution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalNInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Annotation_taskExecution(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Annotation",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Annotation_webhookConfigured(ctx context.Context, field graphql.CollectedField, obj *model.APITaskAnnotation) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Annotation_webhookConfigured(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Annotation().WebhookConfigured(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Annotation_webhookConfigured(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Annotation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_clientDir(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BootstrapSettings_clientDir(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientDir, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BootstrapSettings_clientDir(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_communication(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BootstrapSettings_communication(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Communication, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BootstrapSettings_communication(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_env(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BootstrapSettings_env(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Env, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APIEnvVar)
	fc.Result = res
	return ec.marshalNEnvVar2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIEnvVarᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BootstrapSettings_env(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_EnvVar_key(ctx, field)
			case "value":
				return ec.fieldContext_EnvVar_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type EnvVar", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_jasperBinaryDir(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BootstrapSettings_jasperBinaryDir(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JasperBinaryDir, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BootstrapSettings_jasperBinaryDir(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_jasperCredentialsPath(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BootstrapSettings_jasperCredentialsPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JasperCredentialsPath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BootstrapSettings_jasperCredentialsPath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_method(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BootstrapSettings_method(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Method, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BootstrapSettings_method(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_preconditionScripts(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BootstrapSettings_preconditionScripts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PreconditionScripts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APIPreconditionScript)
	fc.Result = res
	return ec.marshalNPreconditionScript2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPreconditionScriptᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BootstrapSettings_preconditionScripts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "path":
				return ec.fieldContext_PreconditionScript_path(ctx, field)
			case "script":
				return ec.fieldContext_PreconditionScript_script(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PreconditionScript", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_resourceLimits(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BootstrapSettings_resourceLimits(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceLimits, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIResourceLimits)
	fc.Result = res
	return ec.marshalNResourceLimits2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIResourceLimits(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BootstrapSettings_resourceLimits(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lockedMemoryKb":
				return ec.fieldContext_ResourceLimits_lockedMemoryKb(ctx, field)
			case "numFiles":
				return ec.fieldContext_ResourceLimits_numFiles(ctx, field)
			case "numProcesses":
				return ec.fieldContext_ResourceLimits_numProcesses(ctx, field)
			case "numTasks":
				return ec.fieldContext_ResourceLimits_numTasks(ctx, field)
			case "virtualMemoryKb":
				return ec.fieldContext_ResourceLimits_virtualMemoryKb(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ResourceLimits", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_rootDir(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BootstrapSettings_rootDir(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RootDir, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BootstrapSettings_rootDir(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_serviceUser(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BootstrapSettings_serviceUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ServiceUser, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BootstrapSettings_serviceUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BootstrapSettings_shellPath(ctx context.Context, field graphql.CollectedField, obj *model.APIBootstrapSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BootstrapSettings_shellPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ShellPath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BootstrapSettings_shellPath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BootstrapSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_id(ctx context.Context, field graphql.CollectedField, obj *model.APIBuild) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_actualMakespan(ctx context.Context, field graphql.CollectedField, obj *model.APIBuild) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_actualMakespan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ActualMakespan, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIDuration)
	fc.Result = res
	return ec.marshalNDuration2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_actualMakespan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_buildVariant(ctx context.Context, field graphql.CollectedField, obj *model.APIBuild) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_buildVariant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildVariant, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_buildVariant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_predictedMakespan(ctx context.Context, field graphql.CollectedField, obj *model.APIBuild) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_predictedMakespan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PredictedMakespan, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIDuration)
	fc.Result = res
	return ec.marshalNDuration2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_predictedMakespan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Build_status(ctx context.Context, field graphql.CollectedField, obj *model.APIBuild) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Build_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Build_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Build",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaron_bbTicketCreationDefined(ctx context.Context, field graphql.CollectedField, obj *BuildBaron) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildBaron_bbTicketCreationDefined(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BbTicketCreationDefined, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildBaron_bbTicketCreationDefined(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaron",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaron_buildBaronConfigured(ctx context.Context, field graphql.CollectedField, obj *BuildBaron) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildBaron_buildBaronConfigured(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildBaronConfigured, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildBaron_buildBaronConfigured(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaron",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaron_searchReturnInfo(ctx context.Context, field graphql.CollectedField, obj *BuildBaron) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildBaron_searchReturnInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SearchReturnInfo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*thirdparty.SearchReturnInfo)
	fc.Result = res
	return ec.marshalOSearchReturnInfo2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐSearchReturnInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildBaron_searchReturnInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaron",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "featuresURL":
				return ec.fieldContext_SearchReturnInfo_featuresURL(ctx, field)
			case "issues":
				return ec.fieldContext_SearchReturnInfo_issues(ctx, field)
			case "search":
				return ec.fieldContext_SearchReturnInfo_search(ctx, field)
			case "source":
				return ec.fieldContext_SearchReturnInfo_source(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SearchReturnInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaronSettings_bfSuggestionFeaturesURL(ctx context.Context, field graphql.CollectedField, obj *model.APIBuildBaronSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildBaronSettings_bfSuggestionFeaturesURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BFSuggestionFeaturesURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildBaronSettings_bfSuggestionFeaturesURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaronSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaronSettings_bfSuggestionPassword(ctx context.Context, field graphql.CollectedField, obj *model.APIBuildBaronSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildBaronSettings_bfSuggestionPassword(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BFSuggestionPassword, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildBaronSettings_bfSuggestionPassword(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaronSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaronSettings_bfSuggestionServer(ctx context.Context, field graphql.CollectedField, obj *model.APIBuildBaronSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildBaronSettings_bfSuggestionServer(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BFSuggestionServer, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildBaronSettings_bfSuggestionServer(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaronSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaronSettings_bfSuggestionTimeoutSecs(ctx context.Context, field graphql.CollectedField, obj *model.APIBuildBaronSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildBaronSettings_bfSuggestionTimeoutSecs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BFSuggestionTimeoutSecs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildBaronSettings_bfSuggestionTimeoutSecs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaronSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaronSettings_bfSuggestionUsername(ctx context.Context, field graphql.CollectedField, obj *model.APIBuildBaronSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildBaronSettings_bfSuggestionUsername(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BFSuggestionUsername, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildBaronSettings_bfSuggestionUsername(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaronSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaronSettings_ticketCreateProject(ctx context.Context, field graphql.CollectedField, obj *model.APIBuildBaronSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildBaronSettings_ticketCreateProject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TicketCreateProject, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildBaronSettings_ticketCreateProject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaronSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildBaronSettings_ticketSearchProjects(ctx context.Context, field graphql.CollectedField, obj *model.APIBuildBaronSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildBaronSettings_ticketSearchProjects(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TicketSearchProjects, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2ᚕᚖstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildBaronSettings_ticketSearchProjects(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildBaronSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildVariantTuple_buildVariant(ctx context.Context, field graphql.CollectedField, obj *task.BuildVariantTuple) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildVariantTuple_buildVariant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildVariant, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildVariantTuple_buildVariant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildVariantTuple",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _BuildVariantTuple_displayName(ctx context.Context, field graphql.CollectedField, obj *task.BuildVariantTuple) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_BuildVariantTuple_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_BuildVariantTuple_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "BuildVariantTuple",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChildPatchAlias_alias(ctx context.Context, field graphql.CollectedField, obj *model.APIChildPatchAlias) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChildPatchAlias_alias(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Alias, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChildPatchAlias_alias(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChildPatchAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ChildPatchAlias_patchId(ctx context.Context, field graphql.CollectedField, obj *model.APIChildPatchAlias) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ChildPatchAlias_patchId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PatchID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ChildPatchAlias_patchId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ChildPatchAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ClientBinary_arch(ctx context.Context, field graphql.CollectedField, obj *model.APIClientBinary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ClientBinary_arch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Arch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ClientBinary_arch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ClientBinary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ClientBinary_displayName(ctx context.Context, field graphql.CollectedField, obj *model.APIClientBinary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ClientBinary_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ClientBinary_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ClientBinary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ClientBinary_os(ctx context.Context, field graphql.CollectedField, obj *model.APIClientBinary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ClientBinary_os(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OS, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ClientBinary_os(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ClientBinary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ClientBinary_url(ctx context.Context, field graphql.CollectedField, obj *model.APIClientBinary) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ClientBinary_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ClientBinary_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ClientBinary",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ClientConfig_clientBinaries(ctx context.Context, field graphql.CollectedField, obj *model.APIClientConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ClientConfig_clientBinaries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ClientBinaries, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIClientBinary)
	fc.Result = res
	return ec.marshalOClientBinary2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIClientBinaryᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ClientConfig_clientBinaries(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ClientConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "arch":
				return ec.fieldContext_ClientBinary_arch(ctx, field)
			case "displayName":
				return ec.fieldContext_ClientBinary_displayName(ctx, field)
			case "os":
				return ec.fieldContext_ClientBinary_os(ctx, field)
			case "url":
				return ec.fieldContext_ClientBinary_url(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ClientBinary", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ClientConfig_latestRevision(ctx context.Context, field graphql.CollectedField, obj *model.APIClientConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ClientConfig_latestRevision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LatestRevision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ClientConfig_latestRevision(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ClientConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CloudProviderConfig_aws(ctx context.Context, field graphql.CollectedField, obj *model.APICloudProviders) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CloudProviderConfig_aws(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AWS, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIAWSConfig)
	fc.Result = res
	return ec.marshalOAWSConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAWSConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CloudProviderConfig_aws(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CloudProviderConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "maxVolumeSizePerUser":
				return ec.fieldContext_AWSConfig_maxVolumeSizePerUser(ctx, field)
			case "pod":
				return ec.fieldContext_AWSConfig_pod(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AWSConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CommitQueue_message(ctx context.Context, field graphql.CollectedField, obj *model.APICommitQueue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CommitQueue_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CommitQueue_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CommitQueue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CommitQueue_owner(ctx context.Context, field graphql.CollectedField, obj *model.APICommitQueue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CommitQueue_owner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CommitQueue_owner(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CommitQueue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CommitQueue_projectId(ctx context.Context, field graphql.CollectedField, obj *model.APICommitQueue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CommitQueue_projectId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CommitQueue_projectId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CommitQueue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CommitQueue_queue(ctx context.Context, field graphql.CollectedField, obj *model.APICommitQueue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CommitQueue_queue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Queue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APICommitQueueItem)
	fc.Result = res
	return ec.marshalOCommitQueueItem2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPICommitQueueItemᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CommitQueue_queue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CommitQueue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "enqueueTime":
				return ec.fieldContext_CommitQueueItem_enqueueTime(ctx, field)
			case "issue":
				return ec.fieldContext_CommitQueueItem_issue(ctx, field)
			case "modules":
				return ec.fieldContext_CommitQueueItem_modules(ctx, field)
			case "patch":
				return ec.fieldContext_CommitQueueItem_patch(ctx, field)
			case "source":
				return ec.fieldContext_CommitQueueItem_source(ctx, field)
			case "version":
				return ec.fieldContext_CommitQueueItem_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CommitQueueItem", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CommitQueue_repo(ctx context.Context, field graphql.CollectedField, obj *model.APICommitQueue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CommitQueue_repo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CommitQueue_repo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CommitQueue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CommitQueueItem_enqueueTime(ctx context.Context, field graphql.CollectedField, obj *model.APICommitQueueItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CommitQueueItem_enqueueTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnqueueTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CommitQueueItem_enqueueTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CommitQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CommitQueueItem_issue(ctx context.Context, field graphql.CollectedField, obj *model.APICommitQueueItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CommitQueueItem_issue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Issue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CommitQueueItem_issue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CommitQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CommitQueueItem_modules(ctx context.Context, field graphql.CollectedField, obj *model.APICommitQueueItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CommitQueueItem_modules(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Modules, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIModule)
	fc.Result = res
	return ec.marshalOModule2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIModuleᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CommitQueueItem_modules(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CommitQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "issue":
				return ec.fieldContext_Module_issue(ctx, field)
			case "module":
				return ec.fieldContext_Module_module(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Module", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CommitQueueItem_patch(ctx context.Context, field graphql.CollectedField, obj *model.APICommitQueueItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CommitQueueItem_patch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Patch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIPatch)
	fc.Result = res
	return ec.marshalOPatch2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CommitQueueItem_patch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CommitQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Patch_id(ctx, field)
			case "activated":
				return ec.fieldContext_Patch_activated(ctx, field)
			case "alias":
				return ec.fieldContext_Patch_alias(ctx, field)
			case "author":
				return ec.fieldContext_Patch_author(ctx, field)
			case "authorDisplayName":
				return ec.fieldContext_Patch_authorDisplayName(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Patch_baseTaskStatuses(ctx, field)
			case "builds":
				return ec.fieldContext_Patch_builds(ctx, field)
			case "canEnqueueToCommitQueue":
				return ec.fieldContext_Patch_canEnqueueToCommitQueue(ctx, field)
			case "childPatchAliases":
				return ec.fieldContext_Patch_childPatchAliases(ctx, field)
			case "childPatches":
				return ec.fieldContext_Patch_childPatches(ctx, field)
			case "commitQueuePosition":
				return ec.fieldContext_Patch_commitQueuePosition(ctx, field)
			case "createTime":
				return ec.fieldContext_Patch_createTime(ctx, field)
			case "description":
				return ec.fieldContext_Patch_description(ctx, field)
			case "duration":
				return ec.fieldContext_Patch_duration(ctx, field)
			case "githash":
				return ec.fieldContext_Patch_githash(ctx, field)
			case "hidden":
				return ec.fieldContext_Patch_hidden(ctx, field)
			case "moduleCodeChanges":
				return ec.fieldContext_Patch_moduleCodeChanges(ctx, field)
			case "parameters":
				return ec.fieldContext_Patch_parameters(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Patch_patchNumber(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Patch_patchTriggerAliases(ctx, field)
			case "project":
				return ec.fieldContext_Patch_project(ctx, field)
			case "projectID":
				return ec.fieldContext_Patch_projectID(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Patch_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Patch_projectMetadata(ctx, field)
			case "status":
				return ec.fieldContext_Patch_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Patch_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Patch_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Patch_taskStatuses(ctx, field)
			case "time":
				return ec.fieldContext_Patch_time(ctx, field)
			case "variants":
				return ec.fieldContext_Patch_variants(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_Patch_variantsTasks(ctx, field)
			case "versionFull":
				return ec.fieldContext_Patch_versionFull(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Patch", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _CommitQueueItem_source(ctx context.Context, field graphql.CollectedField, obj *model.APICommitQueueItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CommitQueueItem_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CommitQueueItem_source(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CommitQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CommitQueueItem_version(ctx context.Context, field graphql.CollectedField, obj *model.APICommitQueueItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CommitQueueItem_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CommitQueueItem_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CommitQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CommitQueueParams_enabled(ctx context.Context, field graphql.CollectedField, obj *model.APICommitQueueParams) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CommitQueueParams_enabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CommitQueueParams_enabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CommitQueueParams",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CommitQueueParams_mergeMethod(ctx context.Context, field graphql.CollectedField, obj *model.APICommitQueueParams) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CommitQueueParams_mergeMethod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MergeMethod, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CommitQueueParams_mergeMethod(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CommitQueueParams",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CommitQueueParams_mergeQueue(ctx context.Context, field graphql.CollectedField, obj *model.APICommitQueueParams) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CommitQueueParams_mergeQueue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MergeQueue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model1.MergeQueue)
	fc.Result = res
	return ec.marshalNMergeQueue2githubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐMergeQueue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CommitQueueParams_mergeQueue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CommitQueueParams",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MergeQueue does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _CommitQueueParams_message(ctx context.Context, field graphql.CollectedField, obj *model.APICommitQueueParams) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_CommitQueueParams_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_CommitQueueParams_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "CommitQueueParams",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerResources_name(ctx context.Context, field graphql.CollectedField, obj *model.APIContainerResources) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerResources_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerResources_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerResources",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerResources_cpu(ctx context.Context, field graphql.CollectedField, obj *model.APIContainerResources) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerResources_cpu(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CPU, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalNInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerResources_cpu(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerResources",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ContainerResources_memoryMb(ctx context.Context, field graphql.CollectedField, obj *model.APIContainerResources) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ContainerResources_memoryMb(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MemoryMB, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalNInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ContainerResources_memoryMb(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ContainerResources",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DeleteDistroPayload_deletedDistroId(ctx context.Context, field graphql.CollectedField, obj *DeleteDistroPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DeleteDistroPayload_deletedDistroId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeletedDistroID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DeleteDistroPayload_deletedDistroId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DeleteDistroPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dependency_buildVariant(ctx context.Context, field graphql.CollectedField, obj *Dependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dependency_buildVariant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildVariant, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dependency_buildVariant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dependency_metStatus(ctx context.Context, field graphql.CollectedField, obj *Dependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dependency_metStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MetStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(MetStatus)
	fc.Result = res
	return ec.marshalNMetStatus2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐMetStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dependency_metStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MetStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dependency_name(ctx context.Context, field graphql.CollectedField, obj *Dependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dependency_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dependency_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dependency_requiredStatus(ctx context.Context, field graphql.CollectedField, obj *Dependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dependency_requiredStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RequiredStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(RequiredStatus)
	fc.Result = res
	return ec.marshalNRequiredStatus2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐRequiredStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dependency_requiredStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type RequiredStatus does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Dependency_taskId(ctx context.Context, field graphql.CollectedField, obj *Dependency) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Dependency_taskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Dependency_taskId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Dependency",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DispatcherSettings_version(ctx context.Context, field graphql.CollectedField, obj *model.APIDispatcherSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DispatcherSettings_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.DispatcherSettings().Version(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(DispatcherVersion)
	fc.Result = res
	return ec.marshalNDispatcherVersion2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDispatcherVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DispatcherSettings_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DispatcherSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type DispatcherVersion does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_aliases(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_aliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Aliases, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_aliases(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_arch(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_arch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Arch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_arch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_authorizedKeysFile(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_authorizedKeysFile(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AuthorizedKeysFile, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_authorizedKeysFile(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_bootstrapSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_bootstrapSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BootstrapSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIBootstrapSettings)
	fc.Result = res
	return ec.marshalNBootstrapSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIBootstrapSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_bootstrapSettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "clientDir":
				return ec.fieldContext_BootstrapSettings_clientDir(ctx, field)
			case "communication":
				return ec.fieldContext_BootstrapSettings_communication(ctx, field)
			case "env":
				return ec.fieldContext_BootstrapSettings_env(ctx, field)
			case "jasperBinaryDir":
				return ec.fieldContext_BootstrapSettings_jasperBinaryDir(ctx, field)
			case "jasperCredentialsPath":
				return ec.fieldContext_BootstrapSettings_jasperCredentialsPath(ctx, field)
			case "method":
				return ec.fieldContext_BootstrapSettings_method(ctx, field)
			case "preconditionScripts":
				return ec.fieldContext_BootstrapSettings_preconditionScripts(ctx, field)
			case "resourceLimits":
				return ec.fieldContext_BootstrapSettings_resourceLimits(ctx, field)
			case "rootDir":
				return ec.fieldContext_BootstrapSettings_rootDir(ctx, field)
			case "serviceUser":
				return ec.fieldContext_BootstrapSettings_serviceUser(ctx, field)
			case "shellPath":
				return ec.fieldContext_BootstrapSettings_shellPath(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BootstrapSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_cloneMethod(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_cloneMethod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Distro().CloneMethod(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(CloneMethod)
	fc.Result = res
	return ec.marshalNCloneMethod2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐCloneMethod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_cloneMethod(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type CloneMethod does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_containerPool(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_containerPool(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContainerPool, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_containerPool(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_disabled(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_disabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Disabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_disabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_disableShallowClone(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_disableShallowClone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisableShallowClone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_disableShallowClone(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_dispatcherSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_dispatcherSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DispatcherSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIDispatcherSettings)
	fc.Result = res
	return ec.marshalNDispatcherSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDispatcherSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_dispatcherSettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "version":
				return ec.fieldContext_DispatcherSettings_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DispatcherSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_expansions(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_expansions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Expansions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APIExpansion)
	fc.Result = res
	return ec.marshalNExpansion2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIExpansionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_expansions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_Expansion_key(ctx, field)
			case "value":
				return ec.fieldContext_Expansion_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Expansion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_finderSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_finderSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FinderSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIFinderSettings)
	fc.Result = res
	return ec.marshalNFinderSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIFinderSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_finderSettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "version":
				return ec.fieldContext_FinderSettings_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FinderSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_homeVolumeSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_homeVolumeSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HomeVolumeSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIHomeVolumeSettings)
	fc.Result = res
	return ec.marshalNHomeVolumeSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHomeVolumeSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_homeVolumeSettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "formatCommand":
				return ec.fieldContext_HomeVolumeSettings_formatCommand(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HomeVolumeSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_hostAllocatorSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_hostAllocatorSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostAllocatorSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIHostAllocatorSettings)
	fc.Result = res
	return ec.marshalNHostAllocatorSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHostAllocatorSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_hostAllocatorSettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "acceptableHostIdleTime":
				return ec.fieldContext_HostAllocatorSettings_acceptableHostIdleTime(ctx, field)
			case "feedbackRule":
				return ec.fieldContext_HostAllocatorSettings_feedbackRule(ctx, field)
			case "futureHostFraction":
				return ec.fieldContext_HostAllocatorSettings_futureHostFraction(ctx, field)
			case "hostsOverallocatedRule":
				return ec.fieldContext_HostAllocatorSettings_hostsOverallocatedRule(ctx, field)
			case "maximumHosts":
				return ec.fieldContext_HostAllocatorSettings_maximumHosts(ctx, field)
			case "minimumHosts":
				return ec.fieldContext_HostAllocatorSettings_minimumHosts(ctx, field)
			case "roundingRule":
				return ec.fieldContext_HostAllocatorSettings_roundingRule(ctx, field)
			case "version":
				return ec.fieldContext_HostAllocatorSettings_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HostAllocatorSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_iceCreamSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_iceCreamSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IcecreamSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIIceCreamSettings)
	fc.Result = res
	return ec.marshalNIceCreamSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIIceCreamSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_iceCreamSettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "configPath":
				return ec.fieldContext_IceCreamSettings_configPath(ctx, field)
			case "schedulerHost":
				return ec.fieldContext_IceCreamSettings_schedulerHost(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type IceCreamSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_isCluster(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_isCluster(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsCluster, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_isCluster(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_isVirtualWorkStation(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_isVirtualWorkStation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsVirtualWorkstation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_isVirtualWorkStation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_name(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_note(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_note(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Note, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_note(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_plannerSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_plannerSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PlannerSettings, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIPlannerSettings)
	fc.Result = res
	return ec.marshalNPlannerSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPlannerSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_plannerSettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "commitQueueFactor":
				return ec.fieldContext_PlannerSettings_commitQueueFactor(ctx, field)
			case "expectedRuntimeFactor":
				return ec.fieldContext_PlannerSettings_expectedRuntimeFactor(ctx, field)
			case "generateTaskFactor":
				return ec.fieldContext_PlannerSettings_generateTaskFactor(ctx, field)
			case "groupVersions":
				return ec.fieldContext_PlannerSettings_groupVersions(ctx, field)
			case "mainlineTimeInQueueFactor":
				return ec.fieldContext_PlannerSettings_mainlineTimeInQueueFactor(ctx, field)
			case "patchFactor":
				return ec.fieldContext_PlannerSettings_patchFactor(ctx, field)
			case "patchTimeInQueueFactor":
				return ec.fieldContext_PlannerSettings_patchTimeInQueueFactor(ctx, field)
			case "targetTime":
				return ec.fieldContext_PlannerSettings_targetTime(ctx, field)
			case "version":
				return ec.fieldContext_PlannerSettings_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PlannerSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_provider(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_provider(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Distro().Provider(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(Provider)
	fc.Result = res
	return ec.marshalNProvider2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProvider(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_provider(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Provider does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_providerSettingsList(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_providerSettingsList(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Distro().ProviderSettingsList(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]map[string]interface{})
	fc.Result = res
	return ec.marshalNMap2ᚕmapᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_providerSettingsList(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_setup(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_setup(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Setup, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_setup(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_setupAsSudo(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_setupAsSudo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SetupAsSudo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_setupAsSudo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_sshKey(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_sshKey(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SSHKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_sshKey(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_sshOptions(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_sshOptions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SSHOptions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_sshOptions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_user(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_userSpawnAllowed(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_userSpawnAllowed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserSpawnAllowed, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_userSpawnAllowed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_validProjects(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_validProjects(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ValidProjects, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalNString2ᚕᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_validProjects(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Distro_workDir(ctx context.Context, field graphql.CollectedField, obj *model.APIDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Distro_workDir(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkDir, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Distro_workDir(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Distro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroEvent_after(ctx context.Context, field graphql.CollectedField, obj *DistroEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroEvent_after(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.After, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroEvent_after(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroEvent_before(ctx context.Context, field graphql.CollectedField, obj *DistroEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroEvent_before(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Before, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroEvent_before(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroEvent_data(ctx context.Context, field graphql.CollectedField, obj *DistroEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroEvent_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroEvent_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroEvent_timestamp(ctx context.Context, field graphql.CollectedField, obj *DistroEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroEvent_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalNTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroEvent_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroEvent_user(ctx context.Context, field graphql.CollectedField, obj *DistroEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroEvent_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroEvent_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroEvent",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroEventsPayload_count(ctx context.Context, field graphql.CollectedField, obj *DistroEventsPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroEventsPayload_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroEventsPayload_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroEventsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroEventsPayload_eventLogEntries(ctx context.Context, field graphql.CollectedField, obj *DistroEventsPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroEventsPayload_eventLogEntries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventLogEntries, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*DistroEvent)
	fc.Result = res
	return ec.marshalNDistroEvent2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroEventᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroEventsPayload_eventLogEntries(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroEventsPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "after":
				return ec.fieldContext_DistroEvent_after(ctx, field)
			case "before":
				return ec.fieldContext_DistroEvent_before(ctx, field)
			case "data":
				return ec.fieldContext_DistroEvent_data(ctx, field)
			case "timestamp":
				return ec.fieldContext_DistroEvent_timestamp(ctx, field)
			case "user":
				return ec.fieldContext_DistroEvent_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DistroEvent", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroInfo_id(ctx context.Context, field graphql.CollectedField, obj *model.DistroInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroInfo_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroInfo_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroInfo_bootstrapMethod(ctx context.Context, field graphql.CollectedField, obj *model.DistroInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroInfo_bootstrapMethod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BootstrapMethod, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroInfo_bootstrapMethod(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroInfo_isVirtualWorkStation(ctx context.Context, field graphql.CollectedField, obj *model.DistroInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroInfo_isVirtualWorkStation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsVirtualWorkstation, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroInfo_isVirtualWorkStation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroInfo_isWindows(ctx context.Context, field graphql.CollectedField, obj *model.DistroInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroInfo_isWindows(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsWindows, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroInfo_isWindows(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroInfo_user(ctx context.Context, field graphql.CollectedField, obj *model.DistroInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroInfo_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroInfo_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroInfo_workDir(ctx context.Context, field graphql.CollectedField, obj *model.DistroInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroInfo_workDir(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkDir, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroInfo_workDir(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroPermissions_admin(ctx context.Context, field graphql.CollectedField, obj *DistroPermissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroPermissions_admin(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Admin, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroPermissions_admin(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroPermissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroPermissions_edit(ctx context.Context, field graphql.CollectedField, obj *DistroPermissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroPermissions_edit(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Edit, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroPermissions_edit(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroPermissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _DistroPermissions_view(ctx context.Context, field graphql.CollectedField, obj *DistroPermissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_DistroPermissions_view(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.View, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_DistroPermissions_view(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "DistroPermissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ECSConfig_maxCPU(ctx context.Context, field graphql.CollectedField, obj *model.APIECSConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ECSConfig_maxCPU(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxCPU, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalNInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ECSConfig_maxCPU(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ECSConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ECSConfig_maxMemoryMb(ctx context.Context, field graphql.CollectedField, obj *model.APIECSConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ECSConfig_maxMemoryMb(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaxMemoryMB, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalNInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ECSConfig_maxMemoryMb(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ECSConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EnvVar_key(ctx context.Context, field graphql.CollectedField, obj *model.APIEnvVar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EnvVar_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EnvVar_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EnvVar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _EnvVar_value(ctx context.Context, field graphql.CollectedField, obj *model.APIEnvVar) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_EnvVar_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_EnvVar_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "EnvVar",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Expansion_key(ctx context.Context, field graphql.CollectedField, obj *model.APIExpansion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Expansion_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Expansion_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Expansion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Expansion_value(ctx context.Context, field graphql.CollectedField, obj *model.APIExpansion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Expansion_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Expansion_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Expansion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExternalLink_displayName(ctx context.Context, field graphql.CollectedField, obj *model.APIExternalLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ExternalLink_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ExternalLink_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExternalLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExternalLink_requesters(ctx context.Context, field graphql.CollectedField, obj *model.APIExternalLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ExternalLink_requesters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Requesters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalNString2ᚕᚖstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ExternalLink_requesters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExternalLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExternalLink_urlTemplate(ctx context.Context, field graphql.CollectedField, obj *model.APIExternalLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ExternalLink_urlTemplate(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URLTemplate, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ExternalLink_urlTemplate(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExternalLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExternalLinkForMetadata_url(ctx context.Context, field graphql.CollectedField, obj *ExternalLinkForMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ExternalLinkForMetadata_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ExternalLinkForMetadata_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExternalLinkForMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ExternalLinkForMetadata_displayName(ctx context.Context, field graphql.CollectedField, obj *ExternalLinkForMetadata) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ExternalLinkForMetadata_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ExternalLinkForMetadata_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ExternalLinkForMetadata",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _File_link(ctx context.Context, field graphql.CollectedField, obj *model.APIFile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_File_link(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Link, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_File_link(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "File",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _File_name(ctx context.Context, field graphql.CollectedField, obj *model.APIFile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_File_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_File_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "File",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _File_visibility(ctx context.Context, field graphql.CollectedField, obj *model.APIFile) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_File_visibility(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Visibility, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_File_visibility(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "File",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDiff_additions(ctx context.Context, field graphql.CollectedField, obj *model.FileDiff) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDiff_additions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Additions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDiff_additions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDiff",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDiff_deletions(ctx context.Context, field graphql.CollectedField, obj *model.FileDiff) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDiff_deletions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Deletions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDiff_deletions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDiff",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDiff_description(ctx context.Context, field graphql.CollectedField, obj *model.FileDiff) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDiff_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDiff_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDiff",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDiff_diffLink(ctx context.Context, field graphql.CollectedField, obj *model.FileDiff) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDiff_diffLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DiffLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDiff_diffLink(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDiff",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FileDiff_fileName(ctx context.Context, field graphql.CollectedField, obj *model.FileDiff) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FileDiff_fileName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FileDiff_fileName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FileDiff",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _FinderSettings_version(ctx context.Context, field graphql.CollectedField, obj *model.APIFinderSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_FinderSettings_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.FinderSettings().Version(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(FinderVersion)
	fc.Result = res
	return ec.marshalNFinderVersion2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐFinderVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_FinderSettings_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "FinderSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type FinderVersion does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneralSubscription_id(ctx context.Context, field graphql.CollectedField, obj *model.APISubscription) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GeneralSubscription_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GeneralSubscription_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneralSubscription",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneralSubscription_ownerType(ctx context.Context, field graphql.CollectedField, obj *model.APISubscription) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GeneralSubscription_ownerType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OwnerType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GeneralSubscription_ownerType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneralSubscription",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneralSubscription_regexSelectors(ctx context.Context, field graphql.CollectedField, obj *model.APISubscription) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GeneralSubscription_regexSelectors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RegexSelectors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APISelector)
	fc.Result = res
	return ec.marshalNSelector2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISelectorᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GeneralSubscription_regexSelectors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneralSubscription",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_Selector_data(ctx, field)
			case "type":
				return ec.fieldContext_Selector_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Selector", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneralSubscription_resourceType(ctx context.Context, field graphql.CollectedField, obj *model.APISubscription) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GeneralSubscription_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GeneralSubscription_resourceType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneralSubscription",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneralSubscription_selectors(ctx context.Context, field graphql.CollectedField, obj *model.APISubscription) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GeneralSubscription_selectors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Selectors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APISelector)
	fc.Result = res
	return ec.marshalNSelector2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISelectorᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GeneralSubscription_selectors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneralSubscription",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "data":
				return ec.fieldContext_Selector_data(ctx, field)
			case "type":
				return ec.fieldContext_Selector_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Selector", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneralSubscription_subscriber(ctx context.Context, field graphql.CollectedField, obj *model.APISubscription) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GeneralSubscription_subscriber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Subscriber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.APISubscriber)
	fc.Result = res
	return ec.marshalOSubscriberWrapper2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISubscriber(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GeneralSubscription_subscriber(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneralSubscription",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "subscriber":
				return ec.fieldContext_SubscriberWrapper_subscriber(ctx, field)
			case "type":
				return ec.fieldContext_SubscriberWrapper_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SubscriberWrapper", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneralSubscription_trigger(ctx context.Context, field graphql.CollectedField, obj *model.APISubscription) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GeneralSubscription_trigger(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Trigger, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GeneralSubscription_trigger(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneralSubscription",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GeneralSubscription_triggerData(ctx context.Context, field graphql.CollectedField, obj *model.APISubscription) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GeneralSubscription_triggerData(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TriggerData, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]string)
	fc.Result = res
	return ec.marshalOStringMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GeneralSubscription_triggerData(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GeneralSubscription",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StringMap does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitTag_tag(ctx context.Context, field graphql.CollectedField, obj *model.APIGitTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitTag_tag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tag, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitTag_tag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GitTag_pusher(ctx context.Context, field graphql.CollectedField, obj *model.APIGitTag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GitTag_pusher(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pusher, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GitTag_pusher(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GitTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubCheckSubscriber_owner(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubCheckSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubCheckSubscriber_owner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubCheckSubscriber_owner(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubCheckSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubCheckSubscriber_ref(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubCheckSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubCheckSubscriber_ref(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ref, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubCheckSubscriber_ref(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubCheckSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubCheckSubscriber_repo(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubCheckSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubCheckSubscriber_repo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubCheckSubscriber_repo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubCheckSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubPRSubscriber_owner(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubPRSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubPRSubscriber_owner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubPRSubscriber_owner(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubPRSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubPRSubscriber_prNumber(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubPRSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubPRSubscriber_prNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PRNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubPRSubscriber_prNumber(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubPRSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubPRSubscriber_ref(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubPRSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubPRSubscriber_ref(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ref, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubPRSubscriber_ref(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubPRSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubPRSubscriber_repo(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubPRSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubPRSubscriber_repo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubPRSubscriber_repo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubPRSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubProjectConflicts_commitCheckIdentifiers(ctx context.Context, field graphql.CollectedField, obj *model1.GithubProjectConflicts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubProjectConflicts_commitCheckIdentifiers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CommitCheckIdentifiers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubProjectConflicts_commitCheckIdentifiers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubProjectConflicts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubProjectConflicts_commitQueueIdentifiers(ctx context.Context, field graphql.CollectedField, obj *model1.GithubProjectConflicts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubProjectConflicts_commitQueueIdentifiers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CommitQueueIdentifiers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubProjectConflicts_commitQueueIdentifiers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubProjectConflicts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubProjectConflicts_prTestingIdentifiers(ctx context.Context, field graphql.CollectedField, obj *model1.GithubProjectConflicts) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubProjectConflicts_prTestingIdentifiers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PRTestingIdentifiers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubProjectConflicts_prTestingIdentifiers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubProjectConflicts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubUser_lastKnownAs(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubUser_lastKnownAs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastKnownAs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubUser_lastKnownAs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GithubUser_uid(ctx context.Context, field graphql.CollectedField, obj *model.APIGithubUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GithubUser_uid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GithubUser_uid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GithubUser",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedBuildVariant_displayName(ctx context.Context, field graphql.CollectedField, obj *GroupedBuildVariant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupedBuildVariant_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupedBuildVariant_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedBuildVariant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedBuildVariant_tasks(ctx context.Context, field graphql.CollectedField, obj *GroupedBuildVariant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupedBuildVariant_tasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.APITask)
	fc.Result = res
	return ec.marshalOTask2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupedBuildVariant_tasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedBuildVariant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canSync":
				return ec.fieldContext_Task_canSync(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "taskFiles":
				return ec.fieldContext_Task_taskFiles(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedBuildVariant_variant(ctx context.Context, field graphql.CollectedField, obj *GroupedBuildVariant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupedBuildVariant_variant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Variant, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupedBuildVariant_variant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedBuildVariant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedFiles_files(ctx context.Context, field graphql.CollectedField, obj *GroupedFiles) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupedFiles_files(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Files, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.APIFile)
	fc.Result = res
	return ec.marshalOFile2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIFileᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupedFiles_files(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedFiles",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "link":
				return ec.fieldContext_File_link(ctx, field)
			case "name":
				return ec.fieldContext_File_name(ctx, field)
			case "visibility":
				return ec.fieldContext_File_visibility(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type File", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedFiles_taskName(ctx context.Context, field graphql.CollectedField, obj *GroupedFiles) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupedFiles_taskName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupedFiles_taskName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedFiles",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedProjects_groupDisplayName(ctx context.Context, field graphql.CollectedField, obj *GroupedProjects) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupedProjects_groupDisplayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GroupDisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupedProjects_groupDisplayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedProjects",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedProjects_projects(ctx context.Context, field graphql.CollectedField, obj *GroupedProjects) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupedProjects_projects(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Projects, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIProjectRef)
	fc.Result = res
	return ec.marshalNProject2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRefᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupedProjects_projects(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedProjects",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "private":
				return ec.fieldContext_Project_private(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "taskSync":
				return ec.fieldContext_Project_taskSync(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedProjects_repo(ctx context.Context, field graphql.CollectedField, obj *GroupedProjects) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupedProjects_repo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectRef)
	fc.Result = res
	return ec.marshalORepoRef2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupedProjects_repo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedProjects",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RepoRef_id(ctx, field)
			case "admins":
				return ec.fieldContext_RepoRef_admins(ctx, field)
			case "batchTime":
				return ec.fieldContext_RepoRef_batchTime(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_RepoRef_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_RepoRef_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_RepoRef_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_RepoRef_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_RepoRef_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_RepoRef_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_RepoRef_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_RepoRef_enabled(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_RepoRef_githubChecksEnabled(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_RepoRef_githubTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_RepoRef_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_RepoRef_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_RepoRef_gitTagVersionsEnabled(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_RepoRef_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_RepoRef_notifyOnBuildFailure(ctx, field)
			case "owner":
				return ec.fieldContext_RepoRef_owner(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_RepoRef_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_RepoRef_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_RepoRef_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_RepoRef_periodicBuilds(ctx, field)
			case "private":
				return ec.fieldContext_RepoRef_private(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_RepoRef_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_RepoRef_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_RepoRef_repo(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_RepoRef_repotrackerDisabled(ctx, field)
			case "restricted":
				return ec.fieldContext_RepoRef_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_RepoRef_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_RepoRef_stepbackDisabled(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_RepoRef_taskAnnotationSettings(ctx, field)
			case "taskSync":
				return ec.fieldContext_RepoRef_taskSync(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_RepoRef_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_RepoRef_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_RepoRef_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_RepoRef_workstationConfig(ctx, field)
			case "externalLinks":
				return ec.fieldContext_RepoRef_externalLinks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepoRef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedTaskStatusCount_displayName(ctx context.Context, field graphql.CollectedField, obj *task.GroupedTaskStatusCount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupedTaskStatusCount_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupedTaskStatusCount_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedTaskStatusCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedTaskStatusCount_statusCounts(ctx context.Context, field graphql.CollectedField, obj *task.GroupedTaskStatusCount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupedTaskStatusCount_statusCounts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StatusCounts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*task.StatusCount)
	fc.Result = res
	return ec.marshalNStatusCount2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋtaskᚐStatusCountᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupedTaskStatusCount_statusCounts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedTaskStatusCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_StatusCount_count(ctx, field)
			case "status":
				return ec.fieldContext_StatusCount_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StatusCount", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _GroupedTaskStatusCount_variant(ctx context.Context, field graphql.CollectedField, obj *task.GroupedTaskStatusCount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_GroupedTaskStatusCount_variant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Variant, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_GroupedTaskStatusCount_variant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "GroupedTaskStatusCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HomeVolumeSettings_formatCommand(ctx context.Context, field graphql.CollectedField, obj *model.APIHomeVolumeSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HomeVolumeSettings_formatCommand(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FormatCommand, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HomeVolumeSettings_formatCommand(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HomeVolumeSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_id(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNID2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_availabilityZone(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_availabilityZone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvailabilityZone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_availabilityZone(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_ami(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_ami(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Host().Ami(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_ami(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_displayName(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_distro(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_distro(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distro, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.DistroInfo)
	fc.Result = res
	return ec.marshalODistroInfo2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐDistroInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_distro(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_DistroInfo_id(ctx, field)
			case "bootstrapMethod":
				return ec.fieldContext_DistroInfo_bootstrapMethod(ctx, field)
			case "isVirtualWorkStation":
				return ec.fieldContext_DistroInfo_isVirtualWorkStation(ctx, field)
			case "isWindows":
				return ec.fieldContext_DistroInfo_isWindows(ctx, field)
			case "user":
				return ec.fieldContext_DistroInfo_user(ctx, field)
			case "workDir":
				return ec.fieldContext_DistroInfo_workDir(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DistroInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_distroId(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_distroId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Host().DistroID(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_distroId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_elapsed(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_elapsed(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Host().Elapsed(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_elapsed(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_expiration(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_expiration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Expiration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_expiration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_hostUrl(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_hostUrl(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_hostUrl(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_homeVolume(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_homeVolume(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Host().HomeVolume(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIVolume)
	fc.Result = res
	return ec.marshalOVolume2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVolume(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_homeVolume(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Volume_id(ctx, field)
			case "availabilityZone":
				return ec.fieldContext_Volume_availabilityZone(ctx, field)
			case "createdBy":
				return ec.fieldContext_Volume_createdBy(ctx, field)
			case "creationTime":
				return ec.fieldContext_Volume_creationTime(ctx, field)
			case "deviceName":
				return ec.fieldContext_Volume_deviceName(ctx, field)
			case "displayName":
				return ec.fieldContext_Volume_displayName(ctx, field)
			case "expiration":
				return ec.fieldContext_Volume_expiration(ctx, field)
			case "homeVolume":
				return ec.fieldContext_Volume_homeVolume(ctx, field)
			case "host":
				return ec.fieldContext_Volume_host(ctx, field)
			case "hostID":
				return ec.fieldContext_Volume_hostID(ctx, field)
			case "migrating":
				return ec.fieldContext_Volume_migrating(ctx, field)
			case "noExpiration":
				return ec.fieldContext_Volume_noExpiration(ctx, field)
			case "size":
				return ec.fieldContext_Volume_size(ctx, field)
			case "type":
				return ec.fieldContext_Volume_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Volume", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_homeVolumeID(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_homeVolumeID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HomeVolumeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_homeVolumeID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_instanceType(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_instanceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InstanceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_instanceType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_instanceTags(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_instanceTags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InstanceTags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]host.Tag)
	fc.Result = res
	return ec.marshalNInstanceTag2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋhostᚐTagᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_instanceTags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "canBeModified":
				return ec.fieldContext_InstanceTag_canBeModified(ctx, field)
			case "key":
				return ec.fieldContext_InstanceTag_key(ctx, field)
			case "value":
				return ec.fieldContext_InstanceTag_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type InstanceTag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_lastCommunicationTime(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_lastCommunicationTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LastCommunicationTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_lastCommunicationTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_noExpiration(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_noExpiration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NoExpiration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_noExpiration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_provider(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_provider(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Provider, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_provider(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_runningTask(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_runningTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RunningTask, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.TaskInfo)
	fc.Result = res
	return ec.marshalOTaskInfo2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐTaskInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_runningTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TaskInfo_id(ctx, field)
			case "name":
				return ec.fieldContext_TaskInfo_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_startedBy(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_startedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_startedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_status(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_tag(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_tag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tag, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_tag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_totalIdleTime(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_totalIdleTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalIdleTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.APIDuration)
	fc.Result = res
	return ec.marshalODuration2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_totalIdleTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_uptime(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_uptime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Host().Uptime(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_uptime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_user(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Host_volumes(ctx context.Context, field graphql.CollectedField, obj *model.APIHost) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Host_volumes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Host().Volumes(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIVolume)
	fc.Result = res
	return ec.marshalNVolume2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVolumeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Host_volumes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Host",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Volume_id(ctx, field)
			case "availabilityZone":
				return ec.fieldContext_Volume_availabilityZone(ctx, field)
			case "createdBy":
				return ec.fieldContext_Volume_createdBy(ctx, field)
			case "creationTime":
				return ec.fieldContext_Volume_creationTime(ctx, field)
			case "deviceName":
				return ec.fieldContext_Volume_deviceName(ctx, field)
			case "displayName":
				return ec.fieldContext_Volume_displayName(ctx, field)
			case "expiration":
				return ec.fieldContext_Volume_expiration(ctx, field)
			case "homeVolume":
				return ec.fieldContext_Volume_homeVolume(ctx, field)
			case "host":
				return ec.fieldContext_Volume_host(ctx, field)
			case "hostID":
				return ec.fieldContext_Volume_hostID(ctx, field)
			case "migrating":
				return ec.fieldContext_Volume_migrating(ctx, field)
			case "noExpiration":
				return ec.fieldContext_Volume_noExpiration(ctx, field)
			case "size":
				return ec.fieldContext_Volume_size(ctx, field)
			case "type":
				return ec.fieldContext_Volume_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Volume", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostAllocatorSettings_acceptableHostIdleTime(ctx context.Context, field graphql.CollectedField, obj *model.APIHostAllocatorSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostAllocatorSettings_acceptableHostIdleTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AcceptableHostIdleTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIDuration)
	fc.Result = res
	return ec.marshalNDuration2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostAllocatorSettings_acceptableHostIdleTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostAllocatorSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostAllocatorSettings_feedbackRule(ctx context.Context, field graphql.CollectedField, obj *model.APIHostAllocatorSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostAllocatorSettings_feedbackRule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeedbackRule, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostAllocatorSettings_feedbackRule(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostAllocatorSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostAllocatorSettings_futureHostFraction(ctx context.Context, field graphql.CollectedField, obj *model.APIHostAllocatorSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostAllocatorSettings_futureHostFraction(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FutureHostFraction, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalNFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostAllocatorSettings_futureHostFraction(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostAllocatorSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostAllocatorSettings_hostsOverallocatedRule(ctx context.Context, field graphql.CollectedField, obj *model.APIHostAllocatorSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostAllocatorSettings_hostsOverallocatedRule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostsOverallocatedRule, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostAllocatorSettings_hostsOverallocatedRule(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostAllocatorSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostAllocatorSettings_maximumHosts(ctx context.Context, field graphql.CollectedField, obj *model.APIHostAllocatorSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostAllocatorSettings_maximumHosts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MaximumHosts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostAllocatorSettings_maximumHosts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostAllocatorSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostAllocatorSettings_minimumHosts(ctx context.Context, field graphql.CollectedField, obj *model.APIHostAllocatorSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostAllocatorSettings_minimumHosts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MinimumHosts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostAllocatorSettings_minimumHosts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostAllocatorSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostAllocatorSettings_roundingRule(ctx context.Context, field graphql.CollectedField, obj *model.APIHostAllocatorSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostAllocatorSettings_roundingRule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RoundingRule, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostAllocatorSettings_roundingRule(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostAllocatorSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostAllocatorSettings_version(ctx context.Context, field graphql.CollectedField, obj *model.APIHostAllocatorSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostAllocatorSettings_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostAllocatorSettings_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostAllocatorSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_agentBuild(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_agentBuild(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentBuild, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_agentBuild(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_agentRevision(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_agentRevision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentRevision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_agentRevision(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_duration(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_duration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Duration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIDuration)
	fc.Result = res
	return ec.marshalNDuration2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_duration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_execution(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_execution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Execution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_execution(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_hostname(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_hostname(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hostname, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_hostname(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_jasperRevision(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_jasperRevision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JasperRevision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_jasperRevision(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_logs(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_logs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Logs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_logs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_monitorOp(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_monitorOp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MonitorOp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_monitorOp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_newStatus(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_newStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_newStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_oldStatus(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_oldStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OldStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_oldStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_provisioningMethod(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_provisioningMethod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProvisioningMethod, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_provisioningMethod(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_successful(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_successful(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Successful, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_successful(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_taskId(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_taskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_taskId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_taskPid(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_taskPid(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskPid, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_taskPid(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_taskStatus(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_taskStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_taskStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogData_user(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogData_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogData_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogEntry_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogEntry_data(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogEntry_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.HostAPIEventData)
	fc.Result = res
	return ec.marshalNHostEventLogData2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐHostAPIEventData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogEntry_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "agentBuild":
				return ec.fieldContext_HostEventLogData_agentBuild(ctx, field)
			case "agentRevision":
				return ec.fieldContext_HostEventLogData_agentRevision(ctx, field)
			case "duration":
				return ec.fieldContext_HostEventLogData_duration(ctx, field)
			case "execution":
				return ec.fieldContext_HostEventLogData_execution(ctx, field)
			case "hostname":
				return ec.fieldContext_HostEventLogData_hostname(ctx, field)
			case "jasperRevision":
				return ec.fieldContext_HostEventLogData_jasperRevision(ctx, field)
			case "logs":
				return ec.fieldContext_HostEventLogData_logs(ctx, field)
			case "monitorOp":
				return ec.fieldContext_HostEventLogData_monitorOp(ctx, field)
			case "newStatus":
				return ec.fieldContext_HostEventLogData_newStatus(ctx, field)
			case "oldStatus":
				return ec.fieldContext_HostEventLogData_oldStatus(ctx, field)
			case "provisioningMethod":
				return ec.fieldContext_HostEventLogData_provisioningMethod(ctx, field)
			case "successful":
				return ec.fieldContext_HostEventLogData_successful(ctx, field)
			case "taskId":
				return ec.fieldContext_HostEventLogData_taskId(ctx, field)
			case "taskPid":
				return ec.fieldContext_HostEventLogData_taskPid(ctx, field)
			case "taskStatus":
				return ec.fieldContext_HostEventLogData_taskStatus(ctx, field)
			case "user":
				return ec.fieldContext_HostEventLogData_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HostEventLogData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogEntry_eventType(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogEntry_eventType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogEntry_eventType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogEntry_processedAt(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogEntry_processedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProcessedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogEntry_processedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogEntry_resourceId(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogEntry_resourceId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogEntry_resourceId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogEntry_resourceType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEventLogEntry_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.HostAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEventLogEntry_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEventLogEntry_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEvents_count(ctx context.Context, field graphql.CollectedField, obj *HostEvents) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEvents_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEvents_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEvents",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostEvents_eventLogEntries(ctx context.Context, field graphql.CollectedField, obj *HostEvents) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostEvents_eventLogEntries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventLogEntries, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.HostAPIEventLogEntry)
	fc.Result = res
	return ec.marshalNHostEventLogEntry2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐHostAPIEventLogEntryᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostEvents_eventLogEntries(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostEvents",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_HostEventLogEntry_id(ctx, field)
			case "data":
				return ec.fieldContext_HostEventLogEntry_data(ctx, field)
			case "eventType":
				return ec.fieldContext_HostEventLogEntry_eventType(ctx, field)
			case "processedAt":
				return ec.fieldContext_HostEventLogEntry_processedAt(ctx, field)
			case "resourceId":
				return ec.fieldContext_HostEventLogEntry_resourceId(ctx, field)
			case "resourceType":
				return ec.fieldContext_HostEventLogEntry_resourceType(ctx, field)
			case "timestamp":
				return ec.fieldContext_HostEventLogEntry_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HostEventLogEntry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostsResponse_filteredHostsCount(ctx context.Context, field graphql.CollectedField, obj *HostsResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostsResponse_filteredHostsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FilteredHostsCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostsResponse_filteredHostsCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostsResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostsResponse_hosts(ctx context.Context, field graphql.CollectedField, obj *HostsResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostsResponse_hosts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hosts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIHost)
	fc.Result = res
	return ec.marshalNHost2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHostᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostsResponse_hosts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostsResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "availabilityZone":
				return ec.fieldContext_Host_availabilityZone(ctx, field)
			case "ami":
				return ec.fieldContext_Host_ami(ctx, field)
			case "displayName":
				return ec.fieldContext_Host_displayName(ctx, field)
			case "distro":
				return ec.fieldContext_Host_distro(ctx, field)
			case "distroId":
				return ec.fieldContext_Host_distroId(ctx, field)
			case "elapsed":
				return ec.fieldContext_Host_elapsed(ctx, field)
			case "expiration":
				return ec.fieldContext_Host_expiration(ctx, field)
			case "hostUrl":
				return ec.fieldContext_Host_hostUrl(ctx, field)
			case "homeVolume":
				return ec.fieldContext_Host_homeVolume(ctx, field)
			case "homeVolumeID":
				return ec.fieldContext_Host_homeVolumeID(ctx, field)
			case "instanceType":
				return ec.fieldContext_Host_instanceType(ctx, field)
			case "instanceTags":
				return ec.fieldContext_Host_instanceTags(ctx, field)
			case "lastCommunicationTime":
				return ec.fieldContext_Host_lastCommunicationTime(ctx, field)
			case "noExpiration":
				return ec.fieldContext_Host_noExpiration(ctx, field)
			case "provider":
				return ec.fieldContext_Host_provider(ctx, field)
			case "runningTask":
				return ec.fieldContext_Host_runningTask(ctx, field)
			case "startedBy":
				return ec.fieldContext_Host_startedBy(ctx, field)
			case "status":
				return ec.fieldContext_Host_status(ctx, field)
			case "tag":
				return ec.fieldContext_Host_tag(ctx, field)
			case "totalIdleTime":
				return ec.fieldContext_Host_totalIdleTime(ctx, field)
			case "uptime":
				return ec.fieldContext_Host_uptime(ctx, field)
			case "user":
				return ec.fieldContext_Host_user(ctx, field)
			case "volumes":
				return ec.fieldContext_Host_volumes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _HostsResponse_totalHostsCount(ctx context.Context, field graphql.CollectedField, obj *HostsResponse) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_HostsResponse_totalHostsCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalHostsCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_HostsResponse_totalHostsCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "HostsResponse",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IceCreamSettings_configPath(ctx context.Context, field graphql.CollectedField, obj *model.APIIceCreamSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IceCreamSettings_configPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConfigPath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IceCreamSettings_configPath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IceCreamSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IceCreamSettings_schedulerHost(ctx context.Context, field graphql.CollectedField, obj *model.APIIceCreamSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IceCreamSettings_schedulerHost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SchedulerHost, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IceCreamSettings_schedulerHost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IceCreamSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InstanceTag_canBeModified(ctx context.Context, field graphql.CollectedField, obj *host.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InstanceTag_canBeModified(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CanBeModified, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InstanceTag_canBeModified(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InstanceTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InstanceTag_key(ctx context.Context, field graphql.CollectedField, obj *host.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InstanceTag_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InstanceTag_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InstanceTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _InstanceTag_value(ctx context.Context, field graphql.CollectedField, obj *host.Tag) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_InstanceTag_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_InstanceTag_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "InstanceTag",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IssueLink_confidenceScore(ctx context.Context, field graphql.CollectedField, obj *model.APIIssueLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IssueLink_confidenceScore(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConfidenceScore, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*float64)
	fc.Result = res
	return ec.marshalOFloat2ᚖfloat64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IssueLink_confidenceScore(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IssueLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IssueLink_issueKey(ctx context.Context, field graphql.CollectedField, obj *model.APIIssueLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IssueLink_issueKey(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IssueKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IssueLink_issueKey(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IssueLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _IssueLink_jiraTicket(ctx context.Context, field graphql.CollectedField, obj *model.APIIssueLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IssueLink_jiraTicket(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.IssueLink().JiraTicket(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*thirdparty.JiraTicket)
	fc.Result = res
	return ec.marshalOJiraTicket2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐJiraTicket(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IssueLink_jiraTicket(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IssueLink",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "fields":
				return ec.fieldContext_JiraTicket_fields(ctx, field)
			case "key":
				return ec.fieldContext_JiraTicket_key(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JiraTicket", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IssueLink_source(ctx context.Context, field graphql.CollectedField, obj *model.APIIssueLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IssueLink_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APISource)
	fc.Result = res
	return ec.marshalOSource2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IssueLink_source(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IssueLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "author":
				return ec.fieldContext_Source_author(ctx, field)
			case "requester":
				return ec.fieldContext_Source_requester(ctx, field)
			case "time":
				return ec.fieldContext_Source_time(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Source", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _IssueLink_url(ctx context.Context, field graphql.CollectedField, obj *model.APIIssueLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_IssueLink_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_IssueLink_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "IssueLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraConfig_host(ctx context.Context, field graphql.CollectedField, obj *model.APIJiraConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JiraConfig_host(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Host, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JiraConfig_host(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraField_displayText(ctx context.Context, field graphql.CollectedField, obj *model.APIJiraField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JiraField_displayText(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayText, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JiraField_displayText(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraField",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraField_field(ctx context.Context, field graphql.CollectedField, obj *model.APIJiraField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JiraField_field(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Field, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JiraField_field(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraField",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraIssueSubscriber_issueType(ctx context.Context, field graphql.CollectedField, obj *model.APIJIRAIssueSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JiraIssueSubscriber_issueType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IssueType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JiraIssueSubscriber_issueType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraIssueSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraIssueSubscriber_project(ctx context.Context, field graphql.CollectedField, obj *model.APIJIRAIssueSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JiraIssueSubscriber_project(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Project, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JiraIssueSubscriber_project(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraIssueSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraStatus_id(ctx context.Context, field graphql.CollectedField, obj *thirdparty.JiraStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JiraStatus_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JiraStatus_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraStatus_name(ctx context.Context, field graphql.CollectedField, obj *thirdparty.JiraStatus) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JiraStatus_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JiraStatus_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraStatus",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraTicket_fields(ctx context.Context, field graphql.CollectedField, obj *thirdparty.JiraTicket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JiraTicket_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*thirdparty.TicketFields)
	fc.Result = res
	return ec.marshalNTicketFields2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐTicketFields(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JiraTicket_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraTicket",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "assignedTeam":
				return ec.fieldContext_TicketFields_assignedTeam(ctx, field)
			case "assigneeDisplayName":
				return ec.fieldContext_TicketFields_assigneeDisplayName(ctx, field)
			case "created":
				return ec.fieldContext_TicketFields_created(ctx, field)
			case "resolutionName":
				return ec.fieldContext_TicketFields_resolutionName(ctx, field)
			case "status":
				return ec.fieldContext_TicketFields_status(ctx, field)
			case "summary":
				return ec.fieldContext_TicketFields_summary(ctx, field)
			case "updated":
				return ec.fieldContext_TicketFields_updated(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TicketFields", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _JiraTicket_key(ctx context.Context, field graphql.CollectedField, obj *thirdparty.JiraTicket) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_JiraTicket_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_JiraTicket_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "JiraTicket",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogMessage_message(ctx context.Context, field graphql.CollectedField, obj *apimodels.LogMessage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogMessage_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogMessage_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogMessage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogMessage_severity(ctx context.Context, field graphql.CollectedField, obj *apimodels.LogMessage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogMessage_severity(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Severity, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogMessage_severity(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogMessage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogMessage_timestamp(ctx context.Context, field graphql.CollectedField, obj *apimodels.LogMessage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogMessage_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(time.Time)
	fc.Result = res
	return ec.marshalOTime2timeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogMessage_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogMessage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogMessage_type(ctx context.Context, field graphql.CollectedField, obj *apimodels.LogMessage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogMessage_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogMessage_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogMessage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogMessage_version(ctx context.Context, field graphql.CollectedField, obj *apimodels.LogMessage) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogMessage_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogMessage_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogMessage",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperBuild_id(ctx context.Context, field graphql.CollectedField, obj *plank.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperBuild_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperBuild_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperBuild_builder(ctx context.Context, field graphql.CollectedField, obj *plank.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperBuild_builder(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Builder, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperBuild_builder(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperBuild_buildNum(ctx context.Context, field graphql.CollectedField, obj *plank.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperBuild_buildNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperBuild_buildNum(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperBuild_taskId(ctx context.Context, field graphql.CollectedField, obj *plank.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperBuild_taskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperBuild_taskId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperBuild_taskExecution(ctx context.Context, field graphql.CollectedField, obj *plank.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperBuild_taskExecution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskExecution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperBuild_taskExecution(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperBuild_tests(ctx context.Context, field graphql.CollectedField, obj *plank.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperBuild_tests(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tests, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]plank.Test)
	fc.Result = res
	return ec.marshalNLogkeeperTest2ᚕgithubᚗcomᚋevergreenᚑciᚋplankᚐTestᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperBuild_tests(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LogkeeperTest_id(ctx, field)
			case "name":
				return ec.fieldContext_LogkeeperTest_name(ctx, field)
			case "buildId":
				return ec.fieldContext_LogkeeperTest_buildId(ctx, field)
			case "taskId":
				return ec.fieldContext_LogkeeperTest_taskId(ctx, field)
			case "taskExecution":
				return ec.fieldContext_LogkeeperTest_taskExecution(ctx, field)
			case "phase":
				return ec.fieldContext_LogkeeperTest_phase(ctx, field)
			case "command":
				return ec.fieldContext_LogkeeperTest_command(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LogkeeperTest", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperBuild_task(ctx context.Context, field graphql.CollectedField, obj *plank.Build) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperBuild_task(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.LogkeeperBuild().Task(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APITask)
	fc.Result = res
	return ec.marshalNTask2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperBuild_task(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperBuild",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canSync":
				return ec.fieldContext_Task_canSync(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "taskFiles":
				return ec.fieldContext_Task_taskFiles(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperTest_id(ctx context.Context, field graphql.CollectedField, obj *plank.Test) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperTest_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperTest_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperTest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperTest_name(ctx context.Context, field graphql.CollectedField, obj *plank.Test) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperTest_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperTest_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperTest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperTest_buildId(ctx context.Context, field graphql.CollectedField, obj *plank.Test) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperTest_buildId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperTest_buildId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperTest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperTest_taskId(ctx context.Context, field graphql.CollectedField, obj *plank.Test) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperTest_taskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperTest_taskId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperTest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperTest_taskExecution(ctx context.Context, field graphql.CollectedField, obj *plank.Test) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperTest_taskExecution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskExecution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperTest_taskExecution(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperTest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperTest_phase(ctx context.Context, field graphql.CollectedField, obj *plank.Test) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperTest_phase(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Phase, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperTest_phase(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperTest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _LogkeeperTest_command(ctx context.Context, field graphql.CollectedField, obj *plank.Test) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_LogkeeperTest_command(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Command, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_LogkeeperTest_command(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "LogkeeperTest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MainlineCommitVersion_rolledUpVersions(ctx context.Context, field graphql.CollectedField, obj *MainlineCommitVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MainlineCommitVersion_rolledUpVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RolledUpVersions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.APIVersion)
	fc.Result = res
	return ec.marshalOVersion2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVersionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MainlineCommitVersion_rolledUpVersions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MainlineCommitVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MainlineCommitVersion_version(ctx context.Context, field graphql.CollectedField, obj *MainlineCommitVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MainlineCommitVersion_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIVersion)
	fc.Result = res
	return ec.marshalOVersion2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MainlineCommitVersion_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MainlineCommitVersion",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _MainlineCommits_nextPageOrderNumber(ctx context.Context, field graphql.CollectedField, obj *MainlineCommits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MainlineCommits_nextPageOrderNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextPageOrderNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MainlineCommits_nextPageOrderNumber(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MainlineCommits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MainlineCommits_prevPageOrderNumber(ctx context.Context, field graphql.CollectedField, obj *MainlineCommits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MainlineCommits_prevPageOrderNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PrevPageOrderNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MainlineCommits_prevPageOrderNumber(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MainlineCommits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MainlineCommits_versions(ctx context.Context, field graphql.CollectedField, obj *MainlineCommits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MainlineCommits_versions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Versions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*MainlineCommitVersion)
	fc.Result = res
	return ec.marshalNMainlineCommitVersion2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐMainlineCommitVersionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MainlineCommits_versions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MainlineCommits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "rolledUpVersions":
				return ec.fieldContext_MainlineCommitVersion_rolledUpVersions(ctx, field)
			case "version":
				return ec.fieldContext_MainlineCommitVersion_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MainlineCommitVersion", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Manifest_id(ctx context.Context, field graphql.CollectedField, obj *Manifest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Manifest_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Manifest_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Manifest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Manifest_branch(ctx context.Context, field graphql.CollectedField, obj *Manifest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Manifest_branch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Branch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Manifest_branch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Manifest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Manifest_isBase(ctx context.Context, field graphql.CollectedField, obj *Manifest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Manifest_isBase(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsBase, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Manifest_isBase(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Manifest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Manifest_moduleOverrides(ctx context.Context, field graphql.CollectedField, obj *Manifest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Manifest_moduleOverrides(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModuleOverrides, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]string)
	fc.Result = res
	return ec.marshalOStringMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Manifest_moduleOverrides(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Manifest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StringMap does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Manifest_modules(ctx context.Context, field graphql.CollectedField, obj *Manifest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Manifest_modules(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Modules, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]interface{})
	fc.Result = res
	return ec.marshalOMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Manifest_modules(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Manifest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Map does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Manifest_project(ctx context.Context, field graphql.CollectedField, obj *Manifest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Manifest_project(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Project, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Manifest_project(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Manifest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Manifest_revision(ctx context.Context, field graphql.CollectedField, obj *Manifest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Manifest_revision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Manifest_revision(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Manifest",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MetadataLink_url(ctx context.Context, field graphql.CollectedField, obj *model.APIMetadataLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MetadataLink_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MetadataLink_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MetadataLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MetadataLink_text(ctx context.Context, field graphql.CollectedField, obj *model.APIMetadataLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MetadataLink_text(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Text, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MetadataLink_text(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MetadataLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _MetadataLink_source(ctx context.Context, field graphql.CollectedField, obj *model.APIMetadataLink) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_MetadataLink_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APISource)
	fc.Result = res
	return ec.marshalOSource2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_MetadataLink_source(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "MetadataLink",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "author":
				return ec.fieldContext_Source_author(ctx, field)
			case "requester":
				return ec.fieldContext_Source_requester(ctx, field)
			case "time":
				return ec.fieldContext_Source_time(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Source", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Module_issue(ctx context.Context, field graphql.CollectedField, obj *model.APIModule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Module_issue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Issue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Module_issue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Module",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Module_module(ctx context.Context, field graphql.CollectedField, obj *model.APIModule) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Module_module(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Module, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Module_module(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Module",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModuleCodeChange_branchName(ctx context.Context, field graphql.CollectedField, obj *model.APIModulePatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModuleCodeChange_branchName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BranchName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModuleCodeChange_branchName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModuleCodeChange",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModuleCodeChange_fileDiffs(ctx context.Context, field graphql.CollectedField, obj *model.APIModulePatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModuleCodeChange_fileDiffs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileDiffs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.FileDiff)
	fc.Result = res
	return ec.marshalNFileDiff2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐFileDiffᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModuleCodeChange_fileDiffs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModuleCodeChange",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "additions":
				return ec.fieldContext_FileDiff_additions(ctx, field)
			case "deletions":
				return ec.fieldContext_FileDiff_deletions(ctx, field)
			case "description":
				return ec.fieldContext_FileDiff_description(ctx, field)
			case "diffLink":
				return ec.fieldContext_FileDiff_diffLink(ctx, field)
			case "fileName":
				return ec.fieldContext_FileDiff_fileName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type FileDiff", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModuleCodeChange_htmlLink(ctx context.Context, field graphql.CollectedField, obj *model.APIModulePatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModuleCodeChange_htmlLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HTMLLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModuleCodeChange_htmlLink(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModuleCodeChange",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ModuleCodeChange_rawLink(ctx context.Context, field graphql.CollectedField, obj *model.APIModulePatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ModuleCodeChange_rawLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RawLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ModuleCodeChange_rawLink(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ModuleCodeChange",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_bbCreateTicket(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_bbCreateTicket(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().BbCreateTicket(rctx, fc.Args["taskId"].(string), fc.Args["execution"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_bbCreateTicket(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_bbCreateTicket_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addAnnotationIssue(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addAnnotationIssue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddAnnotationIssue(rctx, fc.Args["taskId"].(string), fc.Args["execution"].(int), fc.Args["apiIssue"].(model.APIIssueLink), fc.Args["isIssue"].(bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addAnnotationIssue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addAnnotationIssue_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_editAnnotationNote(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_editAnnotationNote(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().EditAnnotationNote(rctx, fc.Args["taskId"].(string), fc.Args["execution"].(int), fc.Args["originalMessage"].(string), fc.Args["newMessage"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_editAnnotationNote(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_editAnnotationNote_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_moveAnnotationIssue(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_moveAnnotationIssue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().MoveAnnotationIssue(rctx, fc.Args["taskId"].(string), fc.Args["execution"].(int), fc.Args["apiIssue"].(model.APIIssueLink), fc.Args["isIssue"].(bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_moveAnnotationIssue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_moveAnnotationIssue_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_removeAnnotationIssue(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_removeAnnotationIssue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RemoveAnnotationIssue(rctx, fc.Args["taskId"].(string), fc.Args["execution"].(int), fc.Args["apiIssue"].(model.APIIssueLink), fc.Args["isIssue"].(bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_removeAnnotationIssue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_removeAnnotationIssue_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setAnnotationMetadataLinks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_setAnnotationMetadataLinks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SetAnnotationMetadataLinks(rctx, fc.Args["taskId"].(string), fc.Args["execution"].(int), fc.Args["metadataLinks"].([]*model.APIMetadataLink))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_setAnnotationMetadataLinks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setAnnotationMetadataLinks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteDistro(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteDistro(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteDistro(rctx, fc.Args["opts"].(DeleteDistroInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*DeleteDistroPayload)
	fc.Result = res
	return ec.marshalNDeleteDistroPayload2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDeleteDistroPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteDistro(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "deletedDistroId":
				return ec.fieldContext_DeleteDistroPayload_deletedDistroId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DeleteDistroPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteDistro_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_copyDistro(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_copyDistro(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CopyDistro(rctx, fc.Args["opts"].(data.CopyDistroOpts))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*NewDistroPayload)
	fc.Result = res
	return ec.marshalNNewDistroPayload2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐNewDistroPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_copyDistro(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "newDistroId":
				return ec.fieldContext_NewDistroPayload_newDistroId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NewDistroPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_copyDistro_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createDistro(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createDistro(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateDistro(rctx, fc.Args["opts"].(CreateDistroInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*NewDistroPayload)
	fc.Result = res
	return ec.marshalNNewDistroPayload2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐNewDistroPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createDistro(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "newDistroId":
				return ec.fieldContext_NewDistroPayload_newDistroId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type NewDistroPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createDistro_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_saveDistro(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_saveDistro(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SaveDistro(rctx, fc.Args["opts"].(SaveDistroInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*SaveDistroPayload)
	fc.Result = res
	return ec.marshalNSaveDistroPayload2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSaveDistroPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_saveDistro(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "distro":
				return ec.fieldContext_SaveDistroPayload_distro(ctx, field)
			case "hostCount":
				return ec.fieldContext_SaveDistroPayload_hostCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SaveDistroPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_saveDistro_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_reprovisionToNew(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_reprovisionToNew(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ReprovisionToNew(rctx, fc.Args["hostIds"].([]string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_reprovisionToNew(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_reprovisionToNew_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_restartJasper(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_restartJasper(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RestartJasper(rctx, fc.Args["hostIds"].([]string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_restartJasper(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_restartJasper_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateHostStatus(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateHostStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateHostStatus(rctx, fc.Args["hostIds"].([]string), fc.Args["status"].(string), fc.Args["notes"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateHostStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateHostStatus_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_enqueuePatch(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_enqueuePatch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().EnqueuePatch(rctx, fc.Args["patchId"].(string), fc.Args["commitMessage"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIPatch)
	fc.Result = res
	return ec.marshalNPatch2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_enqueuePatch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Patch_id(ctx, field)
			case "activated":
				return ec.fieldContext_Patch_activated(ctx, field)
			case "alias":
				return ec.fieldContext_Patch_alias(ctx, field)
			case "author":
				return ec.fieldContext_Patch_author(ctx, field)
			case "authorDisplayName":
				return ec.fieldContext_Patch_authorDisplayName(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Patch_baseTaskStatuses(ctx, field)
			case "builds":
				return ec.fieldContext_Patch_builds(ctx, field)
			case "canEnqueueToCommitQueue":
				return ec.fieldContext_Patch_canEnqueueToCommitQueue(ctx, field)
			case "childPatchAliases":
				return ec.fieldContext_Patch_childPatchAliases(ctx, field)
			case "childPatches":
				return ec.fieldContext_Patch_childPatches(ctx, field)
			case "commitQueuePosition":
				return ec.fieldContext_Patch_commitQueuePosition(ctx, field)
			case "createTime":
				return ec.fieldContext_Patch_createTime(ctx, field)
			case "description":
				return ec.fieldContext_Patch_description(ctx, field)
			case "duration":
				return ec.fieldContext_Patch_duration(ctx, field)
			case "githash":
				return ec.fieldContext_Patch_githash(ctx, field)
			case "hidden":
				return ec.fieldContext_Patch_hidden(ctx, field)
			case "moduleCodeChanges":
				return ec.fieldContext_Patch_moduleCodeChanges(ctx, field)
			case "parameters":
				return ec.fieldContext_Patch_parameters(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Patch_patchNumber(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Patch_patchTriggerAliases(ctx, field)
			case "project":
				return ec.fieldContext_Patch_project(ctx, field)
			case "projectID":
				return ec.fieldContext_Patch_projectID(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Patch_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Patch_projectMetadata(ctx, field)
			case "status":
				return ec.fieldContext_Patch_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Patch_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Patch_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Patch_taskStatuses(ctx, field)
			case "time":
				return ec.fieldContext_Patch_time(ctx, field)
			case "variants":
				return ec.fieldContext_Patch_variants(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_Patch_variantsTasks(ctx, field)
			case "versionFull":
				return ec.fieldContext_Patch_versionFull(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Patch", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_enqueuePatch_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setPatchVisibility(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_setPatchVisibility(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SetPatchVisibility(rctx, fc.Args["patchIds"].([]string), fc.Args["hidden"].(bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIPatch)
	fc.Result = res
	return ec.marshalNPatch2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatchᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_setPatchVisibility(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Patch_id(ctx, field)
			case "activated":
				return ec.fieldContext_Patch_activated(ctx, field)
			case "alias":
				return ec.fieldContext_Patch_alias(ctx, field)
			case "author":
				return ec.fieldContext_Patch_author(ctx, field)
			case "authorDisplayName":
				return ec.fieldContext_Patch_authorDisplayName(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Patch_baseTaskStatuses(ctx, field)
			case "builds":
				return ec.fieldContext_Patch_builds(ctx, field)
			case "canEnqueueToCommitQueue":
				return ec.fieldContext_Patch_canEnqueueToCommitQueue(ctx, field)
			case "childPatchAliases":
				return ec.fieldContext_Patch_childPatchAliases(ctx, field)
			case "childPatches":
				return ec.fieldContext_Patch_childPatches(ctx, field)
			case "commitQueuePosition":
				return ec.fieldContext_Patch_commitQueuePosition(ctx, field)
			case "createTime":
				return ec.fieldContext_Patch_createTime(ctx, field)
			case "description":
				return ec.fieldContext_Patch_description(ctx, field)
			case "duration":
				return ec.fieldContext_Patch_duration(ctx, field)
			case "githash":
				return ec.fieldContext_Patch_githash(ctx, field)
			case "hidden":
				return ec.fieldContext_Patch_hidden(ctx, field)
			case "moduleCodeChanges":
				return ec.fieldContext_Patch_moduleCodeChanges(ctx, field)
			case "parameters":
				return ec.fieldContext_Patch_parameters(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Patch_patchNumber(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Patch_patchTriggerAliases(ctx, field)
			case "project":
				return ec.fieldContext_Patch_project(ctx, field)
			case "projectID":
				return ec.fieldContext_Patch_projectID(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Patch_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Patch_projectMetadata(ctx, field)
			case "status":
				return ec.fieldContext_Patch_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Patch_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Patch_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Patch_taskStatuses(ctx, field)
			case "time":
				return ec.fieldContext_Patch_time(ctx, field)
			case "variants":
				return ec.fieldContext_Patch_variants(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_Patch_variantsTasks(ctx, field)
			case "versionFull":
				return ec.fieldContext_Patch_versionFull(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Patch", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setPatchVisibility_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_schedulePatch(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_schedulePatch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SchedulePatch(rctx, fc.Args["patchId"].(string), fc.Args["configure"].(PatchConfigure))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIPatch)
	fc.Result = res
	return ec.marshalNPatch2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_schedulePatch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Patch_id(ctx, field)
			case "activated":
				return ec.fieldContext_Patch_activated(ctx, field)
			case "alias":
				return ec.fieldContext_Patch_alias(ctx, field)
			case "author":
				return ec.fieldContext_Patch_author(ctx, field)
			case "authorDisplayName":
				return ec.fieldContext_Patch_authorDisplayName(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Patch_baseTaskStatuses(ctx, field)
			case "builds":
				return ec.fieldContext_Patch_builds(ctx, field)
			case "canEnqueueToCommitQueue":
				return ec.fieldContext_Patch_canEnqueueToCommitQueue(ctx, field)
			case "childPatchAliases":
				return ec.fieldContext_Patch_childPatchAliases(ctx, field)
			case "childPatches":
				return ec.fieldContext_Patch_childPatches(ctx, field)
			case "commitQueuePosition":
				return ec.fieldContext_Patch_commitQueuePosition(ctx, field)
			case "createTime":
				return ec.fieldContext_Patch_createTime(ctx, field)
			case "description":
				return ec.fieldContext_Patch_description(ctx, field)
			case "duration":
				return ec.fieldContext_Patch_duration(ctx, field)
			case "githash":
				return ec.fieldContext_Patch_githash(ctx, field)
			case "hidden":
				return ec.fieldContext_Patch_hidden(ctx, field)
			case "moduleCodeChanges":
				return ec.fieldContext_Patch_moduleCodeChanges(ctx, field)
			case "parameters":
				return ec.fieldContext_Patch_parameters(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Patch_patchNumber(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Patch_patchTriggerAliases(ctx, field)
			case "project":
				return ec.fieldContext_Patch_project(ctx, field)
			case "projectID":
				return ec.fieldContext_Patch_projectID(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Patch_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Patch_projectMetadata(ctx, field)
			case "status":
				return ec.fieldContext_Patch_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Patch_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Patch_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Patch_taskStatuses(ctx, field)
			case "time":
				return ec.fieldContext_Patch_time(ctx, field)
			case "variants":
				return ec.fieldContext_Patch_variants(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_Patch_variantsTasks(ctx, field)
			case "versionFull":
				return ec.fieldContext_Patch_versionFull(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Patch", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_schedulePatch_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_schedulePatchTasks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_schedulePatchTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SchedulePatchTasks(rctx, fc.Args["patchId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_schedulePatchTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_schedulePatchTasks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_scheduleUndispatchedBaseTasks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_scheduleUndispatchedBaseTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ScheduleUndispatchedBaseTasks(rctx, fc.Args["patchId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.APITask)
	fc.Result = res
	return ec.marshalOTask2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_scheduleUndispatchedBaseTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canSync":
				return ec.fieldContext_Task_canSync(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "taskFiles":
				return ec.fieldContext_Task_taskFiles(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_scheduleUndispatchedBaseTasks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setPatchPriority(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_setPatchPriority(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SetPatchPriority(rctx, fc.Args["patchId"].(string), fc.Args["priority"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_setPatchPriority(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setPatchPriority_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_unschedulePatchTasks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_unschedulePatchTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UnschedulePatchTasks(rctx, fc.Args["patchId"].(string), fc.Args["abort"].(bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_unschedulePatchTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_unschedulePatchTasks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_addFavoriteProject(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_addFavoriteProject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AddFavoriteProject(rctx, fc.Args["identifier"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectRef)
	fc.Result = res
	return ec.marshalNProject2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_addFavoriteProject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "private":
				return ec.fieldContext_Project_private(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "taskSync":
				return ec.fieldContext_Project_taskSync(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_addFavoriteProject_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_attachProjectToNewRepo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_attachProjectToNewRepo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AttachProjectToNewRepo(rctx, fc.Args["project"].(MoveProjectInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectRef)
	fc.Result = res
	return ec.marshalNProject2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_attachProjectToNewRepo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "private":
				return ec.fieldContext_Project_private(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "taskSync":
				return ec.fieldContext_Project_taskSync(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_attachProjectToNewRepo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_attachProjectToRepo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_attachProjectToRepo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AttachProjectToRepo(rctx, fc.Args["projectId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectRef)
	fc.Result = res
	return ec.marshalNProject2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_attachProjectToRepo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "private":
				return ec.fieldContext_Project_private(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "taskSync":
				return ec.fieldContext_Project_taskSync(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_attachProjectToRepo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createProject(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createProject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreateProject(rctx, fc.Args["project"].(model.APIProjectRef), fc.Args["requestS3Creds"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectRef)
	fc.Result = res
	return ec.marshalNProject2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createProject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "private":
				return ec.fieldContext_Project_private(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "taskSync":
				return ec.fieldContext_Project_taskSync(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createProject_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_copyProject(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_copyProject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CopyProject(rctx, fc.Args["project"].(data.CopyProjectOpts), fc.Args["requestS3Creds"].(*bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectRef)
	fc.Result = res
	return ec.marshalNProject2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_copyProject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "private":
				return ec.fieldContext_Project_private(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "taskSync":
				return ec.fieldContext_Project_taskSync(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_copyProject_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deactivateStepbackTask(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deactivateStepbackTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeactivateStepbackTask(rctx, fc.Args["projectId"].(string), fc.Args["buildVariantName"].(string), fc.Args["taskName"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deactivateStepbackTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deactivateStepbackTask_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_defaultSectionToRepo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_defaultSectionToRepo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DefaultSectionToRepo(rctx, fc.Args["projectId"].(string), fc.Args["section"].(ProjectSettingsSection))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_defaultSectionToRepo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_defaultSectionToRepo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteProject(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteProject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteProject(rctx, fc.Args["projectId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteProject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteProject_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_detachProjectFromRepo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_detachProjectFromRepo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DetachProjectFromRepo(rctx, fc.Args["projectId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectRef)
	fc.Result = res
	return ec.marshalNProject2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_detachProjectFromRepo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "private":
				return ec.fieldContext_Project_private(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "taskSync":
				return ec.fieldContext_Project_taskSync(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_detachProjectFromRepo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_forceRepotrackerRun(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_forceRepotrackerRun(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ForceRepotrackerRun(rctx, fc.Args["projectId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_forceRepotrackerRun(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_forceRepotrackerRun_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_promoteVarsToRepo(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_promoteVarsToRepo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().PromoteVarsToRepo(rctx, fc.Args["projectId"].(string), fc.Args["varNames"].([]string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_promoteVarsToRepo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_promoteVarsToRepo_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_removeFavoriteProject(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_removeFavoriteProject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RemoveFavoriteProject(rctx, fc.Args["identifier"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectRef)
	fc.Result = res
	return ec.marshalNProject2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_removeFavoriteProject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "private":
				return ec.fieldContext_Project_private(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "taskSync":
				return ec.fieldContext_Project_taskSync(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_removeFavoriteProject_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_saveProjectSettingsForSection(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_saveProjectSettingsForSection(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SaveProjectSettingsForSection(rctx, fc.Args["projectSettings"].(*model.APIProjectSettings), fc.Args["section"].(ProjectSettingsSection))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectSettings)
	fc.Result = res
	return ec.marshalNProjectSettings2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_saveProjectSettingsForSection(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aliases":
				return ec.fieldContext_ProjectSettings_aliases(ctx, field)
			case "githubWebhooksEnabled":
				return ec.fieldContext_ProjectSettings_githubWebhooksEnabled(ctx, field)
			case "projectRef":
				return ec.fieldContext_ProjectSettings_projectRef(ctx, field)
			case "subscriptions":
				return ec.fieldContext_ProjectSettings_subscriptions(ctx, field)
			case "vars":
				return ec.fieldContext_ProjectSettings_vars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectSettings", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_saveProjectSettingsForSection_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_saveRepoSettingsForSection(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_saveRepoSettingsForSection(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SaveRepoSettingsForSection(rctx, fc.Args["repoSettings"].(*model.APIProjectSettings), fc.Args["section"].(ProjectSettingsSection))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectSettings)
	fc.Result = res
	return ec.marshalNRepoSettings2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_saveRepoSettingsForSection(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aliases":
				return ec.fieldContext_RepoSettings_aliases(ctx, field)
			case "githubWebhooksEnabled":
				return ec.fieldContext_RepoSettings_githubWebhooksEnabled(ctx, field)
			case "projectRef":
				return ec.fieldContext_RepoSettings_projectRef(ctx, field)
			case "subscriptions":
				return ec.fieldContext_RepoSettings_subscriptions(ctx, field)
			case "vars":
				return ec.fieldContext_RepoSettings_vars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepoSettings", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_saveRepoSettingsForSection_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_attachVolumeToHost(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_attachVolumeToHost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AttachVolumeToHost(rctx, fc.Args["volumeAndHost"].(VolumeHost))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_attachVolumeToHost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_attachVolumeToHost_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_detachVolumeFromHost(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_detachVolumeFromHost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DetachVolumeFromHost(rctx, fc.Args["volumeId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_detachVolumeFromHost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_detachVolumeFromHost_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_editSpawnHost(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_editSpawnHost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().EditSpawnHost(rctx, fc.Args["spawnHost"].(*EditSpawnHostInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIHost)
	fc.Result = res
	return ec.marshalNHost2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_editSpawnHost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "availabilityZone":
				return ec.fieldContext_Host_availabilityZone(ctx, field)
			case "ami":
				return ec.fieldContext_Host_ami(ctx, field)
			case "displayName":
				return ec.fieldContext_Host_displayName(ctx, field)
			case "distro":
				return ec.fieldContext_Host_distro(ctx, field)
			case "distroId":
				return ec.fieldContext_Host_distroId(ctx, field)
			case "elapsed":
				return ec.fieldContext_Host_elapsed(ctx, field)
			case "expiration":
				return ec.fieldContext_Host_expiration(ctx, field)
			case "hostUrl":
				return ec.fieldContext_Host_hostUrl(ctx, field)
			case "homeVolume":
				return ec.fieldContext_Host_homeVolume(ctx, field)
			case "homeVolumeID":
				return ec.fieldContext_Host_homeVolumeID(ctx, field)
			case "instanceType":
				return ec.fieldContext_Host_instanceType(ctx, field)
			case "instanceTags":
				return ec.fieldContext_Host_instanceTags(ctx, field)
			case "lastCommunicationTime":
				return ec.fieldContext_Host_lastCommunicationTime(ctx, field)
			case "noExpiration":
				return ec.fieldContext_Host_noExpiration(ctx, field)
			case "provider":
				return ec.fieldContext_Host_provider(ctx, field)
			case "runningTask":
				return ec.fieldContext_Host_runningTask(ctx, field)
			case "startedBy":
				return ec.fieldContext_Host_startedBy(ctx, field)
			case "status":
				return ec.fieldContext_Host_status(ctx, field)
			case "tag":
				return ec.fieldContext_Host_tag(ctx, field)
			case "totalIdleTime":
				return ec.fieldContext_Host_totalIdleTime(ctx, field)
			case "uptime":
				return ec.fieldContext_Host_uptime(ctx, field)
			case "user":
				return ec.fieldContext_Host_user(ctx, field)
			case "volumes":
				return ec.fieldContext_Host_volumes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_editSpawnHost_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_migrateVolume(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_migrateVolume(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().MigrateVolume(rctx, fc.Args["volumeId"].(string), fc.Args["spawnHostInput"].(*SpawnHostInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_migrateVolume(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_migrateVolume_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_spawnHost(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_spawnHost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SpawnHost(rctx, fc.Args["spawnHostInput"].(*SpawnHostInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIHost)
	fc.Result = res
	return ec.marshalNHost2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_spawnHost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "availabilityZone":
				return ec.fieldContext_Host_availabilityZone(ctx, field)
			case "ami":
				return ec.fieldContext_Host_ami(ctx, field)
			case "displayName":
				return ec.fieldContext_Host_displayName(ctx, field)
			case "distro":
				return ec.fieldContext_Host_distro(ctx, field)
			case "distroId":
				return ec.fieldContext_Host_distroId(ctx, field)
			case "elapsed":
				return ec.fieldContext_Host_elapsed(ctx, field)
			case "expiration":
				return ec.fieldContext_Host_expiration(ctx, field)
			case "hostUrl":
				return ec.fieldContext_Host_hostUrl(ctx, field)
			case "homeVolume":
				return ec.fieldContext_Host_homeVolume(ctx, field)
			case "homeVolumeID":
				return ec.fieldContext_Host_homeVolumeID(ctx, field)
			case "instanceType":
				return ec.fieldContext_Host_instanceType(ctx, field)
			case "instanceTags":
				return ec.fieldContext_Host_instanceTags(ctx, field)
			case "lastCommunicationTime":
				return ec.fieldContext_Host_lastCommunicationTime(ctx, field)
			case "noExpiration":
				return ec.fieldContext_Host_noExpiration(ctx, field)
			case "provider":
				return ec.fieldContext_Host_provider(ctx, field)
			case "runningTask":
				return ec.fieldContext_Host_runningTask(ctx, field)
			case "startedBy":
				return ec.fieldContext_Host_startedBy(ctx, field)
			case "status":
				return ec.fieldContext_Host_status(ctx, field)
			case "tag":
				return ec.fieldContext_Host_tag(ctx, field)
			case "totalIdleTime":
				return ec.fieldContext_Host_totalIdleTime(ctx, field)
			case "uptime":
				return ec.fieldContext_Host_uptime(ctx, field)
			case "user":
				return ec.fieldContext_Host_user(ctx, field)
			case "volumes":
				return ec.fieldContext_Host_volumes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_spawnHost_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_spawnVolume(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_spawnVolume(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SpawnVolume(rctx, fc.Args["spawnVolumeInput"].(SpawnVolumeInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_spawnVolume(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_spawnVolume_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_removeVolume(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_removeVolume(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RemoveVolume(rctx, fc.Args["volumeId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_removeVolume(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_removeVolume_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateSpawnHostStatus(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateSpawnHostStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateSpawnHostStatus(rctx, fc.Args["hostId"].(string), fc.Args["action"].(SpawnHostStatusActions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIHost)
	fc.Result = res
	return ec.marshalNHost2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateSpawnHostStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "availabilityZone":
				return ec.fieldContext_Host_availabilityZone(ctx, field)
			case "ami":
				return ec.fieldContext_Host_ami(ctx, field)
			case "displayName":
				return ec.fieldContext_Host_displayName(ctx, field)
			case "distro":
				return ec.fieldContext_Host_distro(ctx, field)
			case "distroId":
				return ec.fieldContext_Host_distroId(ctx, field)
			case "elapsed":
				return ec.fieldContext_Host_elapsed(ctx, field)
			case "expiration":
				return ec.fieldContext_Host_expiration(ctx, field)
			case "hostUrl":
				return ec.fieldContext_Host_hostUrl(ctx, field)
			case "homeVolume":
				return ec.fieldContext_Host_homeVolume(ctx, field)
			case "homeVolumeID":
				return ec.fieldContext_Host_homeVolumeID(ctx, field)
			case "instanceType":
				return ec.fieldContext_Host_instanceType(ctx, field)
			case "instanceTags":
				return ec.fieldContext_Host_instanceTags(ctx, field)
			case "lastCommunicationTime":
				return ec.fieldContext_Host_lastCommunicationTime(ctx, field)
			case "noExpiration":
				return ec.fieldContext_Host_noExpiration(ctx, field)
			case "provider":
				return ec.fieldContext_Host_provider(ctx, field)
			case "runningTask":
				return ec.fieldContext_Host_runningTask(ctx, field)
			case "startedBy":
				return ec.fieldContext_Host_startedBy(ctx, field)
			case "status":
				return ec.fieldContext_Host_status(ctx, field)
			case "tag":
				return ec.fieldContext_Host_tag(ctx, field)
			case "totalIdleTime":
				return ec.fieldContext_Host_totalIdleTime(ctx, field)
			case "uptime":
				return ec.fieldContext_Host_uptime(ctx, field)
			case "user":
				return ec.fieldContext_Host_user(ctx, field)
			case "volumes":
				return ec.fieldContext_Host_volumes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateSpawnHostStatus_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateVolume(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateVolume(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateVolume(rctx, fc.Args["updateVolumeInput"].(UpdateVolumeInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateVolume(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateVolume_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_abortTask(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_abortTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().AbortTask(rctx, fc.Args["taskId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APITask)
	fc.Result = res
	return ec.marshalNTask2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_abortTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canSync":
				return ec.fieldContext_Task_canSync(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "taskFiles":
				return ec.fieldContext_Task_taskFiles(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_abortTask_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_overrideTaskDependencies(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_overrideTaskDependencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().OverrideTaskDependencies(rctx, fc.Args["taskId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APITask)
	fc.Result = res
	return ec.marshalNTask2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_overrideTaskDependencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canSync":
				return ec.fieldContext_Task_canSync(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "taskFiles":
				return ec.fieldContext_Task_taskFiles(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_overrideTaskDependencies_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_restartTask(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_restartTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RestartTask(rctx, fc.Args["taskId"].(string), fc.Args["failedOnly"].(bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APITask)
	fc.Result = res
	return ec.marshalNTask2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_restartTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canSync":
				return ec.fieldContext_Task_canSync(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "taskFiles":
				return ec.fieldContext_Task_taskFiles(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_restartTask_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_scheduleTasks(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_scheduleTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ScheduleTasks(rctx, fc.Args["taskIds"].([]string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APITask)
	fc.Result = res
	return ec.marshalNTask2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_scheduleTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canSync":
				return ec.fieldContext_Task_canSync(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "taskFiles":
				return ec.fieldContext_Task_taskFiles(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_scheduleTasks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_setTaskPriority(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_setTaskPriority(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SetTaskPriority(rctx, fc.Args["taskId"].(string), fc.Args["priority"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APITask)
	fc.Result = res
	return ec.marshalNTask2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_setTaskPriority(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canSync":
				return ec.fieldContext_Task_canSync(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "taskFiles":
				return ec.fieldContext_Task_taskFiles(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_setTaskPriority_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_unscheduleTask(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_unscheduleTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UnscheduleTask(rctx, fc.Args["taskId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APITask)
	fc.Result = res
	return ec.marshalNTask2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_unscheduleTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canSync":
				return ec.fieldContext_Task_canSync(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "taskFiles":
				return ec.fieldContext_Task_taskFiles(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_unscheduleTask_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_clearMySubscriptions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_clearMySubscriptions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().ClearMySubscriptions(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_clearMySubscriptions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_createPublicKey(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_createPublicKey(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().CreatePublicKey(rctx, fc.Args["publicKeyInput"].(PublicKeyInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIPubKey)
	fc.Result = res
	return ec.marshalNPublicKey2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPubKeyᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_createPublicKey(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_PublicKey_key(ctx, field)
			case "name":
				return ec.fieldContext_PublicKey_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PublicKey", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_createPublicKey_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_deleteSubscriptions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_deleteSubscriptions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().DeleteSubscriptions(rctx, fc.Args["subscriptionIds"].([]string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_deleteSubscriptions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_deleteSubscriptions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_removePublicKey(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_removePublicKey(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RemovePublicKey(rctx, fc.Args["keyName"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIPubKey)
	fc.Result = res
	return ec.marshalNPublicKey2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPubKeyᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_removePublicKey(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_PublicKey_key(ctx, field)
			case "name":
				return ec.fieldContext_PublicKey_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PublicKey", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_removePublicKey_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_saveSubscription(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_saveSubscription(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().SaveSubscription(rctx, fc.Args["subscription"].(model.APISubscription))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_saveSubscription(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_saveSubscription_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updatePublicKey(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updatePublicKey(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdatePublicKey(rctx, fc.Args["targetKeyName"].(string), fc.Args["updateInfo"].(PublicKeyInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIPubKey)
	fc.Result = res
	return ec.marshalNPublicKey2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPubKeyᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updatePublicKey(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_PublicKey_key(ctx, field)
			case "name":
				return ec.fieldContext_PublicKey_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PublicKey", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updatePublicKey_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_updateUserSettings(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_updateUserSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().UpdateUserSettings(rctx, fc.Args["userSettings"].(*model.APIUserSettings))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_updateUserSettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_updateUserSettings_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_removeItemFromCommitQueue(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_removeItemFromCommitQueue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RemoveItemFromCommitQueue(rctx, fc.Args["commitQueueId"].(string), fc.Args["issue"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_removeItemFromCommitQueue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_removeItemFromCommitQueue_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Mutation_restartVersions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Mutation_restartVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Mutation().RestartVersions(rctx, fc.Args["versionId"].(string), fc.Args["abort"].(bool), fc.Args["versionsToRestart"].([]*model1.VersionToRestart))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.APIVersion)
	fc.Result = res
	return ec.marshalOVersion2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVersionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Mutation_restartVersions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Mutation",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Mutation_restartVersions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _NewDistroPayload_newDistroId(ctx context.Context, field graphql.CollectedField, obj *NewDistroPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_NewDistroPayload_newDistroId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewDistroID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_NewDistroPayload_newDistroId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "NewDistroPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Note_message(ctx context.Context, field graphql.CollectedField, obj *model.APINote) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Note_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Note_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Note",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Note_source(ctx context.Context, field graphql.CollectedField, obj *model.APINote) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Note_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APISource)
	fc.Result = res
	return ec.marshalNSource2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISource(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Note_source(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Note",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "author":
				return ec.fieldContext_Source_author(ctx, field)
			case "requester":
				return ec.fieldContext_Source_requester(ctx, field)
			case "time":
				return ec.fieldContext_Source_time(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Source", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_buildBreak(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notifications_buildBreak(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildBreak, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notifications_buildBreak(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_buildBreakId(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notifications_buildBreakId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildBreakID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notifications_buildBreakId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_commitQueue(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notifications_commitQueue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CommitQueue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notifications_commitQueue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_commitQueueId(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notifications_commitQueueId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CommitQueueID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notifications_commitQueueId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_patchFinish(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notifications_patchFinish(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PatchFinish, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notifications_patchFinish(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_patchFinishId(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notifications_patchFinishId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PatchFinishID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notifications_patchFinishId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_patchFirstFailure(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notifications_patchFirstFailure(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PatchFirstFailure, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notifications_patchFirstFailure(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_patchFirstFailureId(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notifications_patchFirstFailureId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PatchFirstFailureID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notifications_patchFirstFailureId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_spawnHostExpiration(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notifications_spawnHostExpiration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpawnHostExpiration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notifications_spawnHostExpiration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_spawnHostExpirationId(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notifications_spawnHostExpirationId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpawnHostExpirationID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notifications_spawnHostExpirationId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_spawnHostOutcome(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notifications_spawnHostOutcome(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpawnHostOutcome, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notifications_spawnHostOutcome(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Notifications_spawnHostOutcomeId(ctx context.Context, field graphql.CollectedField, obj *model.APINotificationPreferences) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Notifications_spawnHostOutcomeId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpawnHostOutcomeID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Notifications_spawnHostOutcomeId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Notifications",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OomTrackerInfo_detected(ctx context.Context, field graphql.CollectedField, obj *model.APIOomTrackerInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OomTrackerInfo_detected(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Detected, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OomTrackerInfo_detected(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OomTrackerInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _OomTrackerInfo_pids(ctx context.Context, field graphql.CollectedField, obj *model.APIOomTrackerInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_OomTrackerInfo_pids(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Pids, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]int)
	fc.Result = res
	return ec.marshalOInt2ᚕint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_OomTrackerInfo_pids(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "OomTrackerInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Parameter_key(ctx context.Context, field graphql.CollectedField, obj *model.APIParameter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Parameter_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Parameter_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Parameter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Parameter_value(ctx context.Context, field graphql.CollectedField, obj *model.APIParameter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Parameter_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Parameter_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Parameter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ParsleyFilter_expression(ctx context.Context, field graphql.CollectedField, obj *model.APIParsleyFilter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ParsleyFilter_expression(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Expression, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ParsleyFilter_expression(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ParsleyFilter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ParsleyFilter_caseSensitive(ctx context.Context, field graphql.CollectedField, obj *model.APIParsleyFilter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ParsleyFilter_caseSensitive(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CaseSensitive, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ParsleyFilter_caseSensitive(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ParsleyFilter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ParsleyFilter_exactMatch(ctx context.Context, field graphql.CollectedField, obj *model.APIParsleyFilter) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ParsleyFilter_exactMatch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExactMatch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ParsleyFilter_exactMatch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ParsleyFilter",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_id(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNID2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_activated(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_activated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Activated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_activated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_alias(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_alias(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Alias, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_alias(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_author(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_author(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Author, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_author(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_authorDisplayName(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_authorDisplayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Patch().AuthorDisplayName(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_authorDisplayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_baseTaskStatuses(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_baseTaskStatuses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Patch().BaseTaskStatuses(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_baseTaskStatuses(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_builds(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_builds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Patch().Builds(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIBuild)
	fc.Result = res
	return ec.marshalNBuild2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIBuildᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_builds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Build_id(ctx, field)
			case "actualMakespan":
				return ec.fieldContext_Build_actualMakespan(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Build_buildVariant(ctx, field)
			case "predictedMakespan":
				return ec.fieldContext_Build_predictedMakespan(ctx, field)
			case "status":
				return ec.fieldContext_Build_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Build", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_canEnqueueToCommitQueue(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_canEnqueueToCommitQueue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CanEnqueueToCommitQueue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_canEnqueueToCommitQueue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_childPatchAliases(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_childPatchAliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChildPatchAliases, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIChildPatchAlias)
	fc.Result = res
	return ec.marshalOChildPatchAlias2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIChildPatchAliasᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_childPatchAliases(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "alias":
				return ec.fieldContext_ChildPatchAlias_alias(ctx, field)
			case "patchId":
				return ec.fieldContext_ChildPatchAlias_patchId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ChildPatchAlias", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_childPatches(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_childPatches(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChildPatches, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIPatch)
	fc.Result = res
	return ec.marshalOPatch2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatchᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_childPatches(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Patch_id(ctx, field)
			case "activated":
				return ec.fieldContext_Patch_activated(ctx, field)
			case "alias":
				return ec.fieldContext_Patch_alias(ctx, field)
			case "author":
				return ec.fieldContext_Patch_author(ctx, field)
			case "authorDisplayName":
				return ec.fieldContext_Patch_authorDisplayName(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Patch_baseTaskStatuses(ctx, field)
			case "builds":
				return ec.fieldContext_Patch_builds(ctx, field)
			case "canEnqueueToCommitQueue":
				return ec.fieldContext_Patch_canEnqueueToCommitQueue(ctx, field)
			case "childPatchAliases":
				return ec.fieldContext_Patch_childPatchAliases(ctx, field)
			case "childPatches":
				return ec.fieldContext_Patch_childPatches(ctx, field)
			case "commitQueuePosition":
				return ec.fieldContext_Patch_commitQueuePosition(ctx, field)
			case "createTime":
				return ec.fieldContext_Patch_createTime(ctx, field)
			case "description":
				return ec.fieldContext_Patch_description(ctx, field)
			case "duration":
				return ec.fieldContext_Patch_duration(ctx, field)
			case "githash":
				return ec.fieldContext_Patch_githash(ctx, field)
			case "hidden":
				return ec.fieldContext_Patch_hidden(ctx, field)
			case "moduleCodeChanges":
				return ec.fieldContext_Patch_moduleCodeChanges(ctx, field)
			case "parameters":
				return ec.fieldContext_Patch_parameters(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Patch_patchNumber(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Patch_patchTriggerAliases(ctx, field)
			case "project":
				return ec.fieldContext_Patch_project(ctx, field)
			case "projectID":
				return ec.fieldContext_Patch_projectID(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Patch_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Patch_projectMetadata(ctx, field)
			case "status":
				return ec.fieldContext_Patch_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Patch_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Patch_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Patch_taskStatuses(ctx, field)
			case "time":
				return ec.fieldContext_Patch_time(ctx, field)
			case "variants":
				return ec.fieldContext_Patch_variants(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_Patch_variantsTasks(ctx, field)
			case "versionFull":
				return ec.fieldContext_Patch_versionFull(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Patch", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_commitQueuePosition(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_commitQueuePosition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Patch().CommitQueuePosition(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_commitQueuePosition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_createTime(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_createTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreateTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_createTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_description(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_duration(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_duration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Patch().Duration(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*PatchDuration)
	fc.Result = res
	return ec.marshalOPatchDuration2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPatchDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_duration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "makespan":
				return ec.fieldContext_PatchDuration_makespan(ctx, field)
			case "time":
				return ec.fieldContext_PatchDuration_time(ctx, field)
			case "timeTaken":
				return ec.fieldContext_PatchDuration_timeTaken(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PatchDuration", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_githash(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_githash(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Githash, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_githash(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_hidden(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_hidden(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hidden, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_hidden(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_moduleCodeChanges(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_moduleCodeChanges(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ModuleCodeChanges, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APIModulePatch)
	fc.Result = res
	return ec.marshalNModuleCodeChange2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIModulePatchᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_moduleCodeChanges(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "branchName":
				return ec.fieldContext_ModuleCodeChange_branchName(ctx, field)
			case "fileDiffs":
				return ec.fieldContext_ModuleCodeChange_fileDiffs(ctx, field)
			case "htmlLink":
				return ec.fieldContext_ModuleCodeChange_htmlLink(ctx, field)
			case "rawLink":
				return ec.fieldContext_ModuleCodeChange_rawLink(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ModuleCodeChange", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_parameters(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_parameters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Parameters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APIParameter)
	fc.Result = res
	return ec.marshalNParameter2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParameterᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_parameters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_Parameter_key(ctx, field)
			case "value":
				return ec.fieldContext_Parameter_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Parameter", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_patchNumber(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_patchNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PatchNumber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_patchNumber(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_patchTriggerAliases(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_patchTriggerAliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Patch().PatchTriggerAliases(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIPatchTriggerDefinition)
	fc.Result = res
	return ec.marshalNPatchTriggerAlias2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatchTriggerDefinitionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_patchTriggerAliases(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "alias":
				return ec.fieldContext_PatchTriggerAlias_alias(ctx, field)
			case "childProjectId":
				return ec.fieldContext_PatchTriggerAlias_childProjectId(ctx, field)
			case "childProjectIdentifier":
				return ec.fieldContext_PatchTriggerAlias_childProjectIdentifier(ctx, field)
			case "parentAsModule":
				return ec.fieldContext_PatchTriggerAlias_parentAsModule(ctx, field)
			case "status":
				return ec.fieldContext_PatchTriggerAlias_status(ctx, field)
			case "taskSpecifiers":
				return ec.fieldContext_PatchTriggerAlias_taskSpecifiers(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_PatchTriggerAlias_variantsTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PatchTriggerAlias", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_project(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_project(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Patch().Project(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*PatchProject)
	fc.Result = res
	return ec.marshalOPatchProject2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPatchProject(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_project(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "variants":
				return ec.fieldContext_PatchProject_variants(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PatchProject", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_projectID(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_projectID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_projectID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_projectIdentifier(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_projectIdentifier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Patch().ProjectIdentifier(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_projectIdentifier(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_projectMetadata(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_projectMetadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Patch().ProjectMetadata(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectRef)
	fc.Result = res
	return ec.marshalOProject2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_projectMetadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "private":
				return ec.fieldContext_Project_private(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "taskSync":
				return ec.fieldContext_Project_taskSync(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_status(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_taskCount(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_taskCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Patch().TaskCount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_taskCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_tasks(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_tasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalNString2ᚕᚖstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_tasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_taskStatuses(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_taskStatuses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Patch().TaskStatuses(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_taskStatuses(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_time(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Patch().Time(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*PatchTime)
	fc.Result = res
	return ec.marshalOPatchTime2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPatchTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_time(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "finished":
				return ec.fieldContext_PatchTime_finished(ctx, field)
			case "started":
				return ec.fieldContext_PatchTime_started(ctx, field)
			case "submittedAt":
				return ec.fieldContext_PatchTime_submittedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PatchTime", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_variants(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_variants(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Variants, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalNString2ᚕᚖstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_variants(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_variantsTasks(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_variantsTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VariantsTasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.VariantTask)
	fc.Result = res
	return ec.marshalNVariantTask2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐVariantTask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_variantsTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_VariantTask_name(ctx, field)
			case "tasks":
				return ec.fieldContext_VariantTask_tasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VariantTask", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patch_versionFull(ctx context.Context, field graphql.CollectedField, obj *model.APIPatch) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patch_versionFull(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Patch().VersionFull(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIVersion)
	fc.Result = res
	return ec.marshalOVersion2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patch_versionFull(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patch",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchDuration_makespan(ctx context.Context, field graphql.CollectedField, obj *PatchDuration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchDuration_makespan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Makespan, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchDuration_makespan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchDuration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchDuration_time(ctx context.Context, field graphql.CollectedField, obj *PatchDuration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchDuration_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Time, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*PatchTime)
	fc.Result = res
	return ec.marshalOPatchTime2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPatchTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchDuration_time(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchDuration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "finished":
				return ec.fieldContext_PatchTime_finished(ctx, field)
			case "started":
				return ec.fieldContext_PatchTime_started(ctx, field)
			case "submittedAt":
				return ec.fieldContext_PatchTime_submittedAt(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PatchTime", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchDuration_timeTaken(ctx context.Context, field graphql.CollectedField, obj *PatchDuration) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchDuration_timeTaken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimeTaken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchDuration_timeTaken(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchDuration",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchProject_variants(ctx context.Context, field graphql.CollectedField, obj *PatchProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchProject_variants(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Variants, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ProjectBuildVariant)
	fc.Result = res
	return ec.marshalNProjectBuildVariant2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectBuildVariantᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchProject_variants(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "displayName":
				return ec.fieldContext_ProjectBuildVariant_displayName(ctx, field)
			case "name":
				return ec.fieldContext_ProjectBuildVariant_name(ctx, field)
			case "tasks":
				return ec.fieldContext_ProjectBuildVariant_tasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectBuildVariant", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTime_finished(ctx context.Context, field graphql.CollectedField, obj *PatchTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchTime_finished(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Finished, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchTime_finished(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTime_started(ctx context.Context, field graphql.CollectedField, obj *PatchTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchTime_started(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Started, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchTime_started(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTime_submittedAt(ctx context.Context, field graphql.CollectedField, obj *PatchTime) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchTime_submittedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubmittedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchTime_submittedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTime",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTriggerAlias_alias(ctx context.Context, field graphql.CollectedField, obj *model.APIPatchTriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchTriggerAlias_alias(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Alias, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchTriggerAlias_alias(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTriggerAlias_childProjectId(ctx context.Context, field graphql.CollectedField, obj *model.APIPatchTriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchTriggerAlias_childProjectId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChildProjectId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchTriggerAlias_childProjectId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTriggerAlias_childProjectIdentifier(ctx context.Context, field graphql.CollectedField, obj *model.APIPatchTriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchTriggerAlias_childProjectIdentifier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ChildProjectIdentifier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchTriggerAlias_childProjectIdentifier(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTriggerAlias_parentAsModule(ctx context.Context, field graphql.CollectedField, obj *model.APIPatchTriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchTriggerAlias_parentAsModule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParentAsModule, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchTriggerAlias_parentAsModule(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTriggerAlias_status(ctx context.Context, field graphql.CollectedField, obj *model.APIPatchTriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchTriggerAlias_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchTriggerAlias_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTriggerAlias_taskSpecifiers(ctx context.Context, field graphql.CollectedField, obj *model.APIPatchTriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchTriggerAlias_taskSpecifiers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskSpecifiers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APITaskSpecifier)
	fc.Result = res
	return ec.marshalOTaskSpecifier2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskSpecifierᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchTriggerAlias_taskSpecifiers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "patchAlias":
				return ec.fieldContext_TaskSpecifier_patchAlias(ctx, field)
			case "taskRegex":
				return ec.fieldContext_TaskSpecifier_taskRegex(ctx, field)
			case "variantRegex":
				return ec.fieldContext_TaskSpecifier_variantRegex(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskSpecifier", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PatchTriggerAlias_variantsTasks(ctx context.Context, field graphql.CollectedField, obj *model.APIPatchTriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PatchTriggerAlias_variantsTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VariantsTasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.VariantTask)
	fc.Result = res
	return ec.marshalNVariantTask2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐVariantTaskᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PatchTriggerAlias_variantsTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PatchTriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_VariantTask_name(ctx, field)
			case "tasks":
				return ec.fieldContext_VariantTask_tasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VariantTask", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patches_filteredPatchCount(ctx context.Context, field graphql.CollectedField, obj *Patches) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patches_filteredPatchCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FilteredPatchCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patches_filteredPatchCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patches",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Patches_patches(ctx context.Context, field graphql.CollectedField, obj *Patches) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Patches_patches(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Patches, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIPatch)
	fc.Result = res
	return ec.marshalNPatch2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatchᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Patches_patches(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Patches",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Patch_id(ctx, field)
			case "activated":
				return ec.fieldContext_Patch_activated(ctx, field)
			case "alias":
				return ec.fieldContext_Patch_alias(ctx, field)
			case "author":
				return ec.fieldContext_Patch_author(ctx, field)
			case "authorDisplayName":
				return ec.fieldContext_Patch_authorDisplayName(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Patch_baseTaskStatuses(ctx, field)
			case "builds":
				return ec.fieldContext_Patch_builds(ctx, field)
			case "canEnqueueToCommitQueue":
				return ec.fieldContext_Patch_canEnqueueToCommitQueue(ctx, field)
			case "childPatchAliases":
				return ec.fieldContext_Patch_childPatchAliases(ctx, field)
			case "childPatches":
				return ec.fieldContext_Patch_childPatches(ctx, field)
			case "commitQueuePosition":
				return ec.fieldContext_Patch_commitQueuePosition(ctx, field)
			case "createTime":
				return ec.fieldContext_Patch_createTime(ctx, field)
			case "description":
				return ec.fieldContext_Patch_description(ctx, field)
			case "duration":
				return ec.fieldContext_Patch_duration(ctx, field)
			case "githash":
				return ec.fieldContext_Patch_githash(ctx, field)
			case "hidden":
				return ec.fieldContext_Patch_hidden(ctx, field)
			case "moduleCodeChanges":
				return ec.fieldContext_Patch_moduleCodeChanges(ctx, field)
			case "parameters":
				return ec.fieldContext_Patch_parameters(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Patch_patchNumber(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Patch_patchTriggerAliases(ctx, field)
			case "project":
				return ec.fieldContext_Patch_project(ctx, field)
			case "projectID":
				return ec.fieldContext_Patch_projectID(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Patch_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Patch_projectMetadata(ctx, field)
			case "status":
				return ec.fieldContext_Patch_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Patch_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Patch_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Patch_taskStatuses(ctx, field)
			case "time":
				return ec.fieldContext_Patch_time(ctx, field)
			case "variants":
				return ec.fieldContext_Patch_variants(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_Patch_variantsTasks(ctx, field)
			case "versionFull":
				return ec.fieldContext_Patch_versionFull(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Patch", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PeriodicBuild_id(ctx context.Context, field graphql.CollectedField, obj *model.APIPeriodicBuildDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PeriodicBuild_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PeriodicBuild_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PeriodicBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PeriodicBuild_alias(ctx context.Context, field graphql.CollectedField, obj *model.APIPeriodicBuildDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PeriodicBuild_alias(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Alias, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PeriodicBuild_alias(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PeriodicBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PeriodicBuild_configFile(ctx context.Context, field graphql.CollectedField, obj *model.APIPeriodicBuildDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PeriodicBuild_configFile(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConfigFile, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PeriodicBuild_configFile(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PeriodicBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PeriodicBuild_intervalHours(ctx context.Context, field graphql.CollectedField, obj *model.APIPeriodicBuildDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PeriodicBuild_intervalHours(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IntervalHours, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalNInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PeriodicBuild_intervalHours(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PeriodicBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PeriodicBuild_cron(ctx context.Context, field graphql.CollectedField, obj *model.APIPeriodicBuildDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PeriodicBuild_cron(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Cron, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PeriodicBuild_cron(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PeriodicBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PeriodicBuild_message(ctx context.Context, field graphql.CollectedField, obj *model.APIPeriodicBuildDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PeriodicBuild_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PeriodicBuild_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PeriodicBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PeriodicBuild_nextRunTime(ctx context.Context, field graphql.CollectedField, obj *model.APIPeriodicBuildDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PeriodicBuild_nextRunTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NextRunTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PeriodicBuild_nextRunTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PeriodicBuild",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_canCreateDistro(ctx context.Context, field graphql.CollectedField, obj *Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_canCreateDistro(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Permissions().CanCreateDistro(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_canCreateDistro(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_canCreateProject(ctx context.Context, field graphql.CollectedField, obj *Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_canCreateProject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Permissions().CanCreateProject(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_canCreateProject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_distroPermissions(ctx context.Context, field graphql.CollectedField, obj *Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_distroPermissions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Permissions().DistroPermissions(rctx, obj, fc.Args["options"].(DistroPermissionsOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*DistroPermissions)
	fc.Result = res
	return ec.marshalNDistroPermissions2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroPermissions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_distroPermissions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "admin":
				return ec.fieldContext_DistroPermissions_admin(ctx, field)
			case "edit":
				return ec.fieldContext_DistroPermissions_edit(ctx, field)
			case "view":
				return ec.fieldContext_DistroPermissions_view(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DistroPermissions", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Permissions_distroPermissions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Permissions_userId(ctx context.Context, field graphql.CollectedField, obj *Permissions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Permissions_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Permissions_userId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Permissions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannerSettings_commitQueueFactor(ctx context.Context, field graphql.CollectedField, obj *model.APIPlannerSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannerSettings_commitQueueFactor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CommitQueueFactor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannerSettings_commitQueueFactor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannerSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannerSettings_expectedRuntimeFactor(ctx context.Context, field graphql.CollectedField, obj *model.APIPlannerSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannerSettings_expectedRuntimeFactor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpectedRuntimeFactor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannerSettings_expectedRuntimeFactor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannerSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannerSettings_generateTaskFactor(ctx context.Context, field graphql.CollectedField, obj *model.APIPlannerSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannerSettings_generateTaskFactor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GenerateTaskFactor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannerSettings_generateTaskFactor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannerSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannerSettings_groupVersions(ctx context.Context, field graphql.CollectedField, obj *model.APIPlannerSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannerSettings_groupVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GroupVersions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannerSettings_groupVersions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannerSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannerSettings_mainlineTimeInQueueFactor(ctx context.Context, field graphql.CollectedField, obj *model.APIPlannerSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannerSettings_mainlineTimeInQueueFactor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MainlineTimeInQueueFactor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannerSettings_mainlineTimeInQueueFactor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannerSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannerSettings_patchFactor(ctx context.Context, field graphql.CollectedField, obj *model.APIPlannerSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannerSettings_patchFactor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PatchFactor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannerSettings_patchFactor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannerSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannerSettings_patchTimeInQueueFactor(ctx context.Context, field graphql.CollectedField, obj *model.APIPlannerSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannerSettings_patchTimeInQueueFactor(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PatchTimeInQueueFactor, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannerSettings_patchTimeInQueueFactor(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannerSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannerSettings_targetTime(ctx context.Context, field graphql.CollectedField, obj *model.APIPlannerSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannerSettings_targetTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TargetTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIDuration)
	fc.Result = res
	return ec.marshalNDuration2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannerSettings_targetTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannerSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PlannerSettings_version(ctx context.Context, field graphql.CollectedField, obj *model.APIPlannerSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PlannerSettings_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PlannerSettings().Version(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(PlannerVersion)
	fc.Result = res
	return ec.marshalNPlannerVersion2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPlannerVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PlannerSettings_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PlannerSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type PlannerVersion does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pod_events(ctx context.Context, field graphql.CollectedField, obj *model.APIPod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pod_events(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Pod().Events(rctx, obj, fc.Args["limit"].(*int), fc.Args["page"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*PodEvents)
	fc.Result = res
	return ec.marshalNPodEvents2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPodEvents(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pod_events(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pod",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_PodEvents_count(ctx, field)
			case "eventLogEntries":
				return ec.fieldContext_PodEvents_eventLogEntries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PodEvents", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Pod_events_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Pod_id(ctx context.Context, field graphql.CollectedField, obj *model.APIPod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pod_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pod_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pod_status(ctx context.Context, field graphql.CollectedField, obj *model.APIPod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pod_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Pod().Status(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pod_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pod",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pod_task(ctx context.Context, field graphql.CollectedField, obj *model.APIPod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pod_task(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Pod().Task(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APITask)
	fc.Result = res
	return ec.marshalOTask2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pod_task(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pod",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canSync":
				return ec.fieldContext_Task_canSync(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "taskFiles":
				return ec.fieldContext_Task_taskFiles(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pod_taskContainerCreationOpts(ctx context.Context, field graphql.CollectedField, obj *model.APIPod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pod_taskContainerCreationOpts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskContainerCreationOpts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIPodTaskContainerCreationOptions)
	fc.Result = res
	return ec.marshalNTaskContainerCreationOpts2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPodTaskContainerCreationOptions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pod_taskContainerCreationOpts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pod",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "image":
				return ec.fieldContext_TaskContainerCreationOpts_image(ctx, field)
			case "memoryMB":
				return ec.fieldContext_TaskContainerCreationOpts_memoryMB(ctx, field)
			case "cpu":
				return ec.fieldContext_TaskContainerCreationOpts_cpu(ctx, field)
			case "os":
				return ec.fieldContext_TaskContainerCreationOpts_os(ctx, field)
			case "arch":
				return ec.fieldContext_TaskContainerCreationOpts_arch(ctx, field)
			case "workingDir":
				return ec.fieldContext_TaskContainerCreationOpts_workingDir(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskContainerCreationOpts", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Pod_type(ctx context.Context, field graphql.CollectedField, obj *model.APIPod) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Pod_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Pod().Type(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Pod_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Pod",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogData_oldStatus(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogData_oldStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OldStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogData_oldStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogData_newStatus(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogData_newStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NewStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogData_newStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogData_reason(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogData_reason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Reason, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogData_reason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogData_taskID(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogData_taskID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogData_taskID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogData_taskExecution(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogData_taskExecution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskExecution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogData_taskExecution(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogData_taskStatus(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogData_taskStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogData_taskStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogData_task(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogData_task(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.PodEventLogData().Task(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APITask)
	fc.Result = res
	return ec.marshalOTask2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogData_task(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogData",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canSync":
				return ec.fieldContext_Task_canSync(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "taskFiles":
				return ec.fieldContext_Task_taskFiles(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogEntry_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogEntry_data(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogEntry_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.PodAPIEventData)
	fc.Result = res
	return ec.marshalNPodEventLogData2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐPodAPIEventData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogEntry_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "oldStatus":
				return ec.fieldContext_PodEventLogData_oldStatus(ctx, field)
			case "newStatus":
				return ec.fieldContext_PodEventLogData_newStatus(ctx, field)
			case "reason":
				return ec.fieldContext_PodEventLogData_reason(ctx, field)
			case "taskID":
				return ec.fieldContext_PodEventLogData_taskID(ctx, field)
			case "taskExecution":
				return ec.fieldContext_PodEventLogData_taskExecution(ctx, field)
			case "taskStatus":
				return ec.fieldContext_PodEventLogData_taskStatus(ctx, field)
			case "task":
				return ec.fieldContext_PodEventLogData_task(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PodEventLogData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogEntry_eventType(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogEntry_eventType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogEntry_eventType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogEntry_processedAt(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogEntry_processedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProcessedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogEntry_processedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogEntry_resourceId(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogEntry_resourceId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogEntry_resourceId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogEntry_resourceType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEventLogEntry_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.PodAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEventLogEntry_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEventLogEntry_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEvents_count(ctx context.Context, field graphql.CollectedField, obj *PodEvents) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEvents_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEvents_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEvents",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PodEvents_eventLogEntries(ctx context.Context, field graphql.CollectedField, obj *PodEvents) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PodEvents_eventLogEntries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventLogEntries, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.PodAPIEventLogEntry)
	fc.Result = res
	return ec.marshalNPodEventLogEntry2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐPodAPIEventLogEntryᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PodEvents_eventLogEntries(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PodEvents",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_PodEventLogEntry_id(ctx, field)
			case "data":
				return ec.fieldContext_PodEventLogEntry_data(ctx, field)
			case "eventType":
				return ec.fieldContext_PodEventLogEntry_eventType(ctx, field)
			case "processedAt":
				return ec.fieldContext_PodEventLogEntry_processedAt(ctx, field)
			case "resourceId":
				return ec.fieldContext_PodEventLogEntry_resourceId(ctx, field)
			case "resourceType":
				return ec.fieldContext_PodEventLogEntry_resourceType(ctx, field)
			case "timestamp":
				return ec.fieldContext_PodEventLogEntry_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PodEventLogEntry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreconditionScript_path(ctx context.Context, field graphql.CollectedField, obj *model.APIPreconditionScript) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PreconditionScript_path(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Path, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PreconditionScript_path(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreconditionScript",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PreconditionScript_script(ctx context.Context, field graphql.CollectedField, obj *model.APIPreconditionScript) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PreconditionScript_script(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Script, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PreconditionScript_script(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PreconditionScript",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_id(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_admins(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_admins(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Admins, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2ᚕᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_admins(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_banner(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_banner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Banner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.APIProjectBanner)
	fc.Result = res
	return ec.marshalOProjectBanner2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectBanner(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_banner(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "text":
				return ec.fieldContext_ProjectBanner_text(ctx, field)
			case "theme":
				return ec.fieldContext_ProjectBanner_theme(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectBanner", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_batchTime(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_batchTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.BatchTime, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_batchTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_branch(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_branch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Branch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_branch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_buildBaronSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_buildBaronSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.BuildBaronSettings, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.APIBuildBaronSettings); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/rest/model.APIBuildBaronSettings`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIBuildBaronSettings)
	fc.Result = res
	return ec.marshalNBuildBaronSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIBuildBaronSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_buildBaronSettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "bfSuggestionFeaturesURL":
				return ec.fieldContext_BuildBaronSettings_bfSuggestionFeaturesURL(ctx, field)
			case "bfSuggestionPassword":
				return ec.fieldContext_BuildBaronSettings_bfSuggestionPassword(ctx, field)
			case "bfSuggestionServer":
				return ec.fieldContext_BuildBaronSettings_bfSuggestionServer(ctx, field)
			case "bfSuggestionTimeoutSecs":
				return ec.fieldContext_BuildBaronSettings_bfSuggestionTimeoutSecs(ctx, field)
			case "bfSuggestionUsername":
				return ec.fieldContext_BuildBaronSettings_bfSuggestionUsername(ctx, field)
			case "ticketCreateProject":
				return ec.fieldContext_BuildBaronSettings_ticketCreateProject(ctx, field)
			case "ticketSearchProjects":
				return ec.fieldContext_BuildBaronSettings_ticketSearchProjects(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BuildBaronSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_commitQueue(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_commitQueue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CommitQueue, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.APICommitQueueParams); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/rest/model.APICommitQueueParams`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APICommitQueueParams)
	fc.Result = res
	return ec.marshalNCommitQueueParams2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPICommitQueueParams(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_commitQueue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "enabled":
				return ec.fieldContext_CommitQueueParams_enabled(ctx, field)
			case "mergeMethod":
				return ec.fieldContext_CommitQueueParams_mergeMethod(ctx, field)
			case "mergeQueue":
				return ec.fieldContext_CommitQueueParams_mergeQueue(ctx, field)
			case "message":
				return ec.fieldContext_CommitQueueParams_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CommitQueueParams", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_containerSizeDefinitions(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ContainerSizeDefinitions, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]model.APIContainerResources); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []github.com/evergreen-ci/evergreen/rest/model.APIContainerResources`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIContainerResources)
	fc.Result = res
	return ec.marshalOContainerResources2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIContainerResourcesᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_containerSizeDefinitions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ContainerResources_name(ctx, field)
			case "cpu":
				return ec.fieldContext_ContainerResources_cpu(ctx, field)
			case "memoryMb":
				return ec.fieldContext_ContainerResources_memoryMb(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContainerResources", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_deactivatePrevious(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_deactivatePrevious(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.DeactivatePrevious, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_deactivatePrevious(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_disabledStatsCache(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_disabledStatsCache(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.DisabledStatsCache, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_disabledStatsCache(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_dispatchingDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_dispatchingDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.DispatchingDisabled, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_dispatchingDisabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_displayName(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_enabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_enabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_enabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_externalLinks(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_externalLinks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExternalLinks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIExternalLink)
	fc.Result = res
	return ec.marshalOExternalLink2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIExternalLinkᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_externalLinks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "displayName":
				return ec.fieldContext_ExternalLink_displayName(ctx, field)
			case "requesters":
				return ec.fieldContext_ExternalLink_requesters(ctx, field)
			case "urlTemplate":
				return ec.fieldContext_ExternalLink_urlTemplate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ExternalLink", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_githubChecksEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_githubChecksEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.GithubChecksEnabled, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_githubChecksEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_githubTriggerAliases(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_githubTriggerAliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.GithubTriggerAliases, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2ᚕᚖstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_githubTriggerAliases(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_gitTagAuthorizedTeams(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.GitTagAuthorizedTeams, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2ᚕᚖstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_gitTagAuthorizedTeams(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_gitTagAuthorizedUsers(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.GitTagAuthorizedUsers, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2ᚕᚖstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_gitTagAuthorizedUsers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_gitTagVersionsEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.GitTagVersionsEnabled, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_gitTagVersionsEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_hidden(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_hidden(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Hidden, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_hidden(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_identifier(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_identifier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Identifier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_identifier(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_isFavorite(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_isFavorite(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Project().IsFavorite(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_isFavorite(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_manualPrTestingEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ManualPRTestingEnabled, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_manualPrTestingEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_notifyOnBuildFailure(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.NotifyOnBuildFailure, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_notifyOnBuildFailure(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_owner(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_owner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_owner(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_parsleyFilters(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_parsleyFilters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ParsleyFilters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIParsleyFilter)
	fc.Result = res
	return ec.marshalOParsleyFilter2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParsleyFilterᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_parsleyFilters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "expression":
				return ec.fieldContext_ParsleyFilter_expression(ctx, field)
			case "caseSensitive":
				return ec.fieldContext_ParsleyFilter_caseSensitive(ctx, field)
			case "exactMatch":
				return ec.fieldContext_ParsleyFilter_exactMatch(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ParsleyFilter", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_patches(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_patches(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Project().Patches(rctx, obj, fc.Args["patchesInput"].(PatchesInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Patches)
	fc.Result = res
	return ec.marshalNPatches2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPatches(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_patches(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "filteredPatchCount":
				return ec.fieldContext_Patches_filteredPatchCount(ctx, field)
			case "patches":
				return ec.fieldContext_Patches_patches(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Patches", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Project_patches_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Project_patchingDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_patchingDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.PatchingDisabled, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_patchingDisabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_patchTriggerAliases(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_patchTriggerAliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.PatchTriggerAliases, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]model.APIPatchTriggerDefinition); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []github.com/evergreen-ci/evergreen/rest/model.APIPatchTriggerDefinition`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIPatchTriggerDefinition)
	fc.Result = res
	return ec.marshalOPatchTriggerAlias2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatchTriggerDefinitionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_patchTriggerAliases(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "alias":
				return ec.fieldContext_PatchTriggerAlias_alias(ctx, field)
			case "childProjectId":
				return ec.fieldContext_PatchTriggerAlias_childProjectId(ctx, field)
			case "childProjectIdentifier":
				return ec.fieldContext_PatchTriggerAlias_childProjectIdentifier(ctx, field)
			case "parentAsModule":
				return ec.fieldContext_PatchTriggerAlias_parentAsModule(ctx, field)
			case "status":
				return ec.fieldContext_PatchTriggerAlias_status(ctx, field)
			case "taskSpecifiers":
				return ec.fieldContext_PatchTriggerAlias_taskSpecifiers(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_PatchTriggerAlias_variantsTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PatchTriggerAlias", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_perfEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_perfEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.PerfEnabled, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_perfEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_periodicBuilds(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_periodicBuilds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.PeriodicBuilds, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]model.APIPeriodicBuildDefinition); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []github.com/evergreen-ci/evergreen/rest/model.APIPeriodicBuildDefinition`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIPeriodicBuildDefinition)
	fc.Result = res
	return ec.marshalOPeriodicBuild2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPeriodicBuildDefinitionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_periodicBuilds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_PeriodicBuild_id(ctx, field)
			case "alias":
				return ec.fieldContext_PeriodicBuild_alias(ctx, field)
			case "configFile":
				return ec.fieldContext_PeriodicBuild_configFile(ctx, field)
			case "intervalHours":
				return ec.fieldContext_PeriodicBuild_intervalHours(ctx, field)
			case "cron":
				return ec.fieldContext_PeriodicBuild_cron(ctx, field)
			case "message":
				return ec.fieldContext_PeriodicBuild_message(ctx, field)
			case "nextRunTime":
				return ec.fieldContext_PeriodicBuild_nextRunTime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PeriodicBuild", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_private(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_private(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Private, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_private(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_projectHealthView(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_projectHealthView(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectHealthView, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model1.ProjectHealthView)
	fc.Result = res
	return ec.marshalNProjectHealthView2githubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐProjectHealthView(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_projectHealthView(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ProjectHealthView does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_prTestingEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_prTestingEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.PRTestingEnabled, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_prTestingEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_remotePath(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_remotePath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.RemotePath, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_remotePath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_repo(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_repo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_repo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_repoRefId(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_repoRefId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RepoRefId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_repoRefId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_repotrackerDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_repotrackerDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.RepotrackerDisabled, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_repotrackerDisabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_restricted(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_restricted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Restricted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_restricted(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_spawnHostScriptPath(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpawnHostScriptPath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_spawnHostScriptPath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_stepbackDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_stepbackDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.StepbackDisabled, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_stepbackDisabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_taskAnnotationSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TaskAnnotationSettings, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.APITaskAnnotationSettings); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/rest/model.APITaskAnnotationSettings`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APITaskAnnotationSettings)
	fc.Result = res
	return ec.marshalNTaskAnnotationSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskAnnotationSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_taskAnnotationSettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "fileTicketWebhook":
				return ec.fieldContext_TaskAnnotationSettings_fileTicketWebhook(ctx, field)
			case "jiraCustomFields":
				return ec.fieldContext_TaskAnnotationSettings_jiraCustomFields(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskAnnotationSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_taskSync(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_taskSync(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TaskSync, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.APITaskSyncOptions); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/rest/model.APITaskSyncOptions`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APITaskSyncOptions)
	fc.Result = res
	return ec.marshalNTaskSyncOptions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskSyncOptions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_taskSync(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "configEnabled":
				return ec.fieldContext_TaskSyncOptions_configEnabled(ctx, field)
			case "patchEnabled":
				return ec.fieldContext_TaskSyncOptions_patchEnabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskSyncOptions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_tracksPushEvents(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_tracksPushEvents(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TracksPushEvents, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_tracksPushEvents(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_triggers(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_triggers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Triggers, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]model.APITriggerDefinition); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []github.com/evergreen-ci/evergreen/rest/model.APITriggerDefinition`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APITriggerDefinition)
	fc.Result = res
	return ec.marshalOTriggerAlias2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITriggerDefinitionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_triggers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "alias":
				return ec.fieldContext_TriggerAlias_alias(ctx, field)
			case "buildVariantRegex":
				return ec.fieldContext_TriggerAlias_buildVariantRegex(ctx, field)
			case "configFile":
				return ec.fieldContext_TriggerAlias_configFile(ctx, field)
			case "dateCutoff":
				return ec.fieldContext_TriggerAlias_dateCutoff(ctx, field)
			case "level":
				return ec.fieldContext_TriggerAlias_level(ctx, field)
			case "project":
				return ec.fieldContext_TriggerAlias_project(ctx, field)
			case "status":
				return ec.fieldContext_TriggerAlias_status(ctx, field)
			case "taskRegex":
				return ec.fieldContext_TriggerAlias_taskRegex(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TriggerAlias", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_versionControlEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_versionControlEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.VersionControlEnabled, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_versionControlEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Project_workstationConfig(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Project_workstationConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.WorkstationConfig, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.APIWorkstationConfig); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/rest/model.APIWorkstationConfig`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIWorkstationConfig)
	fc.Result = res
	return ec.marshalNWorkstationConfig2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWorkstationConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Project_workstationConfig(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Project",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "gitClone":
				return ec.fieldContext_WorkstationConfig_gitClone(ctx, field)
			case "setupCommands":
				return ec.fieldContext_WorkstationConfig_setupCommands(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkstationConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAlias_id(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectAlias) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectAlias_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectAlias_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAlias_alias(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectAlias) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectAlias_alias(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Alias, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectAlias_alias(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAlias_description(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectAlias) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectAlias_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectAlias_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAlias_gitTag(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectAlias) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectAlias_gitTag(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GitTag, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectAlias_gitTag(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAlias_remotePath(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectAlias) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectAlias_remotePath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.RemotePath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectAlias_remotePath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAlias_task(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectAlias) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectAlias_task(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Task, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectAlias_task(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAlias_taskTags(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectAlias) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectAlias_taskTags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskTags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalNString2ᚕᚖstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectAlias_taskTags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAlias_variant(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectAlias) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectAlias_variant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Variant, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectAlias_variant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAlias_variantTags(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectAlias) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectAlias_variantTags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VariantTags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalNString2ᚕᚖstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectAlias_variantTags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectAlias_parameters(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectAlias) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectAlias_parameters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Parameters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIParameter)
	fc.Result = res
	return ec.marshalNParameter2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParameterᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectAlias_parameters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_Parameter_key(ctx, field)
			case "value":
				return ec.fieldContext_Parameter_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Parameter", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectBanner_text(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectBanner) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectBanner_text(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Text, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectBanner_text(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectBanner",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectBanner_theme(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectBanner) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectBanner_theme(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Theme, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(evergreen.BannerTheme)
	fc.Result = res
	return ec.marshalNBannerTheme2githubᚗcomᚋevergreenᚑciᚋevergreenᚐBannerTheme(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectBanner_theme(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectBanner",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type BannerTheme does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectBuildVariant_displayName(ctx context.Context, field graphql.CollectedField, obj *ProjectBuildVariant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectBuildVariant_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectBuildVariant_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectBuildVariant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectBuildVariant_name(ctx context.Context, field graphql.CollectedField, obj *ProjectBuildVariant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectBuildVariant_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectBuildVariant_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectBuildVariant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectBuildVariant_tasks(ctx context.Context, field graphql.CollectedField, obj *ProjectBuildVariant) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectBuildVariant_tasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectBuildVariant_tasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectBuildVariant",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEventLogEntry_after(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectEventLogEntry_after(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.After, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.APIProjectEventSettings)
	fc.Result = res
	return ec.marshalOProjectEventSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectEventSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectEventLogEntry_after(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aliases":
				return ec.fieldContext_ProjectEventSettings_aliases(ctx, field)
			case "githubWebhooksEnabled":
				return ec.fieldContext_ProjectEventSettings_githubWebhooksEnabled(ctx, field)
			case "projectRef":
				return ec.fieldContext_ProjectEventSettings_projectRef(ctx, field)
			case "subscriptions":
				return ec.fieldContext_ProjectEventSettings_subscriptions(ctx, field)
			case "vars":
				return ec.fieldContext_ProjectEventSettings_vars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectEventSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEventLogEntry_before(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectEventLogEntry_before(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Before, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.APIProjectEventSettings)
	fc.Result = res
	return ec.marshalOProjectEventSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectEventSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectEventLogEntry_before(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aliases":
				return ec.fieldContext_ProjectEventSettings_aliases(ctx, field)
			case "githubWebhooksEnabled":
				return ec.fieldContext_ProjectEventSettings_githubWebhooksEnabled(ctx, field)
			case "projectRef":
				return ec.fieldContext_ProjectEventSettings_projectRef(ctx, field)
			case "subscriptions":
				return ec.fieldContext_ProjectEventSettings_subscriptions(ctx, field)
			case "vars":
				return ec.fieldContext_ProjectEventSettings_vars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectEventSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEventLogEntry_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectEventLogEntry_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectEventLogEntry_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEventLogEntry_user(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectEvent) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectEventLogEntry_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectEventLogEntry_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEventSettings_aliases(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectEventSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectEventSettings_aliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Aliases, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIProjectAlias)
	fc.Result = res
	return ec.marshalOProjectAlias2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectAliasᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectEventSettings_aliases(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEventSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProjectAlias_id(ctx, field)
			case "alias":
				return ec.fieldContext_ProjectAlias_alias(ctx, field)
			case "description":
				return ec.fieldContext_ProjectAlias_description(ctx, field)
			case "gitTag":
				return ec.fieldContext_ProjectAlias_gitTag(ctx, field)
			case "remotePath":
				return ec.fieldContext_ProjectAlias_remotePath(ctx, field)
			case "task":
				return ec.fieldContext_ProjectAlias_task(ctx, field)
			case "taskTags":
				return ec.fieldContext_ProjectAlias_taskTags(ctx, field)
			case "variant":
				return ec.fieldContext_ProjectAlias_variant(ctx, field)
			case "variantTags":
				return ec.fieldContext_ProjectAlias_variantTags(ctx, field)
			case "parameters":
				return ec.fieldContext_ProjectAlias_parameters(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectAlias", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEventSettings_githubWebhooksEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectEventSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectEventSettings_githubWebhooksEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GithubWebhooksEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectEventSettings_githubWebhooksEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEventSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEventSettings_projectRef(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectEventSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectEventSettings_projectRef(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectRef, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.APIProjectRef)
	fc.Result = res
	return ec.marshalOProject2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectEventSettings_projectRef(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEventSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "private":
				return ec.fieldContext_Project_private(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "taskSync":
				return ec.fieldContext_Project_taskSync(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEventSettings_subscriptions(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectEventSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectEventSettings_subscriptions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Subscriptions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APISubscription)
	fc.Result = res
	return ec.marshalOGeneralSubscription2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISubscriptionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectEventSettings_subscriptions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEventSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GeneralSubscription_id(ctx, field)
			case "ownerType":
				return ec.fieldContext_GeneralSubscription_ownerType(ctx, field)
			case "regexSelectors":
				return ec.fieldContext_GeneralSubscription_regexSelectors(ctx, field)
			case "resourceType":
				return ec.fieldContext_GeneralSubscription_resourceType(ctx, field)
			case "selectors":
				return ec.fieldContext_GeneralSubscription_selectors(ctx, field)
			case "subscriber":
				return ec.fieldContext_GeneralSubscription_subscriber(ctx, field)
			case "trigger":
				return ec.fieldContext_GeneralSubscription_trigger(ctx, field)
			case "triggerData":
				return ec.fieldContext_GeneralSubscription_triggerData(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GeneralSubscription", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEventSettings_vars(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectEventSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectEventSettings_vars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Vars, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.APIProjectVars)
	fc.Result = res
	return ec.marshalOProjectVars2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectVars(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectEventSettings_vars(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEventSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "adminOnlyVars":
				return ec.fieldContext_ProjectVars_adminOnlyVars(ctx, field)
			case "privateVars":
				return ec.fieldContext_ProjectVars_privateVars(ctx, field)
			case "vars":
				return ec.fieldContext_ProjectVars_vars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectVars", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEvents_count(ctx context.Context, field graphql.CollectedField, obj *ProjectEvents) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectEvents_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectEvents_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEvents",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectEvents_eventLogEntries(ctx context.Context, field graphql.CollectedField, obj *ProjectEvents) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectEvents_eventLogEntries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventLogEntries, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIProjectEvent)
	fc.Result = res
	return ec.marshalNProjectEventLogEntry2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectEventᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectEvents_eventLogEntries(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectEvents",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "after":
				return ec.fieldContext_ProjectEventLogEntry_after(ctx, field)
			case "before":
				return ec.fieldContext_ProjectEventLogEntry_before(ctx, field)
			case "timestamp":
				return ec.fieldContext_ProjectEventLogEntry_timestamp(ctx, field)
			case "user":
				return ec.fieldContext_ProjectEventLogEntry_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectEventLogEntry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectSettings_aliases(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectSettings_aliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProjectSettings().Aliases(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.APIProjectAlias)
	fc.Result = res
	return ec.marshalOProjectAlias2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectAliasᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectSettings_aliases(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProjectAlias_id(ctx, field)
			case "alias":
				return ec.fieldContext_ProjectAlias_alias(ctx, field)
			case "description":
				return ec.fieldContext_ProjectAlias_description(ctx, field)
			case "gitTag":
				return ec.fieldContext_ProjectAlias_gitTag(ctx, field)
			case "remotePath":
				return ec.fieldContext_ProjectAlias_remotePath(ctx, field)
			case "task":
				return ec.fieldContext_ProjectAlias_task(ctx, field)
			case "taskTags":
				return ec.fieldContext_ProjectAlias_taskTags(ctx, field)
			case "variant":
				return ec.fieldContext_ProjectAlias_variant(ctx, field)
			case "variantTags":
				return ec.fieldContext_ProjectAlias_variantTags(ctx, field)
			case "parameters":
				return ec.fieldContext_ProjectAlias_parameters(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectAlias", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectSettings_githubWebhooksEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectSettings_githubWebhooksEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProjectSettings().GithubWebhooksEnabled(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectSettings_githubWebhooksEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectSettings_projectRef(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectSettings_projectRef(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectRef, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.APIProjectRef)
	fc.Result = res
	return ec.marshalOProject2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectSettings_projectRef(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "private":
				return ec.fieldContext_Project_private(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "taskSync":
				return ec.fieldContext_Project_taskSync(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectSettings_subscriptions(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectSettings_subscriptions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProjectSettings().Subscriptions(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.APISubscription)
	fc.Result = res
	return ec.marshalOGeneralSubscription2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISubscriptionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectSettings_subscriptions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GeneralSubscription_id(ctx, field)
			case "ownerType":
				return ec.fieldContext_GeneralSubscription_ownerType(ctx, field)
			case "regexSelectors":
				return ec.fieldContext_GeneralSubscription_regexSelectors(ctx, field)
			case "resourceType":
				return ec.fieldContext_GeneralSubscription_resourceType(ctx, field)
			case "selectors":
				return ec.fieldContext_GeneralSubscription_selectors(ctx, field)
			case "subscriber":
				return ec.fieldContext_GeneralSubscription_subscriber(ctx, field)
			case "trigger":
				return ec.fieldContext_GeneralSubscription_trigger(ctx, field)
			case "triggerData":
				return ec.fieldContext_GeneralSubscription_triggerData(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GeneralSubscription", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectSettings_vars(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectSettings_vars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProjectSettings().Vars(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectVars)
	fc.Result = res
	return ec.marshalOProjectVars2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectVars(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectSettings_vars(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "adminOnlyVars":
				return ec.fieldContext_ProjectVars_adminOnlyVars(ctx, field)
			case "privateVars":
				return ec.fieldContext_ProjectVars_privateVars(ctx, field)
			case "vars":
				return ec.fieldContext_ProjectVars_vars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectVars", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectVars_adminOnlyVars(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectVars) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectVars_adminOnlyVars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProjectVars().AdminOnlyVars(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectVars_adminOnlyVars(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectVars",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectVars_privateVars(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectVars) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectVars_privateVars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.ProjectVars().PrivateVars(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectVars_privateVars(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectVars",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ProjectVars_vars(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectVars) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ProjectVars_vars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Vars, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(map[string]string)
	fc.Result = res
	return ec.marshalOStringMap2map(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ProjectVars_vars(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ProjectVars",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type StringMap does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PublicKey_key(ctx context.Context, field graphql.CollectedField, obj *model.APIPubKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PublicKey_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PublicKey_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PublicKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _PublicKey_name(ctx context.Context, field graphql.CollectedField, obj *model.APIPubKey) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_PublicKey_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_PublicKey_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "PublicKey",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_bbGetCreatedTickets(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_bbGetCreatedTickets(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().BbGetCreatedTickets(rctx, fc.Args["taskId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*thirdparty.JiraTicket)
	fc.Result = res
	return ec.marshalNJiraTicket2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐJiraTicketᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_bbGetCreatedTickets(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "fields":
				return ec.fieldContext_JiraTicket_fields(ctx, field)
			case "key":
				return ec.fieldContext_JiraTicket_key(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JiraTicket", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_bbGetCreatedTickets_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_buildBaron(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_buildBaron(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().BuildBaron(rctx, fc.Args["taskId"].(string), fc.Args["execution"].(int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*BuildBaron)
	fc.Result = res
	return ec.marshalNBuildBaron2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐBuildBaron(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_buildBaron(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "bbTicketCreationDefined":
				return ec.fieldContext_BuildBaron_bbTicketCreationDefined(ctx, field)
			case "buildBaronConfigured":
				return ec.fieldContext_BuildBaron_buildBaronConfigured(ctx, field)
			case "searchReturnInfo":
				return ec.fieldContext_BuildBaron_searchReturnInfo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BuildBaron", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_buildBaron_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_awsRegions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_awsRegions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().AwsRegions(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_awsRegions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_clientConfig(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_clientConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ClientConfig(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIClientConfig)
	fc.Result = res
	return ec.marshalOClientConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIClientConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_clientConfig(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "clientBinaries":
				return ec.fieldContext_ClientConfig_clientBinaries(ctx, field)
			case "latestRevision":
				return ec.fieldContext_ClientConfig_latestRevision(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ClientConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_instanceTypes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_instanceTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().InstanceTypes(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_instanceTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_spruceConfig(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_spruceConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().SpruceConfig(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIAdminSettings)
	fc.Result = res
	return ec.marshalOSpruceConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAdminSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_spruceConfig(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "banner":
				return ec.fieldContext_SpruceConfig_banner(ctx, field)
			case "bannerTheme":
				return ec.fieldContext_SpruceConfig_bannerTheme(ctx, field)
			case "githubOrgs":
				return ec.fieldContext_SpruceConfig_githubOrgs(ctx, field)
			case "jira":
				return ec.fieldContext_SpruceConfig_jira(ctx, field)
			case "providers":
				return ec.fieldContext_SpruceConfig_providers(ctx, field)
			case "spawnHost":
				return ec.fieldContext_SpruceConfig_spawnHost(ctx, field)
			case "ui":
				return ec.fieldContext_SpruceConfig_ui(ctx, field)
			case "slack":
				return ec.fieldContext_SpruceConfig_slack(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SpruceConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_subnetAvailabilityZones(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_subnetAvailabilityZones(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().SubnetAvailabilityZones(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_subnetAvailabilityZones(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_distro(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_distro(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Distro(rctx, fc.Args["distroId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIDistro)
	fc.Result = res
	return ec.marshalODistro2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDistro(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_distro(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aliases":
				return ec.fieldContext_Distro_aliases(ctx, field)
			case "arch":
				return ec.fieldContext_Distro_arch(ctx, field)
			case "authorizedKeysFile":
				return ec.fieldContext_Distro_authorizedKeysFile(ctx, field)
			case "bootstrapSettings":
				return ec.fieldContext_Distro_bootstrapSettings(ctx, field)
			case "cloneMethod":
				return ec.fieldContext_Distro_cloneMethod(ctx, field)
			case "containerPool":
				return ec.fieldContext_Distro_containerPool(ctx, field)
			case "disabled":
				return ec.fieldContext_Distro_disabled(ctx, field)
			case "disableShallowClone":
				return ec.fieldContext_Distro_disableShallowClone(ctx, field)
			case "dispatcherSettings":
				return ec.fieldContext_Distro_dispatcherSettings(ctx, field)
			case "expansions":
				return ec.fieldContext_Distro_expansions(ctx, field)
			case "finderSettings":
				return ec.fieldContext_Distro_finderSettings(ctx, field)
			case "homeVolumeSettings":
				return ec.fieldContext_Distro_homeVolumeSettings(ctx, field)
			case "hostAllocatorSettings":
				return ec.fieldContext_Distro_hostAllocatorSettings(ctx, field)
			case "iceCreamSettings":
				return ec.fieldContext_Distro_iceCreamSettings(ctx, field)
			case "isCluster":
				return ec.fieldContext_Distro_isCluster(ctx, field)
			case "isVirtualWorkStation":
				return ec.fieldContext_Distro_isVirtualWorkStation(ctx, field)
			case "name":
				return ec.fieldContext_Distro_name(ctx, field)
			case "note":
				return ec.fieldContext_Distro_note(ctx, field)
			case "plannerSettings":
				return ec.fieldContext_Distro_plannerSettings(ctx, field)
			case "provider":
				return ec.fieldContext_Distro_provider(ctx, field)
			case "providerSettingsList":
				return ec.fieldContext_Distro_providerSettingsList(ctx, field)
			case "setup":
				return ec.fieldContext_Distro_setup(ctx, field)
			case "setupAsSudo":
				return ec.fieldContext_Distro_setupAsSudo(ctx, field)
			case "sshKey":
				return ec.fieldContext_Distro_sshKey(ctx, field)
			case "sshOptions":
				return ec.fieldContext_Distro_sshOptions(ctx, field)
			case "user":
				return ec.fieldContext_Distro_user(ctx, field)
			case "userSpawnAllowed":
				return ec.fieldContext_Distro_userSpawnAllowed(ctx, field)
			case "validProjects":
				return ec.fieldContext_Distro_validProjects(ctx, field)
			case "workDir":
				return ec.fieldContext_Distro_workDir(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Distro", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_distro_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_distroEvents(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_distroEvents(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().DistroEvents(rctx, fc.Args["opts"].(DistroEventsInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*DistroEventsPayload)
	fc.Result = res
	return ec.marshalNDistroEventsPayload2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroEventsPayload(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_distroEvents(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_DistroEventsPayload_count(ctx, field)
			case "eventLogEntries":
				return ec.fieldContext_DistroEventsPayload_eventLogEntries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type DistroEventsPayload", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_distroEvents_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_distros(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_distros(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Distros(rctx, fc.Args["onlySpawnable"].(bool))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIDistro)
	fc.Result = res
	return ec.marshalNDistro2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDistro(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_distros(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aliases":
				return ec.fieldContext_Distro_aliases(ctx, field)
			case "arch":
				return ec.fieldContext_Distro_arch(ctx, field)
			case "authorizedKeysFile":
				return ec.fieldContext_Distro_authorizedKeysFile(ctx, field)
			case "bootstrapSettings":
				return ec.fieldContext_Distro_bootstrapSettings(ctx, field)
			case "cloneMethod":
				return ec.fieldContext_Distro_cloneMethod(ctx, field)
			case "containerPool":
				return ec.fieldContext_Distro_containerPool(ctx, field)
			case "disabled":
				return ec.fieldContext_Distro_disabled(ctx, field)
			case "disableShallowClone":
				return ec.fieldContext_Distro_disableShallowClone(ctx, field)
			case "dispatcherSettings":
				return ec.fieldContext_Distro_dispatcherSettings(ctx, field)
			case "expansions":
				return ec.fieldContext_Distro_expansions(ctx, field)
			case "finderSettings":
				return ec.fieldContext_Distro_finderSettings(ctx, field)
			case "homeVolumeSettings":
				return ec.fieldContext_Distro_homeVolumeSettings(ctx, field)
			case "hostAllocatorSettings":
				return ec.fieldContext_Distro_hostAllocatorSettings(ctx, field)
			case "iceCreamSettings":
				return ec.fieldContext_Distro_iceCreamSettings(ctx, field)
			case "isCluster":
				return ec.fieldContext_Distro_isCluster(ctx, field)
			case "isVirtualWorkStation":
				return ec.fieldContext_Distro_isVirtualWorkStation(ctx, field)
			case "name":
				return ec.fieldContext_Distro_name(ctx, field)
			case "note":
				return ec.fieldContext_Distro_note(ctx, field)
			case "plannerSettings":
				return ec.fieldContext_Distro_plannerSettings(ctx, field)
			case "provider":
				return ec.fieldContext_Distro_provider(ctx, field)
			case "providerSettingsList":
				return ec.fieldContext_Distro_providerSettingsList(ctx, field)
			case "setup":
				return ec.fieldContext_Distro_setup(ctx, field)
			case "setupAsSudo":
				return ec.fieldContext_Distro_setupAsSudo(ctx, field)
			case "sshKey":
				return ec.fieldContext_Distro_sshKey(ctx, field)
			case "sshOptions":
				return ec.fieldContext_Distro_sshOptions(ctx, field)
			case "user":
				return ec.fieldContext_Distro_user(ctx, field)
			case "userSpawnAllowed":
				return ec.fieldContext_Distro_userSpawnAllowed(ctx, field)
			case "validProjects":
				return ec.fieldContext_Distro_validProjects(ctx, field)
			case "workDir":
				return ec.fieldContext_Distro_workDir(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Distro", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_distros_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_distroTaskQueue(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_distroTaskQueue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().DistroTaskQueue(rctx, fc.Args["distroId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APITaskQueueItem)
	fc.Result = res
	return ec.marshalNTaskQueueItem2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskQueueItemᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_distroTaskQueue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TaskQueueItem_id(ctx, field)
			case "buildVariant":
				return ec.fieldContext_TaskQueueItem_buildVariant(ctx, field)
			case "displayName":
				return ec.fieldContext_TaskQueueItem_displayName(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_TaskQueueItem_expectedDuration(ctx, field)
			case "priority":
				return ec.fieldContext_TaskQueueItem_priority(ctx, field)
			case "project":
				return ec.fieldContext_TaskQueueItem_project(ctx, field)
			case "requester":
				return ec.fieldContext_TaskQueueItem_requester(ctx, field)
			case "activatedBy":
				return ec.fieldContext_TaskQueueItem_activatedBy(ctx, field)
			case "revision":
				return ec.fieldContext_TaskQueueItem_revision(ctx, field)
			case "version":
				return ec.fieldContext_TaskQueueItem_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskQueueItem", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_distroTaskQueue_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_host(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_host(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Host(rctx, fc.Args["hostId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIHost)
	fc.Result = res
	return ec.marshalOHost2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_host(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "availabilityZone":
				return ec.fieldContext_Host_availabilityZone(ctx, field)
			case "ami":
				return ec.fieldContext_Host_ami(ctx, field)
			case "displayName":
				return ec.fieldContext_Host_displayName(ctx, field)
			case "distro":
				return ec.fieldContext_Host_distro(ctx, field)
			case "distroId":
				return ec.fieldContext_Host_distroId(ctx, field)
			case "elapsed":
				return ec.fieldContext_Host_elapsed(ctx, field)
			case "expiration":
				return ec.fieldContext_Host_expiration(ctx, field)
			case "hostUrl":
				return ec.fieldContext_Host_hostUrl(ctx, field)
			case "homeVolume":
				return ec.fieldContext_Host_homeVolume(ctx, field)
			case "homeVolumeID":
				return ec.fieldContext_Host_homeVolumeID(ctx, field)
			case "instanceType":
				return ec.fieldContext_Host_instanceType(ctx, field)
			case "instanceTags":
				return ec.fieldContext_Host_instanceTags(ctx, field)
			case "lastCommunicationTime":
				return ec.fieldContext_Host_lastCommunicationTime(ctx, field)
			case "noExpiration":
				return ec.fieldContext_Host_noExpiration(ctx, field)
			case "provider":
				return ec.fieldContext_Host_provider(ctx, field)
			case "runningTask":
				return ec.fieldContext_Host_runningTask(ctx, field)
			case "startedBy":
				return ec.fieldContext_Host_startedBy(ctx, field)
			case "status":
				return ec.fieldContext_Host_status(ctx, field)
			case "tag":
				return ec.fieldContext_Host_tag(ctx, field)
			case "totalIdleTime":
				return ec.fieldContext_Host_totalIdleTime(ctx, field)
			case "uptime":
				return ec.fieldContext_Host_uptime(ctx, field)
			case "user":
				return ec.fieldContext_Host_user(ctx, field)
			case "volumes":
				return ec.fieldContext_Host_volumes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_host_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_hostEvents(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_hostEvents(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().HostEvents(rctx, fc.Args["hostId"].(string), fc.Args["hostTag"].(*string), fc.Args["limit"].(*int), fc.Args["page"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*HostEvents)
	fc.Result = res
	return ec.marshalNHostEvents2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐHostEvents(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_hostEvents(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_HostEvents_count(ctx, field)
			case "eventLogEntries":
				return ec.fieldContext_HostEvents_eventLogEntries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HostEvents", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_hostEvents_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_hosts(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_hosts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Hosts(rctx, fc.Args["hostId"].(*string), fc.Args["distroId"].(*string), fc.Args["currentTaskId"].(*string), fc.Args["statuses"].([]string), fc.Args["startedBy"].(*string), fc.Args["sortBy"].(*HostSortBy), fc.Args["sortDir"].(*SortDirection), fc.Args["page"].(*int), fc.Args["limit"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*HostsResponse)
	fc.Result = res
	return ec.marshalNHostsResponse2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐHostsResponse(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_hosts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "filteredHostsCount":
				return ec.fieldContext_HostsResponse_filteredHostsCount(ctx, field)
			case "hosts":
				return ec.fieldContext_HostsResponse_hosts(ctx, field)
			case "totalHostsCount":
				return ec.fieldContext_HostsResponse_totalHostsCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type HostsResponse", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_hosts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_taskQueueDistros(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_taskQueueDistros(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().TaskQueueDistros(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*TaskQueueDistro)
	fc.Result = res
	return ec.marshalNTaskQueueDistro2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskQueueDistroᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_taskQueueDistros(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TaskQueueDistro_id(ctx, field)
			case "hostCount":
				return ec.fieldContext_TaskQueueDistro_hostCount(ctx, field)
			case "taskCount":
				return ec.fieldContext_TaskQueueDistro_taskCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskQueueDistro", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_pod(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_pod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Pod(rctx, fc.Args["podId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIPod)
	fc.Result = res
	return ec.marshalNPod2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_pod(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "events":
				return ec.fieldContext_Pod_events(ctx, field)
			case "id":
				return ec.fieldContext_Pod_id(ctx, field)
			case "status":
				return ec.fieldContext_Pod_status(ctx, field)
			case "task":
				return ec.fieldContext_Pod_task(ctx, field)
			case "taskContainerCreationOpts":
				return ec.fieldContext_Pod_taskContainerCreationOpts(ctx, field)
			case "type":
				return ec.fieldContext_Pod_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Pod", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_pod_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_patch(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_patch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Patch(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIPatch)
	fc.Result = res
	return ec.marshalNPatch2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_patch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Patch_id(ctx, field)
			case "activated":
				return ec.fieldContext_Patch_activated(ctx, field)
			case "alias":
				return ec.fieldContext_Patch_alias(ctx, field)
			case "author":
				return ec.fieldContext_Patch_author(ctx, field)
			case "authorDisplayName":
				return ec.fieldContext_Patch_authorDisplayName(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Patch_baseTaskStatuses(ctx, field)
			case "builds":
				return ec.fieldContext_Patch_builds(ctx, field)
			case "canEnqueueToCommitQueue":
				return ec.fieldContext_Patch_canEnqueueToCommitQueue(ctx, field)
			case "childPatchAliases":
				return ec.fieldContext_Patch_childPatchAliases(ctx, field)
			case "childPatches":
				return ec.fieldContext_Patch_childPatches(ctx, field)
			case "commitQueuePosition":
				return ec.fieldContext_Patch_commitQueuePosition(ctx, field)
			case "createTime":
				return ec.fieldContext_Patch_createTime(ctx, field)
			case "description":
				return ec.fieldContext_Patch_description(ctx, field)
			case "duration":
				return ec.fieldContext_Patch_duration(ctx, field)
			case "githash":
				return ec.fieldContext_Patch_githash(ctx, field)
			case "hidden":
				return ec.fieldContext_Patch_hidden(ctx, field)
			case "moduleCodeChanges":
				return ec.fieldContext_Patch_moduleCodeChanges(ctx, field)
			case "parameters":
				return ec.fieldContext_Patch_parameters(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Patch_patchNumber(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Patch_patchTriggerAliases(ctx, field)
			case "project":
				return ec.fieldContext_Patch_project(ctx, field)
			case "projectID":
				return ec.fieldContext_Patch_projectID(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Patch_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Patch_projectMetadata(ctx, field)
			case "status":
				return ec.fieldContext_Patch_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Patch_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Patch_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Patch_taskStatuses(ctx, field)
			case "time":
				return ec.fieldContext_Patch_time(ctx, field)
			case "variants":
				return ec.fieldContext_Patch_variants(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_Patch_variantsTasks(ctx, field)
			case "versionFull":
				return ec.fieldContext_Patch_versionFull(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Patch", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_patch_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_githubProjectConflicts(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_githubProjectConflicts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().GithubProjectConflicts(rctx, fc.Args["projectId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model1.GithubProjectConflicts)
	fc.Result = res
	return ec.marshalNGithubProjectConflicts2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐGithubProjectConflicts(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_githubProjectConflicts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "commitCheckIdentifiers":
				return ec.fieldContext_GithubProjectConflicts_commitCheckIdentifiers(ctx, field)
			case "commitQueueIdentifiers":
				return ec.fieldContext_GithubProjectConflicts_commitQueueIdentifiers(ctx, field)
			case "prTestingIdentifiers":
				return ec.fieldContext_GithubProjectConflicts_prTestingIdentifiers(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubProjectConflicts", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_githubProjectConflicts_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_project(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_project(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Project(rctx, fc.Args["projectIdentifier"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectRef)
	fc.Result = res
	return ec.marshalNProject2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_project(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "private":
				return ec.fieldContext_Project_private(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "taskSync":
				return ec.fieldContext_Project_taskSync(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_project_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_projects(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_projects(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Projects(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*GroupedProjects)
	fc.Result = res
	return ec.marshalNGroupedProjects2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐGroupedProjects(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_projects(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "groupDisplayName":
				return ec.fieldContext_GroupedProjects_groupDisplayName(ctx, field)
			case "projects":
				return ec.fieldContext_GroupedProjects_projects(ctx, field)
			case "repo":
				return ec.fieldContext_GroupedProjects_repo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupedProjects", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_projectEvents(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_projectEvents(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ProjectEvents(rctx, fc.Args["identifier"].(string), fc.Args["limit"].(*int), fc.Args["before"].(*time.Time))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ProjectEvents)
	fc.Result = res
	return ec.marshalNProjectEvents2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectEvents(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_projectEvents(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_ProjectEvents_count(ctx, field)
			case "eventLogEntries":
				return ec.fieldContext_ProjectEvents_eventLogEntries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectEvents", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_projectEvents_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_projectSettings(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_projectSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ProjectSettings(rctx, fc.Args["identifier"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectSettings)
	fc.Result = res
	return ec.marshalNProjectSettings2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_projectSettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aliases":
				return ec.fieldContext_ProjectSettings_aliases(ctx, field)
			case "githubWebhooksEnabled":
				return ec.fieldContext_ProjectSettings_githubWebhooksEnabled(ctx, field)
			case "projectRef":
				return ec.fieldContext_ProjectSettings_projectRef(ctx, field)
			case "subscriptions":
				return ec.fieldContext_ProjectSettings_subscriptions(ctx, field)
			case "vars":
				return ec.fieldContext_ProjectSettings_vars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectSettings", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_projectSettings_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_repoEvents(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_repoEvents(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().RepoEvents(rctx, fc.Args["id"].(string), fc.Args["limit"].(*int), fc.Args["before"].(*time.Time))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*ProjectEvents)
	fc.Result = res
	return ec.marshalNProjectEvents2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectEvents(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_repoEvents(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_ProjectEvents_count(ctx, field)
			case "eventLogEntries":
				return ec.fieldContext_ProjectEvents_eventLogEntries(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectEvents", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_repoEvents_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_repoSettings(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_repoSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().RepoSettings(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectSettings)
	fc.Result = res
	return ec.marshalNRepoSettings2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_repoSettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aliases":
				return ec.fieldContext_RepoSettings_aliases(ctx, field)
			case "githubWebhooksEnabled":
				return ec.fieldContext_RepoSettings_githubWebhooksEnabled(ctx, field)
			case "projectRef":
				return ec.fieldContext_RepoSettings_projectRef(ctx, field)
			case "subscriptions":
				return ec.fieldContext_RepoSettings_subscriptions(ctx, field)
			case "vars":
				return ec.fieldContext_RepoSettings_vars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepoSettings", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_repoSettings_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_viewableProjectRefs(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_viewableProjectRefs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().ViewableProjectRefs(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*GroupedProjects)
	fc.Result = res
	return ec.marshalNGroupedProjects2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐGroupedProjects(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_viewableProjectRefs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "groupDisplayName":
				return ec.fieldContext_GroupedProjects_groupDisplayName(ctx, field)
			case "projects":
				return ec.fieldContext_GroupedProjects_projects(ctx, field)
			case "repo":
				return ec.fieldContext_GroupedProjects_repo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupedProjects", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_myHosts(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_myHosts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MyHosts(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIHost)
	fc.Result = res
	return ec.marshalNHost2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHostᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_myHosts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "availabilityZone":
				return ec.fieldContext_Host_availabilityZone(ctx, field)
			case "ami":
				return ec.fieldContext_Host_ami(ctx, field)
			case "displayName":
				return ec.fieldContext_Host_displayName(ctx, field)
			case "distro":
				return ec.fieldContext_Host_distro(ctx, field)
			case "distroId":
				return ec.fieldContext_Host_distroId(ctx, field)
			case "elapsed":
				return ec.fieldContext_Host_elapsed(ctx, field)
			case "expiration":
				return ec.fieldContext_Host_expiration(ctx, field)
			case "hostUrl":
				return ec.fieldContext_Host_hostUrl(ctx, field)
			case "homeVolume":
				return ec.fieldContext_Host_homeVolume(ctx, field)
			case "homeVolumeID":
				return ec.fieldContext_Host_homeVolumeID(ctx, field)
			case "instanceType":
				return ec.fieldContext_Host_instanceType(ctx, field)
			case "instanceTags":
				return ec.fieldContext_Host_instanceTags(ctx, field)
			case "lastCommunicationTime":
				return ec.fieldContext_Host_lastCommunicationTime(ctx, field)
			case "noExpiration":
				return ec.fieldContext_Host_noExpiration(ctx, field)
			case "provider":
				return ec.fieldContext_Host_provider(ctx, field)
			case "runningTask":
				return ec.fieldContext_Host_runningTask(ctx, field)
			case "startedBy":
				return ec.fieldContext_Host_startedBy(ctx, field)
			case "status":
				return ec.fieldContext_Host_status(ctx, field)
			case "tag":
				return ec.fieldContext_Host_tag(ctx, field)
			case "totalIdleTime":
				return ec.fieldContext_Host_totalIdleTime(ctx, field)
			case "uptime":
				return ec.fieldContext_Host_uptime(ctx, field)
			case "user":
				return ec.fieldContext_Host_user(ctx, field)
			case "volumes":
				return ec.fieldContext_Host_volumes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_myVolumes(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_myVolumes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MyVolumes(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIVolume)
	fc.Result = res
	return ec.marshalNVolume2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVolumeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_myVolumes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Volume_id(ctx, field)
			case "availabilityZone":
				return ec.fieldContext_Volume_availabilityZone(ctx, field)
			case "createdBy":
				return ec.fieldContext_Volume_createdBy(ctx, field)
			case "creationTime":
				return ec.fieldContext_Volume_creationTime(ctx, field)
			case "deviceName":
				return ec.fieldContext_Volume_deviceName(ctx, field)
			case "displayName":
				return ec.fieldContext_Volume_displayName(ctx, field)
			case "expiration":
				return ec.fieldContext_Volume_expiration(ctx, field)
			case "homeVolume":
				return ec.fieldContext_Volume_homeVolume(ctx, field)
			case "host":
				return ec.fieldContext_Volume_host(ctx, field)
			case "hostID":
				return ec.fieldContext_Volume_hostID(ctx, field)
			case "migrating":
				return ec.fieldContext_Volume_migrating(ctx, field)
			case "noExpiration":
				return ec.fieldContext_Volume_noExpiration(ctx, field)
			case "size":
				return ec.fieldContext_Volume_size(ctx, field)
			case "type":
				return ec.fieldContext_Volume_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Volume", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_logkeeperBuildMetadata(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_logkeeperBuildMetadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().LogkeeperBuildMetadata(rctx, fc.Args["buildId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*plank.Build)
	fc.Result = res
	return ec.marshalNLogkeeperBuild2ᚖgithubᚗcomᚋevergreenᚑciᚋplankᚐBuild(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_logkeeperBuildMetadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_LogkeeperBuild_id(ctx, field)
			case "builder":
				return ec.fieldContext_LogkeeperBuild_builder(ctx, field)
			case "buildNum":
				return ec.fieldContext_LogkeeperBuild_buildNum(ctx, field)
			case "taskId":
				return ec.fieldContext_LogkeeperBuild_taskId(ctx, field)
			case "taskExecution":
				return ec.fieldContext_LogkeeperBuild_taskExecution(ctx, field)
			case "tests":
				return ec.fieldContext_LogkeeperBuild_tests(ctx, field)
			case "task":
				return ec.fieldContext_LogkeeperBuild_task(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LogkeeperBuild", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_logkeeperBuildMetadata_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_task(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_task(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Task(rctx, fc.Args["taskId"].(string), fc.Args["execution"].(*int))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APITask)
	fc.Result = res
	return ec.marshalOTask2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_task(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canSync":
				return ec.fieldContext_Task_canSync(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "taskFiles":
				return ec.fieldContext_Task_taskFiles(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_task_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_taskAllExecutions(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_taskAllExecutions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().TaskAllExecutions(rctx, fc.Args["taskId"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APITask)
	fc.Result = res
	return ec.marshalNTask2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_taskAllExecutions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canSync":
				return ec.fieldContext_Task_canSync(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "taskFiles":
				return ec.fieldContext_Task_taskFiles(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_taskAllExecutions_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_taskTestSample(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_taskTestSample(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().TaskTestSample(rctx, fc.Args["tasks"].([]string), fc.Args["filters"].([]*TestFilter))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*TaskTestResultSample)
	fc.Result = res
	return ec.marshalOTaskTestResultSample2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskTestResultSampleᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_taskTestSample(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "execution":
				return ec.fieldContext_TaskTestResultSample_execution(ctx, field)
			case "matchingFailedTestNames":
				return ec.fieldContext_TaskTestResultSample_matchingFailedTestNames(ctx, field)
			case "taskId":
				return ec.fieldContext_TaskTestResultSample_taskId(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_TaskTestResultSample_totalTestCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskTestResultSample", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_taskTestSample_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_myPublicKeys(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_myPublicKeys(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MyPublicKeys(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APIPubKey)
	fc.Result = res
	return ec.marshalNPublicKey2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPubKeyᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_myPublicKeys(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_PublicKey_key(ctx, field)
			case "name":
				return ec.fieldContext_PublicKey_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PublicKey", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_user(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().User(rctx, fc.Args["userId"].(*string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIDBUser)
	fc.Result = res
	return ec.marshalNUser2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDBUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "displayName":
				return ec.fieldContext_User_displayName(ctx, field)
			case "emailAddress":
				return ec.fieldContext_User_emailAddress(ctx, field)
			case "patches":
				return ec.fieldContext_User_patches(ctx, field)
			case "permissions":
				return ec.fieldContext_User_permissions(ctx, field)
			case "subscriptions":
				return ec.fieldContext_User_subscriptions(ctx, field)
			case "userId":
				return ec.fieldContext_User_userId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type User", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_user_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_userConfig(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserConfig(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*UserConfig)
	fc.Result = res
	return ec.marshalOUserConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐUserConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userConfig(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "api_key":
				return ec.fieldContext_UserConfig_api_key(ctx, field)
			case "api_server_host":
				return ec.fieldContext_UserConfig_api_server_host(ctx, field)
			case "ui_server_host":
				return ec.fieldContext_UserConfig_ui_server_host(ctx, field)
			case "user":
				return ec.fieldContext_UserConfig_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_userSettings(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_userSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().UserSettings(rctx)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIUserSettings)
	fc.Result = res
	return ec.marshalOUserSettings2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIUserSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_userSettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "githubUser":
				return ec.fieldContext_UserSettings_githubUser(ctx, field)
			case "notifications":
				return ec.fieldContext_UserSettings_notifications(ctx, field)
			case "region":
				return ec.fieldContext_UserSettings_region(ctx, field)
			case "slackUsername":
				return ec.fieldContext_UserSettings_slackUsername(ctx, field)
			case "slackMemberId":
				return ec.fieldContext_UserSettings_slackMemberId(ctx, field)
			case "timezone":
				return ec.fieldContext_UserSettings_timezone(ctx, field)
			case "useSpruceOptions":
				return ec.fieldContext_UserSettings_useSpruceOptions(ctx, field)
			case "dateFormat":
				return ec.fieldContext_UserSettings_dateFormat(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UserSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Query_commitQueue(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_commitQueue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().CommitQueue(rctx, fc.Args["projectIdentifier"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APICommitQueue)
	fc.Result = res
	return ec.marshalNCommitQueue2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPICommitQueue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_commitQueue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "message":
				return ec.fieldContext_CommitQueue_message(ctx, field)
			case "owner":
				return ec.fieldContext_CommitQueue_owner(ctx, field)
			case "projectId":
				return ec.fieldContext_CommitQueue_projectId(ctx, field)
			case "queue":
				return ec.fieldContext_CommitQueue_queue(ctx, field)
			case "repo":
				return ec.fieldContext_CommitQueue_repo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CommitQueue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_commitQueue_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_buildVariantsForTaskName(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_buildVariantsForTaskName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().BuildVariantsForTaskName(rctx, fc.Args["projectIdentifier"].(string), fc.Args["taskName"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*task.BuildVariantTuple)
	fc.Result = res
	return ec.marshalOBuildVariantTuple2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋtaskᚐBuildVariantTuple(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_buildVariantsForTaskName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "buildVariant":
				return ec.fieldContext_BuildVariantTuple_buildVariant(ctx, field)
			case "displayName":
				return ec.fieldContext_BuildVariantTuple_displayName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BuildVariantTuple", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_buildVariantsForTaskName_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_mainlineCommits(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_mainlineCommits(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().MainlineCommits(rctx, fc.Args["options"].(MainlineCommitsOptions), fc.Args["buildVariantOptions"].(*BuildVariantOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*MainlineCommits)
	fc.Result = res
	return ec.marshalOMainlineCommits2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐMainlineCommits(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_mainlineCommits(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "nextPageOrderNumber":
				return ec.fieldContext_MainlineCommits_nextPageOrderNumber(ctx, field)
			case "prevPageOrderNumber":
				return ec.fieldContext_MainlineCommits_prevPageOrderNumber(ctx, field)
			case "versions":
				return ec.fieldContext_MainlineCommits_versions(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type MainlineCommits", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_mainlineCommits_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_taskNamesForBuildVariant(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_taskNamesForBuildVariant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().TaskNamesForBuildVariant(rctx, fc.Args["projectIdentifier"].(string), fc.Args["buildVariant"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalOString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_taskNamesForBuildVariant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_taskNamesForBuildVariant_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_hasVersion(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_hasVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().HasVersion(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_hasVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_hasVersion_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query_version(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Query().Version(rctx, fc.Args["id"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIVersion)
	fc.Result = res
	return ec.marshalNVersion2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query_version_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectType(fc.Args["name"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Query___type_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Query___schema(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.introspectSchema()
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	fc.Result = res
	return ec.marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Query___schema(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Query",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext___Schema_description(ctx, field)
			case "types":
				return ec.fieldContext___Schema_types(ctx, field)
			case "queryType":
				return ec.fieldContext___Schema_queryType(ctx, field)
			case "mutationType":
				return ec.fieldContext___Schema_mutationType(ctx, field)
			case "subscriptionType":
				return ec.fieldContext___Schema_subscriptionType(ctx, field)
			case "directives":
				return ec.fieldContext___Schema_directives(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Schema", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoCommitQueueParams_enabled(ctx context.Context, field graphql.CollectedField, obj *model.APICommitQueueParams) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoCommitQueueParams_enabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoCommitQueueParams_enabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoCommitQueueParams",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoCommitQueueParams_mergeMethod(ctx context.Context, field graphql.CollectedField, obj *model.APICommitQueueParams) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoCommitQueueParams_mergeMethod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MergeMethod, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoCommitQueueParams_mergeMethod(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoCommitQueueParams",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoCommitQueueParams_mergeQueue(ctx context.Context, field graphql.CollectedField, obj *model.APICommitQueueParams) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoCommitQueueParams_mergeQueue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MergeQueue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model1.MergeQueue)
	fc.Result = res
	return ec.marshalNMergeQueue2githubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐMergeQueue(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoCommitQueueParams_mergeQueue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoCommitQueueParams",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type MergeQueue does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoCommitQueueParams_message(ctx context.Context, field graphql.CollectedField, obj *model.APICommitQueueParams) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoCommitQueueParams_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoCommitQueueParams_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoCommitQueueParams",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_id(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_admins(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_admins(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Admins, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalNString2ᚕᚖstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_admins(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_batchTime(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_batchTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.BatchTime, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(int); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be int`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_batchTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_buildBaronSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_buildBaronSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.BuildBaronSettings, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.APIBuildBaronSettings); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/rest/model.APIBuildBaronSettings`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIBuildBaronSettings)
	fc.Result = res
	return ec.marshalNBuildBaronSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIBuildBaronSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_buildBaronSettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "bfSuggestionFeaturesURL":
				return ec.fieldContext_BuildBaronSettings_bfSuggestionFeaturesURL(ctx, field)
			case "bfSuggestionPassword":
				return ec.fieldContext_BuildBaronSettings_bfSuggestionPassword(ctx, field)
			case "bfSuggestionServer":
				return ec.fieldContext_BuildBaronSettings_bfSuggestionServer(ctx, field)
			case "bfSuggestionTimeoutSecs":
				return ec.fieldContext_BuildBaronSettings_bfSuggestionTimeoutSecs(ctx, field)
			case "bfSuggestionUsername":
				return ec.fieldContext_BuildBaronSettings_bfSuggestionUsername(ctx, field)
			case "ticketCreateProject":
				return ec.fieldContext_BuildBaronSettings_ticketCreateProject(ctx, field)
			case "ticketSearchProjects":
				return ec.fieldContext_BuildBaronSettings_ticketSearchProjects(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type BuildBaronSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_commitQueue(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_commitQueue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.CommitQueue, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.APICommitQueueParams); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/rest/model.APICommitQueueParams`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APICommitQueueParams)
	fc.Result = res
	return ec.marshalNRepoCommitQueueParams2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPICommitQueueParams(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_commitQueue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "enabled":
				return ec.fieldContext_RepoCommitQueueParams_enabled(ctx, field)
			case "mergeMethod":
				return ec.fieldContext_RepoCommitQueueParams_mergeMethod(ctx, field)
			case "mergeQueue":
				return ec.fieldContext_RepoCommitQueueParams_mergeQueue(ctx, field)
			case "message":
				return ec.fieldContext_RepoCommitQueueParams_message(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepoCommitQueueParams", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_containerSizeDefinitions(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_containerSizeDefinitions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ContainerSizeDefinitions, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]model.APIContainerResources); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []github.com/evergreen-ci/evergreen/rest/model.APIContainerResources`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIContainerResources)
	fc.Result = res
	return ec.marshalOContainerResources2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIContainerResourcesᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_containerSizeDefinitions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_ContainerResources_name(ctx, field)
			case "cpu":
				return ec.fieldContext_ContainerResources_cpu(ctx, field)
			case "memoryMb":
				return ec.fieldContext_ContainerResources_memoryMb(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ContainerResources", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_deactivatePrevious(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_deactivatePrevious(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.DeactivatePrevious, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_deactivatePrevious(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_disabledStatsCache(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_disabledStatsCache(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.DisabledStatsCache, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_disabledStatsCache(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_dispatchingDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_dispatchingDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.DispatchingDisabled, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_dispatchingDisabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_displayName(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_enabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_enabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Enabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_enabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_githubChecksEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_githubChecksEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.GithubChecksEnabled, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_githubChecksEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_githubTriggerAliases(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_githubTriggerAliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.GithubTriggerAliases, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2ᚕᚖstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_githubTriggerAliases(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_gitTagAuthorizedTeams(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_gitTagAuthorizedTeams(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.GitTagAuthorizedTeams, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2ᚕᚖstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_gitTagAuthorizedTeams(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_gitTagAuthorizedUsers(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_gitTagAuthorizedUsers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.GitTagAuthorizedUsers, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []*string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2ᚕᚖstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_gitTagAuthorizedUsers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_gitTagVersionsEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_gitTagVersionsEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.GitTagVersionsEnabled, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_gitTagVersionsEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_manualPrTestingEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_manualPrTestingEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ManualPRTestingEnabled, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_manualPrTestingEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_notifyOnBuildFailure(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_notifyOnBuildFailure(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.NotifyOnBuildFailure, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_notifyOnBuildFailure(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_owner(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_owner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_owner(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_patchingDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_patchingDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.PatchingDisabled, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_patchingDisabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_patchTriggerAliases(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_patchTriggerAliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.PatchTriggerAliases, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]model.APIPatchTriggerDefinition); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []github.com/evergreen-ci/evergreen/rest/model.APIPatchTriggerDefinition`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIPatchTriggerDefinition)
	fc.Result = res
	return ec.marshalOPatchTriggerAlias2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatchTriggerDefinitionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_patchTriggerAliases(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "alias":
				return ec.fieldContext_PatchTriggerAlias_alias(ctx, field)
			case "childProjectId":
				return ec.fieldContext_PatchTriggerAlias_childProjectId(ctx, field)
			case "childProjectIdentifier":
				return ec.fieldContext_PatchTriggerAlias_childProjectIdentifier(ctx, field)
			case "parentAsModule":
				return ec.fieldContext_PatchTriggerAlias_parentAsModule(ctx, field)
			case "status":
				return ec.fieldContext_PatchTriggerAlias_status(ctx, field)
			case "taskSpecifiers":
				return ec.fieldContext_PatchTriggerAlias_taskSpecifiers(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_PatchTriggerAlias_variantsTasks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PatchTriggerAlias", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_perfEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_perfEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.PerfEnabled, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_perfEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_periodicBuilds(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_periodicBuilds(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.PeriodicBuilds, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]model.APIPeriodicBuildDefinition); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []github.com/evergreen-ci/evergreen/rest/model.APIPeriodicBuildDefinition`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIPeriodicBuildDefinition)
	fc.Result = res
	return ec.marshalOPeriodicBuild2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPeriodicBuildDefinitionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_periodicBuilds(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_PeriodicBuild_id(ctx, field)
			case "alias":
				return ec.fieldContext_PeriodicBuild_alias(ctx, field)
			case "configFile":
				return ec.fieldContext_PeriodicBuild_configFile(ctx, field)
			case "intervalHours":
				return ec.fieldContext_PeriodicBuild_intervalHours(ctx, field)
			case "cron":
				return ec.fieldContext_PeriodicBuild_cron(ctx, field)
			case "message":
				return ec.fieldContext_PeriodicBuild_message(ctx, field)
			case "nextRunTime":
				return ec.fieldContext_PeriodicBuild_nextRunTime(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type PeriodicBuild", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_private(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_private(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Private, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_private(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_prTestingEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_prTestingEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.PRTestingEnabled, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_prTestingEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_remotePath(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_remotePath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.RemotePath, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*string); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_remotePath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_repo(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_repo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_repo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_repotrackerDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_repotrackerDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.RepotrackerDisabled, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_repotrackerDisabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_restricted(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_restricted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Restricted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_restricted(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_spawnHostScriptPath(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_spawnHostScriptPath(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpawnHostScriptPath, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_spawnHostScriptPath(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_stepbackDisabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_stepbackDisabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.StepbackDisabled, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_stepbackDisabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_taskAnnotationSettings(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_taskAnnotationSettings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TaskAnnotationSettings, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.APITaskAnnotationSettings); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/rest/model.APITaskAnnotationSettings`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APITaskAnnotationSettings)
	fc.Result = res
	return ec.marshalNTaskAnnotationSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskAnnotationSettings(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_taskAnnotationSettings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "fileTicketWebhook":
				return ec.fieldContext_TaskAnnotationSettings_fileTicketWebhook(ctx, field)
			case "jiraCustomFields":
				return ec.fieldContext_TaskAnnotationSettings_jiraCustomFields(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskAnnotationSettings", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_taskSync(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_taskSync(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TaskSync, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.APITaskSyncOptions); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/rest/model.APITaskSyncOptions`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APITaskSyncOptions)
	fc.Result = res
	return ec.marshalNRepoTaskSyncOptions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskSyncOptions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_taskSync(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "configEnabled":
				return ec.fieldContext_RepoTaskSyncOptions_configEnabled(ctx, field)
			case "patchEnabled":
				return ec.fieldContext_RepoTaskSyncOptions_patchEnabled(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepoTaskSyncOptions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_tracksPushEvents(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_tracksPushEvents(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.TracksPushEvents, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_tracksPushEvents(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_triggers(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_triggers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.Triggers, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]model.APITriggerDefinition); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []github.com/evergreen-ci/evergreen/rest/model.APITriggerDefinition`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APITriggerDefinition)
	fc.Result = res
	return ec.marshalNTriggerAlias2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITriggerDefinitionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_triggers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "alias":
				return ec.fieldContext_TriggerAlias_alias(ctx, field)
			case "buildVariantRegex":
				return ec.fieldContext_TriggerAlias_buildVariantRegex(ctx, field)
			case "configFile":
				return ec.fieldContext_TriggerAlias_configFile(ctx, field)
			case "dateCutoff":
				return ec.fieldContext_TriggerAlias_dateCutoff(ctx, field)
			case "level":
				return ec.fieldContext_TriggerAlias_level(ctx, field)
			case "project":
				return ec.fieldContext_TriggerAlias_project(ctx, field)
			case "status":
				return ec.fieldContext_TriggerAlias_status(ctx, field)
			case "taskRegex":
				return ec.fieldContext_TriggerAlias_taskRegex(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TriggerAlias", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_versionControlEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_versionControlEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.VersionControlEnabled, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(*bool); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be *bool`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_versionControlEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_workstationConfig(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_workstationConfig(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.WorkstationConfig, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.(model.APIWorkstationConfig); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be github.com/evergreen-ci/evergreen/rest/model.APIWorkstationConfig`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIWorkstationConfig)
	fc.Result = res
	return ec.marshalNRepoWorkstationConfig2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWorkstationConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_workstationConfig(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "gitClone":
				return ec.fieldContext_RepoWorkstationConfig_gitClone(ctx, field)
			case "setupCommands":
				return ec.fieldContext_RepoWorkstationConfig_setupCommands(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepoWorkstationConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoRef_externalLinks(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectRef) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoRef_externalLinks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		directive0 := func(rctx context.Context) (interface{}, error) {
			ctx = rctx // use context from middleware stack in children
			return obj.ExternalLinks, nil
		}
		directive1 := func(ctx context.Context) (interface{}, error) {
			if ec.directives.RequireProjectFieldAccess == nil {
				return nil, errors.New("directive requireProjectFieldAccess is not implemented")
			}
			return ec.directives.RequireProjectFieldAccess(ctx, obj, directive0)
		}

		tmp, err := directive1(rctx)
		if err != nil {
			return nil, graphql.ErrorOnPath(ctx, err)
		}
		if tmp == nil {
			return nil, nil
		}
		if data, ok := tmp.([]model.APIExternalLink); ok {
			return data, nil
		}
		return nil, fmt.Errorf(`unexpected type %T from directive, should be []github.com/evergreen-ci/evergreen/rest/model.APIExternalLink`, tmp)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIExternalLink)
	fc.Result = res
	return ec.marshalOExternalLink2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIExternalLinkᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoRef_externalLinks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoRef",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "displayName":
				return ec.fieldContext_ExternalLink_displayName(ctx, field)
			case "requesters":
				return ec.fieldContext_ExternalLink_requesters(ctx, field)
			case "urlTemplate":
				return ec.fieldContext_ExternalLink_urlTemplate(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ExternalLink", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoSettings_aliases(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoSettings_aliases(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RepoSettings().Aliases(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.APIProjectAlias)
	fc.Result = res
	return ec.marshalOProjectAlias2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectAliasᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoSettings_aliases(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_ProjectAlias_id(ctx, field)
			case "alias":
				return ec.fieldContext_ProjectAlias_alias(ctx, field)
			case "description":
				return ec.fieldContext_ProjectAlias_description(ctx, field)
			case "gitTag":
				return ec.fieldContext_ProjectAlias_gitTag(ctx, field)
			case "remotePath":
				return ec.fieldContext_ProjectAlias_remotePath(ctx, field)
			case "task":
				return ec.fieldContext_ProjectAlias_task(ctx, field)
			case "taskTags":
				return ec.fieldContext_ProjectAlias_taskTags(ctx, field)
			case "variant":
				return ec.fieldContext_ProjectAlias_variant(ctx, field)
			case "variantTags":
				return ec.fieldContext_ProjectAlias_variantTags(ctx, field)
			case "parameters":
				return ec.fieldContext_ProjectAlias_parameters(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectAlias", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoSettings_githubWebhooksEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoSettings_githubWebhooksEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RepoSettings().GithubWebhooksEnabled(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoSettings_githubWebhooksEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoSettings_projectRef(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoSettings_projectRef(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectRef, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.APIProjectRef)
	fc.Result = res
	return ec.marshalORepoRef2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoSettings_projectRef(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_RepoRef_id(ctx, field)
			case "admins":
				return ec.fieldContext_RepoRef_admins(ctx, field)
			case "batchTime":
				return ec.fieldContext_RepoRef_batchTime(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_RepoRef_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_RepoRef_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_RepoRef_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_RepoRef_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_RepoRef_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_RepoRef_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_RepoRef_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_RepoRef_enabled(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_RepoRef_githubChecksEnabled(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_RepoRef_githubTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_RepoRef_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_RepoRef_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_RepoRef_gitTagVersionsEnabled(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_RepoRef_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_RepoRef_notifyOnBuildFailure(ctx, field)
			case "owner":
				return ec.fieldContext_RepoRef_owner(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_RepoRef_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_RepoRef_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_RepoRef_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_RepoRef_periodicBuilds(ctx, field)
			case "private":
				return ec.fieldContext_RepoRef_private(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_RepoRef_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_RepoRef_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_RepoRef_repo(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_RepoRef_repotrackerDisabled(ctx, field)
			case "restricted":
				return ec.fieldContext_RepoRef_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_RepoRef_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_RepoRef_stepbackDisabled(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_RepoRef_taskAnnotationSettings(ctx, field)
			case "taskSync":
				return ec.fieldContext_RepoRef_taskSync(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_RepoRef_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_RepoRef_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_RepoRef_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_RepoRef_workstationConfig(ctx, field)
			case "externalLinks":
				return ec.fieldContext_RepoRef_externalLinks(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type RepoRef", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoSettings_subscriptions(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoSettings_subscriptions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RepoSettings().Subscriptions(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.APISubscription)
	fc.Result = res
	return ec.marshalOGeneralSubscription2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISubscriptionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoSettings_subscriptions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GeneralSubscription_id(ctx, field)
			case "ownerType":
				return ec.fieldContext_GeneralSubscription_ownerType(ctx, field)
			case "regexSelectors":
				return ec.fieldContext_GeneralSubscription_regexSelectors(ctx, field)
			case "resourceType":
				return ec.fieldContext_GeneralSubscription_resourceType(ctx, field)
			case "selectors":
				return ec.fieldContext_GeneralSubscription_selectors(ctx, field)
			case "subscriber":
				return ec.fieldContext_GeneralSubscription_subscriber(ctx, field)
			case "trigger":
				return ec.fieldContext_GeneralSubscription_trigger(ctx, field)
			case "triggerData":
				return ec.fieldContext_GeneralSubscription_triggerData(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GeneralSubscription", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoSettings_vars(ctx context.Context, field graphql.CollectedField, obj *model.APIProjectSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoSettings_vars(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.RepoSettings().Vars(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectVars)
	fc.Result = res
	return ec.marshalOProjectVars2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectVars(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoSettings_vars(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoSettings",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "adminOnlyVars":
				return ec.fieldContext_ProjectVars_adminOnlyVars(ctx, field)
			case "privateVars":
				return ec.fieldContext_ProjectVars_privateVars(ctx, field)
			case "vars":
				return ec.fieldContext_ProjectVars_vars(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ProjectVars", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoTaskSyncOptions_configEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APITaskSyncOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoTaskSyncOptions_configEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConfigEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoTaskSyncOptions_configEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoTaskSyncOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoTaskSyncOptions_patchEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APITaskSyncOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoTaskSyncOptions_patchEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PatchEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoTaskSyncOptions_patchEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoTaskSyncOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoWorkstationConfig_gitClone(ctx context.Context, field graphql.CollectedField, obj *model.APIWorkstationConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoWorkstationConfig_gitClone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GitClone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalNBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoWorkstationConfig_gitClone(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoWorkstationConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _RepoWorkstationConfig_setupCommands(ctx context.Context, field graphql.CollectedField, obj *model.APIWorkstationConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_RepoWorkstationConfig_setupCommands(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SetupCommands, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIWorkstationSetupCommand)
	fc.Result = res
	return ec.marshalOWorkstationSetupCommand2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWorkstationSetupCommandᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_RepoWorkstationConfig_setupCommands(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "RepoWorkstationConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "command":
				return ec.fieldContext_WorkstationSetupCommand_command(ctx, field)
			case "directory":
				return ec.fieldContext_WorkstationSetupCommand_directory(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkstationSetupCommand", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceLimits_lockedMemoryKb(ctx context.Context, field graphql.CollectedField, obj *model.APIResourceLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceLimits_lockedMemoryKb(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LockedMemoryKB, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceLimits_lockedMemoryKb(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceLimits_numFiles(ctx context.Context, field graphql.CollectedField, obj *model.APIResourceLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceLimits_numFiles(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumFiles, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceLimits_numFiles(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceLimits_numProcesses(ctx context.Context, field graphql.CollectedField, obj *model.APIResourceLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceLimits_numProcesses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumProcesses, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceLimits_numProcesses(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceLimits_numTasks(ctx context.Context, field graphql.CollectedField, obj *model.APIResourceLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceLimits_numTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NumTasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceLimits_numTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _ResourceLimits_virtualMemoryKb(ctx context.Context, field graphql.CollectedField, obj *model.APIResourceLimits) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_ResourceLimits_virtualMemoryKb(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VirtualMemoryKB, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_ResourceLimits_virtualMemoryKb(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "ResourceLimits",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SaveDistroPayload_distro(ctx context.Context, field graphql.CollectedField, obj *SaveDistroPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SaveDistroPayload_distro(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Distro, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIDistro)
	fc.Result = res
	return ec.marshalNDistro2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDistro(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SaveDistroPayload_distro(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SaveDistroPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aliases":
				return ec.fieldContext_Distro_aliases(ctx, field)
			case "arch":
				return ec.fieldContext_Distro_arch(ctx, field)
			case "authorizedKeysFile":
				return ec.fieldContext_Distro_authorizedKeysFile(ctx, field)
			case "bootstrapSettings":
				return ec.fieldContext_Distro_bootstrapSettings(ctx, field)
			case "cloneMethod":
				return ec.fieldContext_Distro_cloneMethod(ctx, field)
			case "containerPool":
				return ec.fieldContext_Distro_containerPool(ctx, field)
			case "disabled":
				return ec.fieldContext_Distro_disabled(ctx, field)
			case "disableShallowClone":
				return ec.fieldContext_Distro_disableShallowClone(ctx, field)
			case "dispatcherSettings":
				return ec.fieldContext_Distro_dispatcherSettings(ctx, field)
			case "expansions":
				return ec.fieldContext_Distro_expansions(ctx, field)
			case "finderSettings":
				return ec.fieldContext_Distro_finderSettings(ctx, field)
			case "homeVolumeSettings":
				return ec.fieldContext_Distro_homeVolumeSettings(ctx, field)
			case "hostAllocatorSettings":
				return ec.fieldContext_Distro_hostAllocatorSettings(ctx, field)
			case "iceCreamSettings":
				return ec.fieldContext_Distro_iceCreamSettings(ctx, field)
			case "isCluster":
				return ec.fieldContext_Distro_isCluster(ctx, field)
			case "isVirtualWorkStation":
				return ec.fieldContext_Distro_isVirtualWorkStation(ctx, field)
			case "name":
				return ec.fieldContext_Distro_name(ctx, field)
			case "note":
				return ec.fieldContext_Distro_note(ctx, field)
			case "plannerSettings":
				return ec.fieldContext_Distro_plannerSettings(ctx, field)
			case "provider":
				return ec.fieldContext_Distro_provider(ctx, field)
			case "providerSettingsList":
				return ec.fieldContext_Distro_providerSettingsList(ctx, field)
			case "setup":
				return ec.fieldContext_Distro_setup(ctx, field)
			case "setupAsSudo":
				return ec.fieldContext_Distro_setupAsSudo(ctx, field)
			case "sshKey":
				return ec.fieldContext_Distro_sshKey(ctx, field)
			case "sshOptions":
				return ec.fieldContext_Distro_sshOptions(ctx, field)
			case "user":
				return ec.fieldContext_Distro_user(ctx, field)
			case "userSpawnAllowed":
				return ec.fieldContext_Distro_userSpawnAllowed(ctx, field)
			case "validProjects":
				return ec.fieldContext_Distro_validProjects(ctx, field)
			case "workDir":
				return ec.fieldContext_Distro_workDir(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Distro", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SaveDistroPayload_hostCount(ctx context.Context, field graphql.CollectedField, obj *SaveDistroPayload) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SaveDistroPayload_hostCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SaveDistroPayload_hostCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SaveDistroPayload",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchReturnInfo_featuresURL(ctx context.Context, field graphql.CollectedField, obj *thirdparty.SearchReturnInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchReturnInfo_featuresURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FeaturesURL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchReturnInfo_featuresURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchReturnInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchReturnInfo_issues(ctx context.Context, field graphql.CollectedField, obj *thirdparty.SearchReturnInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchReturnInfo_issues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Issues, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]thirdparty.JiraTicket)
	fc.Result = res
	return ec.marshalNJiraTicket2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐJiraTicketᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchReturnInfo_issues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchReturnInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "fields":
				return ec.fieldContext_JiraTicket_fields(ctx, field)
			case "key":
				return ec.fieldContext_JiraTicket_key(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JiraTicket", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchReturnInfo_search(ctx context.Context, field graphql.CollectedField, obj *thirdparty.SearchReturnInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchReturnInfo_search(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Search, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchReturnInfo_search(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchReturnInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SearchReturnInfo_source(ctx context.Context, field graphql.CollectedField, obj *thirdparty.SearchReturnInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SearchReturnInfo_source(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Source, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SearchReturnInfo_source(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SearchReturnInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Selector_data(ctx context.Context, field graphql.CollectedField, obj *model.APISelector) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Selector_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Selector_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Selector",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Selector_type(ctx context.Context, field graphql.CollectedField, obj *model.APISelector) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Selector_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Selector_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Selector",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SlackConfig_name(ctx context.Context, field graphql.CollectedField, obj *model.APISlackConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SlackConfig_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SlackConfig_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SlackConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Source_author(ctx context.Context, field graphql.CollectedField, obj *model.APISource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Source_author(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Author, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Source_author(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Source",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Source_requester(ctx context.Context, field graphql.CollectedField, obj *model.APISource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Source_requester(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Requester, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Source_requester(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Source",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Source_time(ctx context.Context, field graphql.CollectedField, obj *model.APISource) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Source_time(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Time, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Source_time(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Source",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpawnHostConfig_spawnHostsPerUser(ctx context.Context, field graphql.CollectedField, obj *model.APISpawnHostConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpawnHostConfig_spawnHostsPerUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpawnHostsPerUser, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalNInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpawnHostConfig_spawnHostsPerUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpawnHostConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpawnHostConfig_unexpirableHostsPerUser(ctx context.Context, field graphql.CollectedField, obj *model.APISpawnHostConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpawnHostConfig_unexpirableHostsPerUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UnexpirableHostsPerUser, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalNInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpawnHostConfig_unexpirableHostsPerUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpawnHostConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpawnHostConfig_unexpirableVolumesPerUser(ctx context.Context, field graphql.CollectedField, obj *model.APISpawnHostConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpawnHostConfig_unexpirableVolumesPerUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UnexpirableVolumesPerUser, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalNInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpawnHostConfig_unexpirableVolumesPerUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpawnHostConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_banner(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpruceConfig_banner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Banner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpruceConfig_banner(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_bannerTheme(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpruceConfig_bannerTheme(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BannerTheme, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpruceConfig_bannerTheme(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_githubOrgs(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpruceConfig_githubOrgs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GithubOrgs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpruceConfig_githubOrgs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_jira(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpruceConfig_jira(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Jira, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIJiraConfig)
	fc.Result = res
	return ec.marshalOJiraConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIJiraConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpruceConfig_jira(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "host":
				return ec.fieldContext_JiraConfig_host(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JiraConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_providers(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpruceConfig_providers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Providers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APICloudProviders)
	fc.Result = res
	return ec.marshalOCloudProviderConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPICloudProviders(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpruceConfig_providers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "aws":
				return ec.fieldContext_CloudProviderConfig_aws(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type CloudProviderConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_spawnHost(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpruceConfig_spawnHost(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Spawnhost, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APISpawnHostConfig)
	fc.Result = res
	return ec.marshalNSpawnHostConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISpawnHostConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpruceConfig_spawnHost(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "spawnHostsPerUser":
				return ec.fieldContext_SpawnHostConfig_spawnHostsPerUser(ctx, field)
			case "unexpirableHostsPerUser":
				return ec.fieldContext_SpawnHostConfig_unexpirableHostsPerUser(ctx, field)
			case "unexpirableVolumesPerUser":
				return ec.fieldContext_SpawnHostConfig_unexpirableVolumesPerUser(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SpawnHostConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_ui(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpruceConfig_ui(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Ui, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIUIConfig)
	fc.Result = res
	return ec.marshalOUIConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIUIConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpruceConfig_ui(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "defaultProject":
				return ec.fieldContext_UIConfig_defaultProject(ctx, field)
			case "userVoice":
				return ec.fieldContext_UIConfig_userVoice(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UIConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SpruceConfig_slack(ctx context.Context, field graphql.CollectedField, obj *model.APIAdminSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SpruceConfig_slack(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Slack, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APISlackConfig)
	fc.Result = res
	return ec.marshalOSlackConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISlackConfig(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SpruceConfig_slack(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SpruceConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext_SlackConfig_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type SlackConfig", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _StatusCount_count(ctx context.Context, field graphql.CollectedField, obj *task.StatusCount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StatusCount_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StatusCount_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StatusCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _StatusCount_status(ctx context.Context, field graphql.CollectedField, obj *task.StatusCount) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_StatusCount_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_StatusCount_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "StatusCount",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscriber_emailSubscriber(ctx context.Context, field graphql.CollectedField, obj *Subscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscriber_emailSubscriber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EmailSubscriber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Subscriber_emailSubscriber(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscriber_githubCheckSubscriber(ctx context.Context, field graphql.CollectedField, obj *Subscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscriber_githubCheckSubscriber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GithubCheckSubscriber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIGithubCheckSubscriber)
	fc.Result = res
	return ec.marshalOGithubCheckSubscriber2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGithubCheckSubscriber(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Subscriber_githubCheckSubscriber(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "owner":
				return ec.fieldContext_GithubCheckSubscriber_owner(ctx, field)
			case "ref":
				return ec.fieldContext_GithubCheckSubscriber_ref(ctx, field)
			case "repo":
				return ec.fieldContext_GithubCheckSubscriber_repo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubCheckSubscriber", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscriber_githubPRSubscriber(ctx context.Context, field graphql.CollectedField, obj *Subscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscriber_githubPRSubscriber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GithubPRSubscriber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIGithubPRSubscriber)
	fc.Result = res
	return ec.marshalOGithubPRSubscriber2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGithubPRSubscriber(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Subscriber_githubPRSubscriber(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "owner":
				return ec.fieldContext_GithubPRSubscriber_owner(ctx, field)
			case "prNumber":
				return ec.fieldContext_GithubPRSubscriber_prNumber(ctx, field)
			case "ref":
				return ec.fieldContext_GithubPRSubscriber_ref(ctx, field)
			case "repo":
				return ec.fieldContext_GithubPRSubscriber_repo(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubPRSubscriber", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscriber_jiraCommentSubscriber(ctx context.Context, field graphql.CollectedField, obj *Subscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscriber_jiraCommentSubscriber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JiraCommentSubscriber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Subscriber_jiraCommentSubscriber(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscriber_jiraIssueSubscriber(ctx context.Context, field graphql.CollectedField, obj *Subscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscriber_jiraIssueSubscriber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JiraIssueSubscriber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIJIRAIssueSubscriber)
	fc.Result = res
	return ec.marshalOJiraIssueSubscriber2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIJIRAIssueSubscriber(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Subscriber_jiraIssueSubscriber(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "issueType":
				return ec.fieldContext_JiraIssueSubscriber_issueType(ctx, field)
			case "project":
				return ec.fieldContext_JiraIssueSubscriber_project(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JiraIssueSubscriber", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscriber_slackSubscriber(ctx context.Context, field graphql.CollectedField, obj *Subscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscriber_slackSubscriber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SlackSubscriber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Subscriber_slackSubscriber(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Subscriber_webhookSubscriber(ctx context.Context, field graphql.CollectedField, obj *Subscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Subscriber_webhookSubscriber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WebhookSubscriber, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIWebhookSubscriber)
	fc.Result = res
	return ec.marshalOWebhookSubscriber2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWebhookSubscriber(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Subscriber_webhookSubscriber(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Subscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "headers":
				return ec.fieldContext_WebhookSubscriber_headers(ctx, field)
			case "secret":
				return ec.fieldContext_WebhookSubscriber_secret(ctx, field)
			case "url":
				return ec.fieldContext_WebhookSubscriber_url(ctx, field)
			case "retries":
				return ec.fieldContext_WebhookSubscriber_retries(ctx, field)
			case "minDelayMs":
				return ec.fieldContext_WebhookSubscriber_minDelayMs(ctx, field)
			case "timeoutMs":
				return ec.fieldContext_WebhookSubscriber_timeoutMs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WebhookSubscriber", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SubscriberWrapper_subscriber(ctx context.Context, field graphql.CollectedField, obj *model.APISubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SubscriberWrapper_subscriber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.SubscriberWrapper().Subscriber(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Subscriber)
	fc.Result = res
	return ec.marshalNSubscriber2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSubscriber(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SubscriberWrapper_subscriber(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SubscriberWrapper",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "emailSubscriber":
				return ec.fieldContext_Subscriber_emailSubscriber(ctx, field)
			case "githubCheckSubscriber":
				return ec.fieldContext_Subscriber_githubCheckSubscriber(ctx, field)
			case "githubPRSubscriber":
				return ec.fieldContext_Subscriber_githubPRSubscriber(ctx, field)
			case "jiraCommentSubscriber":
				return ec.fieldContext_Subscriber_jiraCommentSubscriber(ctx, field)
			case "jiraIssueSubscriber":
				return ec.fieldContext_Subscriber_jiraIssueSubscriber(ctx, field)
			case "slackSubscriber":
				return ec.fieldContext_Subscriber_slackSubscriber(ctx, field)
			case "webhookSubscriber":
				return ec.fieldContext_Subscriber_webhookSubscriber(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Subscriber", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _SubscriberWrapper_type(ctx context.Context, field graphql.CollectedField, obj *model.APISubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_SubscriberWrapper_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_SubscriberWrapper_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "SubscriberWrapper",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_id(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_aborted(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_aborted(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Aborted, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_aborted(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_abortInfo(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_abortInfo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().AbortInfo(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*AbortInfo)
	fc.Result = res
	return ec.marshalOAbortInfo2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAbortInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_abortInfo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "buildVariantDisplayName":
				return ec.fieldContext_AbortInfo_buildVariantDisplayName(ctx, field)
			case "newVersion":
				return ec.fieldContext_AbortInfo_newVersion(ctx, field)
			case "prClosed":
				return ec.fieldContext_AbortInfo_prClosed(ctx, field)
			case "taskDisplayName":
				return ec.fieldContext_AbortInfo_taskDisplayName(ctx, field)
			case "taskID":
				return ec.fieldContext_AbortInfo_taskID(ctx, field)
			case "user":
				return ec.fieldContext_AbortInfo_user(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type AbortInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_activated(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_activated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Activated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_activated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_activatedBy(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_activatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ActivatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_activatedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_activatedTime(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_activatedTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ActivatedTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_activatedTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_ami(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_ami(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().Ami(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_ami(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_annotation(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_annotation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().Annotation(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APITaskAnnotation)
	fc.Result = res
	return ec.marshalOAnnotation2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskAnnotation(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_annotation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Annotation_id(ctx, field)
			case "createdIssues":
				return ec.fieldContext_Annotation_createdIssues(ctx, field)
			case "issues":
				return ec.fieldContext_Annotation_issues(ctx, field)
			case "note":
				return ec.fieldContext_Annotation_note(ctx, field)
			case "suspectedIssues":
				return ec.fieldContext_Annotation_suspectedIssues(ctx, field)
			case "metadataLinks":
				return ec.fieldContext_Annotation_metadataLinks(ctx, field)
			case "taskId":
				return ec.fieldContext_Annotation_taskId(ctx, field)
			case "taskExecution":
				return ec.fieldContext_Annotation_taskExecution(ctx, field)
			case "webhookConfigured":
				return ec.fieldContext_Annotation_webhookConfigured(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Annotation", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_baseStatus(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_baseStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().BaseStatus(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_baseStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_baseTask(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_baseTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().BaseTask(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APITask)
	fc.Result = res
	return ec.marshalOTask2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_baseTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canSync":
				return ec.fieldContext_Task_canSync(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "taskFiles":
				return ec.fieldContext_Task_taskFiles(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_blocked(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_blocked(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Blocked, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_blocked(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_buildId(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_buildId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_buildId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_buildVariant(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_buildVariant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildVariant, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_buildVariant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_buildVariantDisplayName(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().BuildVariantDisplayName(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_buildVariantDisplayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_canAbort(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_canAbort(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().CanAbort(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_canAbort(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_canDisable(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_canDisable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().CanDisable(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_canDisable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_canModifyAnnotation(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_canModifyAnnotation(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().CanModifyAnnotation(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_canModifyAnnotation(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_canOverrideDependencies(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_canOverrideDependencies(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().CanOverrideDependencies(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_canOverrideDependencies(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_canRestart(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_canRestart(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().CanRestart(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_canRestart(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_canSchedule(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_canSchedule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().CanSchedule(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_canSchedule(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_canSetPriority(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_canSetPriority(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().CanSetPriority(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_canSetPriority(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_canSync(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_canSync(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CanSync, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_canSync(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_canUnschedule(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_canUnschedule(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().CanUnschedule(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_canUnschedule(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_containerAllocatedTime(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_containerAllocatedTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ContainerAllocatedTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_containerAllocatedTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_createTime(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_createTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreateTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_createTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_dependsOn(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_dependsOn(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().DependsOn(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*Dependency)
	fc.Result = res
	return ec.marshalODependency2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDependencyᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_dependsOn(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "buildVariant":
				return ec.fieldContext_Dependency_buildVariant(ctx, field)
			case "metStatus":
				return ec.fieldContext_Dependency_metStatus(ctx, field)
			case "name":
				return ec.fieldContext_Dependency_name(ctx, field)
			case "requiredStatus":
				return ec.fieldContext_Dependency_requiredStatus(ctx, field)
			case "taskId":
				return ec.fieldContext_Dependency_taskId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Dependency", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_details(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_details(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Details, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.ApiTaskEndDetail)
	fc.Result = res
	return ec.marshalOTaskEndDetail2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐApiTaskEndDetail(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_details(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "description":
				return ec.fieldContext_TaskEndDetail_description(ctx, field)
			case "oomTracker":
				return ec.fieldContext_TaskEndDetail_oomTracker(ctx, field)
			case "status":
				return ec.fieldContext_TaskEndDetail_status(ctx, field)
			case "timedOut":
				return ec.fieldContext_TaskEndDetail_timedOut(ctx, field)
			case "timeoutType":
				return ec.fieldContext_TaskEndDetail_timeoutType(ctx, field)
			case "type":
				return ec.fieldContext_TaskEndDetail_type(ctx, field)
			case "traceID":
				return ec.fieldContext_TaskEndDetail_traceID(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskEndDetail", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_dispatchTime(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_dispatchTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DispatchTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_dispatchTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_displayName(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_displayOnly(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_displayOnly(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayOnly, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_displayOnly(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_displayTask(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_displayTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().DisplayTask(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APITask)
	fc.Result = res
	return ec.marshalOTask2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_displayTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canSync":
				return ec.fieldContext_Task_canSync(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "taskFiles":
				return ec.fieldContext_Task_taskFiles(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_distroId(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_distroId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DistroId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_distroId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_estimatedStart(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_estimatedStart(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().EstimatedStart(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIDuration)
	fc.Result = res
	return ec.marshalODuration2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_estimatedStart(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_execution(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_execution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Execution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_execution(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_executionTasks(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_executionTasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExecutionTasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalOString2ᚕᚖstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_executionTasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_executionTasksFull(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_executionTasksFull(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().ExecutionTasksFull(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.APITask)
	fc.Result = res
	return ec.marshalOTask2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_executionTasksFull(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canSync":
				return ec.fieldContext_Task_canSync(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "taskFiles":
				return ec.fieldContext_Task_taskFiles(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_expectedDuration(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_expectedDuration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpectedDuration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.APIDuration)
	fc.Result = res
	return ec.marshalODuration2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_expectedDuration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_failedTestCount(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_failedTestCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().FailedTestCount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_failedTestCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_finishTime(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_finishTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FinishTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_finishTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_generatedBy(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_generatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GeneratedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_generatedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_generatedByName(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_generatedByName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().GeneratedByName(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_generatedByName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_generateTask(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_generateTask(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GenerateTask, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_generateTask(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_hostId(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_hostId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_hostId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_ingestTime(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_ingestTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IngestTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_ingestTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_isPerfPluginEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().IsPerfPluginEnabled(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_isPerfPluginEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_latestExecution(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_latestExecution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().LatestExecution(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_latestExecution(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_logs(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_logs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Logs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.LogLinks)
	fc.Result = res
	return ec.marshalNTaskLogLinks2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐLogLinks(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_logs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "agentLogLink":
				return ec.fieldContext_TaskLogLinks_agentLogLink(ctx, field)
			case "allLogLink":
				return ec.fieldContext_TaskLogLinks_allLogLink(ctx, field)
			case "eventLogLink":
				return ec.fieldContext_TaskLogLinks_eventLogLink(ctx, field)
			case "systemLogLink":
				return ec.fieldContext_TaskLogLinks_systemLogLink(ctx, field)
			case "taskLogLink":
				return ec.fieldContext_TaskLogLinks_taskLogLink(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskLogLinks", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_minQueuePosition(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_minQueuePosition(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().MinQueuePosition(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_minQueuePosition(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_order(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_order(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Order, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_order(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_patch(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_patch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().Patch(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIPatch)
	fc.Result = res
	return ec.marshalOPatch2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_patch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Patch_id(ctx, field)
			case "activated":
				return ec.fieldContext_Patch_activated(ctx, field)
			case "alias":
				return ec.fieldContext_Patch_alias(ctx, field)
			case "author":
				return ec.fieldContext_Patch_author(ctx, field)
			case "authorDisplayName":
				return ec.fieldContext_Patch_authorDisplayName(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Patch_baseTaskStatuses(ctx, field)
			case "builds":
				return ec.fieldContext_Patch_builds(ctx, field)
			case "canEnqueueToCommitQueue":
				return ec.fieldContext_Patch_canEnqueueToCommitQueue(ctx, field)
			case "childPatchAliases":
				return ec.fieldContext_Patch_childPatchAliases(ctx, field)
			case "childPatches":
				return ec.fieldContext_Patch_childPatches(ctx, field)
			case "commitQueuePosition":
				return ec.fieldContext_Patch_commitQueuePosition(ctx, field)
			case "createTime":
				return ec.fieldContext_Patch_createTime(ctx, field)
			case "description":
				return ec.fieldContext_Patch_description(ctx, field)
			case "duration":
				return ec.fieldContext_Patch_duration(ctx, field)
			case "githash":
				return ec.fieldContext_Patch_githash(ctx, field)
			case "hidden":
				return ec.fieldContext_Patch_hidden(ctx, field)
			case "moduleCodeChanges":
				return ec.fieldContext_Patch_moduleCodeChanges(ctx, field)
			case "parameters":
				return ec.fieldContext_Patch_parameters(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Patch_patchNumber(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Patch_patchTriggerAliases(ctx, field)
			case "project":
				return ec.fieldContext_Patch_project(ctx, field)
			case "projectID":
				return ec.fieldContext_Patch_projectID(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Patch_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Patch_projectMetadata(ctx, field)
			case "status":
				return ec.fieldContext_Patch_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Patch_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Patch_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Patch_taskStatuses(ctx, field)
			case "time":
				return ec.fieldContext_Patch_time(ctx, field)
			case "variants":
				return ec.fieldContext_Patch_variants(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_Patch_variantsTasks(ctx, field)
			case "versionFull":
				return ec.fieldContext_Patch_versionFull(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Patch", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_patchNumber(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_patchNumber(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().PatchNumber(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_patchNumber(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_pod(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_pod(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().Pod(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIPod)
	fc.Result = res
	return ec.marshalOPod2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPod(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_pod(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "events":
				return ec.fieldContext_Pod_events(ctx, field)
			case "id":
				return ec.fieldContext_Pod_id(ctx, field)
			case "status":
				return ec.fieldContext_Pod_status(ctx, field)
			case "task":
				return ec.fieldContext_Pod_task(ctx, field)
			case "taskContainerCreationOpts":
				return ec.fieldContext_Pod_taskContainerCreationOpts(ctx, field)
			case "type":
				return ec.fieldContext_Pod_type(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Pod", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_priority(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_priority(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Priority, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_priority(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_project(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_project(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().Project(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectRef)
	fc.Result = res
	return ec.marshalOProject2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_project(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "private":
				return ec.fieldContext_Project_private(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "taskSync":
				return ec.fieldContext_Project_taskSync(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_projectId(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_projectId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_projectId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_projectIdentifier(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_projectIdentifier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().ProjectIdentifier(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_projectIdentifier(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_requester(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_requester(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Requester, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_requester(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_resetWhenFinished(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_resetWhenFinished(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResetWhenFinished, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_resetWhenFinished(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_revision(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_revision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_revision(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_scheduledTime(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_scheduledTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ScheduledTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_scheduledTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_spawnHostLink(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_spawnHostLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().SpawnHostLink(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_spawnHostLink(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_startTime(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_startTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_startTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_status(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().Status(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_taskFiles(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_taskFiles(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().TaskFiles(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*TaskFiles)
	fc.Result = res
	return ec.marshalNTaskFiles2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskFiles(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_taskFiles(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "fileCount":
				return ec.fieldContext_TaskFiles_fileCount(ctx, field)
			case "groupedFiles":
				return ec.fieldContext_TaskFiles_groupedFiles(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskFiles", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_taskGroup(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_taskGroup(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskGroup, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalOString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_taskGroup(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_taskGroupMaxHosts(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskGroupMaxHosts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_taskGroupMaxHosts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_taskLogs(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_taskLogs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().TaskLogs(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*TaskLogs)
	fc.Result = res
	return ec.marshalNTaskLogs2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskLogs(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_taskLogs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "agentLogs":
				return ec.fieldContext_TaskLogs_agentLogs(ctx, field)
			case "allLogs":
				return ec.fieldContext_TaskLogs_allLogs(ctx, field)
			case "defaultLogger":
				return ec.fieldContext_TaskLogs_defaultLogger(ctx, field)
			case "eventLogs":
				return ec.fieldContext_TaskLogs_eventLogs(ctx, field)
			case "execution":
				return ec.fieldContext_TaskLogs_execution(ctx, field)
			case "systemLogs":
				return ec.fieldContext_TaskLogs_systemLogs(ctx, field)
			case "taskId":
				return ec.fieldContext_TaskLogs_taskId(ctx, field)
			case "taskLogs":
				return ec.fieldContext_TaskLogs_taskLogs(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskLogs", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_tests(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_tests(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().Tests(rctx, obj, fc.Args["opts"].(*TestFilterOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*TaskTestResult)
	fc.Result = res
	return ec.marshalNTaskTestResult2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskTestResult(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_tests(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "testResults":
				return ec.fieldContext_TaskTestResult_testResults(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_TaskTestResult_totalTestCount(ctx, field)
			case "filteredTestCount":
				return ec.fieldContext_TaskTestResult_filteredTestCount(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskTestResult", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Task_tests_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Task_timeTaken(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_timeTaken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimeTaken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(model.APIDuration)
	fc.Result = res
	return ec.marshalODuration2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_timeTaken(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_totalTestCount(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_totalTestCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().TotalTestCount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_totalTestCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Task_versionMetadata(ctx context.Context, field graphql.CollectedField, obj *model.APITask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Task_versionMetadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Task().VersionMetadata(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.APIVersion)
	fc.Result = res
	return ec.marshalNVersion2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Task_versionMetadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Task",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskAnnotationSettings_fileTicketWebhook(ctx context.Context, field graphql.CollectedField, obj *model.APITaskAnnotationSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskAnnotationSettings_fileTicketWebhook(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileTicketWebhook, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIWebHook)
	fc.Result = res
	return ec.marshalNWebhook2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWebHook(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskAnnotationSettings_fileTicketWebhook(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskAnnotationSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "endpoint":
				return ec.fieldContext_Webhook_endpoint(ctx, field)
			case "secret":
				return ec.fieldContext_Webhook_secret(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Webhook", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskAnnotationSettings_jiraCustomFields(ctx context.Context, field graphql.CollectedField, obj *model.APITaskAnnotationSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskAnnotationSettings_jiraCustomFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JiraCustomFields, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIJiraField)
	fc.Result = res
	return ec.marshalOJiraField2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIJiraFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskAnnotationSettings_jiraCustomFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskAnnotationSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "displayText":
				return ec.fieldContext_JiraField_displayText(ctx, field)
			case "field":
				return ec.fieldContext_JiraField_field(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JiraField", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskContainerCreationOpts_image(ctx context.Context, field graphql.CollectedField, obj *model.APIPodTaskContainerCreationOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskContainerCreationOpts_image(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Image, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskContainerCreationOpts_image(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskContainerCreationOpts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskContainerCreationOpts_memoryMB(ctx context.Context, field graphql.CollectedField, obj *model.APIPodTaskContainerCreationOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskContainerCreationOpts_memoryMB(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MemoryMB, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalNInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskContainerCreationOpts_memoryMB(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskContainerCreationOpts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskContainerCreationOpts_cpu(ctx context.Context, field graphql.CollectedField, obj *model.APIPodTaskContainerCreationOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskContainerCreationOpts_cpu(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CPU, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalNInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskContainerCreationOpts_cpu(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskContainerCreationOpts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskContainerCreationOpts_os(ctx context.Context, field graphql.CollectedField, obj *model.APIPodTaskContainerCreationOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskContainerCreationOpts_os(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TaskContainerCreationOpts().Os(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskContainerCreationOpts_os(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskContainerCreationOpts",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskContainerCreationOpts_arch(ctx context.Context, field graphql.CollectedField, obj *model.APIPodTaskContainerCreationOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskContainerCreationOpts_arch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TaskContainerCreationOpts().Arch(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskContainerCreationOpts_arch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskContainerCreationOpts",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskContainerCreationOpts_workingDir(ctx context.Context, field graphql.CollectedField, obj *model.APIPodTaskContainerCreationOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskContainerCreationOpts_workingDir(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.WorkingDir, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskContainerCreationOpts_workingDir(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskContainerCreationOpts",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEndDetail_description(ctx context.Context, field graphql.CollectedField, obj *model.ApiTaskEndDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEndDetail_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEndDetail_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEndDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEndDetail_oomTracker(ctx context.Context, field graphql.CollectedField, obj *model.ApiTaskEndDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEndDetail_oomTracker(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OOMTracker, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIOomTrackerInfo)
	fc.Result = res
	return ec.marshalNOomTrackerInfo2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIOomTrackerInfo(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEndDetail_oomTracker(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEndDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "detected":
				return ec.fieldContext_OomTrackerInfo_detected(ctx, field)
			case "pids":
				return ec.fieldContext_OomTrackerInfo_pids(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type OomTrackerInfo", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEndDetail_status(ctx context.Context, field graphql.CollectedField, obj *model.ApiTaskEndDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEndDetail_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEndDetail_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEndDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEndDetail_timedOut(ctx context.Context, field graphql.CollectedField, obj *model.ApiTaskEndDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEndDetail_timedOut(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimedOut, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalOBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEndDetail_timedOut(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEndDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEndDetail_timeoutType(ctx context.Context, field graphql.CollectedField, obj *model.ApiTaskEndDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEndDetail_timeoutType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimeoutType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEndDetail_timeoutType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEndDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEndDetail_type(ctx context.Context, field graphql.CollectedField, obj *model.ApiTaskEndDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEndDetail_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEndDetail_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEndDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEndDetail_traceID(ctx context.Context, field graphql.CollectedField, obj *model.ApiTaskEndDetail) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEndDetail_traceID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TraceID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEndDetail_traceID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEndDetail",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogData_hostId(ctx context.Context, field graphql.CollectedField, obj *model.TaskEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogData_hostId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogData_hostId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogData_podId(ctx context.Context, field graphql.CollectedField, obj *model.TaskEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogData_podId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PodId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogData_podId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogData_jiraIssue(ctx context.Context, field graphql.CollectedField, obj *model.TaskEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogData_jiraIssue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JiraIssue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogData_jiraIssue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogData_jiraLink(ctx context.Context, field graphql.CollectedField, obj *model.TaskEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogData_jiraLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.JiraLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogData_jiraLink(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogData_priority(ctx context.Context, field graphql.CollectedField, obj *model.TaskEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogData_priority(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Priority, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalOInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogData_priority(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogData_status(ctx context.Context, field graphql.CollectedField, obj *model.TaskEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogData_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogData_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogData_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.TaskEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogData_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogData_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogData_userId(ctx context.Context, field graphql.CollectedField, obj *model.TaskEventData) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogData_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogData_userId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogData",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogEntry_id(ctx context.Context, field graphql.CollectedField, obj *model.TaskAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogEntry_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogEntry_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogEntry_data(ctx context.Context, field graphql.CollectedField, obj *model.TaskAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogEntry_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*model.TaskEventData)
	fc.Result = res
	return ec.marshalNTaskEventLogData2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐTaskEventData(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogEntry_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hostId":
				return ec.fieldContext_TaskEventLogData_hostId(ctx, field)
			case "podId":
				return ec.fieldContext_TaskEventLogData_podId(ctx, field)
			case "jiraIssue":
				return ec.fieldContext_TaskEventLogData_jiraIssue(ctx, field)
			case "jiraLink":
				return ec.fieldContext_TaskEventLogData_jiraLink(ctx, field)
			case "priority":
				return ec.fieldContext_TaskEventLogData_priority(ctx, field)
			case "status":
				return ec.fieldContext_TaskEventLogData_status(ctx, field)
			case "timestamp":
				return ec.fieldContext_TaskEventLogData_timestamp(ctx, field)
			case "userId":
				return ec.fieldContext_TaskEventLogData_userId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskEventLogData", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogEntry_eventType(ctx context.Context, field graphql.CollectedField, obj *model.TaskAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogEntry_eventType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogEntry_eventType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogEntry_processedAt(ctx context.Context, field graphql.CollectedField, obj *model.TaskAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogEntry_processedAt(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProcessedAt, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogEntry_processedAt(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogEntry_resourceId(ctx context.Context, field graphql.CollectedField, obj *model.TaskAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogEntry_resourceId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogEntry_resourceId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogEntry_resourceType(ctx context.Context, field graphql.CollectedField, obj *model.TaskAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogEntry_resourceType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogEntry_resourceType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskEventLogEntry_timestamp(ctx context.Context, field graphql.CollectedField, obj *model.TaskAPIEventLogEntry) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskEventLogEntry_timestamp(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timestamp, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskEventLogEntry_timestamp(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskEventLogEntry",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskFiles_fileCount(ctx context.Context, field graphql.CollectedField, obj *TaskFiles) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskFiles_fileCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FileCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskFiles_fileCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskFiles",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskFiles_groupedFiles(ctx context.Context, field graphql.CollectedField, obj *TaskFiles) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskFiles_groupedFiles(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GroupedFiles, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*GroupedFiles)
	fc.Result = res
	return ec.marshalNGroupedFiles2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐGroupedFilesᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskFiles_groupedFiles(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskFiles",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "files":
				return ec.fieldContext_GroupedFiles_files(ctx, field)
			case "taskName":
				return ec.fieldContext_GroupedFiles_taskName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupedFiles", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskInfo_id(ctx context.Context, field graphql.CollectedField, obj *model.TaskInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskInfo_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOID2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskInfo_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskInfo_name(ctx context.Context, field graphql.CollectedField, obj *model.TaskInfo) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskInfo_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskInfo_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskInfo",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogLinks_agentLogLink(ctx context.Context, field graphql.CollectedField, obj *model.LogLinks) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLogLinks_agentLogLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AgentLogLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLogLinks_agentLogLink(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogLinks",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogLinks_allLogLink(ctx context.Context, field graphql.CollectedField, obj *model.LogLinks) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLogLinks_allLogLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AllLogLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLogLinks_allLogLink(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogLinks",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogLinks_eventLogLink(ctx context.Context, field graphql.CollectedField, obj *model.LogLinks) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLogLinks_eventLogLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EventLogLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLogLinks_eventLogLink(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogLinks",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogLinks_systemLogLink(ctx context.Context, field graphql.CollectedField, obj *model.LogLinks) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLogLinks_systemLogLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SystemLogLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLogLinks_systemLogLink(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogLinks",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogLinks_taskLogLink(ctx context.Context, field graphql.CollectedField, obj *model.LogLinks) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLogLinks_taskLogLink(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskLogLink, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLogLinks_taskLogLink(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogLinks",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogs_agentLogs(ctx context.Context, field graphql.CollectedField, obj *TaskLogs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLogs_agentLogs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TaskLogs().AgentLogs(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*apimodels.LogMessage)
	fc.Result = res
	return ec.marshalNLogMessage2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋapimodelsᚐLogMessageᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLogs_agentLogs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogs",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "message":
				return ec.fieldContext_LogMessage_message(ctx, field)
			case "severity":
				return ec.fieldContext_LogMessage_severity(ctx, field)
			case "timestamp":
				return ec.fieldContext_LogMessage_timestamp(ctx, field)
			case "type":
				return ec.fieldContext_LogMessage_type(ctx, field)
			case "version":
				return ec.fieldContext_LogMessage_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LogMessage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogs_allLogs(ctx context.Context, field graphql.CollectedField, obj *TaskLogs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLogs_allLogs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TaskLogs().AllLogs(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*apimodels.LogMessage)
	fc.Result = res
	return ec.marshalNLogMessage2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋapimodelsᚐLogMessageᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLogs_allLogs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogs",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "message":
				return ec.fieldContext_LogMessage_message(ctx, field)
			case "severity":
				return ec.fieldContext_LogMessage_severity(ctx, field)
			case "timestamp":
				return ec.fieldContext_LogMessage_timestamp(ctx, field)
			case "type":
				return ec.fieldContext_LogMessage_type(ctx, field)
			case "version":
				return ec.fieldContext_LogMessage_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LogMessage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogs_defaultLogger(ctx context.Context, field graphql.CollectedField, obj *TaskLogs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLogs_defaultLogger(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultLogger, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLogs_defaultLogger(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogs",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogs_eventLogs(ctx context.Context, field graphql.CollectedField, obj *TaskLogs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLogs_eventLogs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TaskLogs().EventLogs(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.TaskAPIEventLogEntry)
	fc.Result = res
	return ec.marshalNTaskEventLogEntry2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐTaskAPIEventLogEntryᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLogs_eventLogs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogs",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TaskEventLogEntry_id(ctx, field)
			case "data":
				return ec.fieldContext_TaskEventLogEntry_data(ctx, field)
			case "eventType":
				return ec.fieldContext_TaskEventLogEntry_eventType(ctx, field)
			case "processedAt":
				return ec.fieldContext_TaskEventLogEntry_processedAt(ctx, field)
			case "resourceId":
				return ec.fieldContext_TaskEventLogEntry_resourceId(ctx, field)
			case "resourceType":
				return ec.fieldContext_TaskEventLogEntry_resourceType(ctx, field)
			case "timestamp":
				return ec.fieldContext_TaskEventLogEntry_timestamp(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskEventLogEntry", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogs_execution(ctx context.Context, field graphql.CollectedField, obj *TaskLogs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLogs_execution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Execution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLogs_execution(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogs",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogs_systemLogs(ctx context.Context, field graphql.CollectedField, obj *TaskLogs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLogs_systemLogs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TaskLogs().SystemLogs(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*apimodels.LogMessage)
	fc.Result = res
	return ec.marshalNLogMessage2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋapimodelsᚐLogMessageᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLogs_systemLogs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogs",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "message":
				return ec.fieldContext_LogMessage_message(ctx, field)
			case "severity":
				return ec.fieldContext_LogMessage_severity(ctx, field)
			case "timestamp":
				return ec.fieldContext_LogMessage_timestamp(ctx, field)
			case "type":
				return ec.fieldContext_LogMessage_type(ctx, field)
			case "version":
				return ec.fieldContext_LogMessage_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LogMessage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogs_taskId(ctx context.Context, field graphql.CollectedField, obj *TaskLogs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLogs_taskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLogs_taskId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogs",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskLogs_taskLogs(ctx context.Context, field graphql.CollectedField, obj *TaskLogs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskLogs_taskLogs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TaskLogs().TaskLogs(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*apimodels.LogMessage)
	fc.Result = res
	return ec.marshalNLogMessage2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋapimodelsᚐLogMessageᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskLogs_taskLogs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskLogs",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "message":
				return ec.fieldContext_LogMessage_message(ctx, field)
			case "severity":
				return ec.fieldContext_LogMessage_severity(ctx, field)
			case "timestamp":
				return ec.fieldContext_LogMessage_timestamp(ctx, field)
			case "type":
				return ec.fieldContext_LogMessage_type(ctx, field)
			case "version":
				return ec.fieldContext_LogMessage_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type LogMessage", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueDistro_id(ctx context.Context, field graphql.CollectedField, obj *TaskQueueDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskQueueDistro_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNID2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskQueueDistro_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueDistro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueDistro_hostCount(ctx context.Context, field graphql.CollectedField, obj *TaskQueueDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskQueueDistro_hostCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskQueueDistro_hostCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueDistro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueDistro_taskCount(ctx context.Context, field graphql.CollectedField, obj *TaskQueueDistro) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskQueueDistro_taskCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskQueueDistro_taskCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueDistro",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_id(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskQueueItem_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNID2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskQueueItem_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type ID does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_buildVariant(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskQueueItem_buildVariant(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildVariant, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskQueueItem_buildVariant(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_displayName(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskQueueItem_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskQueueItem_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_expectedDuration(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskQueueItem_expectedDuration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExpectedDuration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.APIDuration)
	fc.Result = res
	return ec.marshalNDuration2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskQueueItem_expectedDuration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_priority(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskQueueItem_priority(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Priority, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int64)
	fc.Result = res
	return ec.marshalNInt2int64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskQueueItem_priority(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_project(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskQueueItem_project(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Project, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskQueueItem_project(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_requester(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskQueueItem_requester(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TaskQueueItem().Requester(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(TaskQueueItemType)
	fc.Result = res
	return ec.marshalNTaskQueueItemType2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskQueueItemType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskQueueItem_requester(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type TaskQueueItemType does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_activatedBy(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskQueueItem_activatedBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ActivatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskQueueItem_activatedBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_revision(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskQueueItem_revision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskQueueItem_revision(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskQueueItem_version(ctx context.Context, field graphql.CollectedField, obj *model.APITaskQueueItem) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskQueueItem_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskQueueItem_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskQueueItem",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskSpecifier_patchAlias(ctx context.Context, field graphql.CollectedField, obj *model.APITaskSpecifier) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskSpecifier_patchAlias(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PatchAlias, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskSpecifier_patchAlias(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskSpecifier",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskSpecifier_taskRegex(ctx context.Context, field graphql.CollectedField, obj *model.APITaskSpecifier) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskSpecifier_taskRegex(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskRegex, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskSpecifier_taskRegex(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskSpecifier",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskSpecifier_variantRegex(ctx context.Context, field graphql.CollectedField, obj *model.APITaskSpecifier) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskSpecifier_variantRegex(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.VariantRegex, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskSpecifier_variantRegex(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskSpecifier",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskStats_counts(ctx context.Context, field graphql.CollectedField, obj *task.TaskStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskStats_counts(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Counts, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]task.StatusCount)
	fc.Result = res
	return ec.marshalOStatusCount2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋtaskᚐStatusCountᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskStats_counts(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_StatusCount_count(ctx, field)
			case "status":
				return ec.fieldContext_StatusCount_status(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type StatusCount", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskStats_eta(ctx context.Context, field graphql.CollectedField, obj *task.TaskStats) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskStats_eta(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ETA, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskStats_eta(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskStats",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskSyncOptions_configEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APITaskSyncOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskSyncOptions_configEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConfigEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskSyncOptions_configEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskSyncOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskSyncOptions_patchEnabled(ctx context.Context, field graphql.CollectedField, obj *model.APITaskSyncOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskSyncOptions_patchEnabled(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PatchEnabled, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskSyncOptions_patchEnabled(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskSyncOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskTestResult_testResults(ctx context.Context, field graphql.CollectedField, obj *TaskTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskTestResult_testResults(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TestResults, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APITest)
	fc.Result = res
	return ec.marshalNTestResult2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITestᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskTestResult_testResults(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_TestResult_id(ctx, field)
			case "baseStatus":
				return ec.fieldContext_TestResult_baseStatus(ctx, field)
			case "duration":
				return ec.fieldContext_TestResult_duration(ctx, field)
			case "endTime":
				return ec.fieldContext_TestResult_endTime(ctx, field)
			case "execution":
				return ec.fieldContext_TestResult_execution(ctx, field)
			case "exitCode":
				return ec.fieldContext_TestResult_exitCode(ctx, field)
			case "groupID":
				return ec.fieldContext_TestResult_groupID(ctx, field)
			case "logs":
				return ec.fieldContext_TestResult_logs(ctx, field)
			case "startTime":
				return ec.fieldContext_TestResult_startTime(ctx, field)
			case "status":
				return ec.fieldContext_TestResult_status(ctx, field)
			case "taskId":
				return ec.fieldContext_TestResult_taskId(ctx, field)
			case "testFile":
				return ec.fieldContext_TestResult_testFile(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TestResult", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskTestResult_totalTestCount(ctx context.Context, field graphql.CollectedField, obj *TaskTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskTestResult_totalTestCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalTestCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskTestResult_totalTestCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskTestResult_filteredTestCount(ctx context.Context, field graphql.CollectedField, obj *TaskTestResult) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskTestResult_filteredTestCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FilteredTestCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskTestResult_filteredTestCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskTestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskTestResultSample_execution(ctx context.Context, field graphql.CollectedField, obj *TaskTestResultSample) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskTestResultSample_execution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Execution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskTestResultSample_execution(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskTestResultSample",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskTestResultSample_matchingFailedTestNames(ctx context.Context, field graphql.CollectedField, obj *TaskTestResultSample) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskTestResultSample_matchingFailedTestNames(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MatchingFailedTestNames, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskTestResultSample_matchingFailedTestNames(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskTestResultSample",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskTestResultSample_taskId(ctx context.Context, field graphql.CollectedField, obj *TaskTestResultSample) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskTestResultSample_taskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskTestResultSample_taskId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskTestResultSample",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TaskTestResultSample_totalTestCount(ctx context.Context, field graphql.CollectedField, obj *TaskTestResultSample) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TaskTestResultSample_totalTestCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TotalTestCount, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TaskTestResultSample_totalTestCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TaskTestResultSample",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestLog_lineNum(ctx context.Context, field graphql.CollectedField, obj *model.TestLogs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestLog_lineNum(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.LineNum, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestLog_lineNum(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestLog_url(ctx context.Context, field graphql.CollectedField, obj *model.TestLogs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestLog_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestLog_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestLog_urlLobster(ctx context.Context, field graphql.CollectedField, obj *model.TestLogs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestLog_urlLobster(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URLLobster, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestLog_urlLobster(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestLog_urlParsley(ctx context.Context, field graphql.CollectedField, obj *model.TestLogs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestLog_urlParsley(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URLParsley, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestLog_urlParsley(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestLog_urlRaw(ctx context.Context, field graphql.CollectedField, obj *model.TestLogs) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestLog_urlRaw(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URLRaw, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestLog_urlRaw(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestLog",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_id(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestResult_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestResult_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_baseStatus(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestResult_baseStatus(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BaseStatus, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestResult_baseStatus(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_duration(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestResult_duration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Duration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(float64)
	fc.Result = res
	return ec.marshalOFloat2float64(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestResult_duration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Float does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_endTime(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestResult_endTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EndTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestResult_endTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_execution(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestResult_execution(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Execution, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestResult_execution(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_exitCode(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestResult_exitCode(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ExitCode, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalOInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestResult_exitCode(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_groupID(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestResult_groupID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GroupID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestResult_groupID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_logs(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestResult_logs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Logs, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(model.TestLogs)
	fc.Result = res
	return ec.marshalNTestLog2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐTestLogs(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestResult_logs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lineNum":
				return ec.fieldContext_TestLog_lineNum(ctx, field)
			case "url":
				return ec.fieldContext_TestLog_url(ctx, field)
			case "urlLobster":
				return ec.fieldContext_TestLog_urlLobster(ctx, field)
			case "urlParsley":
				return ec.fieldContext_TestLog_urlParsley(ctx, field)
			case "urlRaw":
				return ec.fieldContext_TestLog_urlRaw(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TestLog", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_startTime(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestResult_startTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestResult_startTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_status(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestResult_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestResult_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_taskId(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestResult_taskId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestResult_taskId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TestResult_testFile(ctx context.Context, field graphql.CollectedField, obj *model.APITest) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TestResult_testFile(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TestFile, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TestResult_testFile(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TestResult",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TicketFields_assignedTeam(ctx context.Context, field graphql.CollectedField, obj *thirdparty.TicketFields) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TicketFields_assignedTeam(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TicketFields().AssignedTeam(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TicketFields_assignedTeam(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TicketFields",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TicketFields_assigneeDisplayName(ctx context.Context, field graphql.CollectedField, obj *thirdparty.TicketFields) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TicketFields_assigneeDisplayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TicketFields().AssigneeDisplayName(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TicketFields_assigneeDisplayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TicketFields",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TicketFields_created(ctx context.Context, field graphql.CollectedField, obj *thirdparty.TicketFields) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TicketFields_created(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Created, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TicketFields_created(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TicketFields",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TicketFields_resolutionName(ctx context.Context, field graphql.CollectedField, obj *thirdparty.TicketFields) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TicketFields_resolutionName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.TicketFields().ResolutionName(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TicketFields_resolutionName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TicketFields",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TicketFields_status(ctx context.Context, field graphql.CollectedField, obj *thirdparty.TicketFields) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TicketFields_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*thirdparty.JiraStatus)
	fc.Result = res
	return ec.marshalNJiraStatus2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐJiraStatus(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TicketFields_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TicketFields",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_JiraStatus_id(ctx, field)
			case "name":
				return ec.fieldContext_JiraStatus_name(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type JiraStatus", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _TicketFields_summary(ctx context.Context, field graphql.CollectedField, obj *thirdparty.TicketFields) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TicketFields_summary(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Summary, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TicketFields_summary(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TicketFields",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TicketFields_updated(ctx context.Context, field graphql.CollectedField, obj *thirdparty.TicketFields) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TicketFields_updated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Updated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TicketFields_updated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TicketFields",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TriggerAlias_alias(ctx context.Context, field graphql.CollectedField, obj *model.APITriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TriggerAlias_alias(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Alias, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TriggerAlias_alias(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TriggerAlias_buildVariantRegex(ctx context.Context, field graphql.CollectedField, obj *model.APITriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TriggerAlias_buildVariantRegex(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.BuildVariantRegex, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TriggerAlias_buildVariantRegex(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TriggerAlias_configFile(ctx context.Context, field graphql.CollectedField, obj *model.APITriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TriggerAlias_configFile(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ConfigFile, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TriggerAlias_configFile(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TriggerAlias_dateCutoff(ctx context.Context, field graphql.CollectedField, obj *model.APITriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TriggerAlias_dateCutoff(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DateCutoff, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TriggerAlias_dateCutoff(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TriggerAlias_level(ctx context.Context, field graphql.CollectedField, obj *model.APITriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TriggerAlias_level(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Level, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TriggerAlias_level(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TriggerAlias_project(ctx context.Context, field graphql.CollectedField, obj *model.APITriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TriggerAlias_project(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Project, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TriggerAlias_project(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TriggerAlias_status(ctx context.Context, field graphql.CollectedField, obj *model.APITriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TriggerAlias_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Status, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TriggerAlias_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _TriggerAlias_taskRegex(ctx context.Context, field graphql.CollectedField, obj *model.APITriggerDefinition) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_TriggerAlias_taskRegex(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TaskRegex, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_TriggerAlias_taskRegex(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "TriggerAlias",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UIConfig_defaultProject(ctx context.Context, field graphql.CollectedField, obj *model.APIUIConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UIConfig_defaultProject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultProject, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UIConfig_defaultProject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UIConfig_userVoice(ctx context.Context, field graphql.CollectedField, obj *model.APIUIConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UIConfig_userVoice(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserVoice, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UIConfig_userVoice(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UIConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpstreamProject_owner(ctx context.Context, field graphql.CollectedField, obj *UpstreamProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpstreamProject_owner(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Owner, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpstreamProject_owner(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpstreamProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpstreamProject_project(ctx context.Context, field graphql.CollectedField, obj *UpstreamProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpstreamProject_project(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Project, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpstreamProject_project(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpstreamProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpstreamProject_repo(ctx context.Context, field graphql.CollectedField, obj *UpstreamProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpstreamProject_repo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpstreamProject_repo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpstreamProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpstreamProject_resourceID(ctx context.Context, field graphql.CollectedField, obj *UpstreamProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpstreamProject_resourceID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ResourceID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpstreamProject_resourceID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpstreamProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpstreamProject_revision(ctx context.Context, field graphql.CollectedField, obj *UpstreamProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpstreamProject_revision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpstreamProject_revision(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpstreamProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpstreamProject_task(ctx context.Context, field graphql.CollectedField, obj *UpstreamProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpstreamProject_task(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Task, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APITask)
	fc.Result = res
	return ec.marshalOTask2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITask(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpstreamProject_task(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpstreamProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canSync":
				return ec.fieldContext_Task_canSync(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "taskFiles":
				return ec.fieldContext_Task_taskFiles(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpstreamProject_triggerID(ctx context.Context, field graphql.CollectedField, obj *UpstreamProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpstreamProject_triggerID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TriggerID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpstreamProject_triggerID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpstreamProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpstreamProject_triggerType(ctx context.Context, field graphql.CollectedField, obj *UpstreamProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpstreamProject_triggerType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TriggerType, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpstreamProject_triggerType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpstreamProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UpstreamProject_version(ctx context.Context, field graphql.CollectedField, obj *UpstreamProject) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UpstreamProject_version(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Version, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIVersion)
	fc.Result = res
	return ec.marshalOVersion2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UpstreamProject_version(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UpstreamProject",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UseSpruceOptions_hasUsedMainlineCommitsBefore(ctx context.Context, field graphql.CollectedField, obj *model.APIUseSpruceOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UseSpruceOptions_hasUsedMainlineCommitsBefore(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasUsedMainlineCommitsBefore, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UseSpruceOptions_hasUsedMainlineCommitsBefore(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UseSpruceOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UseSpruceOptions_hasUsedSpruceBefore(ctx context.Context, field graphql.CollectedField, obj *model.APIUseSpruceOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UseSpruceOptions_hasUsedSpruceBefore(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HasUsedSpruceBefore, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UseSpruceOptions_hasUsedSpruceBefore(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UseSpruceOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UseSpruceOptions_spruceV1(ctx context.Context, field graphql.CollectedField, obj *model.APIUseSpruceOptions) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UseSpruceOptions_spruceV1(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpruceV1, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UseSpruceOptions_spruceV1(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UseSpruceOptions",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_displayName(ctx context.Context, field graphql.CollectedField, obj *model.APIDBUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_emailAddress(ctx context.Context, field graphql.CollectedField, obj *model.APIDBUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_emailAddress(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EmailAddress, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_emailAddress(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_patches(ctx context.Context, field graphql.CollectedField, obj *model.APIDBUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_patches(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().Patches(rctx, obj, fc.Args["patchesInput"].(PatchesInput))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Patches)
	fc.Result = res
	return ec.marshalNPatches2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPatches(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_patches(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "filteredPatchCount":
				return ec.fieldContext_Patches_filteredPatchCount(ctx, field)
			case "patches":
				return ec.fieldContext_Patches_patches(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Patches", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_User_patches_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _User_permissions(ctx context.Context, field graphql.CollectedField, obj *model.APIDBUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_permissions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().Permissions(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*Permissions)
	fc.Result = res
	return ec.marshalNPermissions2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPermissions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_permissions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "canCreateDistro":
				return ec.fieldContext_Permissions_canCreateDistro(ctx, field)
			case "canCreateProject":
				return ec.fieldContext_Permissions_canCreateProject(ctx, field)
			case "distroPermissions":
				return ec.fieldContext_Permissions_distroPermissions(ctx, field)
			case "userId":
				return ec.fieldContext_Permissions_userId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Permissions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_subscriptions(ctx context.Context, field graphql.CollectedField, obj *model.APIDBUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_subscriptions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.User().Subscriptions(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.APISubscription)
	fc.Result = res
	return ec.marshalOGeneralSubscription2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISubscriptionᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_subscriptions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_GeneralSubscription_id(ctx, field)
			case "ownerType":
				return ec.fieldContext_GeneralSubscription_ownerType(ctx, field)
			case "regexSelectors":
				return ec.fieldContext_GeneralSubscription_regexSelectors(ctx, field)
			case "resourceType":
				return ec.fieldContext_GeneralSubscription_resourceType(ctx, field)
			case "selectors":
				return ec.fieldContext_GeneralSubscription_selectors(ctx, field)
			case "subscriber":
				return ec.fieldContext_GeneralSubscription_subscriber(ctx, field)
			case "trigger":
				return ec.fieldContext_GeneralSubscription_trigger(ctx, field)
			case "triggerData":
				return ec.fieldContext_GeneralSubscription_triggerData(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GeneralSubscription", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _User_userId(ctx context.Context, field graphql.CollectedField, obj *model.APIDBUser) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_User_userId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UserID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_User_userId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "User",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserConfig_api_key(ctx context.Context, field graphql.CollectedField, obj *UserConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserConfig_api_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIKey, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserConfig_api_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserConfig_api_server_host(ctx context.Context, field graphql.CollectedField, obj *UserConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserConfig_api_server_host(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.APIServerHost, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserConfig_api_server_host(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserConfig_ui_server_host(ctx context.Context, field graphql.CollectedField, obj *UserConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserConfig_ui_server_host(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UIServerHost, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserConfig_ui_server_host(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserConfig_user(ctx context.Context, field graphql.CollectedField, obj *UserConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserConfig_user(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.User, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserConfig_user(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettings_githubUser(ctx context.Context, field graphql.CollectedField, obj *model.APIUserSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSettings_githubUser(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GithubUser, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIGithubUser)
	fc.Result = res
	return ec.marshalOGithubUser2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGithubUser(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSettings_githubUser(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "lastKnownAs":
				return ec.fieldContext_GithubUser_lastKnownAs(ctx, field)
			case "uid":
				return ec.fieldContext_GithubUser_uid(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GithubUser", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettings_notifications(ctx context.Context, field graphql.CollectedField, obj *model.APIUserSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSettings_notifications(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Notifications, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APINotificationPreferences)
	fc.Result = res
	return ec.marshalONotifications2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPINotificationPreferences(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSettings_notifications(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "buildBreak":
				return ec.fieldContext_Notifications_buildBreak(ctx, field)
			case "buildBreakId":
				return ec.fieldContext_Notifications_buildBreakId(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Notifications_commitQueue(ctx, field)
			case "commitQueueId":
				return ec.fieldContext_Notifications_commitQueueId(ctx, field)
			case "patchFinish":
				return ec.fieldContext_Notifications_patchFinish(ctx, field)
			case "patchFinishId":
				return ec.fieldContext_Notifications_patchFinishId(ctx, field)
			case "patchFirstFailure":
				return ec.fieldContext_Notifications_patchFirstFailure(ctx, field)
			case "patchFirstFailureId":
				return ec.fieldContext_Notifications_patchFirstFailureId(ctx, field)
			case "spawnHostExpiration":
				return ec.fieldContext_Notifications_spawnHostExpiration(ctx, field)
			case "spawnHostExpirationId":
				return ec.fieldContext_Notifications_spawnHostExpirationId(ctx, field)
			case "spawnHostOutcome":
				return ec.fieldContext_Notifications_spawnHostOutcome(ctx, field)
			case "spawnHostOutcomeId":
				return ec.fieldContext_Notifications_spawnHostOutcomeId(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Notifications", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettings_region(ctx context.Context, field graphql.CollectedField, obj *model.APIUserSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSettings_region(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Region, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSettings_region(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettings_slackUsername(ctx context.Context, field graphql.CollectedField, obj *model.APIUserSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSettings_slackUsername(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SlackUsername, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSettings_slackUsername(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettings_slackMemberId(ctx context.Context, field graphql.CollectedField, obj *model.APIUserSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSettings_slackMemberId(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SlackMemberId, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSettings_slackMemberId(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettings_timezone(ctx context.Context, field graphql.CollectedField, obj *model.APIUserSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSettings_timezone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Timezone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSettings_timezone(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettings_useSpruceOptions(ctx context.Context, field graphql.CollectedField, obj *model.APIUserSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSettings_useSpruceOptions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.UseSpruceOptions, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIUseSpruceOptions)
	fc.Result = res
	return ec.marshalOUseSpruceOptions2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIUseSpruceOptions(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSettings_useSpruceOptions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "hasUsedMainlineCommitsBefore":
				return ec.fieldContext_UseSpruceOptions_hasUsedMainlineCommitsBefore(ctx, field)
			case "hasUsedSpruceBefore":
				return ec.fieldContext_UseSpruceOptions_hasUsedSpruceBefore(ctx, field)
			case "spruceV1":
				return ec.fieldContext_UseSpruceOptions_spruceV1(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UseSpruceOptions", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _UserSettings_dateFormat(ctx context.Context, field graphql.CollectedField, obj *model.APIUserSettings) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_UserSettings_dateFormat(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DateFormat, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_UserSettings_dateFormat(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "UserSettings",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VariantTask_name(ctx context.Context, field graphql.CollectedField, obj *model.VariantTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VariantTask_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VariantTask_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VariantTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VariantTask_tasks(ctx context.Context, field graphql.CollectedField, obj *model.VariantTask) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VariantTask_tasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Tasks, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalNString2ᚕᚖstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VariantTask_tasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VariantTask",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_id(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Id, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_activated(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_activated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Activated, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_activated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_author(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_author(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Author, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_author(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_baseTaskStatuses(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_baseTaskStatuses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().BaseTaskStatuses(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_baseTaskStatuses(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_baseVersion(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_baseVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().BaseVersion(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIVersion)
	fc.Result = res
	return ec.marshalOVersion2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_baseVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_branch(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_branch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Branch, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_branch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_buildVariants(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_buildVariants(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().BuildVariants(rctx, obj, fc.Args["options"].(BuildVariantOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*GroupedBuildVariant)
	fc.Result = res
	return ec.marshalOGroupedBuildVariant2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐGroupedBuildVariant(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_buildVariants(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "displayName":
				return ec.fieldContext_GroupedBuildVariant_displayName(ctx, field)
			case "tasks":
				return ec.fieldContext_GroupedBuildVariant_tasks(ctx, field)
			case "variant":
				return ec.fieldContext_GroupedBuildVariant_variant(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupedBuildVariant", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Version_buildVariants_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Version_buildVariantStats(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_buildVariantStats(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().BuildVariantStats(rctx, obj, fc.Args["options"].(BuildVariantOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*task.GroupedTaskStatusCount)
	fc.Result = res
	return ec.marshalOGroupedTaskStatusCount2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋtaskᚐGroupedTaskStatusCountᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_buildVariantStats(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "displayName":
				return ec.fieldContext_GroupedTaskStatusCount_displayName(ctx, field)
			case "statusCounts":
				return ec.fieldContext_GroupedTaskStatusCount_statusCounts(ctx, field)
			case "variant":
				return ec.fieldContext_GroupedTaskStatusCount_variant(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GroupedTaskStatusCount", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Version_buildVariantStats_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Version_childVersions(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_childVersions(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().ChildVersions(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*model.APIVersion)
	fc.Result = res
	return ec.marshalOVersion2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_childVersions(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_createTime(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_createTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreateTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalNTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_createTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_errors(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_errors(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Errors, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*string)
	fc.Result = res
	return ec.marshalNString2ᚕᚖstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_errors(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_externalLinksForMetadata(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().ExternalLinksForMetadata(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*ExternalLinkForMetadata)
	fc.Result = res
	return ec.marshalNExternalLinkForMetadata2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐExternalLinkForMetadataᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_externalLinksForMetadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "url":
				return ec.fieldContext_ExternalLinkForMetadata_url(ctx, field)
			case "displayName":
				return ec.fieldContext_ExternalLinkForMetadata_displayName(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type ExternalLinkForMetadata", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_finishTime(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_finishTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.FinishTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_finishTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_gitTags(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_gitTags(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GitTags, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIGitTag)
	fc.Result = res
	return ec.marshalOGitTag2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGitTagᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_gitTags(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "tag":
				return ec.fieldContext_GitTag_tag(ctx, field)
			case "pusher":
				return ec.fieldContext_GitTag_pusher(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type GitTag", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_isPatch(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_isPatch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().IsPatch(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_isPatch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_manifest(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_manifest(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().Manifest(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*Manifest)
	fc.Result = res
	return ec.marshalOManifest2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐManifest(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_manifest(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Manifest_id(ctx, field)
			case "branch":
				return ec.fieldContext_Manifest_branch(ctx, field)
			case "isBase":
				return ec.fieldContext_Manifest_isBase(ctx, field)
			case "moduleOverrides":
				return ec.fieldContext_Manifest_moduleOverrides(ctx, field)
			case "modules":
				return ec.fieldContext_Manifest_modules(ctx, field)
			case "project":
				return ec.fieldContext_Manifest_project(ctx, field)
			case "revision":
				return ec.fieldContext_Manifest_revision(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Manifest", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_message(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_message(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Message, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_message(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_order(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_order(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Order, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_order(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_parameters(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_parameters(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Parameters, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APIParameter)
	fc.Result = res
	return ec.marshalNParameter2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParameterᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_parameters(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_Parameter_key(ctx, field)
			case "value":
				return ec.fieldContext_Parameter_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Parameter", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_patch(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_patch(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().Patch(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIPatch)
	fc.Result = res
	return ec.marshalOPatch2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatch(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_patch(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Patch_id(ctx, field)
			case "activated":
				return ec.fieldContext_Patch_activated(ctx, field)
			case "alias":
				return ec.fieldContext_Patch_alias(ctx, field)
			case "author":
				return ec.fieldContext_Patch_author(ctx, field)
			case "authorDisplayName":
				return ec.fieldContext_Patch_authorDisplayName(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Patch_baseTaskStatuses(ctx, field)
			case "builds":
				return ec.fieldContext_Patch_builds(ctx, field)
			case "canEnqueueToCommitQueue":
				return ec.fieldContext_Patch_canEnqueueToCommitQueue(ctx, field)
			case "childPatchAliases":
				return ec.fieldContext_Patch_childPatchAliases(ctx, field)
			case "childPatches":
				return ec.fieldContext_Patch_childPatches(ctx, field)
			case "commitQueuePosition":
				return ec.fieldContext_Patch_commitQueuePosition(ctx, field)
			case "createTime":
				return ec.fieldContext_Patch_createTime(ctx, field)
			case "description":
				return ec.fieldContext_Patch_description(ctx, field)
			case "duration":
				return ec.fieldContext_Patch_duration(ctx, field)
			case "githash":
				return ec.fieldContext_Patch_githash(ctx, field)
			case "hidden":
				return ec.fieldContext_Patch_hidden(ctx, field)
			case "moduleCodeChanges":
				return ec.fieldContext_Patch_moduleCodeChanges(ctx, field)
			case "parameters":
				return ec.fieldContext_Patch_parameters(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Patch_patchNumber(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Patch_patchTriggerAliases(ctx, field)
			case "project":
				return ec.fieldContext_Patch_project(ctx, field)
			case "projectID":
				return ec.fieldContext_Patch_projectID(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Patch_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Patch_projectMetadata(ctx, field)
			case "status":
				return ec.fieldContext_Patch_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Patch_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Patch_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Patch_taskStatuses(ctx, field)
			case "time":
				return ec.fieldContext_Patch_time(ctx, field)
			case "variants":
				return ec.fieldContext_Patch_variants(ctx, field)
			case "variantsTasks":
				return ec.fieldContext_Patch_variantsTasks(ctx, field)
			case "versionFull":
				return ec.fieldContext_Patch_versionFull(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Patch", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_previousVersion(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_previousVersion(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().PreviousVersion(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIVersion)
	fc.Result = res
	return ec.marshalOVersion2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVersion(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_previousVersion(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Version_id(ctx, field)
			case "activated":
				return ec.fieldContext_Version_activated(ctx, field)
			case "author":
				return ec.fieldContext_Version_author(ctx, field)
			case "baseTaskStatuses":
				return ec.fieldContext_Version_baseTaskStatuses(ctx, field)
			case "baseVersion":
				return ec.fieldContext_Version_baseVersion(ctx, field)
			case "branch":
				return ec.fieldContext_Version_branch(ctx, field)
			case "buildVariants":
				return ec.fieldContext_Version_buildVariants(ctx, field)
			case "buildVariantStats":
				return ec.fieldContext_Version_buildVariantStats(ctx, field)
			case "childVersions":
				return ec.fieldContext_Version_childVersions(ctx, field)
			case "createTime":
				return ec.fieldContext_Version_createTime(ctx, field)
			case "errors":
				return ec.fieldContext_Version_errors(ctx, field)
			case "externalLinksForMetadata":
				return ec.fieldContext_Version_externalLinksForMetadata(ctx, field)
			case "finishTime":
				return ec.fieldContext_Version_finishTime(ctx, field)
			case "gitTags":
				return ec.fieldContext_Version_gitTags(ctx, field)
			case "isPatch":
				return ec.fieldContext_Version_isPatch(ctx, field)
			case "manifest":
				return ec.fieldContext_Version_manifest(ctx, field)
			case "message":
				return ec.fieldContext_Version_message(ctx, field)
			case "order":
				return ec.fieldContext_Version_order(ctx, field)
			case "parameters":
				return ec.fieldContext_Version_parameters(ctx, field)
			case "patch":
				return ec.fieldContext_Version_patch(ctx, field)
			case "previousVersion":
				return ec.fieldContext_Version_previousVersion(ctx, field)
			case "project":
				return ec.fieldContext_Version_project(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Version_projectIdentifier(ctx, field)
			case "projectMetadata":
				return ec.fieldContext_Version_projectMetadata(ctx, field)
			case "repo":
				return ec.fieldContext_Version_repo(ctx, field)
			case "requester":
				return ec.fieldContext_Version_requester(ctx, field)
			case "revision":
				return ec.fieldContext_Version_revision(ctx, field)
			case "startTime":
				return ec.fieldContext_Version_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Version_status(ctx, field)
			case "taskCount":
				return ec.fieldContext_Version_taskCount(ctx, field)
			case "tasks":
				return ec.fieldContext_Version_tasks(ctx, field)
			case "taskStatuses":
				return ec.fieldContext_Version_taskStatuses(ctx, field)
			case "taskStatusStats":
				return ec.fieldContext_Version_taskStatusStats(ctx, field)
			case "upstreamProject":
				return ec.fieldContext_Version_upstreamProject(ctx, field)
			case "versionTiming":
				return ec.fieldContext_Version_versionTiming(ctx, field)
			case "warnings":
				return ec.fieldContext_Version_warnings(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Version", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_project(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_project(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Project, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_project(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_projectIdentifier(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_projectIdentifier(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ProjectIdentifier, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_projectIdentifier(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_projectMetadata(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_projectMetadata(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().ProjectMetadata(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIProjectRef)
	fc.Result = res
	return ec.marshalOProject2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_projectMetadata(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Project_id(ctx, field)
			case "admins":
				return ec.fieldContext_Project_admins(ctx, field)
			case "banner":
				return ec.fieldContext_Project_banner(ctx, field)
			case "batchTime":
				return ec.fieldContext_Project_batchTime(ctx, field)
			case "branch":
				return ec.fieldContext_Project_branch(ctx, field)
			case "buildBaronSettings":
				return ec.fieldContext_Project_buildBaronSettings(ctx, field)
			case "commitQueue":
				return ec.fieldContext_Project_commitQueue(ctx, field)
			case "containerSizeDefinitions":
				return ec.fieldContext_Project_containerSizeDefinitions(ctx, field)
			case "deactivatePrevious":
				return ec.fieldContext_Project_deactivatePrevious(ctx, field)
			case "disabledStatsCache":
				return ec.fieldContext_Project_disabledStatsCache(ctx, field)
			case "dispatchingDisabled":
				return ec.fieldContext_Project_dispatchingDisabled(ctx, field)
			case "displayName":
				return ec.fieldContext_Project_displayName(ctx, field)
			case "enabled":
				return ec.fieldContext_Project_enabled(ctx, field)
			case "externalLinks":
				return ec.fieldContext_Project_externalLinks(ctx, field)
			case "githubChecksEnabled":
				return ec.fieldContext_Project_githubChecksEnabled(ctx, field)
			case "githubTriggerAliases":
				return ec.fieldContext_Project_githubTriggerAliases(ctx, field)
			case "gitTagAuthorizedTeams":
				return ec.fieldContext_Project_gitTagAuthorizedTeams(ctx, field)
			case "gitTagAuthorizedUsers":
				return ec.fieldContext_Project_gitTagAuthorizedUsers(ctx, field)
			case "gitTagVersionsEnabled":
				return ec.fieldContext_Project_gitTagVersionsEnabled(ctx, field)
			case "hidden":
				return ec.fieldContext_Project_hidden(ctx, field)
			case "identifier":
				return ec.fieldContext_Project_identifier(ctx, field)
			case "isFavorite":
				return ec.fieldContext_Project_isFavorite(ctx, field)
			case "manualPrTestingEnabled":
				return ec.fieldContext_Project_manualPrTestingEnabled(ctx, field)
			case "notifyOnBuildFailure":
				return ec.fieldContext_Project_notifyOnBuildFailure(ctx, field)
			case "owner":
				return ec.fieldContext_Project_owner(ctx, field)
			case "parsleyFilters":
				return ec.fieldContext_Project_parsleyFilters(ctx, field)
			case "patches":
				return ec.fieldContext_Project_patches(ctx, field)
			case "patchingDisabled":
				return ec.fieldContext_Project_patchingDisabled(ctx, field)
			case "patchTriggerAliases":
				return ec.fieldContext_Project_patchTriggerAliases(ctx, field)
			case "perfEnabled":
				return ec.fieldContext_Project_perfEnabled(ctx, field)
			case "periodicBuilds":
				return ec.fieldContext_Project_periodicBuilds(ctx, field)
			case "private":
				return ec.fieldContext_Project_private(ctx, field)
			case "projectHealthView":
				return ec.fieldContext_Project_projectHealthView(ctx, field)
			case "prTestingEnabled":
				return ec.fieldContext_Project_prTestingEnabled(ctx, field)
			case "remotePath":
				return ec.fieldContext_Project_remotePath(ctx, field)
			case "repo":
				return ec.fieldContext_Project_repo(ctx, field)
			case "repoRefId":
				return ec.fieldContext_Project_repoRefId(ctx, field)
			case "repotrackerDisabled":
				return ec.fieldContext_Project_repotrackerDisabled(ctx, field)
			case "restricted":
				return ec.fieldContext_Project_restricted(ctx, field)
			case "spawnHostScriptPath":
				return ec.fieldContext_Project_spawnHostScriptPath(ctx, field)
			case "stepbackDisabled":
				return ec.fieldContext_Project_stepbackDisabled(ctx, field)
			case "taskAnnotationSettings":
				return ec.fieldContext_Project_taskAnnotationSettings(ctx, field)
			case "taskSync":
				return ec.fieldContext_Project_taskSync(ctx, field)
			case "tracksPushEvents":
				return ec.fieldContext_Project_tracksPushEvents(ctx, field)
			case "triggers":
				return ec.fieldContext_Project_triggers(ctx, field)
			case "versionControlEnabled":
				return ec.fieldContext_Project_versionControlEnabled(ctx, field)
			case "workstationConfig":
				return ec.fieldContext_Project_workstationConfig(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Project", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_repo(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_repo(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Repo, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_repo(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_requester(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_requester(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Requester, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_requester(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_revision(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_revision(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Revision, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_revision(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_startTime(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_startTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.StartTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_startTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_status(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_status(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().Status(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_status(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_taskCount(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_taskCount(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().TaskCount(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*int)
	fc.Result = res
	return ec.marshalOInt2ᚖint(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_taskCount(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_tasks(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_tasks(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().Tasks(rctx, obj, fc.Args["options"].(TaskFilterOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*VersionTasks)
	fc.Result = res
	return ec.marshalNVersionTasks2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐVersionTasks(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_tasks(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "count":
				return ec.fieldContext_VersionTasks_count(ctx, field)
			case "data":
				return ec.fieldContext_VersionTasks_data(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VersionTasks", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Version_tasks_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Version_taskStatuses(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_taskStatuses(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().TaskStatuses(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_taskStatuses(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_taskStatusStats(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_taskStatusStats(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().TaskStatusStats(rctx, obj, fc.Args["options"].(BuildVariantOptions))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*task.TaskStats)
	fc.Result = res
	return ec.marshalOTaskStats2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋtaskᚐTaskStats(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_taskStatusStats(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "counts":
				return ec.fieldContext_TaskStats_counts(ctx, field)
			case "eta":
				return ec.fieldContext_TaskStats_eta(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type TaskStats", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field_Version_taskStatusStats_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) _Version_upstreamProject(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_upstreamProject(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().UpstreamProject(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*UpstreamProject)
	fc.Result = res
	return ec.marshalOUpstreamProject2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐUpstreamProject(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_upstreamProject(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "owner":
				return ec.fieldContext_UpstreamProject_owner(ctx, field)
			case "project":
				return ec.fieldContext_UpstreamProject_project(ctx, field)
			case "repo":
				return ec.fieldContext_UpstreamProject_repo(ctx, field)
			case "resourceID":
				return ec.fieldContext_UpstreamProject_resourceID(ctx, field)
			case "revision":
				return ec.fieldContext_UpstreamProject_revision(ctx, field)
			case "task":
				return ec.fieldContext_UpstreamProject_task(ctx, field)
			case "triggerID":
				return ec.fieldContext_UpstreamProject_triggerID(ctx, field)
			case "triggerType":
				return ec.fieldContext_UpstreamProject_triggerType(ctx, field)
			case "version":
				return ec.fieldContext_UpstreamProject_version(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type UpstreamProject", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_versionTiming(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_versionTiming(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().VersionTiming(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*VersionTiming)
	fc.Result = res
	return ec.marshalOVersionTiming2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐVersionTiming(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_versionTiming(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "makespan":
				return ec.fieldContext_VersionTiming_makespan(ctx, field)
			case "timeTaken":
				return ec.fieldContext_VersionTiming_timeTaken(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type VersionTiming", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Version_warnings(ctx context.Context, field graphql.CollectedField, obj *model.APIVersion) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Version_warnings(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Version().Warnings(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalNString2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Version_warnings(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Version",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionTasks_count(ctx context.Context, field graphql.CollectedField, obj *VersionTasks) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionTasks_count(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Count, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionTasks_count(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionTasks",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionTasks_data(ctx context.Context, field graphql.CollectedField, obj *VersionTasks) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionTasks_data(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Data, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]*model.APITask)
	fc.Result = res
	return ec.marshalNTask2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionTasks_data(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionTasks",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Task_id(ctx, field)
			case "aborted":
				return ec.fieldContext_Task_aborted(ctx, field)
			case "abortInfo":
				return ec.fieldContext_Task_abortInfo(ctx, field)
			case "activated":
				return ec.fieldContext_Task_activated(ctx, field)
			case "activatedBy":
				return ec.fieldContext_Task_activatedBy(ctx, field)
			case "activatedTime":
				return ec.fieldContext_Task_activatedTime(ctx, field)
			case "ami":
				return ec.fieldContext_Task_ami(ctx, field)
			case "annotation":
				return ec.fieldContext_Task_annotation(ctx, field)
			case "baseStatus":
				return ec.fieldContext_Task_baseStatus(ctx, field)
			case "baseTask":
				return ec.fieldContext_Task_baseTask(ctx, field)
			case "blocked":
				return ec.fieldContext_Task_blocked(ctx, field)
			case "buildId":
				return ec.fieldContext_Task_buildId(ctx, field)
			case "buildVariant":
				return ec.fieldContext_Task_buildVariant(ctx, field)
			case "buildVariantDisplayName":
				return ec.fieldContext_Task_buildVariantDisplayName(ctx, field)
			case "canAbort":
				return ec.fieldContext_Task_canAbort(ctx, field)
			case "canDisable":
				return ec.fieldContext_Task_canDisable(ctx, field)
			case "canModifyAnnotation":
				return ec.fieldContext_Task_canModifyAnnotation(ctx, field)
			case "canOverrideDependencies":
				return ec.fieldContext_Task_canOverrideDependencies(ctx, field)
			case "canRestart":
				return ec.fieldContext_Task_canRestart(ctx, field)
			case "canSchedule":
				return ec.fieldContext_Task_canSchedule(ctx, field)
			case "canSetPriority":
				return ec.fieldContext_Task_canSetPriority(ctx, field)
			case "canSync":
				return ec.fieldContext_Task_canSync(ctx, field)
			case "canUnschedule":
				return ec.fieldContext_Task_canUnschedule(ctx, field)
			case "containerAllocatedTime":
				return ec.fieldContext_Task_containerAllocatedTime(ctx, field)
			case "createTime":
				return ec.fieldContext_Task_createTime(ctx, field)
			case "dependsOn":
				return ec.fieldContext_Task_dependsOn(ctx, field)
			case "details":
				return ec.fieldContext_Task_details(ctx, field)
			case "dispatchTime":
				return ec.fieldContext_Task_dispatchTime(ctx, field)
			case "displayName":
				return ec.fieldContext_Task_displayName(ctx, field)
			case "displayOnly":
				return ec.fieldContext_Task_displayOnly(ctx, field)
			case "displayTask":
				return ec.fieldContext_Task_displayTask(ctx, field)
			case "distroId":
				return ec.fieldContext_Task_distroId(ctx, field)
			case "estimatedStart":
				return ec.fieldContext_Task_estimatedStart(ctx, field)
			case "execution":
				return ec.fieldContext_Task_execution(ctx, field)
			case "executionTasks":
				return ec.fieldContext_Task_executionTasks(ctx, field)
			case "executionTasksFull":
				return ec.fieldContext_Task_executionTasksFull(ctx, field)
			case "expectedDuration":
				return ec.fieldContext_Task_expectedDuration(ctx, field)
			case "failedTestCount":
				return ec.fieldContext_Task_failedTestCount(ctx, field)
			case "finishTime":
				return ec.fieldContext_Task_finishTime(ctx, field)
			case "generatedBy":
				return ec.fieldContext_Task_generatedBy(ctx, field)
			case "generatedByName":
				return ec.fieldContext_Task_generatedByName(ctx, field)
			case "generateTask":
				return ec.fieldContext_Task_generateTask(ctx, field)
			case "hostId":
				return ec.fieldContext_Task_hostId(ctx, field)
			case "ingestTime":
				return ec.fieldContext_Task_ingestTime(ctx, field)
			case "isPerfPluginEnabled":
				return ec.fieldContext_Task_isPerfPluginEnabled(ctx, field)
			case "latestExecution":
				return ec.fieldContext_Task_latestExecution(ctx, field)
			case "logs":
				return ec.fieldContext_Task_logs(ctx, field)
			case "minQueuePosition":
				return ec.fieldContext_Task_minQueuePosition(ctx, field)
			case "order":
				return ec.fieldContext_Task_order(ctx, field)
			case "patch":
				return ec.fieldContext_Task_patch(ctx, field)
			case "patchNumber":
				return ec.fieldContext_Task_patchNumber(ctx, field)
			case "pod":
				return ec.fieldContext_Task_pod(ctx, field)
			case "priority":
				return ec.fieldContext_Task_priority(ctx, field)
			case "project":
				return ec.fieldContext_Task_project(ctx, field)
			case "projectId":
				return ec.fieldContext_Task_projectId(ctx, field)
			case "projectIdentifier":
				return ec.fieldContext_Task_projectIdentifier(ctx, field)
			case "requester":
				return ec.fieldContext_Task_requester(ctx, field)
			case "resetWhenFinished":
				return ec.fieldContext_Task_resetWhenFinished(ctx, field)
			case "revision":
				return ec.fieldContext_Task_revision(ctx, field)
			case "scheduledTime":
				return ec.fieldContext_Task_scheduledTime(ctx, field)
			case "spawnHostLink":
				return ec.fieldContext_Task_spawnHostLink(ctx, field)
			case "startTime":
				return ec.fieldContext_Task_startTime(ctx, field)
			case "status":
				return ec.fieldContext_Task_status(ctx, field)
			case "taskFiles":
				return ec.fieldContext_Task_taskFiles(ctx, field)
			case "taskGroup":
				return ec.fieldContext_Task_taskGroup(ctx, field)
			case "taskGroupMaxHosts":
				return ec.fieldContext_Task_taskGroupMaxHosts(ctx, field)
			case "taskLogs":
				return ec.fieldContext_Task_taskLogs(ctx, field)
			case "tests":
				return ec.fieldContext_Task_tests(ctx, field)
			case "timeTaken":
				return ec.fieldContext_Task_timeTaken(ctx, field)
			case "totalTestCount":
				return ec.fieldContext_Task_totalTestCount(ctx, field)
			case "versionMetadata":
				return ec.fieldContext_Task_versionMetadata(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Task", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionTiming_makespan(ctx context.Context, field graphql.CollectedField, obj *VersionTiming) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionTiming_makespan(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Makespan, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIDuration)
	fc.Result = res
	return ec.marshalODuration2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionTiming_makespan(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionTiming",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _VersionTiming_timeTaken(ctx context.Context, field graphql.CollectedField, obj *VersionTiming) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_VersionTiming_timeTaken(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimeTaken, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIDuration)
	fc.Result = res
	return ec.marshalODuration2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDuration(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_VersionTiming_timeTaken(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "VersionTiming",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Duration does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_id(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_id(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.ID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_id(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_availabilityZone(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_availabilityZone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.AvailabilityZone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_availabilityZone(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_createdBy(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_createdBy(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreatedBy, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_createdBy(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_creationTime(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_creationTime(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.CreationTime, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_creationTime(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_deviceName(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_deviceName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeviceName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_deviceName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_displayName(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_displayName(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DisplayName, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_displayName(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_expiration(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_expiration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Expiration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*time.Time)
	fc.Result = res
	return ec.marshalOTime2ᚖtimeᚐTime(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_expiration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Time does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_homeVolume(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_homeVolume(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HomeVolume, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_homeVolume(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_host(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_host(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return ec.resolvers.Volume().Host(rctx, obj)
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*model.APIHost)
	fc.Result = res
	return ec.marshalOHost2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHost(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_host(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   true,
		IsResolver: true,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "id":
				return ec.fieldContext_Host_id(ctx, field)
			case "availabilityZone":
				return ec.fieldContext_Host_availabilityZone(ctx, field)
			case "ami":
				return ec.fieldContext_Host_ami(ctx, field)
			case "displayName":
				return ec.fieldContext_Host_displayName(ctx, field)
			case "distro":
				return ec.fieldContext_Host_distro(ctx, field)
			case "distroId":
				return ec.fieldContext_Host_distroId(ctx, field)
			case "elapsed":
				return ec.fieldContext_Host_elapsed(ctx, field)
			case "expiration":
				return ec.fieldContext_Host_expiration(ctx, field)
			case "hostUrl":
				return ec.fieldContext_Host_hostUrl(ctx, field)
			case "homeVolume":
				return ec.fieldContext_Host_homeVolume(ctx, field)
			case "homeVolumeID":
				return ec.fieldContext_Host_homeVolumeID(ctx, field)
			case "instanceType":
				return ec.fieldContext_Host_instanceType(ctx, field)
			case "instanceTags":
				return ec.fieldContext_Host_instanceTags(ctx, field)
			case "lastCommunicationTime":
				return ec.fieldContext_Host_lastCommunicationTime(ctx, field)
			case "noExpiration":
				return ec.fieldContext_Host_noExpiration(ctx, field)
			case "provider":
				return ec.fieldContext_Host_provider(ctx, field)
			case "runningTask":
				return ec.fieldContext_Host_runningTask(ctx, field)
			case "startedBy":
				return ec.fieldContext_Host_startedBy(ctx, field)
			case "status":
				return ec.fieldContext_Host_status(ctx, field)
			case "tag":
				return ec.fieldContext_Host_tag(ctx, field)
			case "totalIdleTime":
				return ec.fieldContext_Host_totalIdleTime(ctx, field)
			case "uptime":
				return ec.fieldContext_Host_uptime(ctx, field)
			case "user":
				return ec.fieldContext_Host_user(ctx, field)
			case "volumes":
				return ec.fieldContext_Host_volumes(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type Host", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_hostID(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_hostID(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.HostID, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_hostID(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_migrating(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_migrating(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Migrating, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_migrating(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_noExpiration(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_noExpiration(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.NoExpiration, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_noExpiration(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_size(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_size(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Size, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_size(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Volume_type(ctx context.Context, field graphql.CollectedField, obj *model.APIVolume) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Volume_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Volume_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Volume",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_endpoint(ctx context.Context, field graphql.CollectedField, obj *model.APIWebHook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_endpoint(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Endpoint, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_endpoint(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _Webhook_secret(ctx context.Context, field graphql.CollectedField, obj *model.APIWebHook) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_Webhook_secret(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Secret, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_Webhook_secret(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "Webhook",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookHeader_key(ctx context.Context, field graphql.CollectedField, obj *model.APIWebhookHeader) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WebhookHeader_key(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Key, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WebhookHeader_key(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookHeader",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookHeader_value(ctx context.Context, field graphql.CollectedField, obj *model.APIWebhookHeader) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WebhookHeader_value(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Value, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WebhookHeader_value(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookHeader",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookSubscriber_headers(ctx context.Context, field graphql.CollectedField, obj *model.APIWebhookSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WebhookSubscriber_headers(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Headers, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]model.APIWebhookHeader)
	fc.Result = res
	return ec.marshalNWebhookHeader2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWebhookHeader(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WebhookSubscriber_headers(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "key":
				return ec.fieldContext_WebhookHeader_key(ctx, field)
			case "value":
				return ec.fieldContext_WebhookHeader_value(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WebhookHeader", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookSubscriber_secret(ctx context.Context, field graphql.CollectedField, obj *model.APIWebhookSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WebhookSubscriber_secret(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Secret, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WebhookSubscriber_secret(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookSubscriber_url(ctx context.Context, field graphql.CollectedField, obj *model.APIWebhookSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WebhookSubscriber_url(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.URL, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WebhookSubscriber_url(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookSubscriber_retries(ctx context.Context, field graphql.CollectedField, obj *model.APIWebhookSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WebhookSubscriber_retries(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Retries, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WebhookSubscriber_retries(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookSubscriber_minDelayMs(ctx context.Context, field graphql.CollectedField, obj *model.APIWebhookSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WebhookSubscriber_minDelayMs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MinDelayMS, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WebhookSubscriber_minDelayMs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WebhookSubscriber_timeoutMs(ctx context.Context, field graphql.CollectedField, obj *model.APIWebhookSubscriber) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WebhookSubscriber_timeoutMs(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.TimeoutMS, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	fc.Result = res
	return ec.marshalNInt2int(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WebhookSubscriber_timeoutMs(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WebhookSubscriber",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Int does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkstationConfig_gitClone(ctx context.Context, field graphql.CollectedField, obj *model.APIWorkstationConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkstationConfig_gitClone(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.GitClone, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*bool)
	fc.Result = res
	return ec.marshalOBoolean2ᚖbool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkstationConfig_gitClone(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkstationConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkstationConfig_setupCommands(ctx context.Context, field graphql.CollectedField, obj *model.APIWorkstationConfig) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkstationConfig_setupCommands(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SetupCommands, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]model.APIWorkstationSetupCommand)
	fc.Result = res
	return ec.marshalOWorkstationSetupCommand2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWorkstationSetupCommandᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkstationConfig_setupCommands(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkstationConfig",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "command":
				return ec.fieldContext_WorkstationSetupCommand_command(ctx, field)
			case "directory":
				return ec.fieldContext_WorkstationSetupCommand_directory(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type WorkstationSetupCommand", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkstationSetupCommand_command(ctx context.Context, field graphql.CollectedField, obj *model.APIWorkstationSetupCommand) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkstationSetupCommand_command(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Command, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkstationSetupCommand_command(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkstationSetupCommand",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) _WorkstationSetupCommand_directory(ctx context.Context, field graphql.CollectedField, obj *model.APIWorkstationSetupCommand) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext_WorkstationSetupCommand_directory(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directory, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalNString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext_WorkstationSetupCommand_directory(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "WorkstationSetupCommand",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_locations(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Locations, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	fc.Result = res
	return ec.marshalN__DirectiveLocation2ᚕstringᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_locations(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __DirectiveLocation does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Directive_isRepeatable(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsRepeatable, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Directive_isRepeatable(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Directive",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___EnumValue_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__EnumValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_args(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Args, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_args(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_isDeprecated(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.IsDeprecated(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	fc.Result = res
	return ec.marshalNBoolean2bool(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_isDeprecated(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type Boolean does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Field_deprecationReason(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DeprecationReason(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Field_deprecationReason(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Field",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalNString2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_type(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Type, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_type(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___InputValue_defaultValue(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.DefaultValue, nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__InputValue",
		Field:      field,
		IsMethod:   false,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_types(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Types(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_types(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_queryType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.QueryType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_queryType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_mutationType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.MutationType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_mutationType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_subscriptionType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SubscriptionType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Schema_directives(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Directives(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	fc.Result = res
	return ec.marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Schema_directives(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Schema",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Directive_name(ctx, field)
			case "description":
				return ec.fieldContext___Directive_description(ctx, field)
			case "locations":
				return ec.fieldContext___Directive_locations(ctx, field)
			case "args":
				return ec.fieldContext___Directive_args(ctx, field)
			case "isRepeatable":
				return ec.fieldContext___Directive_isRepeatable(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Directive", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_kind(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Kind(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		if !graphql.HasFieldError(ctx, fc) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	fc.Result = res
	return ec.marshalN__TypeKind2string(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_kind(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type __TypeKind does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_name(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Name(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_name(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_description(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Description(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_description(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_fields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Fields(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	fc.Result = res
	return ec.marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_fields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___Field_name(ctx, field)
			case "description":
				return ec.fieldContext___Field_description(ctx, field)
			case "args":
				return ec.fieldContext___Field_args(ctx, field)
			case "type":
				return ec.fieldContext___Field_type(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___Field_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___Field_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Field", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_fields_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_interfaces(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.Interfaces(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_interfaces(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_possibleTypes(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.PossibleTypes(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_possibleTypes(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_enumValues(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.EnumValues(fc.Args["includeDeprecated"].(bool)), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	fc.Result = res
	return ec.marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_enumValues(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___EnumValue_name(ctx, field)
			case "description":
				return ec.fieldContext___EnumValue_description(ctx, field)
			case "isDeprecated":
				return ec.fieldContext___EnumValue_isDeprecated(ctx, field)
			case "deprecationReason":
				return ec.fieldContext___EnumValue_deprecationReason(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __EnumValue", field.Name)
		},
	}
	defer func() {
		if r := recover(); r != nil {
			err = ec.Recover(ctx, r)
			ec.Error(ctx, err)
		}
	}()
	ctx = graphql.WithFieldContext(ctx, fc)
	if fc.Args, err = ec.field___Type_enumValues_args(ctx, field.ArgumentMap(ec.Variables)); err != nil {
		ec.Error(ctx, err)
		return
	}
	return fc, nil
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_inputFields(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.InputFields(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	fc.Result = res
	return ec.marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_inputFields(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "name":
				return ec.fieldContext___InputValue_name(ctx, field)
			case "description":
				return ec.fieldContext___InputValue_description(ctx, field)
			case "type":
				return ec.fieldContext___InputValue_type(ctx, field)
			case "defaultValue":
				return ec.fieldContext___InputValue_defaultValue(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __InputValue", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_ofType(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.OfType(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	fc.Result = res
	return ec.marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_ofType(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			switch field.Name {
			case "kind":
				return ec.fieldContext___Type_kind(ctx, field)
			case "name":
				return ec.fieldContext___Type_name(ctx, field)
			case "description":
				return ec.fieldContext___Type_description(ctx, field)
			case "fields":
				return ec.fieldContext___Type_fields(ctx, field)
			case "interfaces":
				return ec.fieldContext___Type_interfaces(ctx, field)
			case "possibleTypes":
				return ec.fieldContext___Type_possibleTypes(ctx, field)
			case "enumValues":
				return ec.fieldContext___Type_enumValues(ctx, field)
			case "inputFields":
				return ec.fieldContext___Type_inputFields(ctx, field)
			case "ofType":
				return ec.fieldContext___Type_ofType(ctx, field)
			case "specifiedByURL":
				return ec.fieldContext___Type_specifiedByURL(ctx, field)
			}
			return nil, fmt.Errorf("no field named %q was found under type __Type", field.Name)
		},
	}
	return fc, nil
}

func (ec *executionContext) ___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) (ret graphql.Marshaler) {
	fc, err := ec.fieldContext___Type_specifiedByURL(ctx, field)
	if err != nil {
		return graphql.Null
	}
	ctx = graphql.WithFieldContext(ctx, fc)
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = graphql.Null
		}
	}()
	resTmp, err := ec.ResolverMiddleware(ctx, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		return obj.SpecifiedByURL(), nil
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	fc.Result = res
	return ec.marshalOString2ᚖstring(ctx, field.Selections, res)
}

func (ec *executionContext) fieldContext___Type_specifiedByURL(ctx context.Context, field graphql.CollectedField) (fc *graphql.FieldContext, err error) {
	fc = &graphql.FieldContext{
		Object:     "__Type",
		Field:      field,
		IsMethod:   true,
		IsResolver: false,
		Child: func(ctx context.Context, field graphql.CollectedField) (*graphql.FieldContext, error) {
			return nil, errors.New("field of type String does not have child fields")
		},
	}
	return fc, nil
}

// endregion **************************** field.gotpl *****************************

// region    **************************** input.gotpl *****************************

func (ec *executionContext) unmarshalInputBootstrapSettingsInput(ctx context.Context, obj interface{}) (model.APIBootstrapSettings, error) {
	var it model.APIBootstrapSettings
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"clientDir", "communication", "env", "jasperBinaryDir", "jasperCredentialsPath", "method", "preconditionScripts", "resourceLimits", "rootDir", "serviceUser", "shellPath"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "clientDir":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("clientDir"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ClientDir = data
		case "communication":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("communication"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Communication = data
		case "env":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("env"))
			data, err := ec.unmarshalNEnvVarInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIEnvVarᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Env = data
		case "jasperBinaryDir":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jasperBinaryDir"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.JasperBinaryDir = data
		case "jasperCredentialsPath":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jasperCredentialsPath"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.JasperCredentialsPath = data
		case "method":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("method"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Method = data
		case "preconditionScripts":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("preconditionScripts"))
			data, err := ec.unmarshalNPreconditionScriptInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPreconditionScriptᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.PreconditionScripts = data
		case "resourceLimits":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resourceLimits"))
			data, err := ec.unmarshalNResourceLimitsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIResourceLimits(ctx, v)
			if err != nil {
				return it, err
			}
			it.ResourceLimits = data
		case "rootDir":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("rootDir"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.RootDir = data
		case "serviceUser":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("serviceUser"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ServiceUser = data
		case "shellPath":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("shellPath"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShellPath = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBuildBaronSettingsInput(ctx context.Context, obj interface{}) (model.APIBuildBaronSettings, error) {
	var it model.APIBuildBaronSettings
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"bfSuggestionFeaturesURL", "bfSuggestionPassword", "bfSuggestionServer", "bfSuggestionTimeoutSecs", "bfSuggestionUsername", "ticketCreateProject", "ticketSearchProjects"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "bfSuggestionFeaturesURL":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bfSuggestionFeaturesURL"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.BFSuggestionFeaturesURL = data
		case "bfSuggestionPassword":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bfSuggestionPassword"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.BFSuggestionPassword = data
		case "bfSuggestionServer":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bfSuggestionServer"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.BFSuggestionServer = data
		case "bfSuggestionTimeoutSecs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bfSuggestionTimeoutSecs"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.BFSuggestionTimeoutSecs = data
		case "bfSuggestionUsername":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bfSuggestionUsername"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.BFSuggestionUsername = data
		case "ticketCreateProject":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ticketCreateProject"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.TicketCreateProject = data
		case "ticketSearchProjects":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ticketSearchProjects"))
			data, err := ec.unmarshalOString2ᚕᚖstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.TicketSearchProjects = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputBuildVariantOptions(ctx context.Context, obj interface{}) (BuildVariantOptions, error) {
	var it BuildVariantOptions
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"includeBaseTasks", "statuses", "tasks", "variants"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "includeBaseTasks":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeBaseTasks"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IncludeBaseTasks = data
		case "statuses":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statuses"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Statuses = data
		case "tasks":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tasks"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tasks = data
		case "variants":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("variants"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Variants = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCommitQueueParamsInput(ctx context.Context, obj interface{}) (model.APICommitQueueParams, error) {
	var it model.APICommitQueueParams
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"enabled", "mergeMethod", "mergeQueue", "message"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "enabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("enabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Enabled = data
		case "mergeMethod":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mergeMethod"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.MergeMethod = data
		case "mergeQueue":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mergeQueue"))
			data, err := ec.unmarshalOMergeQueue2githubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐMergeQueue(ctx, v)
			if err != nil {
				return it, err
			}
			it.MergeQueue = data
		case "message":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("message"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Message = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputContainerResourcesInput(ctx context.Context, obj interface{}) (model.APIContainerResources, error) {
	var it model.APIContainerResources
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"name", "cpu", "memoryMb"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "cpu":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cpu"))
			data, err := ec.unmarshalNInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.CPU = data
		case "memoryMb":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("memoryMb"))
			data, err := ec.unmarshalNInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.MemoryMB = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCopyDistroInput(ctx context.Context, obj interface{}) (data.CopyDistroOpts, error) {
	var it data.CopyDistroOpts
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"newDistroId", "distroIdToCopy"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "newDistroId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("newDistroId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NewDistroId = data
		case "distroIdToCopy":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("distroIdToCopy"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DistroIdToCopy = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCopyProjectInput(ctx context.Context, obj interface{}) (data.CopyProjectOpts, error) {
	var it data.CopyProjectOpts
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"newProjectId", "newProjectIdentifier", "projectIdToCopy"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "newProjectId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("newProjectId"))
			data, err := ec.unmarshalOString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NewProjectId = data
		case "newProjectIdentifier":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("newProjectIdentifier"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NewProjectIdentifier = data
		case "projectIdToCopy":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdToCopy"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProjectIdToCopy = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateDistroInput(ctx context.Context, obj interface{}) (CreateDistroInput, error) {
	var it CreateDistroInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"newDistroId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "newDistroId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("newDistroId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NewDistroID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputCreateProjectInput(ctx context.Context, obj interface{}) (model.APIProjectRef, error) {
	var it model.APIProjectRef
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "identifier", "owner", "repo", "repoRefId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Id = data
		case "identifier":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("identifier"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Identifier = data
		case "owner":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("owner"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Owner = data
		case "repo":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repo"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Repo = data
		case "repoRefId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repoRefId"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.RepoRefId = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDeleteDistroInput(ctx context.Context, obj interface{}) (DeleteDistroInput, error) {
	var it DeleteDistroInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"distroId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "distroId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("distroId"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				access, err := ec.unmarshalNDistroSettingsAccess2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroSettingsAccess(ctx, "ADMIN")
				if err != nil {
					return nil, err
				}
				if ec.directives.RequireDistroAccess == nil {
					return nil, errors.New("directive requireDistroAccess is not implemented")
				}
				return ec.directives.RequireDistroAccess(ctx, obj, directive0, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.DistroID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDispatcherSettingsInput(ctx context.Context, obj interface{}) (model.APIDispatcherSettings, error) {
	var it model.APIDispatcherSettings
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"version"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "version":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalNDispatcherVersion2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDispatcherVersion(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.DispatcherSettingsInput().Version(ctx, &it, data); err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDisplayTask(ctx context.Context, obj interface{}) (DisplayTask, error) {
	var it DisplayTask
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"ExecTasks", "Name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "ExecTasks":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("ExecTasks"))
			data, err := ec.unmarshalNString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExecTasks = data
		case "Name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDistroEventsInput(ctx context.Context, obj interface{}) (DistroEventsInput, error) {
	var it DistroEventsInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"before", "distroId", "limit"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "before":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("before"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Before = data
		case "distroId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("distroId"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				access, err := ec.unmarshalNDistroSettingsAccess2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroSettingsAccess(ctx, "VIEW")
				if err != nil {
					return nil, err
				}
				if ec.directives.RequireDistroAccess == nil {
					return nil, errors.New("directive requireDistroAccess is not implemented")
				}
				return ec.directives.RequireDistroAccess(ctx, obj, directive0, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.DistroID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "limit":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDistroInput(ctx context.Context, obj interface{}) (model.APIDistro, error) {
	var it model.APIDistro
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"aliases", "arch", "authorizedKeysFile", "bootstrapSettings", "cloneMethod", "containerPool", "disabled", "disableShallowClone", "dispatcherSettings", "expansions", "finderSettings", "homeVolumeSettings", "hostAllocatorSettings", "iceCreamSettings", "isCluster", "isVirtualWorkStation", "name", "note", "plannerSettings", "provider", "providerSettingsList", "setup", "setupAsSudo", "sshKey", "sshOptions", "user", "userSpawnAllowed", "validProjects", "workDir"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "aliases":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("aliases"))
			data, err := ec.unmarshalNString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Aliases = data
		case "arch":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("arch"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Arch = data
		case "authorizedKeysFile":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("authorizedKeysFile"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.AuthorizedKeysFile = data
		case "bootstrapSettings":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("bootstrapSettings"))
			data, err := ec.unmarshalNBootstrapSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIBootstrapSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.BootstrapSettings = data
		case "cloneMethod":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cloneMethod"))
			data, err := ec.unmarshalNCloneMethod2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐCloneMethod(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.DistroInput().CloneMethod(ctx, &it, data); err != nil {
				return it, err
			}
		case "containerPool":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("containerPool"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ContainerPool = data
		case "disabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("disabled"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Disabled = data
		case "disableShallowClone":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("disableShallowClone"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisableShallowClone = data
		case "dispatcherSettings":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dispatcherSettings"))
			data, err := ec.unmarshalNDispatcherSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDispatcherSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.DispatcherSettings = data
		case "expansions":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expansions"))
			data, err := ec.unmarshalNExpansionInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIExpansionᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Expansions = data
		case "finderSettings":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("finderSettings"))
			data, err := ec.unmarshalNFinderSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIFinderSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.FinderSettings = data
		case "homeVolumeSettings":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeVolumeSettings"))
			data, err := ec.unmarshalNHomeVolumeSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHomeVolumeSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.HomeVolumeSettings = data
		case "hostAllocatorSettings":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostAllocatorSettings"))
			data, err := ec.unmarshalNHostAllocatorSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHostAllocatorSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.HostAllocatorSettings = data
		case "iceCreamSettings":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("iceCreamSettings"))
			data, err := ec.unmarshalNIceCreamSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIIceCreamSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.IcecreamSettings = data
		case "isCluster":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isCluster"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsCluster = data
		case "isVirtualWorkStation":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isVirtualWorkStation"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsVirtualWorkstation = data
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2ᚖstring(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				access, err := ec.unmarshalNDistroSettingsAccess2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroSettingsAccess(ctx, "EDIT")
				if err != nil {
					return nil, err
				}
				if ec.directives.RequireDistroAccess == nil {
					return nil, errors.New("directive requireDistroAccess is not implemented")
				}
				return ec.directives.RequireDistroAccess(ctx, obj, directive0, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Name = data
			} else if tmp == nil {
				it.Name = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "note":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("note"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Note = data
		case "plannerSettings":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("plannerSettings"))
			data, err := ec.unmarshalNPlannerSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPlannerSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.PlannerSettings = data
		case "provider":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("provider"))
			data, err := ec.unmarshalNProvider2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProvider(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.DistroInput().Provider(ctx, &it, data); err != nil {
				return it, err
			}
		case "providerSettingsList":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("providerSettingsList"))
			data, err := ec.unmarshalNMap2ᚕmapᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.DistroInput().ProviderSettingsList(ctx, &it, data); err != nil {
				return it, err
			}
		case "setup":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("setup"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Setup = data
		case "setupAsSudo":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("setupAsSudo"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SetupAsSudo = data
		case "sshKey":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sshKey"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSHKey = data
		case "sshOptions":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sshOptions"))
			data, err := ec.unmarshalNString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.SSHOptions = data
		case "user":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("user"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.User = data
		case "userSpawnAllowed":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userSpawnAllowed"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserSpawnAllowed = data
		case "validProjects":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("validProjects"))
			data, err := ec.unmarshalNString2ᚕᚖstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ValidProjects = data
		case "workDir":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("workDir"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.WorkDir = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputDistroPermissionsOptions(ctx context.Context, obj interface{}) (DistroPermissionsOptions, error) {
	var it DistroPermissionsOptions
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"distroId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "distroId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("distroId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DistroID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEditSpawnHostInput(ctx context.Context, obj interface{}) (EditSpawnHostInput, error) {
	var it EditSpawnHostInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"addedInstanceTags", "deletedInstanceTags", "displayName", "expiration", "hostId", "instanceType", "noExpiration", "publicKey", "savePublicKey", "servicePassword", "volume"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "addedInstanceTags":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("addedInstanceTags"))
			data, err := ec.unmarshalOInstanceTagInput2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋhostᚐTagᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.AddedInstanceTags = data
		case "deletedInstanceTags":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deletedInstanceTags"))
			data, err := ec.unmarshalOInstanceTagInput2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋhostᚐTagᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeletedInstanceTags = data
		case "displayName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "expiration":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiration"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Expiration = data
		case "hostId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.HostID = data
		case "instanceType":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("instanceType"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.InstanceType = data
		case "noExpiration":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("noExpiration"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.NoExpiration = data
		case "publicKey":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publicKey"))
			data, err := ec.unmarshalOPublicKeyInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPublicKeyInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.PublicKey = data
		case "savePublicKey":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("savePublicKey"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SavePublicKey = data
		case "servicePassword":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("servicePassword"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ServicePassword = data
		case "volume":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("volume"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Volume = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputEnvVarInput(ctx context.Context, obj interface{}) (model.APIEnvVar, error) {
	var it model.APIEnvVar
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "value":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputExpansionInput(ctx context.Context, obj interface{}) (model.APIExpansion, error) {
	var it model.APIExpansion
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "value":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputExternalLinkInput(ctx context.Context, obj interface{}) (model.APIExternalLink, error) {
	var it model.APIExternalLink
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"displayName", "requesters", "urlTemplate"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "displayName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "requesters":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requesters"))
			data, err := ec.unmarshalNString2ᚕᚖstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Requesters = data
		case "urlTemplate":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("urlTemplate"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.URLTemplate = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputFinderSettingsInput(ctx context.Context, obj interface{}) (model.APIFinderSettings, error) {
	var it model.APIFinderSettings
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"version"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "version":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalNFinderVersion2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐFinderVersion(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.FinderSettingsInput().Version(ctx, &it, data); err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputGithubUserInput(ctx context.Context, obj interface{}) (model.APIGithubUser, error) {
	var it model.APIGithubUser
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"lastKnownAs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "lastKnownAs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lastKnownAs"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.LastKnownAs = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputHomeVolumeSettingsInput(ctx context.Context, obj interface{}) (model.APIHomeVolumeSettings, error) {
	var it model.APIHomeVolumeSettings
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"formatCommand"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "formatCommand":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("formatCommand"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.FormatCommand = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputHostAllocatorSettingsInput(ctx context.Context, obj interface{}) (model.APIHostAllocatorSettings, error) {
	var it model.APIHostAllocatorSettings
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"acceptableHostIdleTime", "feedbackRule", "futureHostFraction", "hostsOverallocatedRule", "maximumHosts", "minimumHosts", "roundingRule", "version"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "acceptableHostIdleTime":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("acceptableHostIdleTime"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.HostAllocatorSettingsInput().AcceptableHostIdleTime(ctx, &it, data); err != nil {
				return it, err
			}
		case "feedbackRule":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("feedbackRule"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.FeedbackRule = data
		case "futureHostFraction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("futureHostFraction"))
			data, err := ec.unmarshalNFloat2float64(ctx, v)
			if err != nil {
				return it, err
			}
			it.FutureHostFraction = data
		case "hostsOverallocatedRule":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostsOverallocatedRule"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.HostsOverallocatedRule = data
		case "maximumHosts":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("maximumHosts"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MaximumHosts = data
		case "minimumHosts":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minimumHosts"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MinimumHosts = data
		case "roundingRule":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("roundingRule"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.RoundingRule = data
		case "version":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Version = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputIceCreamSettingsInput(ctx context.Context, obj interface{}) (model.APIIceCreamSettings, error) {
	var it model.APIIceCreamSettings
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"configPath", "schedulerHost"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "configPath":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("configPath"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConfigPath = data
		case "schedulerHost":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("schedulerHost"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SchedulerHost = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputInstanceTagInput(ctx context.Context, obj interface{}) (host.Tag, error) {
	var it host.Tag
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "value":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputIssueLinkInput(ctx context.Context, obj interface{}) (model.APIIssueLink, error) {
	var it model.APIIssueLink
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"confidenceScore", "issueKey", "url"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "confidenceScore":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("confidenceScore"))
			data, err := ec.unmarshalOFloat2ᚖfloat64(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConfidenceScore = data
		case "issueKey":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("issueKey"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IssueKey = data
		case "url":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputJiraFieldInput(ctx context.Context, obj interface{}) (model.APIJiraField, error) {
	var it model.APIJiraField
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"displayText", "field"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "displayText":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayText"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayText = data
		case "field":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("field"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Field = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputJiraIssueSubscriberInput(ctx context.Context, obj interface{}) (model.APIJIRAIssueSubscriber, error) {
	var it model.APIJIRAIssueSubscriber
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"issueType", "project"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "issueType":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("issueType"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.IssueType = data
		case "project":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("project"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Project = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMainlineCommitsOptions(ctx context.Context, obj interface{}) (MainlineCommitsOptions, error) {
	var it MainlineCommitsOptions
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["limit"]; !present {
		asMap["limit"] = 7
	}
	if _, present := asMap["shouldCollapse"]; !present {
		asMap["shouldCollapse"] = false
	}

	fieldsInOrder := [...]string{"limit", "projectIdentifier", "requesters", "shouldCollapse", "skipOrderNumber"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "limit":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "projectIdentifier":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectIdentifier"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProjectIdentifier = data
		case "requesters":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("requesters"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Requesters = data
		case "shouldCollapse":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("shouldCollapse"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ShouldCollapse = data
		case "skipOrderNumber":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("skipOrderNumber"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.SkipOrderNumber = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMetadataLinkInput(ctx context.Context, obj interface{}) (model.APIMetadataLink, error) {
	var it model.APIMetadataLink
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"text", "url"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "text":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("text"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Text = data
		case "url":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputMoveProjectInput(ctx context.Context, obj interface{}) (MoveProjectInput, error) {
	var it MoveProjectInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"newOwner", "newRepo", "projectId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "newOwner":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("newOwner"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NewOwner = data
		case "newRepo":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("newRepo"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.NewRepo = data
		case "projectId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectId"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2string(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				access, err := ec.unmarshalNProjectSettingsAccess2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectSettingsAccess(ctx, "EDIT")
				if err != nil {
					return nil, err
				}
				if ec.directives.RequireProjectAccess == nil {
					return nil, errors.New("directive requireProjectAccess is not implemented")
				}
				return ec.directives.RequireProjectAccess(ctx, obj, directive0, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(string); ok {
				it.ProjectID = data
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputNotificationsInput(ctx context.Context, obj interface{}) (model.APINotificationPreferences, error) {
	var it model.APINotificationPreferences
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"buildBreak", "commitQueue", "patchFinish", "patchFirstFailure", "spawnHostExpiration", "spawnHostOutcome"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "buildBreak":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildBreak"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.BuildBreak = data
		case "commitQueue":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("commitQueue"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.CommitQueue = data
		case "patchFinish":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchFinish"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchFinish = data
		case "patchFirstFailure":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchFirstFailure"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchFirstFailure = data
		case "spawnHostExpiration":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spawnHostExpiration"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpawnHostExpiration = data
		case "spawnHostOutcome":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spawnHostOutcome"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpawnHostOutcome = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputParameterInput(ctx context.Context, obj interface{}) (model.APIParameter, error) {
	var it model.APIParameter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "value":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputParsleyFilterInput(ctx context.Context, obj interface{}) (model.APIParsleyFilter, error) {
	var it model.APIParsleyFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"expression", "caseSensitive", "exactMatch"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "expression":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expression"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Expression = data
		case "caseSensitive":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("caseSensitive"))
			data, err := ec.unmarshalNBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.CaseSensitive = data
		case "exactMatch":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("exactMatch"))
			data, err := ec.unmarshalNBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExactMatch = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPatchConfigure(ctx context.Context, obj interface{}) (PatchConfigure, error) {
	var it PatchConfigure
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"description", "parameters", "patchTriggerAliases", "variantsTasks"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "parameters":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parameters"))
			data, err := ec.unmarshalOParameterInput2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParameter(ctx, v)
			if err != nil {
				return it, err
			}
			it.Parameters = data
		case "patchTriggerAliases":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchTriggerAliases"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchTriggerAliases = data
		case "variantsTasks":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("variantsTasks"))
			data, err := ec.unmarshalNVariantTasks2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐVariantTasksᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.VariantsTasks = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPatchTriggerAliasInput(ctx context.Context, obj interface{}) (model.APIPatchTriggerDefinition, error) {
	var it model.APIPatchTriggerDefinition
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"alias", "childProjectIdentifier", "parentAsModule", "status", "taskSpecifiers"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "alias":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alias"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Alias = data
		case "childProjectIdentifier":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("childProjectIdentifier"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ChildProjectIdentifier = data
		case "parentAsModule":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parentAsModule"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParentAsModule = data
		case "status":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "taskSpecifiers":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskSpecifiers"))
			data, err := ec.unmarshalNTaskSpecifierInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskSpecifierᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskSpecifiers = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPatchesInput(ctx context.Context, obj interface{}) (PatchesInput, error) {
	var it PatchesInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["limit"]; !present {
		asMap["limit"] = 0
	}
	if _, present := asMap["page"]; !present {
		asMap["page"] = 0
	}
	if _, present := asMap["patchName"]; !present {
		asMap["patchName"] = ""
	}
	if _, present := asMap["statuses"]; !present {
		asMap["statuses"] = []interface{}{}
	}

	fieldsInOrder := [...]string{"includeCommitQueue", "limit", "onlyCommitQueue", "page", "patchName", "statuses"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "includeCommitQueue":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeCommitQueue"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IncludeCommitQueue = data
		case "limit":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "onlyCommitQueue":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("onlyCommitQueue"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.OnlyCommitQueue = data
		case "page":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "patchName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchName = data
		case "statuses":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statuses"))
			data, err := ec.unmarshalNString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Statuses = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPeriodicBuildInput(ctx context.Context, obj interface{}) (model.APIPeriodicBuildDefinition, error) {
	var it model.APIPeriodicBuildDefinition
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "alias", "configFile", "cron", "intervalHours", "message", "nextRunTime"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "alias":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alias"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Alias = data
		case "configFile":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("configFile"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConfigFile = data
		case "cron":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("cron"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Cron = data
		case "intervalHours":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("intervalHours"))
			data, err := ec.unmarshalNInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.IntervalHours = data
		case "message":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("message"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Message = data
		case "nextRunTime":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("nextRunTime"))
			data, err := ec.unmarshalNTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.NextRunTime = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPlannerSettingsInput(ctx context.Context, obj interface{}) (model.APIPlannerSettings, error) {
	var it model.APIPlannerSettings
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"commitQueueFactor", "expectedRuntimeFactor", "generateTaskFactor", "groupVersions", "mainlineTimeInQueueFactor", "patchFactor", "patchTimeInQueueFactor", "targetTime", "version"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "commitQueueFactor":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("commitQueueFactor"))
			data, err := ec.unmarshalNInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.CommitQueueFactor = data
		case "expectedRuntimeFactor":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expectedRuntimeFactor"))
			data, err := ec.unmarshalNInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExpectedRuntimeFactor = data
		case "generateTaskFactor":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("generateTaskFactor"))
			data, err := ec.unmarshalNInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.GenerateTaskFactor = data
		case "groupVersions":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("groupVersions"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GroupVersions = data
		case "mainlineTimeInQueueFactor":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("mainlineTimeInQueueFactor"))
			data, err := ec.unmarshalNInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.MainlineTimeInQueueFactor = data
		case "patchFactor":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchFactor"))
			data, err := ec.unmarshalNInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchFactor = data
		case "patchTimeInQueueFactor":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchTimeInQueueFactor"))
			data, err := ec.unmarshalNInt2int64(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchTimeInQueueFactor = data
		case "targetTime":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("targetTime"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.PlannerSettingsInput().TargetTime(ctx, &it, data); err != nil {
				return it, err
			}
		case "version":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("version"))
			data, err := ec.unmarshalNPlannerVersion2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPlannerVersion(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.PlannerSettingsInput().Version(ctx, &it, data); err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPreconditionScriptInput(ctx context.Context, obj interface{}) (model.APIPreconditionScript, error) {
	var it model.APIPreconditionScript
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"path", "script"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "path":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("path"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Path = data
		case "script":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("script"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Script = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProjectAliasInput(ctx context.Context, obj interface{}) (model.APIProjectAlias, error) {
	var it model.APIProjectAlias
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "alias", "description", "gitTag", "remotePath", "task", "taskTags", "variant", "variantTags", "parameters"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "alias":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alias"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Alias = data
		case "description":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("description"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Description = data
		case "gitTag":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gitTag"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitTag = data
		case "remotePath":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remotePath"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemotePath = data
		case "task":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("task"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Task = data
		case "taskTags":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskTags"))
			data, err := ec.unmarshalNString2ᚕᚖstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskTags = data
		case "variant":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("variant"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Variant = data
		case "variantTags":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("variantTags"))
			data, err := ec.unmarshalNString2ᚕᚖstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.VariantTags = data
		case "parameters":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parameters"))
			data, err := ec.unmarshalOParameterInput2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParameterᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Parameters = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProjectBannerInput(ctx context.Context, obj interface{}) (model.APIProjectBanner, error) {
	var it model.APIProjectBanner
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"text", "theme"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "text":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("text"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Text = data
		case "theme":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("theme"))
			data, err := ec.unmarshalNBannerTheme2githubᚗcomᚋevergreenᚑciᚋevergreenᚐBannerTheme(ctx, v)
			if err != nil {
				return it, err
			}
			it.Theme = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProjectInput(ctx context.Context, obj interface{}) (model.APIProjectRef, error) {
	var it model.APIProjectRef
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "admins", "banner", "batchTime", "branch", "buildBaronSettings", "commitQueue", "containerSizeDefinitions", "deactivatePrevious", "disabledStatsCache", "dispatchingDisabled", "displayName", "enabled", "externalLinks", "githubChecksEnabled", "githubTriggerAliases", "gitTagAuthorizedTeams", "gitTagAuthorizedUsers", "gitTagVersionsEnabled", "identifier", "manualPrTestingEnabled", "notifyOnBuildFailure", "owner", "parsleyFilters", "patchingDisabled", "patchTriggerAliases", "perfEnabled", "periodicBuilds", "private", "projectHealthView", "prTestingEnabled", "remotePath", "repo", "repotrackerDisabled", "restricted", "spawnHostScriptPath", "stepbackDisabled", "taskAnnotationSettings", "taskSync", "tracksPushEvents", "triggers", "versionControlEnabled", "workstationConfig"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2ᚖstring(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				access, err := ec.unmarshalNProjectSettingsAccess2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectSettingsAccess(ctx, "EDIT")
				if err != nil {
					return nil, err
				}
				if ec.directives.RequireProjectAccess == nil {
					return nil, errors.New("directive requireProjectAccess is not implemented")
				}
				return ec.directives.RequireProjectAccess(ctx, obj, directive0, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Id = data
			} else if tmp == nil {
				it.Id = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "admins":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("admins"))
			data, err := ec.unmarshalOString2ᚕᚖstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Admins = data
		case "banner":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("banner"))
			data, err := ec.unmarshalOProjectBannerInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectBanner(ctx, v)
			if err != nil {
				return it, err
			}
			it.Banner = data
		case "batchTime":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("batchTime"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.BatchTime = data
		case "branch":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("branch"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Branch = data
		case "buildBaronSettings":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildBaronSettings"))
			data, err := ec.unmarshalOBuildBaronSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIBuildBaronSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.BuildBaronSettings = data
		case "commitQueue":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("commitQueue"))
			data, err := ec.unmarshalOCommitQueueParamsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPICommitQueueParams(ctx, v)
			if err != nil {
				return it, err
			}
			it.CommitQueue = data
		case "containerSizeDefinitions":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("containerSizeDefinitions"))
			data, err := ec.unmarshalOContainerResourcesInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIContainerResourcesᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ContainerSizeDefinitions = data
		case "deactivatePrevious":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deactivatePrevious"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeactivatePrevious = data
		case "disabledStatsCache":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("disabledStatsCache"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisabledStatsCache = data
		case "dispatchingDisabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dispatchingDisabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DispatchingDisabled = data
		case "displayName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "enabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("enabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Enabled = data
		case "externalLinks":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalLinks"))
			data, err := ec.unmarshalOExternalLinkInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIExternalLinkᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalLinks = data
		case "githubChecksEnabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubChecksEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GithubChecksEnabled = data
		case "githubTriggerAliases":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubTriggerAliases"))
			data, err := ec.unmarshalOString2ᚕᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.GithubTriggerAliases = data
		case "gitTagAuthorizedTeams":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gitTagAuthorizedTeams"))
			data, err := ec.unmarshalOString2ᚕᚖstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitTagAuthorizedTeams = data
		case "gitTagAuthorizedUsers":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gitTagAuthorizedUsers"))
			data, err := ec.unmarshalOString2ᚕᚖstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitTagAuthorizedUsers = data
		case "gitTagVersionsEnabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gitTagVersionsEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitTagVersionsEnabled = data
		case "identifier":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("identifier"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Identifier = data
		case "manualPrTestingEnabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("manualPrTestingEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ManualPRTestingEnabled = data
		case "notifyOnBuildFailure":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("notifyOnBuildFailure"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.NotifyOnBuildFailure = data
		case "owner":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("owner"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Owner = data
		case "parsleyFilters":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("parsleyFilters"))
			data, err := ec.unmarshalOParsleyFilterInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParsleyFilterᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ParsleyFilters = data
		case "patchingDisabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchingDisabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchingDisabled = data
		case "patchTriggerAliases":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchTriggerAliases"))
			data, err := ec.unmarshalOPatchTriggerAliasInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatchTriggerDefinitionᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchTriggerAliases = data
		case "perfEnabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("perfEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PerfEnabled = data
		case "periodicBuilds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("periodicBuilds"))
			data, err := ec.unmarshalOPeriodicBuildInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPeriodicBuildDefinitionᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.PeriodicBuilds = data
		case "private":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("private"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Private = data
		case "projectHealthView":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectHealthView"))
			data, err := ec.unmarshalOProjectHealthView2githubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐProjectHealthView(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProjectHealthView = data
		case "prTestingEnabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("prTestingEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PRTestingEnabled = data
		case "remotePath":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remotePath"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemotePath = data
		case "repo":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repo"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Repo = data
		case "repotrackerDisabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repotrackerDisabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.RepotrackerDisabled = data
		case "restricted":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("restricted"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Restricted = data
		case "spawnHostScriptPath":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spawnHostScriptPath"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpawnHostScriptPath = data
		case "stepbackDisabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stepbackDisabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.StepbackDisabled = data
		case "taskAnnotationSettings":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskAnnotationSettings"))
			data, err := ec.unmarshalOTaskAnnotationSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskAnnotationSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskAnnotationSettings = data
		case "taskSync":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskSync"))
			data, err := ec.unmarshalOTaskSyncOptionsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskSyncOptions(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskSync = data
		case "tracksPushEvents":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tracksPushEvents"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.TracksPushEvents = data
		case "triggers":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("triggers"))
			data, err := ec.unmarshalOTriggerAliasInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITriggerDefinitionᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Triggers = data
		case "versionControlEnabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionControlEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.VersionControlEnabled = data
		case "workstationConfig":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("workstationConfig"))
			data, err := ec.unmarshalOWorkstationConfigInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWorkstationConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.WorkstationConfig = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProjectSettingsInput(ctx context.Context, obj interface{}) (model.APIProjectSettings, error) {
	var it model.APIProjectSettings
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"aliases", "githubWebhooksEnabled", "projectRef", "subscriptions", "vars"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "aliases":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("aliases"))
			data, err := ec.unmarshalOProjectAliasInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectAliasᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Aliases = data
		case "githubWebhooksEnabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubWebhooksEnabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GithubWebhooksEnabled = data
		case "projectRef":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectRef"))
			data, err := ec.unmarshalOProjectInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProjectRef = data
		case "subscriptions":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subscriptions"))
			data, err := ec.unmarshalOSubscriptionInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISubscriptionᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Subscriptions = data
		case "vars":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("vars"))
			data, err := ec.unmarshalOProjectVarsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectVars(ctx, v)
			if err != nil {
				return it, err
			}
			it.Vars = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputProjectVarsInput(ctx context.Context, obj interface{}) (model.APIProjectVars, error) {
	var it model.APIProjectVars
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"adminOnlyVarsList", "privateVarsList", "vars"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "adminOnlyVarsList":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("adminOnlyVarsList"))
			data, err := ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.AdminOnlyVarsList = data
		case "privateVarsList":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("privateVarsList"))
			data, err := ec.unmarshalOString2ᚕstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.PrivateVarsList = data
		case "vars":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("vars"))
			data, err := ec.unmarshalOStringMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.Vars = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputPublicKeyInput(ctx context.Context, obj interface{}) (PublicKeyInput, error) {
	var it PublicKeyInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "name"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRepoRefInput(ctx context.Context, obj interface{}) (model.APIProjectRef, error) {
	var it model.APIProjectRef
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "admins", "batchTime", "buildBaronSettings", "commitQueue", "deactivatePrevious", "disabledStatsCache", "dispatchingDisabled", "displayName", "enabled", "externalLinks", "githubChecksEnabled", "githubTriggerAliases", "gitTagAuthorizedTeams", "gitTagAuthorizedUsers", "gitTagVersionsEnabled", "manualPrTestingEnabled", "notifyOnBuildFailure", "owner", "patchingDisabled", "patchTriggerAliases", "perfEnabled", "periodicBuilds", "private", "prTestingEnabled", "remotePath", "repo", "repotrackerDisabled", "restricted", "spawnHostScriptPath", "stepbackDisabled", "taskAnnotationSettings", "taskSync", "tracksPushEvents", "triggers", "versionControlEnabled", "workstationConfig", "containerSizeDefinitions"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			directive0 := func(ctx context.Context) (interface{}, error) { return ec.unmarshalNString2ᚖstring(ctx, v) }
			directive1 := func(ctx context.Context) (interface{}, error) {
				access, err := ec.unmarshalNProjectSettingsAccess2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectSettingsAccess(ctx, "EDIT")
				if err != nil {
					return nil, err
				}
				if ec.directives.RequireProjectAccess == nil {
					return nil, errors.New("directive requireProjectAccess is not implemented")
				}
				return ec.directives.RequireProjectAccess(ctx, obj, directive0, access)
			}

			tmp, err := directive1(ctx)
			if err != nil {
				return it, graphql.ErrorOnPath(ctx, err)
			}
			if data, ok := tmp.(*string); ok {
				it.Id = data
			} else if tmp == nil {
				it.Id = nil
			} else {
				err := fmt.Errorf(`unexpected type %T from directive, should be *string`, tmp)
				return it, graphql.ErrorOnPath(ctx, err)
			}
		case "admins":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("admins"))
			data, err := ec.unmarshalOString2ᚕᚖstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Admins = data
		case "batchTime":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("batchTime"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.BatchTime = data
		case "buildBaronSettings":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildBaronSettings"))
			data, err := ec.unmarshalOBuildBaronSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIBuildBaronSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.BuildBaronSettings = data
		case "commitQueue":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("commitQueue"))
			data, err := ec.unmarshalOCommitQueueParamsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPICommitQueueParams(ctx, v)
			if err != nil {
				return it, err
			}
			it.CommitQueue = data
		case "deactivatePrevious":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("deactivatePrevious"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DeactivatePrevious = data
		case "disabledStatsCache":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("disabledStatsCache"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisabledStatsCache = data
		case "dispatchingDisabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dispatchingDisabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.DispatchingDisabled = data
		case "displayName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayName = data
		case "enabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("enabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Enabled = data
		case "externalLinks":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("externalLinks"))
			data, err := ec.unmarshalOExternalLinkInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIExternalLinkᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExternalLinks = data
		case "githubChecksEnabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubChecksEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GithubChecksEnabled = data
		case "githubTriggerAliases":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubTriggerAliases"))
			data, err := ec.unmarshalOString2ᚕᚖstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.GithubTriggerAliases = data
		case "gitTagAuthorizedTeams":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gitTagAuthorizedTeams"))
			data, err := ec.unmarshalOString2ᚕᚖstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitTagAuthorizedTeams = data
		case "gitTagAuthorizedUsers":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gitTagAuthorizedUsers"))
			data, err := ec.unmarshalOString2ᚕᚖstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitTagAuthorizedUsers = data
		case "gitTagVersionsEnabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gitTagVersionsEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitTagVersionsEnabled = data
		case "manualPrTestingEnabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("manualPrTestingEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ManualPRTestingEnabled = data
		case "notifyOnBuildFailure":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("notifyOnBuildFailure"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.NotifyOnBuildFailure = data
		case "owner":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("owner"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Owner = data
		case "patchingDisabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchingDisabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchingDisabled = data
		case "patchTriggerAliases":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchTriggerAliases"))
			data, err := ec.unmarshalOPatchTriggerAliasInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatchTriggerDefinitionᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchTriggerAliases = data
		case "perfEnabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("perfEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PerfEnabled = data
		case "periodicBuilds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("periodicBuilds"))
			data, err := ec.unmarshalOPeriodicBuildInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPeriodicBuildDefinitionᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.PeriodicBuilds = data
		case "private":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("private"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Private = data
		case "prTestingEnabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("prTestingEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PRTestingEnabled = data
		case "remotePath":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("remotePath"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.RemotePath = data
		case "repo":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repo"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Repo = data
		case "repotrackerDisabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("repotrackerDisabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.RepotrackerDisabled = data
		case "restricted":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("restricted"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.Restricted = data
		case "spawnHostScriptPath":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spawnHostScriptPath"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpawnHostScriptPath = data
		case "stepbackDisabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("stepbackDisabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.StepbackDisabled = data
		case "taskAnnotationSettings":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskAnnotationSettings"))
			data, err := ec.unmarshalOTaskAnnotationSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskAnnotationSettings(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskAnnotationSettings = data
		case "taskSync":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskSync"))
			data, err := ec.unmarshalOTaskSyncOptionsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskSyncOptions(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskSync = data
		case "tracksPushEvents":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tracksPushEvents"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.TracksPushEvents = data
		case "triggers":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("triggers"))
			data, err := ec.unmarshalOTriggerAliasInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITriggerDefinitionᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Triggers = data
		case "versionControlEnabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionControlEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.VersionControlEnabled = data
		case "workstationConfig":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("workstationConfig"))
			data, err := ec.unmarshalOWorkstationConfigInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWorkstationConfig(ctx, v)
			if err != nil {
				return it, err
			}
			it.WorkstationConfig = data
		case "containerSizeDefinitions":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("containerSizeDefinitions"))
			data, err := ec.unmarshalOContainerResourcesInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIContainerResourcesᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.ContainerSizeDefinitions = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputRepoSettingsInput(ctx context.Context, obj interface{}) (model.APIProjectSettings, error) {
	var it model.APIProjectSettings
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"aliases", "githubWebhooksEnabled", "projectRef", "subscriptions", "vars"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "aliases":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("aliases"))
			data, err := ec.unmarshalOProjectAliasInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectAliasᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Aliases = data
		case "githubWebhooksEnabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubWebhooksEnabled"))
			data, err := ec.unmarshalOBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GithubWebhooksEnabled = data
		case "projectRef":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("projectRef"))
			data, err := ec.unmarshalORepoRefInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx, v)
			if err != nil {
				return it, err
			}
			it.ProjectRef = data
		case "subscriptions":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subscriptions"))
			data, err := ec.unmarshalOSubscriptionInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISubscriptionᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Subscriptions = data
		case "vars":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("vars"))
			data, err := ec.unmarshalOProjectVarsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectVars(ctx, v)
			if err != nil {
				return it, err
			}
			it.Vars = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputResourceLimitsInput(ctx context.Context, obj interface{}) (model.APIResourceLimits, error) {
	var it model.APIResourceLimits
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"lockedMemoryKb", "numFiles", "numProcesses", "numTasks", "virtualMemoryKb"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "lockedMemoryKb":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("lockedMemoryKb"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.LockedMemoryKB = data
		case "numFiles":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("numFiles"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.NumFiles = data
		case "numProcesses":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("numProcesses"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.NumProcesses = data
		case "numTasks":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("numTasks"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.NumTasks = data
		case "virtualMemoryKb":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("virtualMemoryKb"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.VirtualMemoryKB = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSaveDistroInput(ctx context.Context, obj interface{}) (SaveDistroInput, error) {
	var it SaveDistroInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"distro", "onSave"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "distro":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("distro"))
			data, err := ec.unmarshalNDistroInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDistro(ctx, v)
			if err != nil {
				return it, err
			}
			it.Distro = data
		case "onSave":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("onSave"))
			data, err := ec.unmarshalNDistroOnSaveOperation2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroOnSaveOperation(ctx, v)
			if err != nil {
				return it, err
			}
			it.OnSave = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSelectorInput(ctx context.Context, obj interface{}) (model.APISelector, error) {
	var it model.APISelector
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"data", "type"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "data":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("data"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Data = data
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSortOrder(ctx context.Context, obj interface{}) (SortOrder, error) {
	var it SortOrder
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"Direction", "Key"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "Direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Direction"))
			data, err := ec.unmarshalNSortDirection2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSortDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		case "Key":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("Key"))
			data, err := ec.unmarshalNTaskSortCategory2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskSortCategory(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSpawnHostInput(ctx context.Context, obj interface{}) (SpawnHostInput, error) {
	var it SpawnHostInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"distroId", "expiration", "homeVolumeSize", "isVirtualWorkStation", "noExpiration", "publicKey", "region", "savePublicKey", "setUpScript", "spawnHostsStartedByTask", "taskId", "taskSync", "useProjectSetupScript", "userDataScript", "useTaskConfig", "volumeId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "distroId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("distroId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.DistroID = data
		case "expiration":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiration"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Expiration = data
		case "homeVolumeSize":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("homeVolumeSize"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.HomeVolumeSize = data
		case "isVirtualWorkStation":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("isVirtualWorkStation"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IsVirtualWorkStation = data
		case "noExpiration":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("noExpiration"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.NoExpiration = data
		case "publicKey":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("publicKey"))
			data, err := ec.unmarshalNPublicKeyInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPublicKeyInput(ctx, v)
			if err != nil {
				return it, err
			}
			it.PublicKey = data
		case "region":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("region"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Region = data
		case "savePublicKey":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("savePublicKey"))
			data, err := ec.unmarshalNBoolean2bool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SavePublicKey = data
		case "setUpScript":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("setUpScript"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SetUpScript = data
		case "spawnHostsStartedByTask":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spawnHostsStartedByTask"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpawnHostsStartedByTask = data
		case "taskId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskId"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskID = data
		case "taskSync":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskSync"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskSync = data
		case "useProjectSetupScript":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("useProjectSetupScript"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UseProjectSetupScript = data
		case "userDataScript":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("userDataScript"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.UserDataScript = data
		case "useTaskConfig":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("useTaskConfig"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.UseTaskConfig = data
		case "volumeId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("volumeId"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.VolumeID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSpawnVolumeInput(ctx context.Context, obj interface{}) (SpawnVolumeInput, error) {
	var it SpawnVolumeInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"availabilityZone", "expiration", "host", "noExpiration", "size", "type"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "availabilityZone":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("availabilityZone"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.AvailabilityZone = data
		case "expiration":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiration"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Expiration = data
		case "host":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("host"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Host = data
		case "noExpiration":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("noExpiration"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.NoExpiration = data
		case "size":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("size"))
			data, err := ec.unmarshalNInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Size = data
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSubscriberInput(ctx context.Context, obj interface{}) (model.APISubscriber, error) {
	var it model.APISubscriber
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"target", "type", "webhookSubscriber", "jiraIssueSubscriber"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "target":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("target"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			if err = ec.resolvers.SubscriberInput().Target(ctx, &it, data); err != nil {
				return it, err
			}
		case "type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("type"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Type = data
		case "webhookSubscriber":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("webhookSubscriber"))
			data, err := ec.unmarshalOWebhookSubscriberInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWebhookSubscriber(ctx, v)
			if err != nil {
				return it, err
			}
			it.WebhookSubscriber = data
		case "jiraIssueSubscriber":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jiraIssueSubscriber"))
			data, err := ec.unmarshalOJiraIssueSubscriberInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIJIRAIssueSubscriber(ctx, v)
			if err != nil {
				return it, err
			}
			it.JiraIssueSubscriber = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputSubscriptionInput(ctx context.Context, obj interface{}) (model.APISubscription, error) {
	var it model.APISubscription
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"id", "owner_type", "owner", "regex_selectors", "resource_type", "selectors", "subscriber", "trigger_data", "trigger"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "id":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("id"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ID = data
		case "owner_type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("owner_type"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.OwnerType = data
		case "owner":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("owner"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Owner = data
		case "regex_selectors":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("regex_selectors"))
			data, err := ec.unmarshalNSelectorInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISelectorᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.RegexSelectors = data
		case "resource_type":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("resource_type"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ResourceType = data
		case "selectors":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("selectors"))
			data, err := ec.unmarshalNSelectorInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISelectorᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Selectors = data
		case "subscriber":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("subscriber"))
			data, err := ec.unmarshalNSubscriberInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISubscriber(ctx, v)
			if err != nil {
				return it, err
			}
			it.Subscriber = data
		case "trigger_data":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trigger_data"))
			data, err := ec.unmarshalNStringMap2map(ctx, v)
			if err != nil {
				return it, err
			}
			it.TriggerData = data
		case "trigger":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("trigger"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Trigger = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTaskAnnotationSettingsInput(ctx context.Context, obj interface{}) (model.APITaskAnnotationSettings, error) {
	var it model.APITaskAnnotationSettings
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"fileTicketWebhook", "jiraCustomFields"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "fileTicketWebhook":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("fileTicketWebhook"))
			data, err := ec.unmarshalOWebhookInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWebHook(ctx, v)
			if err != nil {
				return it, err
			}
			it.FileTicketWebhook = data
		case "jiraCustomFields":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("jiraCustomFields"))
			data, err := ec.unmarshalOJiraFieldInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIJiraFieldᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.JiraCustomFields = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTaskFilterOptions(ctx context.Context, obj interface{}) (TaskFilterOptions, error) {
	var it TaskFilterOptions
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["baseStatuses"]; !present {
		asMap["baseStatuses"] = []interface{}{}
	}
	if _, present := asMap["includeEmptyActivation"]; !present {
		asMap["includeEmptyActivation"] = false
	}
	if _, present := asMap["includeNeverActivatedTasks"]; !present {
		asMap["includeNeverActivatedTasks"] = false
	}
	if _, present := asMap["limit"]; !present {
		asMap["limit"] = 0
	}
	if _, present := asMap["page"]; !present {
		asMap["page"] = 0
	}
	if _, present := asMap["statuses"]; !present {
		asMap["statuses"] = []interface{}{}
	}

	fieldsInOrder := [...]string{"baseStatuses", "includeEmptyActivation", "includeNeverActivatedTasks", "limit", "page", "sorts", "statuses", "taskName", "variant"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "baseStatuses":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("baseStatuses"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.BaseStatuses = data
		case "includeEmptyActivation":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeEmptyActivation"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IncludeEmptyActivation = data
		case "includeNeverActivatedTasks":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("includeNeverActivatedTasks"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.IncludeNeverActivatedTasks = data
		case "limit":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "page":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		case "sorts":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sorts"))
			data, err := ec.unmarshalOSortOrder2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSortOrderᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Sorts = data
		case "statuses":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statuses"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Statuses = data
		case "taskName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskName = data
		case "variant":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("variant"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Variant = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTaskSpecifierInput(ctx context.Context, obj interface{}) (model.APITaskSpecifier, error) {
	var it model.APITaskSpecifier
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"patchAlias", "taskRegex", "variantRegex"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "patchAlias":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchAlias"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchAlias = data
		case "taskRegex":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskRegex"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskRegex = data
		case "variantRegex":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("variantRegex"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.VariantRegex = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTaskSyncOptionsInput(ctx context.Context, obj interface{}) (model.APITaskSyncOptions, error) {
	var it model.APITaskSyncOptions
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"configEnabled", "patchEnabled"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "configEnabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("configEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConfigEnabled = data
		case "patchEnabled":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("patchEnabled"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.PatchEnabled = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTestFilter(ctx context.Context, obj interface{}) (TestFilter, error) {
	var it TestFilter
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"testName", "testStatus"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "testName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("testName"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TestName = data
		case "testStatus":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("testStatus"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.TestStatus = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTestFilterOptions(ctx context.Context, obj interface{}) (TestFilterOptions, error) {
	var it TestFilterOptions
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"testName", "excludeDisplayNames", "statuses", "groupID", "sort", "limit", "page"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "testName":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("testName"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.TestName = data
		case "excludeDisplayNames":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("excludeDisplayNames"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.ExcludeDisplayNames = data
		case "statuses":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("statuses"))
			data, err := ec.unmarshalOString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Statuses = data
		case "groupID":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("groupID"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.GroupID = data
		case "sort":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sort"))
			data, err := ec.unmarshalOTestSortOptions2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTestSortOptionsᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Sort = data
		case "limit":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("limit"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Limit = data
		case "page":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("page"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.Page = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTestSortOptions(ctx context.Context, obj interface{}) (TestSortOptions, error) {
	var it TestSortOptions
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"sortBy", "direction"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "sortBy":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("sortBy"))
			data, err := ec.unmarshalNTestSortCategory2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTestSortCategory(ctx, v)
			if err != nil {
				return it, err
			}
			it.SortBy = data
		case "direction":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("direction"))
			data, err := ec.unmarshalNSortDirection2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSortDirection(ctx, v)
			if err != nil {
				return it, err
			}
			it.Direction = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputTriggerAliasInput(ctx context.Context, obj interface{}) (model.APITriggerDefinition, error) {
	var it model.APITriggerDefinition
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"alias", "buildVariantRegex", "configFile", "dateCutoff", "level", "project", "status", "taskRegex"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "alias":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("alias"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Alias = data
		case "buildVariantRegex":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("buildVariantRegex"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.BuildVariantRegex = data
		case "configFile":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("configFile"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.ConfigFile = data
		case "dateCutoff":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dateCutoff"))
			data, err := ec.unmarshalOInt2ᚖint(ctx, v)
			if err != nil {
				return it, err
			}
			it.DateCutoff = data
		case "level":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("level"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Level = data
		case "project":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("project"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Project = data
		case "status":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("status"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Status = data
		case "taskRegex":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskRegex"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskRegex = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUpdateVolumeInput(ctx context.Context, obj interface{}) (UpdateVolumeInput, error) {
	var it UpdateVolumeInput
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"expiration", "name", "noExpiration", "volumeId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "expiration":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("expiration"))
			data, err := ec.unmarshalOTime2ᚖtimeᚐTime(ctx, v)
			if err != nil {
				return it, err
			}
			it.Expiration = data
		case "name":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("name"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Name = data
		case "noExpiration":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("noExpiration"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.NoExpiration = data
		case "volumeId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("volumeId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.VolumeID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUseSpruceOptionsInput(ctx context.Context, obj interface{}) (model.APIUseSpruceOptions, error) {
	var it model.APIUseSpruceOptions
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"hasUsedMainlineCommitsBefore", "hasUsedSpruceBefore", "spruceV1"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "hasUsedMainlineCommitsBefore":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUsedMainlineCommitsBefore"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUsedMainlineCommitsBefore = data
		case "hasUsedSpruceBefore":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hasUsedSpruceBefore"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.HasUsedSpruceBefore = data
		case "spruceV1":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("spruceV1"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.SpruceV1 = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputUserSettingsInput(ctx context.Context, obj interface{}) (model.APIUserSettings, error) {
	var it model.APIUserSettings
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"githubUser", "notifications", "region", "slackUsername", "slackMemberId", "timezone", "useSpruceOptions", "dateFormat"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "githubUser":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("githubUser"))
			data, err := ec.unmarshalOGithubUserInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGithubUser(ctx, v)
			if err != nil {
				return it, err
			}
			it.GithubUser = data
		case "notifications":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("notifications"))
			data, err := ec.unmarshalONotificationsInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPINotificationPreferences(ctx, v)
			if err != nil {
				return it, err
			}
			it.Notifications = data
		case "region":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("region"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Region = data
		case "slackUsername":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slackUsername"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SlackUsername = data
		case "slackMemberId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("slackMemberId"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.SlackMemberId = data
		case "timezone":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timezone"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Timezone = data
		case "useSpruceOptions":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("useSpruceOptions"))
			data, err := ec.unmarshalOUseSpruceOptionsInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIUseSpruceOptions(ctx, v)
			if err != nil {
				return it, err
			}
			it.UseSpruceOptions = data
		case "dateFormat":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("dateFormat"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.DateFormat = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputVariantTasks(ctx context.Context, obj interface{}) (VariantTasks, error) {
	var it VariantTasks
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"displayTasks", "tasks", "variant"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "displayTasks":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("displayTasks"))
			data, err := ec.unmarshalNDisplayTask2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDisplayTaskᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.DisplayTasks = data
		case "tasks":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("tasks"))
			data, err := ec.unmarshalNString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.Tasks = data
		case "variant":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("variant"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.Variant = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputVersionToRestart(ctx context.Context, obj interface{}) (model1.VersionToRestart, error) {
	var it model1.VersionToRestart
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"versionId", "taskIds"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "versionId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("versionId"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.VersionId = data
		case "taskIds":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("taskIds"))
			data, err := ec.unmarshalNString2ᚕstringᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.TaskIds = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputVolumeHost(ctx context.Context, obj interface{}) (VolumeHost, error) {
	var it VolumeHost
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"volumeId", "hostId"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "volumeId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("volumeId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.VolumeID = data
		case "hostId":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("hostId"))
			data, err := ec.unmarshalNString2string(ctx, v)
			if err != nil {
				return it, err
			}
			it.HostID = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWebhookHeaderInput(ctx context.Context, obj interface{}) (model.APIWebhookHeader, error) {
	var it model.APIWebhookHeader
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"key", "value"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "key":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("key"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Key = data
		case "value":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("value"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Value = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWebhookInput(ctx context.Context, obj interface{}) (model.APIWebHook, error) {
	var it model.APIWebHook
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"endpoint", "secret"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "endpoint":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("endpoint"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Endpoint = data
		case "secret":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("secret"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Secret = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWebhookSubscriberInput(ctx context.Context, obj interface{}) (model.APIWebhookSubscriber, error) {
	var it model.APIWebhookSubscriber
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	if _, present := asMap["retries"]; !present {
		asMap["retries"] = 0
	}
	if _, present := asMap["minDelayMs"]; !present {
		asMap["minDelayMs"] = 0
	}
	if _, present := asMap["timeoutMs"]; !present {
		asMap["timeoutMs"] = 0
	}

	fieldsInOrder := [...]string{"headers", "secret", "url", "retries", "minDelayMs", "timeoutMs"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "headers":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("headers"))
			data, err := ec.unmarshalNWebhookHeaderInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWebhookHeader(ctx, v)
			if err != nil {
				return it, err
			}
			it.Headers = data
		case "secret":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("secret"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Secret = data
		case "url":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("url"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.URL = data
		case "retries":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("retries"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.Retries = data
		case "minDelayMs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("minDelayMs"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.MinDelayMS = data
		case "timeoutMs":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("timeoutMs"))
			data, err := ec.unmarshalOInt2int(ctx, v)
			if err != nil {
				return it, err
			}
			it.TimeoutMS = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWorkstationConfigInput(ctx context.Context, obj interface{}) (model.APIWorkstationConfig, error) {
	var it model.APIWorkstationConfig
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"gitClone", "setupCommands"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "gitClone":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("gitClone"))
			data, err := ec.unmarshalOBoolean2ᚖbool(ctx, v)
			if err != nil {
				return it, err
			}
			it.GitClone = data
		case "setupCommands":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("setupCommands"))
			data, err := ec.unmarshalOWorkstationSetupCommandInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWorkstationSetupCommandᚄ(ctx, v)
			if err != nil {
				return it, err
			}
			it.SetupCommands = data
		}
	}

	return it, nil
}

func (ec *executionContext) unmarshalInputWorkstationSetupCommandInput(ctx context.Context, obj interface{}) (model.APIWorkstationSetupCommand, error) {
	var it model.APIWorkstationSetupCommand
	asMap := map[string]interface{}{}
	for k, v := range obj.(map[string]interface{}) {
		asMap[k] = v
	}

	fieldsInOrder := [...]string{"command", "directory"}
	for _, k := range fieldsInOrder {
		v, ok := asMap[k]
		if !ok {
			continue
		}
		switch k {
		case "command":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("command"))
			data, err := ec.unmarshalNString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Command = data
		case "directory":
			var err error

			ctx := graphql.WithPathContext(ctx, graphql.NewPathWithField("directory"))
			data, err := ec.unmarshalOString2ᚖstring(ctx, v)
			if err != nil {
				return it, err
			}
			it.Directory = data
		}
	}

	return it, nil
}

// endregion **************************** input.gotpl *****************************

// region    ************************** interface.gotpl ***************************

// endregion ************************** interface.gotpl ***************************

// region    **************************** object.gotpl ****************************

var aWSConfigImplementors = []string{"AWSConfig"}

func (ec *executionContext) _AWSConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIAWSConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, aWSConfigImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AWSConfig")
		case "maxVolumeSizePerUser":

			out.Values[i] = ec._AWSConfig_maxVolumeSizePerUser(ctx, field, obj)

		case "pod":

			out.Values[i] = ec._AWSConfig_pod(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var aWSPodConfigImplementors = []string{"AWSPodConfig"}

func (ec *executionContext) _AWSPodConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIAWSPodConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, aWSPodConfigImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AWSPodConfig")
		case "ecs":

			out.Values[i] = ec._AWSPodConfig_ecs(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var abortInfoImplementors = []string{"AbortInfo"}

func (ec *executionContext) _AbortInfo(ctx context.Context, sel ast.SelectionSet, obj *AbortInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, abortInfoImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AbortInfo")
		case "buildVariantDisplayName":

			out.Values[i] = ec._AbortInfo_buildVariantDisplayName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "newVersion":

			out.Values[i] = ec._AbortInfo_newVersion(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "prClosed":

			out.Values[i] = ec._AbortInfo_prClosed(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "taskDisplayName":

			out.Values[i] = ec._AbortInfo_taskDisplayName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "taskID":

			out.Values[i] = ec._AbortInfo_taskID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "user":

			out.Values[i] = ec._AbortInfo_user(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var annotationImplementors = []string{"Annotation"}

func (ec *executionContext) _Annotation(ctx context.Context, sel ast.SelectionSet, obj *model.APITaskAnnotation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, annotationImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Annotation")
		case "id":

			out.Values[i] = ec._Annotation_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdIssues":

			out.Values[i] = ec._Annotation_createdIssues(ctx, field, obj)

		case "issues":

			out.Values[i] = ec._Annotation_issues(ctx, field, obj)

		case "note":

			out.Values[i] = ec._Annotation_note(ctx, field, obj)

		case "suspectedIssues":

			out.Values[i] = ec._Annotation_suspectedIssues(ctx, field, obj)

		case "metadataLinks":

			out.Values[i] = ec._Annotation_metadataLinks(ctx, field, obj)

		case "taskId":

			out.Values[i] = ec._Annotation_taskId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "taskExecution":

			out.Values[i] = ec._Annotation_taskExecution(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "webhookConfigured":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Annotation_webhookConfigured(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var bootstrapSettingsImplementors = []string{"BootstrapSettings"}

func (ec *executionContext) _BootstrapSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIBootstrapSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, bootstrapSettingsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BootstrapSettings")
		case "clientDir":

			out.Values[i] = ec._BootstrapSettings_clientDir(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "communication":

			out.Values[i] = ec._BootstrapSettings_communication(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "env":

			out.Values[i] = ec._BootstrapSettings_env(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "jasperBinaryDir":

			out.Values[i] = ec._BootstrapSettings_jasperBinaryDir(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "jasperCredentialsPath":

			out.Values[i] = ec._BootstrapSettings_jasperCredentialsPath(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "method":

			out.Values[i] = ec._BootstrapSettings_method(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "preconditionScripts":

			out.Values[i] = ec._BootstrapSettings_preconditionScripts(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "resourceLimits":

			out.Values[i] = ec._BootstrapSettings_resourceLimits(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "rootDir":

			out.Values[i] = ec._BootstrapSettings_rootDir(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "serviceUser":

			out.Values[i] = ec._BootstrapSettings_serviceUser(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "shellPath":

			out.Values[i] = ec._BootstrapSettings_shellPath(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var buildImplementors = []string{"Build"}

func (ec *executionContext) _Build(ctx context.Context, sel ast.SelectionSet, obj *model.APIBuild) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, buildImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Build")
		case "id":

			out.Values[i] = ec._Build_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "actualMakespan":

			out.Values[i] = ec._Build_actualMakespan(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "buildVariant":

			out.Values[i] = ec._Build_buildVariant(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "predictedMakespan":

			out.Values[i] = ec._Build_predictedMakespan(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "status":

			out.Values[i] = ec._Build_status(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var buildBaronImplementors = []string{"BuildBaron"}

func (ec *executionContext) _BuildBaron(ctx context.Context, sel ast.SelectionSet, obj *BuildBaron) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, buildBaronImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BuildBaron")
		case "bbTicketCreationDefined":

			out.Values[i] = ec._BuildBaron_bbTicketCreationDefined(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "buildBaronConfigured":

			out.Values[i] = ec._BuildBaron_buildBaronConfigured(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "searchReturnInfo":

			out.Values[i] = ec._BuildBaron_searchReturnInfo(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var buildBaronSettingsImplementors = []string{"BuildBaronSettings"}

func (ec *executionContext) _BuildBaronSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIBuildBaronSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, buildBaronSettingsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BuildBaronSettings")
		case "bfSuggestionFeaturesURL":

			out.Values[i] = ec._BuildBaronSettings_bfSuggestionFeaturesURL(ctx, field, obj)

		case "bfSuggestionPassword":

			out.Values[i] = ec._BuildBaronSettings_bfSuggestionPassword(ctx, field, obj)

		case "bfSuggestionServer":

			out.Values[i] = ec._BuildBaronSettings_bfSuggestionServer(ctx, field, obj)

		case "bfSuggestionTimeoutSecs":

			out.Values[i] = ec._BuildBaronSettings_bfSuggestionTimeoutSecs(ctx, field, obj)

		case "bfSuggestionUsername":

			out.Values[i] = ec._BuildBaronSettings_bfSuggestionUsername(ctx, field, obj)

		case "ticketCreateProject":

			out.Values[i] = ec._BuildBaronSettings_ticketCreateProject(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ticketSearchProjects":

			out.Values[i] = ec._BuildBaronSettings_ticketSearchProjects(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var buildVariantTupleImplementors = []string{"BuildVariantTuple"}

func (ec *executionContext) _BuildVariantTuple(ctx context.Context, sel ast.SelectionSet, obj *task.BuildVariantTuple) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, buildVariantTupleImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("BuildVariantTuple")
		case "buildVariant":

			out.Values[i] = ec._BuildVariantTuple_buildVariant(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "displayName":

			out.Values[i] = ec._BuildVariantTuple_displayName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var childPatchAliasImplementors = []string{"ChildPatchAlias"}

func (ec *executionContext) _ChildPatchAlias(ctx context.Context, sel ast.SelectionSet, obj *model.APIChildPatchAlias) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, childPatchAliasImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ChildPatchAlias")
		case "alias":

			out.Values[i] = ec._ChildPatchAlias_alias(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "patchId":

			out.Values[i] = ec._ChildPatchAlias_patchId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var clientBinaryImplementors = []string{"ClientBinary"}

func (ec *executionContext) _ClientBinary(ctx context.Context, sel ast.SelectionSet, obj *model.APIClientBinary) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, clientBinaryImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ClientBinary")
		case "arch":

			out.Values[i] = ec._ClientBinary_arch(ctx, field, obj)

		case "displayName":

			out.Values[i] = ec._ClientBinary_displayName(ctx, field, obj)

		case "os":

			out.Values[i] = ec._ClientBinary_os(ctx, field, obj)

		case "url":

			out.Values[i] = ec._ClientBinary_url(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var clientConfigImplementors = []string{"ClientConfig"}

func (ec *executionContext) _ClientConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIClientConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, clientConfigImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ClientConfig")
		case "clientBinaries":

			out.Values[i] = ec._ClientConfig_clientBinaries(ctx, field, obj)

		case "latestRevision":

			out.Values[i] = ec._ClientConfig_latestRevision(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var cloudProviderConfigImplementors = []string{"CloudProviderConfig"}

func (ec *executionContext) _CloudProviderConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APICloudProviders) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, cloudProviderConfigImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CloudProviderConfig")
		case "aws":

			out.Values[i] = ec._CloudProviderConfig_aws(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var commitQueueImplementors = []string{"CommitQueue"}

func (ec *executionContext) _CommitQueue(ctx context.Context, sel ast.SelectionSet, obj *model.APICommitQueue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, commitQueueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CommitQueue")
		case "message":

			out.Values[i] = ec._CommitQueue_message(ctx, field, obj)

		case "owner":

			out.Values[i] = ec._CommitQueue_owner(ctx, field, obj)

		case "projectId":

			out.Values[i] = ec._CommitQueue_projectId(ctx, field, obj)

		case "queue":

			out.Values[i] = ec._CommitQueue_queue(ctx, field, obj)

		case "repo":

			out.Values[i] = ec._CommitQueue_repo(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var commitQueueItemImplementors = []string{"CommitQueueItem"}

func (ec *executionContext) _CommitQueueItem(ctx context.Context, sel ast.SelectionSet, obj *model.APICommitQueueItem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, commitQueueItemImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CommitQueueItem")
		case "enqueueTime":

			out.Values[i] = ec._CommitQueueItem_enqueueTime(ctx, field, obj)

		case "issue":

			out.Values[i] = ec._CommitQueueItem_issue(ctx, field, obj)

		case "modules":

			out.Values[i] = ec._CommitQueueItem_modules(ctx, field, obj)

		case "patch":

			out.Values[i] = ec._CommitQueueItem_patch(ctx, field, obj)

		case "source":

			out.Values[i] = ec._CommitQueueItem_source(ctx, field, obj)

		case "version":

			out.Values[i] = ec._CommitQueueItem_version(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var commitQueueParamsImplementors = []string{"CommitQueueParams"}

func (ec *executionContext) _CommitQueueParams(ctx context.Context, sel ast.SelectionSet, obj *model.APICommitQueueParams) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, commitQueueParamsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("CommitQueueParams")
		case "enabled":

			out.Values[i] = ec._CommitQueueParams_enabled(ctx, field, obj)

		case "mergeMethod":

			out.Values[i] = ec._CommitQueueParams_mergeMethod(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mergeQueue":

			out.Values[i] = ec._CommitQueueParams_mergeQueue(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "message":

			out.Values[i] = ec._CommitQueueParams_message(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var containerResourcesImplementors = []string{"ContainerResources"}

func (ec *executionContext) _ContainerResources(ctx context.Context, sel ast.SelectionSet, obj *model.APIContainerResources) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, containerResourcesImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ContainerResources")
		case "name":

			out.Values[i] = ec._ContainerResources_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cpu":

			out.Values[i] = ec._ContainerResources_cpu(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "memoryMb":

			out.Values[i] = ec._ContainerResources_memoryMb(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var deleteDistroPayloadImplementors = []string{"DeleteDistroPayload"}

func (ec *executionContext) _DeleteDistroPayload(ctx context.Context, sel ast.SelectionSet, obj *DeleteDistroPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, deleteDistroPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DeleteDistroPayload")
		case "deletedDistroId":

			out.Values[i] = ec._DeleteDistroPayload_deletedDistroId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var dependencyImplementors = []string{"Dependency"}

func (ec *executionContext) _Dependency(ctx context.Context, sel ast.SelectionSet, obj *Dependency) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dependencyImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Dependency")
		case "buildVariant":

			out.Values[i] = ec._Dependency_buildVariant(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "metStatus":

			out.Values[i] = ec._Dependency_metStatus(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec._Dependency_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "requiredStatus":

			out.Values[i] = ec._Dependency_requiredStatus(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "taskId":

			out.Values[i] = ec._Dependency_taskId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var dispatcherSettingsImplementors = []string{"DispatcherSettings"}

func (ec *executionContext) _DispatcherSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIDispatcherSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, dispatcherSettingsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DispatcherSettings")
		case "version":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._DispatcherSettings_version(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var distroImplementors = []string{"Distro"}

func (ec *executionContext) _Distro(ctx context.Context, sel ast.SelectionSet, obj *model.APIDistro) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, distroImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Distro")
		case "aliases":

			out.Values[i] = ec._Distro_aliases(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "arch":

			out.Values[i] = ec._Distro_arch(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "authorizedKeysFile":

			out.Values[i] = ec._Distro_authorizedKeysFile(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "bootstrapSettings":

			out.Values[i] = ec._Distro_bootstrapSettings(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "cloneMethod":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Distro_cloneMethod(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "containerPool":

			out.Values[i] = ec._Distro_containerPool(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "disabled":

			out.Values[i] = ec._Distro_disabled(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "disableShallowClone":

			out.Values[i] = ec._Distro_disableShallowClone(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "dispatcherSettings":

			out.Values[i] = ec._Distro_dispatcherSettings(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "expansions":

			out.Values[i] = ec._Distro_expansions(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "finderSettings":

			out.Values[i] = ec._Distro_finderSettings(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "homeVolumeSettings":

			out.Values[i] = ec._Distro_homeVolumeSettings(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "hostAllocatorSettings":

			out.Values[i] = ec._Distro_hostAllocatorSettings(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "iceCreamSettings":

			out.Values[i] = ec._Distro_iceCreamSettings(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "isCluster":

			out.Values[i] = ec._Distro_isCluster(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "isVirtualWorkStation":

			out.Values[i] = ec._Distro_isVirtualWorkStation(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "name":

			out.Values[i] = ec._Distro_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "note":

			out.Values[i] = ec._Distro_note(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "plannerSettings":

			out.Values[i] = ec._Distro_plannerSettings(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "provider":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Distro_provider(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "providerSettingsList":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Distro_providerSettingsList(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "setup":

			out.Values[i] = ec._Distro_setup(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "setupAsSudo":

			out.Values[i] = ec._Distro_setupAsSudo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "sshKey":

			out.Values[i] = ec._Distro_sshKey(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "sshOptions":

			out.Values[i] = ec._Distro_sshOptions(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "user":

			out.Values[i] = ec._Distro_user(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "userSpawnAllowed":

			out.Values[i] = ec._Distro_userSpawnAllowed(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "validProjects":

			out.Values[i] = ec._Distro_validProjects(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "workDir":

			out.Values[i] = ec._Distro_workDir(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var distroEventImplementors = []string{"DistroEvent"}

func (ec *executionContext) _DistroEvent(ctx context.Context, sel ast.SelectionSet, obj *DistroEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, distroEventImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DistroEvent")
		case "after":

			out.Values[i] = ec._DistroEvent_after(ctx, field, obj)

		case "before":

			out.Values[i] = ec._DistroEvent_before(ctx, field, obj)

		case "data":

			out.Values[i] = ec._DistroEvent_data(ctx, field, obj)

		case "timestamp":

			out.Values[i] = ec._DistroEvent_timestamp(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "user":

			out.Values[i] = ec._DistroEvent_user(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var distroEventsPayloadImplementors = []string{"DistroEventsPayload"}

func (ec *executionContext) _DistroEventsPayload(ctx context.Context, sel ast.SelectionSet, obj *DistroEventsPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, distroEventsPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DistroEventsPayload")
		case "count":

			out.Values[i] = ec._DistroEventsPayload_count(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "eventLogEntries":

			out.Values[i] = ec._DistroEventsPayload_eventLogEntries(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var distroInfoImplementors = []string{"DistroInfo"}

func (ec *executionContext) _DistroInfo(ctx context.Context, sel ast.SelectionSet, obj *model.DistroInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, distroInfoImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DistroInfo")
		case "id":

			out.Values[i] = ec._DistroInfo_id(ctx, field, obj)

		case "bootstrapMethod":

			out.Values[i] = ec._DistroInfo_bootstrapMethod(ctx, field, obj)

		case "isVirtualWorkStation":

			out.Values[i] = ec._DistroInfo_isVirtualWorkStation(ctx, field, obj)

		case "isWindows":

			out.Values[i] = ec._DistroInfo_isWindows(ctx, field, obj)

		case "user":

			out.Values[i] = ec._DistroInfo_user(ctx, field, obj)

		case "workDir":

			out.Values[i] = ec._DistroInfo_workDir(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var distroPermissionsImplementors = []string{"DistroPermissions"}

func (ec *executionContext) _DistroPermissions(ctx context.Context, sel ast.SelectionSet, obj *DistroPermissions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, distroPermissionsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("DistroPermissions")
		case "admin":

			out.Values[i] = ec._DistroPermissions_admin(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "edit":

			out.Values[i] = ec._DistroPermissions_edit(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "view":

			out.Values[i] = ec._DistroPermissions_view(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var eCSConfigImplementors = []string{"ECSConfig"}

func (ec *executionContext) _ECSConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIECSConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, eCSConfigImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ECSConfig")
		case "maxCPU":

			out.Values[i] = ec._ECSConfig_maxCPU(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "maxMemoryMb":

			out.Values[i] = ec._ECSConfig_maxMemoryMb(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var envVarImplementors = []string{"EnvVar"}

func (ec *executionContext) _EnvVar(ctx context.Context, sel ast.SelectionSet, obj *model.APIEnvVar) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, envVarImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("EnvVar")
		case "key":

			out.Values[i] = ec._EnvVar_key(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "value":

			out.Values[i] = ec._EnvVar_value(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var expansionImplementors = []string{"Expansion"}

func (ec *executionContext) _Expansion(ctx context.Context, sel ast.SelectionSet, obj *model.APIExpansion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, expansionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Expansion")
		case "key":

			out.Values[i] = ec._Expansion_key(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "value":

			out.Values[i] = ec._Expansion_value(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var externalLinkImplementors = []string{"ExternalLink"}

func (ec *executionContext) _ExternalLink(ctx context.Context, sel ast.SelectionSet, obj *model.APIExternalLink) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, externalLinkImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ExternalLink")
		case "displayName":

			out.Values[i] = ec._ExternalLink_displayName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "requesters":

			out.Values[i] = ec._ExternalLink_requesters(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "urlTemplate":

			out.Values[i] = ec._ExternalLink_urlTemplate(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var externalLinkForMetadataImplementors = []string{"ExternalLinkForMetadata"}

func (ec *executionContext) _ExternalLinkForMetadata(ctx context.Context, sel ast.SelectionSet, obj *ExternalLinkForMetadata) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, externalLinkForMetadataImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ExternalLinkForMetadata")
		case "url":

			out.Values[i] = ec._ExternalLinkForMetadata_url(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "displayName":

			out.Values[i] = ec._ExternalLinkForMetadata_displayName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var fileImplementors = []string{"File"}

func (ec *executionContext) _File(ctx context.Context, sel ast.SelectionSet, obj *model.APIFile) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fileImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("File")
		case "link":

			out.Values[i] = ec._File_link(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec._File_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "visibility":

			out.Values[i] = ec._File_visibility(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var fileDiffImplementors = []string{"FileDiff"}

func (ec *executionContext) _FileDiff(ctx context.Context, sel ast.SelectionSet, obj *model.FileDiff) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, fileDiffImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FileDiff")
		case "additions":

			out.Values[i] = ec._FileDiff_additions(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deletions":

			out.Values[i] = ec._FileDiff_deletions(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec._FileDiff_description(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "diffLink":

			out.Values[i] = ec._FileDiff_diffLink(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "fileName":

			out.Values[i] = ec._FileDiff_fileName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var finderSettingsImplementors = []string{"FinderSettings"}

func (ec *executionContext) _FinderSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIFinderSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, finderSettingsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FinderSettings")
		case "version":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._FinderSettings_version(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var generalSubscriptionImplementors = []string{"GeneralSubscription"}

func (ec *executionContext) _GeneralSubscription(ctx context.Context, sel ast.SelectionSet, obj *model.APISubscription) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, generalSubscriptionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GeneralSubscription")
		case "id":

			out.Values[i] = ec._GeneralSubscription_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ownerType":

			out.Values[i] = ec._GeneralSubscription_ownerType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "regexSelectors":

			out.Values[i] = ec._GeneralSubscription_regexSelectors(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "resourceType":

			out.Values[i] = ec._GeneralSubscription_resourceType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "selectors":

			out.Values[i] = ec._GeneralSubscription_selectors(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "subscriber":

			out.Values[i] = ec._GeneralSubscription_subscriber(ctx, field, obj)

		case "trigger":

			out.Values[i] = ec._GeneralSubscription_trigger(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "triggerData":

			out.Values[i] = ec._GeneralSubscription_triggerData(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var gitTagImplementors = []string{"GitTag"}

func (ec *executionContext) _GitTag(ctx context.Context, sel ast.SelectionSet, obj *model.APIGitTag) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, gitTagImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GitTag")
		case "tag":

			out.Values[i] = ec._GitTag_tag(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "pusher":

			out.Values[i] = ec._GitTag_pusher(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubCheckSubscriberImplementors = []string{"GithubCheckSubscriber"}

func (ec *executionContext) _GithubCheckSubscriber(ctx context.Context, sel ast.SelectionSet, obj *model.APIGithubCheckSubscriber) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubCheckSubscriberImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubCheckSubscriber")
		case "owner":

			out.Values[i] = ec._GithubCheckSubscriber_owner(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ref":

			out.Values[i] = ec._GithubCheckSubscriber_ref(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "repo":

			out.Values[i] = ec._GithubCheckSubscriber_repo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubPRSubscriberImplementors = []string{"GithubPRSubscriber"}

func (ec *executionContext) _GithubPRSubscriber(ctx context.Context, sel ast.SelectionSet, obj *model.APIGithubPRSubscriber) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubPRSubscriberImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubPRSubscriber")
		case "owner":

			out.Values[i] = ec._GithubPRSubscriber_owner(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "prNumber":

			out.Values[i] = ec._GithubPRSubscriber_prNumber(ctx, field, obj)

		case "ref":

			out.Values[i] = ec._GithubPRSubscriber_ref(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "repo":

			out.Values[i] = ec._GithubPRSubscriber_repo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubProjectConflictsImplementors = []string{"GithubProjectConflicts"}

func (ec *executionContext) _GithubProjectConflicts(ctx context.Context, sel ast.SelectionSet, obj *model1.GithubProjectConflicts) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubProjectConflictsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubProjectConflicts")
		case "commitCheckIdentifiers":

			out.Values[i] = ec._GithubProjectConflicts_commitCheckIdentifiers(ctx, field, obj)

		case "commitQueueIdentifiers":

			out.Values[i] = ec._GithubProjectConflicts_commitQueueIdentifiers(ctx, field, obj)

		case "prTestingIdentifiers":

			out.Values[i] = ec._GithubProjectConflicts_prTestingIdentifiers(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var githubUserImplementors = []string{"GithubUser"}

func (ec *executionContext) _GithubUser(ctx context.Context, sel ast.SelectionSet, obj *model.APIGithubUser) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, githubUserImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GithubUser")
		case "lastKnownAs":

			out.Values[i] = ec._GithubUser_lastKnownAs(ctx, field, obj)

		case "uid":

			out.Values[i] = ec._GithubUser_uid(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var groupedBuildVariantImplementors = []string{"GroupedBuildVariant"}

func (ec *executionContext) _GroupedBuildVariant(ctx context.Context, sel ast.SelectionSet, obj *GroupedBuildVariant) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupedBuildVariantImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GroupedBuildVariant")
		case "displayName":

			out.Values[i] = ec._GroupedBuildVariant_displayName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "tasks":

			out.Values[i] = ec._GroupedBuildVariant_tasks(ctx, field, obj)

		case "variant":

			out.Values[i] = ec._GroupedBuildVariant_variant(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var groupedFilesImplementors = []string{"GroupedFiles"}

func (ec *executionContext) _GroupedFiles(ctx context.Context, sel ast.SelectionSet, obj *GroupedFiles) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupedFilesImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GroupedFiles")
		case "files":

			out.Values[i] = ec._GroupedFiles_files(ctx, field, obj)

		case "taskName":

			out.Values[i] = ec._GroupedFiles_taskName(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var groupedProjectsImplementors = []string{"GroupedProjects"}

func (ec *executionContext) _GroupedProjects(ctx context.Context, sel ast.SelectionSet, obj *GroupedProjects) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupedProjectsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GroupedProjects")
		case "groupDisplayName":

			out.Values[i] = ec._GroupedProjects_groupDisplayName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "projects":

			out.Values[i] = ec._GroupedProjects_projects(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "repo":

			out.Values[i] = ec._GroupedProjects_repo(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var groupedTaskStatusCountImplementors = []string{"GroupedTaskStatusCount"}

func (ec *executionContext) _GroupedTaskStatusCount(ctx context.Context, sel ast.SelectionSet, obj *task.GroupedTaskStatusCount) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, groupedTaskStatusCountImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GroupedTaskStatusCount")
		case "displayName":

			out.Values[i] = ec._GroupedTaskStatusCount_displayName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "statusCounts":

			out.Values[i] = ec._GroupedTaskStatusCount_statusCounts(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "variant":

			out.Values[i] = ec._GroupedTaskStatusCount_variant(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var homeVolumeSettingsImplementors = []string{"HomeVolumeSettings"}

func (ec *executionContext) _HomeVolumeSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIHomeVolumeSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, homeVolumeSettingsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HomeVolumeSettings")
		case "formatCommand":

			out.Values[i] = ec._HomeVolumeSettings_formatCommand(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var hostImplementors = []string{"Host"}

func (ec *executionContext) _Host(ctx context.Context, sel ast.SelectionSet, obj *model.APIHost) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hostImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Host")
		case "id":

			out.Values[i] = ec._Host_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "availabilityZone":

			out.Values[i] = ec._Host_availabilityZone(ctx, field, obj)

		case "ami":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_ami(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "displayName":

			out.Values[i] = ec._Host_displayName(ctx, field, obj)

		case "distro":

			out.Values[i] = ec._Host_distro(ctx, field, obj)

		case "distroId":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_distroId(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "elapsed":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_elapsed(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "expiration":

			out.Values[i] = ec._Host_expiration(ctx, field, obj)

		case "hostUrl":

			out.Values[i] = ec._Host_hostUrl(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "homeVolume":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_homeVolume(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "homeVolumeID":

			out.Values[i] = ec._Host_homeVolumeID(ctx, field, obj)

		case "instanceType":

			out.Values[i] = ec._Host_instanceType(ctx, field, obj)

		case "instanceTags":

			out.Values[i] = ec._Host_instanceTags(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "lastCommunicationTime":

			out.Values[i] = ec._Host_lastCommunicationTime(ctx, field, obj)

		case "noExpiration":

			out.Values[i] = ec._Host_noExpiration(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "provider":

			out.Values[i] = ec._Host_provider(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "runningTask":

			out.Values[i] = ec._Host_runningTask(ctx, field, obj)

		case "startedBy":

			out.Values[i] = ec._Host_startedBy(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "status":

			out.Values[i] = ec._Host_status(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "tag":

			out.Values[i] = ec._Host_tag(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "totalIdleTime":

			out.Values[i] = ec._Host_totalIdleTime(ctx, field, obj)

		case "uptime":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_uptime(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "user":

			out.Values[i] = ec._Host_user(ctx, field, obj)

		case "volumes":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Host_volumes(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var hostAllocatorSettingsImplementors = []string{"HostAllocatorSettings"}

func (ec *executionContext) _HostAllocatorSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIHostAllocatorSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hostAllocatorSettingsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HostAllocatorSettings")
		case "acceptableHostIdleTime":

			out.Values[i] = ec._HostAllocatorSettings_acceptableHostIdleTime(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "feedbackRule":

			out.Values[i] = ec._HostAllocatorSettings_feedbackRule(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "futureHostFraction":

			out.Values[i] = ec._HostAllocatorSettings_futureHostFraction(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "hostsOverallocatedRule":

			out.Values[i] = ec._HostAllocatorSettings_hostsOverallocatedRule(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "maximumHosts":

			out.Values[i] = ec._HostAllocatorSettings_maximumHosts(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "minimumHosts":

			out.Values[i] = ec._HostAllocatorSettings_minimumHosts(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "roundingRule":

			out.Values[i] = ec._HostAllocatorSettings_roundingRule(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "version":

			out.Values[i] = ec._HostAllocatorSettings_version(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var hostEventLogDataImplementors = []string{"HostEventLogData"}

func (ec *executionContext) _HostEventLogData(ctx context.Context, sel ast.SelectionSet, obj *model.HostAPIEventData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hostEventLogDataImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HostEventLogData")
		case "agentBuild":

			out.Values[i] = ec._HostEventLogData_agentBuild(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "agentRevision":

			out.Values[i] = ec._HostEventLogData_agentRevision(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "duration":

			out.Values[i] = ec._HostEventLogData_duration(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "execution":

			out.Values[i] = ec._HostEventLogData_execution(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "hostname":

			out.Values[i] = ec._HostEventLogData_hostname(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "jasperRevision":

			out.Values[i] = ec._HostEventLogData_jasperRevision(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "logs":

			out.Values[i] = ec._HostEventLogData_logs(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "monitorOp":

			out.Values[i] = ec._HostEventLogData_monitorOp(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "newStatus":

			out.Values[i] = ec._HostEventLogData_newStatus(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "oldStatus":

			out.Values[i] = ec._HostEventLogData_oldStatus(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "provisioningMethod":

			out.Values[i] = ec._HostEventLogData_provisioningMethod(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "successful":

			out.Values[i] = ec._HostEventLogData_successful(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "taskId":

			out.Values[i] = ec._HostEventLogData_taskId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "taskPid":

			out.Values[i] = ec._HostEventLogData_taskPid(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "taskStatus":

			out.Values[i] = ec._HostEventLogData_taskStatus(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "user":

			out.Values[i] = ec._HostEventLogData_user(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var hostEventLogEntryImplementors = []string{"HostEventLogEntry"}

func (ec *executionContext) _HostEventLogEntry(ctx context.Context, sel ast.SelectionSet, obj *model.HostAPIEventLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hostEventLogEntryImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HostEventLogEntry")
		case "id":

			out.Values[i] = ec._HostEventLogEntry_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "data":

			out.Values[i] = ec._HostEventLogEntry_data(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "eventType":

			out.Values[i] = ec._HostEventLogEntry_eventType(ctx, field, obj)

		case "processedAt":

			out.Values[i] = ec._HostEventLogEntry_processedAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "resourceId":

			out.Values[i] = ec._HostEventLogEntry_resourceId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "resourceType":

			out.Values[i] = ec._HostEventLogEntry_resourceType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "timestamp":

			out.Values[i] = ec._HostEventLogEntry_timestamp(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var hostEventsImplementors = []string{"HostEvents"}

func (ec *executionContext) _HostEvents(ctx context.Context, sel ast.SelectionSet, obj *HostEvents) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hostEventsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HostEvents")
		case "count":

			out.Values[i] = ec._HostEvents_count(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "eventLogEntries":

			out.Values[i] = ec._HostEvents_eventLogEntries(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var hostsResponseImplementors = []string{"HostsResponse"}

func (ec *executionContext) _HostsResponse(ctx context.Context, sel ast.SelectionSet, obj *HostsResponse) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, hostsResponseImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("HostsResponse")
		case "filteredHostsCount":

			out.Values[i] = ec._HostsResponse_filteredHostsCount(ctx, field, obj)

		case "hosts":

			out.Values[i] = ec._HostsResponse_hosts(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalHostsCount":

			out.Values[i] = ec._HostsResponse_totalHostsCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var iceCreamSettingsImplementors = []string{"IceCreamSettings"}

func (ec *executionContext) _IceCreamSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIIceCreamSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, iceCreamSettingsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IceCreamSettings")
		case "configPath":

			out.Values[i] = ec._IceCreamSettings_configPath(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "schedulerHost":

			out.Values[i] = ec._IceCreamSettings_schedulerHost(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var instanceTagImplementors = []string{"InstanceTag"}

func (ec *executionContext) _InstanceTag(ctx context.Context, sel ast.SelectionSet, obj *host.Tag) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, instanceTagImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("InstanceTag")
		case "canBeModified":

			out.Values[i] = ec._InstanceTag_canBeModified(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "key":

			out.Values[i] = ec._InstanceTag_key(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "value":

			out.Values[i] = ec._InstanceTag_value(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var issueLinkImplementors = []string{"IssueLink"}

func (ec *executionContext) _IssueLink(ctx context.Context, sel ast.SelectionSet, obj *model.APIIssueLink) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, issueLinkImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("IssueLink")
		case "confidenceScore":

			out.Values[i] = ec._IssueLink_confidenceScore(ctx, field, obj)

		case "issueKey":

			out.Values[i] = ec._IssueLink_issueKey(ctx, field, obj)

		case "jiraTicket":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._IssueLink_jiraTicket(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "source":

			out.Values[i] = ec._IssueLink_source(ctx, field, obj)

		case "url":

			out.Values[i] = ec._IssueLink_url(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var jiraConfigImplementors = []string{"JiraConfig"}

func (ec *executionContext) _JiraConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIJiraConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jiraConfigImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JiraConfig")
		case "host":

			out.Values[i] = ec._JiraConfig_host(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var jiraFieldImplementors = []string{"JiraField"}

func (ec *executionContext) _JiraField(ctx context.Context, sel ast.SelectionSet, obj *model.APIJiraField) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jiraFieldImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JiraField")
		case "displayText":

			out.Values[i] = ec._JiraField_displayText(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "field":

			out.Values[i] = ec._JiraField_field(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var jiraIssueSubscriberImplementors = []string{"JiraIssueSubscriber"}

func (ec *executionContext) _JiraIssueSubscriber(ctx context.Context, sel ast.SelectionSet, obj *model.APIJIRAIssueSubscriber) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jiraIssueSubscriberImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JiraIssueSubscriber")
		case "issueType":

			out.Values[i] = ec._JiraIssueSubscriber_issueType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "project":

			out.Values[i] = ec._JiraIssueSubscriber_project(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var jiraStatusImplementors = []string{"JiraStatus"}

func (ec *executionContext) _JiraStatus(ctx context.Context, sel ast.SelectionSet, obj *thirdparty.JiraStatus) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jiraStatusImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JiraStatus")
		case "id":

			out.Values[i] = ec._JiraStatus_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec._JiraStatus_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var jiraTicketImplementors = []string{"JiraTicket"}

func (ec *executionContext) _JiraTicket(ctx context.Context, sel ast.SelectionSet, obj *thirdparty.JiraTicket) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, jiraTicketImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("JiraTicket")
		case "fields":

			out.Values[i] = ec._JiraTicket_fields(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "key":

			out.Values[i] = ec._JiraTicket_key(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var logMessageImplementors = []string{"LogMessage"}

func (ec *executionContext) _LogMessage(ctx context.Context, sel ast.SelectionSet, obj *apimodels.LogMessage) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, logMessageImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LogMessage")
		case "message":

			out.Values[i] = ec._LogMessage_message(ctx, field, obj)

		case "severity":

			out.Values[i] = ec._LogMessage_severity(ctx, field, obj)

		case "timestamp":

			out.Values[i] = ec._LogMessage_timestamp(ctx, field, obj)

		case "type":

			out.Values[i] = ec._LogMessage_type(ctx, field, obj)

		case "version":

			out.Values[i] = ec._LogMessage_version(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var logkeeperBuildImplementors = []string{"LogkeeperBuild"}

func (ec *executionContext) _LogkeeperBuild(ctx context.Context, sel ast.SelectionSet, obj *plank.Build) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, logkeeperBuildImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LogkeeperBuild")
		case "id":

			out.Values[i] = ec._LogkeeperBuild_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "builder":

			out.Values[i] = ec._LogkeeperBuild_builder(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "buildNum":

			out.Values[i] = ec._LogkeeperBuild_buildNum(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "taskId":

			out.Values[i] = ec._LogkeeperBuild_taskId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "taskExecution":

			out.Values[i] = ec._LogkeeperBuild_taskExecution(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "tests":

			out.Values[i] = ec._LogkeeperBuild_tests(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "task":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._LogkeeperBuild_task(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var logkeeperTestImplementors = []string{"LogkeeperTest"}

func (ec *executionContext) _LogkeeperTest(ctx context.Context, sel ast.SelectionSet, obj *plank.Test) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, logkeeperTestImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("LogkeeperTest")
		case "id":

			out.Values[i] = ec._LogkeeperTest_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec._LogkeeperTest_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "buildId":

			out.Values[i] = ec._LogkeeperTest_buildId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "taskId":

			out.Values[i] = ec._LogkeeperTest_taskId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "taskExecution":

			out.Values[i] = ec._LogkeeperTest_taskExecution(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "phase":

			out.Values[i] = ec._LogkeeperTest_phase(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "command":

			out.Values[i] = ec._LogkeeperTest_command(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mainlineCommitVersionImplementors = []string{"MainlineCommitVersion"}

func (ec *executionContext) _MainlineCommitVersion(ctx context.Context, sel ast.SelectionSet, obj *MainlineCommitVersion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mainlineCommitVersionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MainlineCommitVersion")
		case "rolledUpVersions":

			out.Values[i] = ec._MainlineCommitVersion_rolledUpVersions(ctx, field, obj)

		case "version":

			out.Values[i] = ec._MainlineCommitVersion_version(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mainlineCommitsImplementors = []string{"MainlineCommits"}

func (ec *executionContext) _MainlineCommits(ctx context.Context, sel ast.SelectionSet, obj *MainlineCommits) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mainlineCommitsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MainlineCommits")
		case "nextPageOrderNumber":

			out.Values[i] = ec._MainlineCommits_nextPageOrderNumber(ctx, field, obj)

		case "prevPageOrderNumber":

			out.Values[i] = ec._MainlineCommits_prevPageOrderNumber(ctx, field, obj)

		case "versions":

			out.Values[i] = ec._MainlineCommits_versions(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var manifestImplementors = []string{"Manifest"}

func (ec *executionContext) _Manifest(ctx context.Context, sel ast.SelectionSet, obj *Manifest) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, manifestImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Manifest")
		case "id":

			out.Values[i] = ec._Manifest_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "branch":

			out.Values[i] = ec._Manifest_branch(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isBase":

			out.Values[i] = ec._Manifest_isBase(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "moduleOverrides":

			out.Values[i] = ec._Manifest_moduleOverrides(ctx, field, obj)

		case "modules":

			out.Values[i] = ec._Manifest_modules(ctx, field, obj)

		case "project":

			out.Values[i] = ec._Manifest_project(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "revision":

			out.Values[i] = ec._Manifest_revision(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var metadataLinkImplementors = []string{"MetadataLink"}

func (ec *executionContext) _MetadataLink(ctx context.Context, sel ast.SelectionSet, obj *model.APIMetadataLink) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, metadataLinkImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MetadataLink")
		case "url":

			out.Values[i] = ec._MetadataLink_url(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "text":

			out.Values[i] = ec._MetadataLink_text(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "source":

			out.Values[i] = ec._MetadataLink_source(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var moduleImplementors = []string{"Module"}

func (ec *executionContext) _Module(ctx context.Context, sel ast.SelectionSet, obj *model.APIModule) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, moduleImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Module")
		case "issue":

			out.Values[i] = ec._Module_issue(ctx, field, obj)

		case "module":

			out.Values[i] = ec._Module_module(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var moduleCodeChangeImplementors = []string{"ModuleCodeChange"}

func (ec *executionContext) _ModuleCodeChange(ctx context.Context, sel ast.SelectionSet, obj *model.APIModulePatch) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, moduleCodeChangeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ModuleCodeChange")
		case "branchName":

			out.Values[i] = ec._ModuleCodeChange_branchName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "fileDiffs":

			out.Values[i] = ec._ModuleCodeChange_fileDiffs(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "htmlLink":

			out.Values[i] = ec._ModuleCodeChange_htmlLink(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "rawLink":

			out.Values[i] = ec._ModuleCodeChange_rawLink(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var mutationImplementors = []string{"Mutation"}

func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, mutationImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Mutation",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "bbCreateTicket":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_bbCreateTicket(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "addAnnotationIssue":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addAnnotationIssue(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "editAnnotationNote":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_editAnnotationNote(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "moveAnnotationIssue":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_moveAnnotationIssue(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "removeAnnotationIssue":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_removeAnnotationIssue(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "setAnnotationMetadataLinks":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setAnnotationMetadataLinks(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteDistro":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteDistro(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "copyDistro":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_copyDistro(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createDistro":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createDistro(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "saveDistro":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_saveDistro(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "reprovisionToNew":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_reprovisionToNew(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "restartJasper":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_restartJasper(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateHostStatus":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateHostStatus(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "enqueuePatch":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_enqueuePatch(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "setPatchVisibility":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setPatchVisibility(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "schedulePatch":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_schedulePatch(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "schedulePatchTasks":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_schedulePatchTasks(ctx, field)
			})

		case "scheduleUndispatchedBaseTasks":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_scheduleUndispatchedBaseTasks(ctx, field)
			})

		case "setPatchPriority":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setPatchPriority(ctx, field)
			})

		case "unschedulePatchTasks":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_unschedulePatchTasks(ctx, field)
			})

		case "addFavoriteProject":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_addFavoriteProject(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "attachProjectToNewRepo":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_attachProjectToNewRepo(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "attachProjectToRepo":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_attachProjectToRepo(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createProject":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createProject(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "copyProject":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_copyProject(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deactivateStepbackTask":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deactivateStepbackTask(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultSectionToRepo":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_defaultSectionToRepo(ctx, field)
			})

		case "deleteProject":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteProject(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "detachProjectFromRepo":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_detachProjectFromRepo(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "forceRepotrackerRun":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_forceRepotrackerRun(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "promoteVarsToRepo":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_promoteVarsToRepo(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "removeFavoriteProject":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_removeFavoriteProject(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "saveProjectSettingsForSection":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_saveProjectSettingsForSection(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "saveRepoSettingsForSection":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_saveRepoSettingsForSection(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "attachVolumeToHost":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_attachVolumeToHost(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "detachVolumeFromHost":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_detachVolumeFromHost(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "editSpawnHost":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_editSpawnHost(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "migrateVolume":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_migrateVolume(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "spawnHost":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_spawnHost(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "spawnVolume":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_spawnVolume(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "removeVolume":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_removeVolume(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateSpawnHostStatus":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateSpawnHostStatus(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateVolume":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateVolume(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "abortTask":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_abortTask(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "overrideTaskDependencies":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_overrideTaskDependencies(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "restartTask":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_restartTask(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "scheduleTasks":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_scheduleTasks(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "setTaskPriority":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_setTaskPriority(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "unscheduleTask":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_unscheduleTask(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "clearMySubscriptions":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_clearMySubscriptions(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "createPublicKey":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_createPublicKey(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deleteSubscriptions":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_deleteSubscriptions(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "removePublicKey":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_removePublicKey(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "saveSubscription":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_saveSubscription(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updatePublicKey":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updatePublicKey(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "updateUserSettings":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_updateUserSettings(ctx, field)
			})

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "removeItemFromCommitQueue":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_removeItemFromCommitQueue(ctx, field)
			})

		case "restartVersions":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Mutation_restartVersions(ctx, field)
			})

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var newDistroPayloadImplementors = []string{"NewDistroPayload"}

func (ec *executionContext) _NewDistroPayload(ctx context.Context, sel ast.SelectionSet, obj *NewDistroPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, newDistroPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NewDistroPayload")
		case "newDistroId":

			out.Values[i] = ec._NewDistroPayload_newDistroId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var noteImplementors = []string{"Note"}

func (ec *executionContext) _Note(ctx context.Context, sel ast.SelectionSet, obj *model.APINote) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, noteImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Note")
		case "message":

			out.Values[i] = ec._Note_message(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "source":

			out.Values[i] = ec._Note_source(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var notificationsImplementors = []string{"Notifications"}

func (ec *executionContext) _Notifications(ctx context.Context, sel ast.SelectionSet, obj *model.APINotificationPreferences) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, notificationsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Notifications")
		case "buildBreak":

			out.Values[i] = ec._Notifications_buildBreak(ctx, field, obj)

		case "buildBreakId":

			out.Values[i] = ec._Notifications_buildBreakId(ctx, field, obj)

		case "commitQueue":

			out.Values[i] = ec._Notifications_commitQueue(ctx, field, obj)

		case "commitQueueId":

			out.Values[i] = ec._Notifications_commitQueueId(ctx, field, obj)

		case "patchFinish":

			out.Values[i] = ec._Notifications_patchFinish(ctx, field, obj)

		case "patchFinishId":

			out.Values[i] = ec._Notifications_patchFinishId(ctx, field, obj)

		case "patchFirstFailure":

			out.Values[i] = ec._Notifications_patchFirstFailure(ctx, field, obj)

		case "patchFirstFailureId":

			out.Values[i] = ec._Notifications_patchFirstFailureId(ctx, field, obj)

		case "spawnHostExpiration":

			out.Values[i] = ec._Notifications_spawnHostExpiration(ctx, field, obj)

		case "spawnHostExpirationId":

			out.Values[i] = ec._Notifications_spawnHostExpirationId(ctx, field, obj)

		case "spawnHostOutcome":

			out.Values[i] = ec._Notifications_spawnHostOutcome(ctx, field, obj)

		case "spawnHostOutcomeId":

			out.Values[i] = ec._Notifications_spawnHostOutcomeId(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var oomTrackerInfoImplementors = []string{"OomTrackerInfo"}

func (ec *executionContext) _OomTrackerInfo(ctx context.Context, sel ast.SelectionSet, obj *model.APIOomTrackerInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, oomTrackerInfoImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OomTrackerInfo")
		case "detected":

			out.Values[i] = ec._OomTrackerInfo_detected(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "pids":

			out.Values[i] = ec._OomTrackerInfo_pids(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var parameterImplementors = []string{"Parameter"}

func (ec *executionContext) _Parameter(ctx context.Context, sel ast.SelectionSet, obj *model.APIParameter) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, parameterImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Parameter")
		case "key":

			out.Values[i] = ec._Parameter_key(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "value":

			out.Values[i] = ec._Parameter_value(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var parsleyFilterImplementors = []string{"ParsleyFilter"}

func (ec *executionContext) _ParsleyFilter(ctx context.Context, sel ast.SelectionSet, obj *model.APIParsleyFilter) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, parsleyFilterImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ParsleyFilter")
		case "expression":

			out.Values[i] = ec._ParsleyFilter_expression(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "caseSensitive":

			out.Values[i] = ec._ParsleyFilter_caseSensitive(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "exactMatch":

			out.Values[i] = ec._ParsleyFilter_exactMatch(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var patchImplementors = []string{"Patch"}

func (ec *executionContext) _Patch(ctx context.Context, sel ast.SelectionSet, obj *model.APIPatch) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, patchImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Patch")
		case "id":

			out.Values[i] = ec._Patch_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "activated":

			out.Values[i] = ec._Patch_activated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "alias":

			out.Values[i] = ec._Patch_alias(ctx, field, obj)

		case "author":

			out.Values[i] = ec._Patch_author(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "authorDisplayName":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_authorDisplayName(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "baseTaskStatuses":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_baseTaskStatuses(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "builds":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_builds(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "canEnqueueToCommitQueue":

			out.Values[i] = ec._Patch_canEnqueueToCommitQueue(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "childPatchAliases":

			out.Values[i] = ec._Patch_childPatchAliases(ctx, field, obj)

		case "childPatches":

			out.Values[i] = ec._Patch_childPatches(ctx, field, obj)

		case "commitQueuePosition":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_commitQueuePosition(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "createTime":

			out.Values[i] = ec._Patch_createTime(ctx, field, obj)

		case "description":

			out.Values[i] = ec._Patch_description(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "duration":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_duration(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "githash":

			out.Values[i] = ec._Patch_githash(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "hidden":

			out.Values[i] = ec._Patch_hidden(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "moduleCodeChanges":

			out.Values[i] = ec._Patch_moduleCodeChanges(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "parameters":

			out.Values[i] = ec._Patch_parameters(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "patchNumber":

			out.Values[i] = ec._Patch_patchNumber(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "patchTriggerAliases":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_patchTriggerAliases(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "project":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_project(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "projectID":

			out.Values[i] = ec._Patch_projectID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "projectIdentifier":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_projectIdentifier(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "projectMetadata":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_projectMetadata(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "status":

			out.Values[i] = ec._Patch_status(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "taskCount":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_taskCount(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "tasks":

			out.Values[i] = ec._Patch_tasks(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "taskStatuses":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_taskStatuses(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "time":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_time(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "variants":

			out.Values[i] = ec._Patch_variants(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "variantsTasks":

			out.Values[i] = ec._Patch_variantsTasks(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "versionFull":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Patch_versionFull(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var patchDurationImplementors = []string{"PatchDuration"}

func (ec *executionContext) _PatchDuration(ctx context.Context, sel ast.SelectionSet, obj *PatchDuration) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, patchDurationImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PatchDuration")
		case "makespan":

			out.Values[i] = ec._PatchDuration_makespan(ctx, field, obj)

		case "time":

			out.Values[i] = ec._PatchDuration_time(ctx, field, obj)

		case "timeTaken":

			out.Values[i] = ec._PatchDuration_timeTaken(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var patchProjectImplementors = []string{"PatchProject"}

func (ec *executionContext) _PatchProject(ctx context.Context, sel ast.SelectionSet, obj *PatchProject) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, patchProjectImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PatchProject")
		case "variants":

			out.Values[i] = ec._PatchProject_variants(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var patchTimeImplementors = []string{"PatchTime"}

func (ec *executionContext) _PatchTime(ctx context.Context, sel ast.SelectionSet, obj *PatchTime) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, patchTimeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PatchTime")
		case "finished":

			out.Values[i] = ec._PatchTime_finished(ctx, field, obj)

		case "started":

			out.Values[i] = ec._PatchTime_started(ctx, field, obj)

		case "submittedAt":

			out.Values[i] = ec._PatchTime_submittedAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var patchTriggerAliasImplementors = []string{"PatchTriggerAlias"}

func (ec *executionContext) _PatchTriggerAlias(ctx context.Context, sel ast.SelectionSet, obj *model.APIPatchTriggerDefinition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, patchTriggerAliasImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PatchTriggerAlias")
		case "alias":

			out.Values[i] = ec._PatchTriggerAlias_alias(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "childProjectId":

			out.Values[i] = ec._PatchTriggerAlias_childProjectId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "childProjectIdentifier":

			out.Values[i] = ec._PatchTriggerAlias_childProjectIdentifier(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "parentAsModule":

			out.Values[i] = ec._PatchTriggerAlias_parentAsModule(ctx, field, obj)

		case "status":

			out.Values[i] = ec._PatchTriggerAlias_status(ctx, field, obj)

		case "taskSpecifiers":

			out.Values[i] = ec._PatchTriggerAlias_taskSpecifiers(ctx, field, obj)

		case "variantsTasks":

			out.Values[i] = ec._PatchTriggerAlias_variantsTasks(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var patchesImplementors = []string{"Patches"}

func (ec *executionContext) _Patches(ctx context.Context, sel ast.SelectionSet, obj *Patches) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, patchesImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Patches")
		case "filteredPatchCount":

			out.Values[i] = ec._Patches_filteredPatchCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "patches":

			out.Values[i] = ec._Patches_patches(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var periodicBuildImplementors = []string{"PeriodicBuild"}

func (ec *executionContext) _PeriodicBuild(ctx context.Context, sel ast.SelectionSet, obj *model.APIPeriodicBuildDefinition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, periodicBuildImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PeriodicBuild")
		case "id":

			out.Values[i] = ec._PeriodicBuild_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "alias":

			out.Values[i] = ec._PeriodicBuild_alias(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "configFile":

			out.Values[i] = ec._PeriodicBuild_configFile(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "intervalHours":

			out.Values[i] = ec._PeriodicBuild_intervalHours(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "cron":

			out.Values[i] = ec._PeriodicBuild_cron(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "message":

			out.Values[i] = ec._PeriodicBuild_message(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "nextRunTime":

			out.Values[i] = ec._PeriodicBuild_nextRunTime(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var permissionsImplementors = []string{"Permissions"}

func (ec *executionContext) _Permissions(ctx context.Context, sel ast.SelectionSet, obj *Permissions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, permissionsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Permissions")
		case "canCreateDistro":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Permissions_canCreateDistro(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "canCreateProject":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Permissions_canCreateProject(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "distroPermissions":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Permissions_distroPermissions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "userId":

			out.Values[i] = ec._Permissions_userId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var plannerSettingsImplementors = []string{"PlannerSettings"}

func (ec *executionContext) _PlannerSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIPlannerSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, plannerSettingsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PlannerSettings")
		case "commitQueueFactor":

			out.Values[i] = ec._PlannerSettings_commitQueueFactor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "expectedRuntimeFactor":

			out.Values[i] = ec._PlannerSettings_expectedRuntimeFactor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "generateTaskFactor":

			out.Values[i] = ec._PlannerSettings_generateTaskFactor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "groupVersions":

			out.Values[i] = ec._PlannerSettings_groupVersions(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "mainlineTimeInQueueFactor":

			out.Values[i] = ec._PlannerSettings_mainlineTimeInQueueFactor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "patchFactor":

			out.Values[i] = ec._PlannerSettings_patchFactor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "patchTimeInQueueFactor":

			out.Values[i] = ec._PlannerSettings_patchTimeInQueueFactor(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "targetTime":

			out.Values[i] = ec._PlannerSettings_targetTime(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "version":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PlannerSettings_version(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var podImplementors = []string{"Pod"}

func (ec *executionContext) _Pod(ctx context.Context, sel ast.SelectionSet, obj *model.APIPod) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, podImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Pod")
		case "events":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Pod_events(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "id":

			out.Values[i] = ec._Pod_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "status":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Pod_status(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "task":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Pod_task(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "taskContainerCreationOpts":

			out.Values[i] = ec._Pod_taskContainerCreationOpts(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "type":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Pod_type(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var podEventLogDataImplementors = []string{"PodEventLogData"}

func (ec *executionContext) _PodEventLogData(ctx context.Context, sel ast.SelectionSet, obj *model.PodAPIEventData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, podEventLogDataImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PodEventLogData")
		case "oldStatus":

			out.Values[i] = ec._PodEventLogData_oldStatus(ctx, field, obj)

		case "newStatus":

			out.Values[i] = ec._PodEventLogData_newStatus(ctx, field, obj)

		case "reason":

			out.Values[i] = ec._PodEventLogData_reason(ctx, field, obj)

		case "taskID":

			out.Values[i] = ec._PodEventLogData_taskID(ctx, field, obj)

		case "taskExecution":

			out.Values[i] = ec._PodEventLogData_taskExecution(ctx, field, obj)

		case "taskStatus":

			out.Values[i] = ec._PodEventLogData_taskStatus(ctx, field, obj)

		case "task":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._PodEventLogData_task(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var podEventLogEntryImplementors = []string{"PodEventLogEntry"}

func (ec *executionContext) _PodEventLogEntry(ctx context.Context, sel ast.SelectionSet, obj *model.PodAPIEventLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, podEventLogEntryImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PodEventLogEntry")
		case "id":

			out.Values[i] = ec._PodEventLogEntry_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "data":

			out.Values[i] = ec._PodEventLogEntry_data(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "eventType":

			out.Values[i] = ec._PodEventLogEntry_eventType(ctx, field, obj)

		case "processedAt":

			out.Values[i] = ec._PodEventLogEntry_processedAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "resourceId":

			out.Values[i] = ec._PodEventLogEntry_resourceId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "resourceType":

			out.Values[i] = ec._PodEventLogEntry_resourceType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "timestamp":

			out.Values[i] = ec._PodEventLogEntry_timestamp(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var podEventsImplementors = []string{"PodEvents"}

func (ec *executionContext) _PodEvents(ctx context.Context, sel ast.SelectionSet, obj *PodEvents) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, podEventsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PodEvents")
		case "count":

			out.Values[i] = ec._PodEvents_count(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "eventLogEntries":

			out.Values[i] = ec._PodEvents_eventLogEntries(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var preconditionScriptImplementors = []string{"PreconditionScript"}

func (ec *executionContext) _PreconditionScript(ctx context.Context, sel ast.SelectionSet, obj *model.APIPreconditionScript) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, preconditionScriptImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PreconditionScript")
		case "path":

			out.Values[i] = ec._PreconditionScript_path(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "script":

			out.Values[i] = ec._PreconditionScript_script(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var projectImplementors = []string{"Project"}

func (ec *executionContext) _Project(ctx context.Context, sel ast.SelectionSet, obj *model.APIProjectRef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Project")
		case "id":

			out.Values[i] = ec._Project_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "admins":

			out.Values[i] = ec._Project_admins(ctx, field, obj)

		case "banner":

			out.Values[i] = ec._Project_banner(ctx, field, obj)

		case "batchTime":

			out.Values[i] = ec._Project_batchTime(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "branch":

			out.Values[i] = ec._Project_branch(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "buildBaronSettings":

			out.Values[i] = ec._Project_buildBaronSettings(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "commitQueue":

			out.Values[i] = ec._Project_commitQueue(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "containerSizeDefinitions":

			out.Values[i] = ec._Project_containerSizeDefinitions(ctx, field, obj)

		case "deactivatePrevious":

			out.Values[i] = ec._Project_deactivatePrevious(ctx, field, obj)

		case "disabledStatsCache":

			out.Values[i] = ec._Project_disabledStatsCache(ctx, field, obj)

		case "dispatchingDisabled":

			out.Values[i] = ec._Project_dispatchingDisabled(ctx, field, obj)

		case "displayName":

			out.Values[i] = ec._Project_displayName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "enabled":

			out.Values[i] = ec._Project_enabled(ctx, field, obj)

		case "externalLinks":

			out.Values[i] = ec._Project_externalLinks(ctx, field, obj)

		case "githubChecksEnabled":

			out.Values[i] = ec._Project_githubChecksEnabled(ctx, field, obj)

		case "githubTriggerAliases":

			out.Values[i] = ec._Project_githubTriggerAliases(ctx, field, obj)

		case "gitTagAuthorizedTeams":

			out.Values[i] = ec._Project_gitTagAuthorizedTeams(ctx, field, obj)

		case "gitTagAuthorizedUsers":

			out.Values[i] = ec._Project_gitTagAuthorizedUsers(ctx, field, obj)

		case "gitTagVersionsEnabled":

			out.Values[i] = ec._Project_gitTagVersionsEnabled(ctx, field, obj)

		case "hidden":

			out.Values[i] = ec._Project_hidden(ctx, field, obj)

		case "identifier":

			out.Values[i] = ec._Project_identifier(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "isFavorite":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Project_isFavorite(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "manualPrTestingEnabled":

			out.Values[i] = ec._Project_manualPrTestingEnabled(ctx, field, obj)

		case "notifyOnBuildFailure":

			out.Values[i] = ec._Project_notifyOnBuildFailure(ctx, field, obj)

		case "owner":

			out.Values[i] = ec._Project_owner(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "parsleyFilters":

			out.Values[i] = ec._Project_parsleyFilters(ctx, field, obj)

		case "patches":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Project_patches(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "patchingDisabled":

			out.Values[i] = ec._Project_patchingDisabled(ctx, field, obj)

		case "patchTriggerAliases":

			out.Values[i] = ec._Project_patchTriggerAliases(ctx, field, obj)

		case "perfEnabled":

			out.Values[i] = ec._Project_perfEnabled(ctx, field, obj)

		case "periodicBuilds":

			out.Values[i] = ec._Project_periodicBuilds(ctx, field, obj)

		case "private":

			out.Values[i] = ec._Project_private(ctx, field, obj)

		case "projectHealthView":

			out.Values[i] = ec._Project_projectHealthView(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "prTestingEnabled":

			out.Values[i] = ec._Project_prTestingEnabled(ctx, field, obj)

		case "remotePath":

			out.Values[i] = ec._Project_remotePath(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "repo":

			out.Values[i] = ec._Project_repo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "repoRefId":

			out.Values[i] = ec._Project_repoRefId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "repotrackerDisabled":

			out.Values[i] = ec._Project_repotrackerDisabled(ctx, field, obj)

		case "restricted":

			out.Values[i] = ec._Project_restricted(ctx, field, obj)

		case "spawnHostScriptPath":

			out.Values[i] = ec._Project_spawnHostScriptPath(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "stepbackDisabled":

			out.Values[i] = ec._Project_stepbackDisabled(ctx, field, obj)

		case "taskAnnotationSettings":

			out.Values[i] = ec._Project_taskAnnotationSettings(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "taskSync":

			out.Values[i] = ec._Project_taskSync(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "tracksPushEvents":

			out.Values[i] = ec._Project_tracksPushEvents(ctx, field, obj)

		case "triggers":

			out.Values[i] = ec._Project_triggers(ctx, field, obj)

		case "versionControlEnabled":

			out.Values[i] = ec._Project_versionControlEnabled(ctx, field, obj)

		case "workstationConfig":

			out.Values[i] = ec._Project_workstationConfig(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var projectAliasImplementors = []string{"ProjectAlias"}

func (ec *executionContext) _ProjectAlias(ctx context.Context, sel ast.SelectionSet, obj *model.APIProjectAlias) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectAliasImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectAlias")
		case "id":

			out.Values[i] = ec._ProjectAlias_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "alias":

			out.Values[i] = ec._ProjectAlias_alias(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec._ProjectAlias_description(ctx, field, obj)

		case "gitTag":

			out.Values[i] = ec._ProjectAlias_gitTag(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "remotePath":

			out.Values[i] = ec._ProjectAlias_remotePath(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "task":

			out.Values[i] = ec._ProjectAlias_task(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "taskTags":

			out.Values[i] = ec._ProjectAlias_taskTags(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "variant":

			out.Values[i] = ec._ProjectAlias_variant(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "variantTags":

			out.Values[i] = ec._ProjectAlias_variantTags(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "parameters":

			out.Values[i] = ec._ProjectAlias_parameters(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var projectBannerImplementors = []string{"ProjectBanner"}

func (ec *executionContext) _ProjectBanner(ctx context.Context, sel ast.SelectionSet, obj *model.APIProjectBanner) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectBannerImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectBanner")
		case "text":

			out.Values[i] = ec._ProjectBanner_text(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "theme":

			out.Values[i] = ec._ProjectBanner_theme(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var projectBuildVariantImplementors = []string{"ProjectBuildVariant"}

func (ec *executionContext) _ProjectBuildVariant(ctx context.Context, sel ast.SelectionSet, obj *ProjectBuildVariant) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectBuildVariantImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectBuildVariant")
		case "displayName":

			out.Values[i] = ec._ProjectBuildVariant_displayName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec._ProjectBuildVariant_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "tasks":

			out.Values[i] = ec._ProjectBuildVariant_tasks(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var projectEventLogEntryImplementors = []string{"ProjectEventLogEntry"}

func (ec *executionContext) _ProjectEventLogEntry(ctx context.Context, sel ast.SelectionSet, obj *model.APIProjectEvent) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectEventLogEntryImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectEventLogEntry")
		case "after":

			out.Values[i] = ec._ProjectEventLogEntry_after(ctx, field, obj)

		case "before":

			out.Values[i] = ec._ProjectEventLogEntry_before(ctx, field, obj)

		case "timestamp":

			out.Values[i] = ec._ProjectEventLogEntry_timestamp(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "user":

			out.Values[i] = ec._ProjectEventLogEntry_user(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var projectEventSettingsImplementors = []string{"ProjectEventSettings"}

func (ec *executionContext) _ProjectEventSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIProjectEventSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectEventSettingsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectEventSettings")
		case "aliases":

			out.Values[i] = ec._ProjectEventSettings_aliases(ctx, field, obj)

		case "githubWebhooksEnabled":

			out.Values[i] = ec._ProjectEventSettings_githubWebhooksEnabled(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "projectRef":

			out.Values[i] = ec._ProjectEventSettings_projectRef(ctx, field, obj)

		case "subscriptions":

			out.Values[i] = ec._ProjectEventSettings_subscriptions(ctx, field, obj)

		case "vars":

			out.Values[i] = ec._ProjectEventSettings_vars(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var projectEventsImplementors = []string{"ProjectEvents"}

func (ec *executionContext) _ProjectEvents(ctx context.Context, sel ast.SelectionSet, obj *ProjectEvents) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectEventsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectEvents")
		case "count":

			out.Values[i] = ec._ProjectEvents_count(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "eventLogEntries":

			out.Values[i] = ec._ProjectEvents_eventLogEntries(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var projectSettingsImplementors = []string{"ProjectSettings"}

func (ec *executionContext) _ProjectSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIProjectSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectSettingsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectSettings")
		case "aliases":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProjectSettings_aliases(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "githubWebhooksEnabled":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProjectSettings_githubWebhooksEnabled(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "projectRef":

			out.Values[i] = ec._ProjectSettings_projectRef(ctx, field, obj)

		case "subscriptions":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProjectSettings_subscriptions(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "vars":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProjectSettings_vars(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var projectVarsImplementors = []string{"ProjectVars"}

func (ec *executionContext) _ProjectVars(ctx context.Context, sel ast.SelectionSet, obj *model.APIProjectVars) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, projectVarsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ProjectVars")
		case "adminOnlyVars":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProjectVars_adminOnlyVars(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "privateVars":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._ProjectVars_privateVars(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "vars":

			out.Values[i] = ec._ProjectVars_vars(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var publicKeyImplementors = []string{"PublicKey"}

func (ec *executionContext) _PublicKey(ctx context.Context, sel ast.SelectionSet, obj *model.APIPubKey) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, publicKeyImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("PublicKey")
		case "key":

			out.Values[i] = ec._PublicKey_key(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec._PublicKey_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var queryImplementors = []string{"Query"}

func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, queryImplementors)
	ctx = graphql.WithFieldContext(ctx, &graphql.FieldContext{
		Object: "Query",
	})

	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		innerCtx := graphql.WithRootFieldContext(ctx, &graphql.RootFieldContext{
			Object: field.Name,
			Field:  field,
		})

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "bbGetCreatedTickets":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_bbGetCreatedTickets(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "buildBaron":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_buildBaron(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "awsRegions":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_awsRegions(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "clientConfig":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_clientConfig(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "instanceTypes":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_instanceTypes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "spruceConfig":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_spruceConfig(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "subnetAvailabilityZones":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_subnetAvailabilityZones(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "distro":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_distro(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "distroEvents":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_distroEvents(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "distros":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_distros(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "distroTaskQueue":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_distroTaskQueue(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "host":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_host(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "hostEvents":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_hostEvents(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "hosts":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_hosts(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "taskQueueDistros":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_taskQueueDistros(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "pod":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_pod(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "patch":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_patch(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "githubProjectConflicts":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_githubProjectConflicts(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "project":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_project(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "projects":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_projects(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "projectEvents":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_projectEvents(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "projectSettings":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_projectSettings(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "repoEvents":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_repoEvents(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "repoSettings":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_repoSettings(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "viewableProjectRefs":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_viewableProjectRefs(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "myHosts":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_myHosts(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "myVolumes":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_myVolumes(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "logkeeperBuildMetadata":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_logkeeperBuildMetadata(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "task":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_task(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "taskAllExecutions":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_taskAllExecutions(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "taskTestSample":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_taskTestSample(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "myPublicKeys":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_myPublicKeys(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "user":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_user(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "userConfig":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userConfig(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "userSettings":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_userSettings(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "commitQueue":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_commitQueue(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "buildVariantsForTaskName":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_buildVariantsForTaskName(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "mainlineCommits":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_mainlineCommits(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "taskNamesForBuildVariant":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_taskNamesForBuildVariant(ctx, field)
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "hasVersion":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_hasVersion(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "version":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Query_version(ctx, field)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			rrm := func(ctx context.Context) graphql.Marshaler {
				return ec.OperationContext.RootResolverMiddleware(ctx, innerFunc)
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return rrm(innerCtx)
			})
		case "__type":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___type(ctx, field)
			})

		case "__schema":

			out.Values[i] = ec.OperationContext.RootResolverMiddleware(innerCtx, func(ctx context.Context) (res graphql.Marshaler) {
				return ec._Query___schema(ctx, field)
			})

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repoCommitQueueParamsImplementors = []string{"RepoCommitQueueParams"}

func (ec *executionContext) _RepoCommitQueueParams(ctx context.Context, sel ast.SelectionSet, obj *model.APICommitQueueParams) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repoCommitQueueParamsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepoCommitQueueParams")
		case "enabled":

			out.Values[i] = ec._RepoCommitQueueParams_enabled(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mergeMethod":

			out.Values[i] = ec._RepoCommitQueueParams_mergeMethod(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mergeQueue":

			out.Values[i] = ec._RepoCommitQueueParams_mergeQueue(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "message":

			out.Values[i] = ec._RepoCommitQueueParams_message(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repoRefImplementors = []string{"RepoRef"}

func (ec *executionContext) _RepoRef(ctx context.Context, sel ast.SelectionSet, obj *model.APIProjectRef) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repoRefImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepoRef")
		case "id":

			out.Values[i] = ec._RepoRef_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "admins":

			out.Values[i] = ec._RepoRef_admins(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "batchTime":

			out.Values[i] = ec._RepoRef_batchTime(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "buildBaronSettings":

			out.Values[i] = ec._RepoRef_buildBaronSettings(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "commitQueue":

			out.Values[i] = ec._RepoRef_commitQueue(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "containerSizeDefinitions":

			out.Values[i] = ec._RepoRef_containerSizeDefinitions(ctx, field, obj)

		case "deactivatePrevious":

			out.Values[i] = ec._RepoRef_deactivatePrevious(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "disabledStatsCache":

			out.Values[i] = ec._RepoRef_disabledStatsCache(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "dispatchingDisabled":

			out.Values[i] = ec._RepoRef_dispatchingDisabled(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "displayName":

			out.Values[i] = ec._RepoRef_displayName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "enabled":

			out.Values[i] = ec._RepoRef_enabled(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "githubChecksEnabled":

			out.Values[i] = ec._RepoRef_githubChecksEnabled(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "githubTriggerAliases":

			out.Values[i] = ec._RepoRef_githubTriggerAliases(ctx, field, obj)

		case "gitTagAuthorizedTeams":

			out.Values[i] = ec._RepoRef_gitTagAuthorizedTeams(ctx, field, obj)

		case "gitTagAuthorizedUsers":

			out.Values[i] = ec._RepoRef_gitTagAuthorizedUsers(ctx, field, obj)

		case "gitTagVersionsEnabled":

			out.Values[i] = ec._RepoRef_gitTagVersionsEnabled(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "manualPrTestingEnabled":

			out.Values[i] = ec._RepoRef_manualPrTestingEnabled(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "notifyOnBuildFailure":

			out.Values[i] = ec._RepoRef_notifyOnBuildFailure(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "owner":

			out.Values[i] = ec._RepoRef_owner(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "patchingDisabled":

			out.Values[i] = ec._RepoRef_patchingDisabled(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "patchTriggerAliases":

			out.Values[i] = ec._RepoRef_patchTriggerAliases(ctx, field, obj)

		case "perfEnabled":

			out.Values[i] = ec._RepoRef_perfEnabled(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "periodicBuilds":

			out.Values[i] = ec._RepoRef_periodicBuilds(ctx, field, obj)

		case "private":

			out.Values[i] = ec._RepoRef_private(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "prTestingEnabled":

			out.Values[i] = ec._RepoRef_prTestingEnabled(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "remotePath":

			out.Values[i] = ec._RepoRef_remotePath(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "repo":

			out.Values[i] = ec._RepoRef_repo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "repotrackerDisabled":

			out.Values[i] = ec._RepoRef_repotrackerDisabled(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "restricted":

			out.Values[i] = ec._RepoRef_restricted(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "spawnHostScriptPath":

			out.Values[i] = ec._RepoRef_spawnHostScriptPath(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "stepbackDisabled":

			out.Values[i] = ec._RepoRef_stepbackDisabled(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "taskAnnotationSettings":

			out.Values[i] = ec._RepoRef_taskAnnotationSettings(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "taskSync":

			out.Values[i] = ec._RepoRef_taskSync(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "tracksPushEvents":

			out.Values[i] = ec._RepoRef_tracksPushEvents(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "triggers":

			out.Values[i] = ec._RepoRef_triggers(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "versionControlEnabled":

			out.Values[i] = ec._RepoRef_versionControlEnabled(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "workstationConfig":

			out.Values[i] = ec._RepoRef_workstationConfig(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "externalLinks":

			out.Values[i] = ec._RepoRef_externalLinks(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repoSettingsImplementors = []string{"RepoSettings"}

func (ec *executionContext) _RepoSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIProjectSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repoSettingsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepoSettings")
		case "aliases":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RepoSettings_aliases(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "githubWebhooksEnabled":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RepoSettings_githubWebhooksEnabled(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "projectRef":

			out.Values[i] = ec._RepoSettings_projectRef(ctx, field, obj)

		case "subscriptions":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RepoSettings_subscriptions(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "vars":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._RepoSettings_vars(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repoTaskSyncOptionsImplementors = []string{"RepoTaskSyncOptions"}

func (ec *executionContext) _RepoTaskSyncOptions(ctx context.Context, sel ast.SelectionSet, obj *model.APITaskSyncOptions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repoTaskSyncOptionsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepoTaskSyncOptions")
		case "configEnabled":

			out.Values[i] = ec._RepoTaskSyncOptions_configEnabled(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "patchEnabled":

			out.Values[i] = ec._RepoTaskSyncOptions_patchEnabled(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var repoWorkstationConfigImplementors = []string{"RepoWorkstationConfig"}

func (ec *executionContext) _RepoWorkstationConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIWorkstationConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, repoWorkstationConfigImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RepoWorkstationConfig")
		case "gitClone":

			out.Values[i] = ec._RepoWorkstationConfig_gitClone(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "setupCommands":

			out.Values[i] = ec._RepoWorkstationConfig_setupCommands(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var resourceLimitsImplementors = []string{"ResourceLimits"}

func (ec *executionContext) _ResourceLimits(ctx context.Context, sel ast.SelectionSet, obj *model.APIResourceLimits) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, resourceLimitsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResourceLimits")
		case "lockedMemoryKb":

			out.Values[i] = ec._ResourceLimits_lockedMemoryKb(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "numFiles":

			out.Values[i] = ec._ResourceLimits_numFiles(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "numProcesses":

			out.Values[i] = ec._ResourceLimits_numProcesses(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "numTasks":

			out.Values[i] = ec._ResourceLimits_numTasks(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "virtualMemoryKb":

			out.Values[i] = ec._ResourceLimits_virtualMemoryKb(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var saveDistroPayloadImplementors = []string{"SaveDistroPayload"}

func (ec *executionContext) _SaveDistroPayload(ctx context.Context, sel ast.SelectionSet, obj *SaveDistroPayload) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, saveDistroPayloadImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SaveDistroPayload")
		case "distro":

			out.Values[i] = ec._SaveDistroPayload_distro(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "hostCount":

			out.Values[i] = ec._SaveDistroPayload_hostCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var searchReturnInfoImplementors = []string{"SearchReturnInfo"}

func (ec *executionContext) _SearchReturnInfo(ctx context.Context, sel ast.SelectionSet, obj *thirdparty.SearchReturnInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, searchReturnInfoImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SearchReturnInfo")
		case "featuresURL":

			out.Values[i] = ec._SearchReturnInfo_featuresURL(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "issues":

			out.Values[i] = ec._SearchReturnInfo_issues(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "search":

			out.Values[i] = ec._SearchReturnInfo_search(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "source":

			out.Values[i] = ec._SearchReturnInfo_source(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var selectorImplementors = []string{"Selector"}

func (ec *executionContext) _Selector(ctx context.Context, sel ast.SelectionSet, obj *model.APISelector) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, selectorImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Selector")
		case "data":

			out.Values[i] = ec._Selector_data(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":

			out.Values[i] = ec._Selector_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var slackConfigImplementors = []string{"SlackConfig"}

func (ec *executionContext) _SlackConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APISlackConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, slackConfigImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SlackConfig")
		case "name":

			out.Values[i] = ec._SlackConfig_name(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var sourceImplementors = []string{"Source"}

func (ec *executionContext) _Source(ctx context.Context, sel ast.SelectionSet, obj *model.APISource) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, sourceImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Source")
		case "author":

			out.Values[i] = ec._Source_author(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "requester":

			out.Values[i] = ec._Source_requester(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "time":

			out.Values[i] = ec._Source_time(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var spawnHostConfigImplementors = []string{"SpawnHostConfig"}

func (ec *executionContext) _SpawnHostConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APISpawnHostConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, spawnHostConfigImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SpawnHostConfig")
		case "spawnHostsPerUser":

			out.Values[i] = ec._SpawnHostConfig_spawnHostsPerUser(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "unexpirableHostsPerUser":

			out.Values[i] = ec._SpawnHostConfig_unexpirableHostsPerUser(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "unexpirableVolumesPerUser":

			out.Values[i] = ec._SpawnHostConfig_unexpirableVolumesPerUser(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var spruceConfigImplementors = []string{"SpruceConfig"}

func (ec *executionContext) _SpruceConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIAdminSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, spruceConfigImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SpruceConfig")
		case "banner":

			out.Values[i] = ec._SpruceConfig_banner(ctx, field, obj)

		case "bannerTheme":

			out.Values[i] = ec._SpruceConfig_bannerTheme(ctx, field, obj)

		case "githubOrgs":

			out.Values[i] = ec._SpruceConfig_githubOrgs(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "jira":

			out.Values[i] = ec._SpruceConfig_jira(ctx, field, obj)

		case "providers":

			out.Values[i] = ec._SpruceConfig_providers(ctx, field, obj)

		case "spawnHost":

			out.Values[i] = ec._SpruceConfig_spawnHost(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ui":

			out.Values[i] = ec._SpruceConfig_ui(ctx, field, obj)

		case "slack":

			out.Values[i] = ec._SpruceConfig_slack(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var statusCountImplementors = []string{"StatusCount"}

func (ec *executionContext) _StatusCount(ctx context.Context, sel ast.SelectionSet, obj *task.StatusCount) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, statusCountImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StatusCount")
		case "count":

			out.Values[i] = ec._StatusCount_count(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "status":

			out.Values[i] = ec._StatusCount_status(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var subscriberImplementors = []string{"Subscriber"}

func (ec *executionContext) _Subscriber(ctx context.Context, sel ast.SelectionSet, obj *Subscriber) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subscriberImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Subscriber")
		case "emailSubscriber":

			out.Values[i] = ec._Subscriber_emailSubscriber(ctx, field, obj)

		case "githubCheckSubscriber":

			out.Values[i] = ec._Subscriber_githubCheckSubscriber(ctx, field, obj)

		case "githubPRSubscriber":

			out.Values[i] = ec._Subscriber_githubPRSubscriber(ctx, field, obj)

		case "jiraCommentSubscriber":

			out.Values[i] = ec._Subscriber_jiraCommentSubscriber(ctx, field, obj)

		case "jiraIssueSubscriber":

			out.Values[i] = ec._Subscriber_jiraIssueSubscriber(ctx, field, obj)

		case "slackSubscriber":

			out.Values[i] = ec._Subscriber_slackSubscriber(ctx, field, obj)

		case "webhookSubscriber":

			out.Values[i] = ec._Subscriber_webhookSubscriber(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var subscriberWrapperImplementors = []string{"SubscriberWrapper"}

func (ec *executionContext) _SubscriberWrapper(ctx context.Context, sel ast.SelectionSet, obj *model.APISubscriber) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, subscriberWrapperImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SubscriberWrapper")
		case "subscriber":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._SubscriberWrapper_subscriber(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "type":

			out.Values[i] = ec._SubscriberWrapper_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var taskImplementors = []string{"Task"}

func (ec *executionContext) _Task(ctx context.Context, sel ast.SelectionSet, obj *model.APITask) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Task")
		case "id":

			out.Values[i] = ec._Task_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "aborted":

			out.Values[i] = ec._Task_aborted(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "abortInfo":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_abortInfo(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "activated":

			out.Values[i] = ec._Task_activated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "activatedBy":

			out.Values[i] = ec._Task_activatedBy(ctx, field, obj)

		case "activatedTime":

			out.Values[i] = ec._Task_activatedTime(ctx, field, obj)

		case "ami":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_ami(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "annotation":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_annotation(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "baseStatus":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_baseStatus(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "baseTask":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_baseTask(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "blocked":

			out.Values[i] = ec._Task_blocked(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "buildId":

			out.Values[i] = ec._Task_buildId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "buildVariant":

			out.Values[i] = ec._Task_buildVariant(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "buildVariantDisplayName":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_buildVariantDisplayName(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "canAbort":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_canAbort(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "canDisable":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_canDisable(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "canModifyAnnotation":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_canModifyAnnotation(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "canOverrideDependencies":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_canOverrideDependencies(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "canRestart":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_canRestart(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "canSchedule":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_canSchedule(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "canSetPriority":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_canSetPriority(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "canSync":

			out.Values[i] = ec._Task_canSync(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "canUnschedule":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_canUnschedule(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "containerAllocatedTime":

			out.Values[i] = ec._Task_containerAllocatedTime(ctx, field, obj)

		case "createTime":

			out.Values[i] = ec._Task_createTime(ctx, field, obj)

		case "dependsOn":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_dependsOn(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "details":

			out.Values[i] = ec._Task_details(ctx, field, obj)

		case "dispatchTime":

			out.Values[i] = ec._Task_dispatchTime(ctx, field, obj)

		case "displayName":

			out.Values[i] = ec._Task_displayName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "displayOnly":

			out.Values[i] = ec._Task_displayOnly(ctx, field, obj)

		case "displayTask":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_displayTask(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "distroId":

			out.Values[i] = ec._Task_distroId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "estimatedStart":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_estimatedStart(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "execution":

			out.Values[i] = ec._Task_execution(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "executionTasks":

			out.Values[i] = ec._Task_executionTasks(ctx, field, obj)

		case "executionTasksFull":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_executionTasksFull(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "expectedDuration":

			out.Values[i] = ec._Task_expectedDuration(ctx, field, obj)

		case "failedTestCount":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_failedTestCount(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "finishTime":

			out.Values[i] = ec._Task_finishTime(ctx, field, obj)

		case "generatedBy":

			out.Values[i] = ec._Task_generatedBy(ctx, field, obj)

		case "generatedByName":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_generatedByName(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "generateTask":

			out.Values[i] = ec._Task_generateTask(ctx, field, obj)

		case "hostId":

			out.Values[i] = ec._Task_hostId(ctx, field, obj)

		case "ingestTime":

			out.Values[i] = ec._Task_ingestTime(ctx, field, obj)

		case "isPerfPluginEnabled":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_isPerfPluginEnabled(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "latestExecution":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_latestExecution(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "logs":

			out.Values[i] = ec._Task_logs(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "minQueuePosition":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_minQueuePosition(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "order":

			out.Values[i] = ec._Task_order(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "patch":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_patch(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "patchNumber":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_patchNumber(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "pod":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_pod(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "priority":

			out.Values[i] = ec._Task_priority(ctx, field, obj)

		case "project":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_project(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "projectId":

			out.Values[i] = ec._Task_projectId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "projectIdentifier":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_projectIdentifier(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "requester":

			out.Values[i] = ec._Task_requester(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "resetWhenFinished":

			out.Values[i] = ec._Task_resetWhenFinished(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "revision":

			out.Values[i] = ec._Task_revision(ctx, field, obj)

		case "scheduledTime":

			out.Values[i] = ec._Task_scheduledTime(ctx, field, obj)

		case "spawnHostLink":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_spawnHostLink(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "startTime":

			out.Values[i] = ec._Task_startTime(ctx, field, obj)

		case "status":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_status(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "taskFiles":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_taskFiles(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "taskGroup":

			out.Values[i] = ec._Task_taskGroup(ctx, field, obj)

		case "taskGroupMaxHosts":

			out.Values[i] = ec._Task_taskGroupMaxHosts(ctx, field, obj)

		case "taskLogs":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_taskLogs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "tests":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_tests(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "timeTaken":

			out.Values[i] = ec._Task_timeTaken(ctx, field, obj)

		case "totalTestCount":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_totalTestCount(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "versionMetadata":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Task_versionMetadata(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var taskAnnotationSettingsImplementors = []string{"TaskAnnotationSettings"}

func (ec *executionContext) _TaskAnnotationSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APITaskAnnotationSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskAnnotationSettingsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskAnnotationSettings")
		case "fileTicketWebhook":

			out.Values[i] = ec._TaskAnnotationSettings_fileTicketWebhook(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "jiraCustomFields":

			out.Values[i] = ec._TaskAnnotationSettings_jiraCustomFields(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var taskContainerCreationOptsImplementors = []string{"TaskContainerCreationOpts"}

func (ec *executionContext) _TaskContainerCreationOpts(ctx context.Context, sel ast.SelectionSet, obj *model.APIPodTaskContainerCreationOptions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskContainerCreationOptsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskContainerCreationOpts")
		case "image":

			out.Values[i] = ec._TaskContainerCreationOpts_image(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "memoryMB":

			out.Values[i] = ec._TaskContainerCreationOpts_memoryMB(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "cpu":

			out.Values[i] = ec._TaskContainerCreationOpts_cpu(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "os":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TaskContainerCreationOpts_os(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "arch":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TaskContainerCreationOpts_arch(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "workingDir":

			out.Values[i] = ec._TaskContainerCreationOpts_workingDir(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var taskEndDetailImplementors = []string{"TaskEndDetail"}

func (ec *executionContext) _TaskEndDetail(ctx context.Context, sel ast.SelectionSet, obj *model.ApiTaskEndDetail) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskEndDetailImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskEndDetail")
		case "description":

			out.Values[i] = ec._TaskEndDetail_description(ctx, field, obj)

		case "oomTracker":

			out.Values[i] = ec._TaskEndDetail_oomTracker(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "status":

			out.Values[i] = ec._TaskEndDetail_status(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "timedOut":

			out.Values[i] = ec._TaskEndDetail_timedOut(ctx, field, obj)

		case "timeoutType":

			out.Values[i] = ec._TaskEndDetail_timeoutType(ctx, field, obj)

		case "type":

			out.Values[i] = ec._TaskEndDetail_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "traceID":

			out.Values[i] = ec._TaskEndDetail_traceID(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var taskEventLogDataImplementors = []string{"TaskEventLogData"}

func (ec *executionContext) _TaskEventLogData(ctx context.Context, sel ast.SelectionSet, obj *model.TaskEventData) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskEventLogDataImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskEventLogData")
		case "hostId":

			out.Values[i] = ec._TaskEventLogData_hostId(ctx, field, obj)

		case "podId":

			out.Values[i] = ec._TaskEventLogData_podId(ctx, field, obj)

		case "jiraIssue":

			out.Values[i] = ec._TaskEventLogData_jiraIssue(ctx, field, obj)

		case "jiraLink":

			out.Values[i] = ec._TaskEventLogData_jiraLink(ctx, field, obj)

		case "priority":

			out.Values[i] = ec._TaskEventLogData_priority(ctx, field, obj)

		case "status":

			out.Values[i] = ec._TaskEventLogData_status(ctx, field, obj)

		case "timestamp":

			out.Values[i] = ec._TaskEventLogData_timestamp(ctx, field, obj)

		case "userId":

			out.Values[i] = ec._TaskEventLogData_userId(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var taskEventLogEntryImplementors = []string{"TaskEventLogEntry"}

func (ec *executionContext) _TaskEventLogEntry(ctx context.Context, sel ast.SelectionSet, obj *model.TaskAPIEventLogEntry) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskEventLogEntryImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskEventLogEntry")
		case "id":

			out.Values[i] = ec._TaskEventLogEntry_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "data":

			out.Values[i] = ec._TaskEventLogEntry_data(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "eventType":

			out.Values[i] = ec._TaskEventLogEntry_eventType(ctx, field, obj)

		case "processedAt":

			out.Values[i] = ec._TaskEventLogEntry_processedAt(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "resourceId":

			out.Values[i] = ec._TaskEventLogEntry_resourceId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "resourceType":

			out.Values[i] = ec._TaskEventLogEntry_resourceType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "timestamp":

			out.Values[i] = ec._TaskEventLogEntry_timestamp(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var taskFilesImplementors = []string{"TaskFiles"}

func (ec *executionContext) _TaskFiles(ctx context.Context, sel ast.SelectionSet, obj *TaskFiles) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskFilesImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskFiles")
		case "fileCount":

			out.Values[i] = ec._TaskFiles_fileCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "groupedFiles":

			out.Values[i] = ec._TaskFiles_groupedFiles(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var taskInfoImplementors = []string{"TaskInfo"}

func (ec *executionContext) _TaskInfo(ctx context.Context, sel ast.SelectionSet, obj *model.TaskInfo) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskInfoImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskInfo")
		case "id":

			out.Values[i] = ec._TaskInfo_id(ctx, field, obj)

		case "name":

			out.Values[i] = ec._TaskInfo_name(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var taskLogLinksImplementors = []string{"TaskLogLinks"}

func (ec *executionContext) _TaskLogLinks(ctx context.Context, sel ast.SelectionSet, obj *model.LogLinks) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskLogLinksImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskLogLinks")
		case "agentLogLink":

			out.Values[i] = ec._TaskLogLinks_agentLogLink(ctx, field, obj)

		case "allLogLink":

			out.Values[i] = ec._TaskLogLinks_allLogLink(ctx, field, obj)

		case "eventLogLink":

			out.Values[i] = ec._TaskLogLinks_eventLogLink(ctx, field, obj)

		case "systemLogLink":

			out.Values[i] = ec._TaskLogLinks_systemLogLink(ctx, field, obj)

		case "taskLogLink":

			out.Values[i] = ec._TaskLogLinks_taskLogLink(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var taskLogsImplementors = []string{"TaskLogs"}

func (ec *executionContext) _TaskLogs(ctx context.Context, sel ast.SelectionSet, obj *TaskLogs) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskLogsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskLogs")
		case "agentLogs":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TaskLogs_agentLogs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "allLogs":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TaskLogs_allLogs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "defaultLogger":

			out.Values[i] = ec._TaskLogs_defaultLogger(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "eventLogs":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TaskLogs_eventLogs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "execution":

			out.Values[i] = ec._TaskLogs_execution(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "systemLogs":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TaskLogs_systemLogs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "taskId":

			out.Values[i] = ec._TaskLogs_taskId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "taskLogs":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TaskLogs_taskLogs(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var taskQueueDistroImplementors = []string{"TaskQueueDistro"}

func (ec *executionContext) _TaskQueueDistro(ctx context.Context, sel ast.SelectionSet, obj *TaskQueueDistro) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskQueueDistroImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskQueueDistro")
		case "id":

			out.Values[i] = ec._TaskQueueDistro_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "hostCount":

			out.Values[i] = ec._TaskQueueDistro_hostCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "taskCount":

			out.Values[i] = ec._TaskQueueDistro_taskCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var taskQueueItemImplementors = []string{"TaskQueueItem"}

func (ec *executionContext) _TaskQueueItem(ctx context.Context, sel ast.SelectionSet, obj *model.APITaskQueueItem) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskQueueItemImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskQueueItem")
		case "id":

			out.Values[i] = ec._TaskQueueItem_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "buildVariant":

			out.Values[i] = ec._TaskQueueItem_buildVariant(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "displayName":

			out.Values[i] = ec._TaskQueueItem_displayName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "expectedDuration":

			out.Values[i] = ec._TaskQueueItem_expectedDuration(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "priority":

			out.Values[i] = ec._TaskQueueItem_priority(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "project":

			out.Values[i] = ec._TaskQueueItem_project(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "requester":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TaskQueueItem_requester(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "activatedBy":

			out.Values[i] = ec._TaskQueueItem_activatedBy(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "revision":

			out.Values[i] = ec._TaskQueueItem_revision(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "version":

			out.Values[i] = ec._TaskQueueItem_version(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var taskSpecifierImplementors = []string{"TaskSpecifier"}

func (ec *executionContext) _TaskSpecifier(ctx context.Context, sel ast.SelectionSet, obj *model.APITaskSpecifier) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskSpecifierImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskSpecifier")
		case "patchAlias":

			out.Values[i] = ec._TaskSpecifier_patchAlias(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "taskRegex":

			out.Values[i] = ec._TaskSpecifier_taskRegex(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "variantRegex":

			out.Values[i] = ec._TaskSpecifier_variantRegex(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var taskStatsImplementors = []string{"TaskStats"}

func (ec *executionContext) _TaskStats(ctx context.Context, sel ast.SelectionSet, obj *task.TaskStats) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskStatsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskStats")
		case "counts":

			out.Values[i] = ec._TaskStats_counts(ctx, field, obj)

		case "eta":

			out.Values[i] = ec._TaskStats_eta(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var taskSyncOptionsImplementors = []string{"TaskSyncOptions"}

func (ec *executionContext) _TaskSyncOptions(ctx context.Context, sel ast.SelectionSet, obj *model.APITaskSyncOptions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskSyncOptionsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskSyncOptions")
		case "configEnabled":

			out.Values[i] = ec._TaskSyncOptions_configEnabled(ctx, field, obj)

		case "patchEnabled":

			out.Values[i] = ec._TaskSyncOptions_patchEnabled(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var taskTestResultImplementors = []string{"TaskTestResult"}

func (ec *executionContext) _TaskTestResult(ctx context.Context, sel ast.SelectionSet, obj *TaskTestResult) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskTestResultImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskTestResult")
		case "testResults":

			out.Values[i] = ec._TaskTestResult_testResults(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalTestCount":

			out.Values[i] = ec._TaskTestResult_totalTestCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "filteredTestCount":

			out.Values[i] = ec._TaskTestResult_filteredTestCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var taskTestResultSampleImplementors = []string{"TaskTestResultSample"}

func (ec *executionContext) _TaskTestResultSample(ctx context.Context, sel ast.SelectionSet, obj *TaskTestResultSample) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, taskTestResultSampleImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TaskTestResultSample")
		case "execution":

			out.Values[i] = ec._TaskTestResultSample_execution(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "matchingFailedTestNames":

			out.Values[i] = ec._TaskTestResultSample_matchingFailedTestNames(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "taskId":

			out.Values[i] = ec._TaskTestResultSample_taskId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "totalTestCount":

			out.Values[i] = ec._TaskTestResultSample_totalTestCount(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var testLogImplementors = []string{"TestLog"}

func (ec *executionContext) _TestLog(ctx context.Context, sel ast.SelectionSet, obj *model.TestLogs) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, testLogImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TestLog")
		case "lineNum":

			out.Values[i] = ec._TestLog_lineNum(ctx, field, obj)

		case "url":

			out.Values[i] = ec._TestLog_url(ctx, field, obj)

		case "urlLobster":

			out.Values[i] = ec._TestLog_urlLobster(ctx, field, obj)

		case "urlParsley":

			out.Values[i] = ec._TestLog_urlParsley(ctx, field, obj)

		case "urlRaw":

			out.Values[i] = ec._TestLog_urlRaw(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var testResultImplementors = []string{"TestResult"}

func (ec *executionContext) _TestResult(ctx context.Context, sel ast.SelectionSet, obj *model.APITest) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, testResultImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TestResult")
		case "id":

			out.Values[i] = ec._TestResult_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "baseStatus":

			out.Values[i] = ec._TestResult_baseStatus(ctx, field, obj)

		case "duration":

			out.Values[i] = ec._TestResult_duration(ctx, field, obj)

		case "endTime":

			out.Values[i] = ec._TestResult_endTime(ctx, field, obj)

		case "execution":

			out.Values[i] = ec._TestResult_execution(ctx, field, obj)

		case "exitCode":

			out.Values[i] = ec._TestResult_exitCode(ctx, field, obj)

		case "groupID":

			out.Values[i] = ec._TestResult_groupID(ctx, field, obj)

		case "logs":

			out.Values[i] = ec._TestResult_logs(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "startTime":

			out.Values[i] = ec._TestResult_startTime(ctx, field, obj)

		case "status":

			out.Values[i] = ec._TestResult_status(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "taskId":

			out.Values[i] = ec._TestResult_taskId(ctx, field, obj)

		case "testFile":

			out.Values[i] = ec._TestResult_testFile(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var ticketFieldsImplementors = []string{"TicketFields"}

func (ec *executionContext) _TicketFields(ctx context.Context, sel ast.SelectionSet, obj *thirdparty.TicketFields) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, ticketFieldsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TicketFields")
		case "assignedTeam":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TicketFields_assignedTeam(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "assigneeDisplayName":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TicketFields_assigneeDisplayName(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "created":

			out.Values[i] = ec._TicketFields_created(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "resolutionName":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._TicketFields_resolutionName(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "status":

			out.Values[i] = ec._TicketFields_status(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "summary":

			out.Values[i] = ec._TicketFields_summary(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "updated":

			out.Values[i] = ec._TicketFields_updated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var triggerAliasImplementors = []string{"TriggerAlias"}

func (ec *executionContext) _TriggerAlias(ctx context.Context, sel ast.SelectionSet, obj *model.APITriggerDefinition) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, triggerAliasImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TriggerAlias")
		case "alias":

			out.Values[i] = ec._TriggerAlias_alias(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "buildVariantRegex":

			out.Values[i] = ec._TriggerAlias_buildVariantRegex(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "configFile":

			out.Values[i] = ec._TriggerAlias_configFile(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "dateCutoff":

			out.Values[i] = ec._TriggerAlias_dateCutoff(ctx, field, obj)

		case "level":

			out.Values[i] = ec._TriggerAlias_level(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "project":

			out.Values[i] = ec._TriggerAlias_project(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "status":

			out.Values[i] = ec._TriggerAlias_status(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "taskRegex":

			out.Values[i] = ec._TriggerAlias_taskRegex(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var uIConfigImplementors = []string{"UIConfig"}

func (ec *executionContext) _UIConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIUIConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, uIConfigImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UIConfig")
		case "defaultProject":

			out.Values[i] = ec._UIConfig_defaultProject(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "userVoice":

			out.Values[i] = ec._UIConfig_userVoice(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var upstreamProjectImplementors = []string{"UpstreamProject"}

func (ec *executionContext) _UpstreamProject(ctx context.Context, sel ast.SelectionSet, obj *UpstreamProject) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, upstreamProjectImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpstreamProject")
		case "owner":

			out.Values[i] = ec._UpstreamProject_owner(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "project":

			out.Values[i] = ec._UpstreamProject_project(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "repo":

			out.Values[i] = ec._UpstreamProject_repo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "resourceID":

			out.Values[i] = ec._UpstreamProject_resourceID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "revision":

			out.Values[i] = ec._UpstreamProject_revision(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "task":

			out.Values[i] = ec._UpstreamProject_task(ctx, field, obj)

		case "triggerID":

			out.Values[i] = ec._UpstreamProject_triggerID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "triggerType":

			out.Values[i] = ec._UpstreamProject_triggerType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "version":

			out.Values[i] = ec._UpstreamProject_version(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var useSpruceOptionsImplementors = []string{"UseSpruceOptions"}

func (ec *executionContext) _UseSpruceOptions(ctx context.Context, sel ast.SelectionSet, obj *model.APIUseSpruceOptions) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, useSpruceOptionsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UseSpruceOptions")
		case "hasUsedMainlineCommitsBefore":

			out.Values[i] = ec._UseSpruceOptions_hasUsedMainlineCommitsBefore(ctx, field, obj)

		case "hasUsedSpruceBefore":

			out.Values[i] = ec._UseSpruceOptions_hasUsedSpruceBefore(ctx, field, obj)

		case "spruceV1":

			out.Values[i] = ec._UseSpruceOptions_spruceV1(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userImplementors = []string{"User"}

func (ec *executionContext) _User(ctx context.Context, sel ast.SelectionSet, obj *model.APIDBUser) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("User")
		case "displayName":

			out.Values[i] = ec._User_displayName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "emailAddress":

			out.Values[i] = ec._User_emailAddress(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "patches":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_patches(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "permissions":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_permissions(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "subscriptions":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._User_subscriptions(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "userId":

			out.Values[i] = ec._User_userId(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userConfigImplementors = []string{"UserConfig"}

func (ec *executionContext) _UserConfig(ctx context.Context, sel ast.SelectionSet, obj *UserConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userConfigImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserConfig")
		case "api_key":

			out.Values[i] = ec._UserConfig_api_key(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "api_server_host":

			out.Values[i] = ec._UserConfig_api_server_host(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "ui_server_host":

			out.Values[i] = ec._UserConfig_ui_server_host(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "user":

			out.Values[i] = ec._UserConfig_user(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var userSettingsImplementors = []string{"UserSettings"}

func (ec *executionContext) _UserSettings(ctx context.Context, sel ast.SelectionSet, obj *model.APIUserSettings) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, userSettingsImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UserSettings")
		case "githubUser":

			out.Values[i] = ec._UserSettings_githubUser(ctx, field, obj)

		case "notifications":

			out.Values[i] = ec._UserSettings_notifications(ctx, field, obj)

		case "region":

			out.Values[i] = ec._UserSettings_region(ctx, field, obj)

		case "slackUsername":

			out.Values[i] = ec._UserSettings_slackUsername(ctx, field, obj)

		case "slackMemberId":

			out.Values[i] = ec._UserSettings_slackMemberId(ctx, field, obj)

		case "timezone":

			out.Values[i] = ec._UserSettings_timezone(ctx, field, obj)

		case "useSpruceOptions":

			out.Values[i] = ec._UserSettings_useSpruceOptions(ctx, field, obj)

		case "dateFormat":

			out.Values[i] = ec._UserSettings_dateFormat(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var variantTaskImplementors = []string{"VariantTask"}

func (ec *executionContext) _VariantTask(ctx context.Context, sel ast.SelectionSet, obj *model.VariantTask) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, variantTaskImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VariantTask")
		case "name":

			out.Values[i] = ec._VariantTask_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "tasks":

			out.Values[i] = ec._VariantTask_tasks(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var versionImplementors = []string{"Version"}

func (ec *executionContext) _Version(ctx context.Context, sel ast.SelectionSet, obj *model.APIVersion) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, versionImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Version")
		case "id":

			out.Values[i] = ec._Version_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "activated":

			out.Values[i] = ec._Version_activated(ctx, field, obj)

		case "author":

			out.Values[i] = ec._Version_author(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "baseTaskStatuses":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_baseTaskStatuses(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "baseVersion":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_baseVersion(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "branch":

			out.Values[i] = ec._Version_branch(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "buildVariants":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_buildVariants(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "buildVariantStats":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_buildVariantStats(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "childVersions":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_childVersions(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "createTime":

			out.Values[i] = ec._Version_createTime(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "errors":

			out.Values[i] = ec._Version_errors(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "externalLinksForMetadata":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_externalLinksForMetadata(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "finishTime":

			out.Values[i] = ec._Version_finishTime(ctx, field, obj)

		case "gitTags":

			out.Values[i] = ec._Version_gitTags(ctx, field, obj)

		case "isPatch":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_isPatch(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "manifest":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_manifest(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "message":

			out.Values[i] = ec._Version_message(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "order":

			out.Values[i] = ec._Version_order(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "parameters":

			out.Values[i] = ec._Version_parameters(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "patch":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_patch(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "previousVersion":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_previousVersion(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "project":

			out.Values[i] = ec._Version_project(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "projectIdentifier":

			out.Values[i] = ec._Version_projectIdentifier(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "projectMetadata":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_projectMetadata(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "repo":

			out.Values[i] = ec._Version_repo(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "requester":

			out.Values[i] = ec._Version_requester(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "revision":

			out.Values[i] = ec._Version_revision(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "startTime":

			out.Values[i] = ec._Version_startTime(ctx, field, obj)

		case "status":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_status(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "taskCount":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_taskCount(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "tasks":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_tasks(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "taskStatuses":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_taskStatuses(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "taskStatusStats":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_taskStatusStats(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "upstreamProject":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_upstreamProject(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "versionTiming":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_versionTiming(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "warnings":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Version_warnings(ctx, field, obj)
				if res == graphql.Null {
					atomic.AddUint32(&invalids, 1)
				}
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var versionTasksImplementors = []string{"VersionTasks"}

func (ec *executionContext) _VersionTasks(ctx context.Context, sel ast.SelectionSet, obj *VersionTasks) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, versionTasksImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VersionTasks")
		case "count":

			out.Values[i] = ec._VersionTasks_count(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "data":

			out.Values[i] = ec._VersionTasks_data(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var versionTimingImplementors = []string{"VersionTiming"}

func (ec *executionContext) _VersionTiming(ctx context.Context, sel ast.SelectionSet, obj *VersionTiming) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, versionTimingImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VersionTiming")
		case "makespan":

			out.Values[i] = ec._VersionTiming_makespan(ctx, field, obj)

		case "timeTaken":

			out.Values[i] = ec._VersionTiming_timeTaken(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var volumeImplementors = []string{"Volume"}

func (ec *executionContext) _Volume(ctx context.Context, sel ast.SelectionSet, obj *model.APIVolume) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, volumeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Volume")
		case "id":

			out.Values[i] = ec._Volume_id(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "availabilityZone":

			out.Values[i] = ec._Volume_availabilityZone(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "createdBy":

			out.Values[i] = ec._Volume_createdBy(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "creationTime":

			out.Values[i] = ec._Volume_creationTime(ctx, field, obj)

		case "deviceName":

			out.Values[i] = ec._Volume_deviceName(ctx, field, obj)

		case "displayName":

			out.Values[i] = ec._Volume_displayName(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "expiration":

			out.Values[i] = ec._Volume_expiration(ctx, field, obj)

		case "homeVolume":

			out.Values[i] = ec._Volume_homeVolume(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "host":
			field := field

			innerFunc := func(ctx context.Context) (res graphql.Marshaler) {
				defer func() {
					if r := recover(); r != nil {
						ec.Error(ctx, ec.Recover(ctx, r))
					}
				}()
				res = ec._Volume_host(ctx, field, obj)
				return res
			}

			out.Concurrently(i, func() graphql.Marshaler {
				return innerFunc(ctx)

			})
		case "hostID":

			out.Values[i] = ec._Volume_hostID(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "migrating":

			out.Values[i] = ec._Volume_migrating(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "noExpiration":

			out.Values[i] = ec._Volume_noExpiration(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "size":

			out.Values[i] = ec._Volume_size(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		case "type":

			out.Values[i] = ec._Volume_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				atomic.AddUint32(&invalids, 1)
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var webhookImplementors = []string{"Webhook"}

func (ec *executionContext) _Webhook(ctx context.Context, sel ast.SelectionSet, obj *model.APIWebHook) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, webhookImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Webhook")
		case "endpoint":

			out.Values[i] = ec._Webhook_endpoint(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "secret":

			out.Values[i] = ec._Webhook_secret(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var webhookHeaderImplementors = []string{"WebhookHeader"}

func (ec *executionContext) _WebhookHeader(ctx context.Context, sel ast.SelectionSet, obj *model.APIWebhookHeader) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, webhookHeaderImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WebhookHeader")
		case "key":

			out.Values[i] = ec._WebhookHeader_key(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "value":

			out.Values[i] = ec._WebhookHeader_value(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var webhookSubscriberImplementors = []string{"WebhookSubscriber"}

func (ec *executionContext) _WebhookSubscriber(ctx context.Context, sel ast.SelectionSet, obj *model.APIWebhookSubscriber) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, webhookSubscriberImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WebhookSubscriber")
		case "headers":

			out.Values[i] = ec._WebhookSubscriber_headers(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "secret":

			out.Values[i] = ec._WebhookSubscriber_secret(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "url":

			out.Values[i] = ec._WebhookSubscriber_url(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "retries":

			out.Values[i] = ec._WebhookSubscriber_retries(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "minDelayMs":

			out.Values[i] = ec._WebhookSubscriber_minDelayMs(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "timeoutMs":

			out.Values[i] = ec._WebhookSubscriber_timeoutMs(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var workstationConfigImplementors = []string{"WorkstationConfig"}

func (ec *executionContext) _WorkstationConfig(ctx context.Context, sel ast.SelectionSet, obj *model.APIWorkstationConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workstationConfigImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkstationConfig")
		case "gitClone":

			out.Values[i] = ec._WorkstationConfig_gitClone(ctx, field, obj)

		case "setupCommands":

			out.Values[i] = ec._WorkstationConfig_setupCommands(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var workstationSetupCommandImplementors = []string{"WorkstationSetupCommand"}

func (ec *executionContext) _WorkstationSetupCommand(ctx context.Context, sel ast.SelectionSet, obj *model.APIWorkstationSetupCommand) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, workstationSetupCommandImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WorkstationSetupCommand")
		case "command":

			out.Values[i] = ec._WorkstationSetupCommand_command(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "directory":

			out.Values[i] = ec._WorkstationSetupCommand_directory(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __DirectiveImplementors = []string{"__Directive"}

func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __DirectiveImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":

			out.Values[i] = ec.___Directive_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Directive_description(ctx, field, obj)

		case "locations":

			out.Values[i] = ec.___Directive_locations(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "args":

			out.Values[i] = ec.___Directive_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isRepeatable":

			out.Values[i] = ec.___Directive_isRepeatable(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __EnumValueImplementors = []string{"__EnumValue"}

func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __EnumValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":

			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)

		case "isDeprecated":

			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __FieldImplementors = []string{"__Field"}

func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __FieldImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":

			out.Values[i] = ec.___Field_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___Field_description(ctx, field, obj)

		case "args":

			out.Values[i] = ec.___Field_args(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "type":

			out.Values[i] = ec.___Field_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "isDeprecated":

			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "deprecationReason":

			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __InputValueImplementors = []string{"__InputValue"}

func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __InputValueImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":

			out.Values[i] = ec.___InputValue_name(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "description":

			out.Values[i] = ec.___InputValue_description(ctx, field, obj)

		case "type":

			out.Values[i] = ec.___InputValue_type(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "defaultValue":

			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __SchemaImplementors = []string{"__Schema"}

func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __SchemaImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "description":

			out.Values[i] = ec.___Schema_description(ctx, field, obj)

		case "types":

			out.Values[i] = ec.___Schema_types(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "queryType":

			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "mutationType":

			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)

		case "subscriptionType":

			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)

		case "directives":

			out.Values[i] = ec.___Schema_directives(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

var __TypeImplementors = []string{"__Type"}

func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.OperationContext, sel, __TypeImplementors)
	out := graphql.NewFieldSet(fields)
	var invalids uint32
	for i, field := range fields {
		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":

			out.Values[i] = ec.___Type_kind(ctx, field, obj)

			if out.Values[i] == graphql.Null {
				invalids++
			}
		case "name":

			out.Values[i] = ec.___Type_name(ctx, field, obj)

		case "description":

			out.Values[i] = ec.___Type_description(ctx, field, obj)

		case "fields":

			out.Values[i] = ec.___Type_fields(ctx, field, obj)

		case "interfaces":

			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)

		case "possibleTypes":

			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)

		case "enumValues":

			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)

		case "inputFields":

			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)

		case "ofType":

			out.Values[i] = ec.___Type_ofType(ctx, field, obj)

		case "specifiedByURL":

			out.Values[i] = ec.___Type_specifiedByURL(ctx, field, obj)

		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	out.Dispatch()
	if invalids > 0 {
		return graphql.Null
	}
	return out
}

// endregion **************************** object.gotpl ****************************

// region    ***************************** type.gotpl *****************************

func (ec *executionContext) unmarshalNBannerTheme2githubᚗcomᚋevergreenᚑciᚋevergreenᚐBannerTheme(ctx context.Context, v interface{}) (evergreen.BannerTheme, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := evergreen.BannerTheme(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBannerTheme2githubᚗcomᚋevergreenᚑciᚋevergreenᚐBannerTheme(ctx context.Context, sel ast.SelectionSet, v evergreen.BannerTheme) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNBootstrapSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIBootstrapSettings(ctx context.Context, sel ast.SelectionSet, v model.APIBootstrapSettings) graphql.Marshaler {
	return ec._BootstrapSettings(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNBootstrapSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIBootstrapSettings(ctx context.Context, v interface{}) (model.APIBootstrapSettings, error) {
	res, err := ec.unmarshalInputBootstrapSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNBuild2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIBuildᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.APIBuild) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNBuild2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIBuild(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNBuild2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIBuild(ctx context.Context, sel ast.SelectionSet, v *model.APIBuild) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Build(ctx, sel, v)
}

func (ec *executionContext) marshalNBuildBaron2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐBuildBaron(ctx context.Context, sel ast.SelectionSet, v BuildBaron) graphql.Marshaler {
	return ec._BuildBaron(ctx, sel, &v)
}

func (ec *executionContext) marshalNBuildBaron2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐBuildBaron(ctx context.Context, sel ast.SelectionSet, v *BuildBaron) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._BuildBaron(ctx, sel, v)
}

func (ec *executionContext) marshalNBuildBaronSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIBuildBaronSettings(ctx context.Context, sel ast.SelectionSet, v model.APIBuildBaronSettings) graphql.Marshaler {
	return ec._BuildBaronSettings(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNBuildVariantOptions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐBuildVariantOptions(ctx context.Context, v interface{}) (BuildVariantOptions, error) {
	res, err := ec.unmarshalInputBuildVariantOptions(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNChildPatchAlias2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIChildPatchAlias(ctx context.Context, sel ast.SelectionSet, v model.APIChildPatchAlias) graphql.Marshaler {
	return ec._ChildPatchAlias(ctx, sel, &v)
}

func (ec *executionContext) marshalNClientBinary2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIClientBinary(ctx context.Context, sel ast.SelectionSet, v model.APIClientBinary) graphql.Marshaler {
	return ec._ClientBinary(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNCloneMethod2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐCloneMethod(ctx context.Context, v interface{}) (CloneMethod, error) {
	var res CloneMethod
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNCloneMethod2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐCloneMethod(ctx context.Context, sel ast.SelectionSet, v CloneMethod) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNCommitQueue2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPICommitQueue(ctx context.Context, sel ast.SelectionSet, v model.APICommitQueue) graphql.Marshaler {
	return ec._CommitQueue(ctx, sel, &v)
}

func (ec *executionContext) marshalNCommitQueue2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPICommitQueue(ctx context.Context, sel ast.SelectionSet, v *model.APICommitQueue) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._CommitQueue(ctx, sel, v)
}

func (ec *executionContext) marshalNCommitQueueItem2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPICommitQueueItem(ctx context.Context, sel ast.SelectionSet, v model.APICommitQueueItem) graphql.Marshaler {
	return ec._CommitQueueItem(ctx, sel, &v)
}

func (ec *executionContext) marshalNCommitQueueParams2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPICommitQueueParams(ctx context.Context, sel ast.SelectionSet, v model.APICommitQueueParams) graphql.Marshaler {
	return ec._CommitQueueParams(ctx, sel, &v)
}

func (ec *executionContext) marshalNContainerResources2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIContainerResources(ctx context.Context, sel ast.SelectionSet, v model.APIContainerResources) graphql.Marshaler {
	return ec._ContainerResources(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNContainerResourcesInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIContainerResources(ctx context.Context, v interface{}) (model.APIContainerResources, error) {
	res, err := ec.unmarshalInputContainerResourcesInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCopyDistroInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋdataᚐCopyDistroOpts(ctx context.Context, v interface{}) (data.CopyDistroOpts, error) {
	res, err := ec.unmarshalInputCopyDistroInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCopyProjectInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋdataᚐCopyProjectOpts(ctx context.Context, v interface{}) (data.CopyProjectOpts, error) {
	res, err := ec.unmarshalInputCopyProjectInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateDistroInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐCreateDistroInput(ctx context.Context, v interface{}) (CreateDistroInput, error) {
	res, err := ec.unmarshalInputCreateDistroInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNCreateProjectInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx context.Context, v interface{}) (model.APIProjectRef, error) {
	res, err := ec.unmarshalInputCreateProjectInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDeleteDistroInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDeleteDistroInput(ctx context.Context, v interface{}) (DeleteDistroInput, error) {
	res, err := ec.unmarshalInputDeleteDistroInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDeleteDistroPayload2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDeleteDistroPayload(ctx context.Context, sel ast.SelectionSet, v DeleteDistroPayload) graphql.Marshaler {
	return ec._DeleteDistroPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNDeleteDistroPayload2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDeleteDistroPayload(ctx context.Context, sel ast.SelectionSet, v *DeleteDistroPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DeleteDistroPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNDependency2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDependency(ctx context.Context, sel ast.SelectionSet, v *Dependency) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Dependency(ctx, sel, v)
}

func (ec *executionContext) marshalNDispatcherSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDispatcherSettings(ctx context.Context, sel ast.SelectionSet, v model.APIDispatcherSettings) graphql.Marshaler {
	return ec._DispatcherSettings(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNDispatcherSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDispatcherSettings(ctx context.Context, v interface{}) (model.APIDispatcherSettings, error) {
	res, err := ec.unmarshalInputDispatcherSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDispatcherVersion2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDispatcherVersion(ctx context.Context, v interface{}) (DispatcherVersion, error) {
	var res DispatcherVersion
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDispatcherVersion2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDispatcherVersion(ctx context.Context, sel ast.SelectionSet, v DispatcherVersion) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNDisplayTask2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDisplayTaskᚄ(ctx context.Context, v interface{}) ([]*DisplayTask, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*DisplayTask, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNDisplayTask2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDisplayTask(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNDisplayTask2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDisplayTask(ctx context.Context, v interface{}) (*DisplayTask, error) {
	res, err := ec.unmarshalInputDisplayTask(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDistro2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDistro(ctx context.Context, sel ast.SelectionSet, v []*model.APIDistro) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalODistro2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDistro(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNDistro2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDistro(ctx context.Context, sel ast.SelectionSet, v *model.APIDistro) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Distro(ctx, sel, v)
}

func (ec *executionContext) marshalNDistroEvent2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroEventᚄ(ctx context.Context, sel ast.SelectionSet, v []*DistroEvent) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDistroEvent2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNDistroEvent2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroEvent(ctx context.Context, sel ast.SelectionSet, v *DistroEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DistroEvent(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDistroEventsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroEventsInput(ctx context.Context, v interface{}) (DistroEventsInput, error) {
	res, err := ec.unmarshalInputDistroEventsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDistroEventsPayload2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroEventsPayload(ctx context.Context, sel ast.SelectionSet, v DistroEventsPayload) graphql.Marshaler {
	return ec._DistroEventsPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNDistroEventsPayload2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroEventsPayload(ctx context.Context, sel ast.SelectionSet, v *DistroEventsPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DistroEventsPayload(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDistroInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDistro(ctx context.Context, v interface{}) (*model.APIDistro, error) {
	res, err := ec.unmarshalInputDistroInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDistroOnSaveOperation2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroOnSaveOperation(ctx context.Context, v interface{}) (DistroOnSaveOperation, error) {
	var res DistroOnSaveOperation
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDistroOnSaveOperation2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroOnSaveOperation(ctx context.Context, sel ast.SelectionSet, v DistroOnSaveOperation) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNDistroPermissions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroPermissions(ctx context.Context, sel ast.SelectionSet, v DistroPermissions) graphql.Marshaler {
	return ec._DistroPermissions(ctx, sel, &v)
}

func (ec *executionContext) marshalNDistroPermissions2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroPermissions(ctx context.Context, sel ast.SelectionSet, v *DistroPermissions) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._DistroPermissions(ctx, sel, v)
}

func (ec *executionContext) unmarshalNDistroPermissionsOptions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroPermissionsOptions(ctx context.Context, v interface{}) (DistroPermissionsOptions, error) {
	res, err := ec.unmarshalInputDistroPermissionsOptions(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNDistroSettingsAccess2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroSettingsAccess(ctx context.Context, v interface{}) (DistroSettingsAccess, error) {
	var res DistroSettingsAccess
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDistroSettingsAccess2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDistroSettingsAccess(ctx context.Context, sel ast.SelectionSet, v DistroSettingsAccess) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNDuration2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDuration(ctx context.Context, v interface{}) (model.APIDuration, error) {
	res, err := model.UnmarshalAPIDuration(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNDuration2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDuration(ctx context.Context, sel ast.SelectionSet, v model.APIDuration) graphql.Marshaler {
	res := model.MarshalAPIDuration(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNEnvVar2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIEnvVar(ctx context.Context, sel ast.SelectionSet, v model.APIEnvVar) graphql.Marshaler {
	return ec._EnvVar(ctx, sel, &v)
}

func (ec *executionContext) marshalNEnvVar2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIEnvVarᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIEnvVar) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNEnvVar2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIEnvVar(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNEnvVarInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIEnvVar(ctx context.Context, v interface{}) (model.APIEnvVar, error) {
	res, err := ec.unmarshalInputEnvVarInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNEnvVarInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIEnvVarᚄ(ctx context.Context, v interface{}) ([]model.APIEnvVar, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.APIEnvVar, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNEnvVarInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIEnvVar(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNExpansion2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIExpansion(ctx context.Context, sel ast.SelectionSet, v model.APIExpansion) graphql.Marshaler {
	return ec._Expansion(ctx, sel, &v)
}

func (ec *executionContext) marshalNExpansion2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIExpansionᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIExpansion) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNExpansion2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIExpansion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNExpansionInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIExpansion(ctx context.Context, v interface{}) (model.APIExpansion, error) {
	res, err := ec.unmarshalInputExpansionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNExpansionInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIExpansionᚄ(ctx context.Context, v interface{}) ([]model.APIExpansion, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.APIExpansion, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNExpansionInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIExpansion(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNExternalLink2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIExternalLink(ctx context.Context, sel ast.SelectionSet, v model.APIExternalLink) graphql.Marshaler {
	return ec._ExternalLink(ctx, sel, &v)
}

func (ec *executionContext) marshalNExternalLinkForMetadata2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐExternalLinkForMetadataᚄ(ctx context.Context, sel ast.SelectionSet, v []*ExternalLinkForMetadata) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNExternalLinkForMetadata2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐExternalLinkForMetadata(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNExternalLinkForMetadata2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐExternalLinkForMetadata(ctx context.Context, sel ast.SelectionSet, v *ExternalLinkForMetadata) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ExternalLinkForMetadata(ctx, sel, v)
}

func (ec *executionContext) unmarshalNExternalLinkInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIExternalLink(ctx context.Context, v interface{}) (model.APIExternalLink, error) {
	res, err := ec.unmarshalInputExternalLinkInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFile2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIFile(ctx context.Context, sel ast.SelectionSet, v *model.APIFile) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._File(ctx, sel, v)
}

func (ec *executionContext) marshalNFileDiff2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐFileDiff(ctx context.Context, sel ast.SelectionSet, v model.FileDiff) graphql.Marshaler {
	return ec._FileDiff(ctx, sel, &v)
}

func (ec *executionContext) marshalNFileDiff2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐFileDiffᚄ(ctx context.Context, sel ast.SelectionSet, v []model.FileDiff) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFileDiff2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐFileDiff(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNFinderSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIFinderSettings(ctx context.Context, sel ast.SelectionSet, v model.APIFinderSettings) graphql.Marshaler {
	return ec._FinderSettings(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNFinderSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIFinderSettings(ctx context.Context, v interface{}) (model.APIFinderSettings, error) {
	res, err := ec.unmarshalInputFinderSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNFinderVersion2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐFinderVersion(ctx context.Context, v interface{}) (FinderVersion, error) {
	var res FinderVersion
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFinderVersion2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐFinderVersion(ctx context.Context, sel ast.SelectionSet, v FinderVersion) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloatContext(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) marshalNGeneralSubscription2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISubscription(ctx context.Context, sel ast.SelectionSet, v model.APISubscription) graphql.Marshaler {
	return ec._GeneralSubscription(ctx, sel, &v)
}

func (ec *executionContext) marshalNGeneralSubscription2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISubscription(ctx context.Context, sel ast.SelectionSet, v *model.APISubscription) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GeneralSubscription(ctx, sel, v)
}

func (ec *executionContext) marshalNGitTag2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGitTag(ctx context.Context, sel ast.SelectionSet, v model.APIGitTag) graphql.Marshaler {
	return ec._GitTag(ctx, sel, &v)
}

func (ec *executionContext) marshalNGithubProjectConflicts2githubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐGithubProjectConflicts(ctx context.Context, sel ast.SelectionSet, v model1.GithubProjectConflicts) graphql.Marshaler {
	return ec._GithubProjectConflicts(ctx, sel, &v)
}

func (ec *executionContext) marshalNGithubProjectConflicts2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐGithubProjectConflicts(ctx context.Context, sel ast.SelectionSet, v *model1.GithubProjectConflicts) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GithubProjectConflicts(ctx, sel, v)
}

func (ec *executionContext) marshalNGroupedFiles2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐGroupedFilesᚄ(ctx context.Context, sel ast.SelectionSet, v []*GroupedFiles) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGroupedFiles2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐGroupedFiles(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNGroupedFiles2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐGroupedFiles(ctx context.Context, sel ast.SelectionSet, v *GroupedFiles) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GroupedFiles(ctx, sel, v)
}

func (ec *executionContext) marshalNGroupedProjects2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐGroupedProjects(ctx context.Context, sel ast.SelectionSet, v []*GroupedProjects) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOGroupedProjects2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐGroupedProjects(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNGroupedTaskStatusCount2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋtaskᚐGroupedTaskStatusCount(ctx context.Context, sel ast.SelectionSet, v *task.GroupedTaskStatusCount) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._GroupedTaskStatusCount(ctx, sel, v)
}

func (ec *executionContext) marshalNHomeVolumeSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHomeVolumeSettings(ctx context.Context, sel ast.SelectionSet, v model.APIHomeVolumeSettings) graphql.Marshaler {
	return ec._HomeVolumeSettings(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNHomeVolumeSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHomeVolumeSettings(ctx context.Context, v interface{}) (model.APIHomeVolumeSettings, error) {
	res, err := ec.unmarshalInputHomeVolumeSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNHost2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHost(ctx context.Context, sel ast.SelectionSet, v model.APIHost) graphql.Marshaler {
	return ec._Host(ctx, sel, &v)
}

func (ec *executionContext) marshalNHost2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHostᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.APIHost) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNHost2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHost(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNHost2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHost(ctx context.Context, sel ast.SelectionSet, v *model.APIHost) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Host(ctx, sel, v)
}

func (ec *executionContext) marshalNHostAllocatorSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHostAllocatorSettings(ctx context.Context, sel ast.SelectionSet, v model.APIHostAllocatorSettings) graphql.Marshaler {
	return ec._HostAllocatorSettings(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNHostAllocatorSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHostAllocatorSettings(ctx context.Context, v interface{}) (model.APIHostAllocatorSettings, error) {
	res, err := ec.unmarshalInputHostAllocatorSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNHostEventLogData2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐHostAPIEventData(ctx context.Context, sel ast.SelectionSet, v *model.HostAPIEventData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._HostEventLogData(ctx, sel, v)
}

func (ec *executionContext) marshalNHostEventLogEntry2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐHostAPIEventLogEntryᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.HostAPIEventLogEntry) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNHostEventLogEntry2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐHostAPIEventLogEntry(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNHostEventLogEntry2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐHostAPIEventLogEntry(ctx context.Context, sel ast.SelectionSet, v *model.HostAPIEventLogEntry) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._HostEventLogEntry(ctx, sel, v)
}

func (ec *executionContext) marshalNHostEvents2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐHostEvents(ctx context.Context, sel ast.SelectionSet, v HostEvents) graphql.Marshaler {
	return ec._HostEvents(ctx, sel, &v)
}

func (ec *executionContext) marshalNHostEvents2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐHostEvents(ctx context.Context, sel ast.SelectionSet, v *HostEvents) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._HostEvents(ctx, sel, v)
}

func (ec *executionContext) marshalNHostsResponse2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐHostsResponse(ctx context.Context, sel ast.SelectionSet, v HostsResponse) graphql.Marshaler {
	return ec._HostsResponse(ctx, sel, &v)
}

func (ec *executionContext) marshalNHostsResponse2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐHostsResponse(ctx context.Context, sel ast.SelectionSet, v *HostsResponse) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._HostsResponse(ctx, sel, v)
}

func (ec *executionContext) unmarshalNID2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalID(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalID(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNID2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	res, err := graphql.UnmarshalID(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNID2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	res := graphql.MarshalID(*v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNIceCreamSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIIceCreamSettings(ctx context.Context, sel ast.SelectionSet, v model.APIIceCreamSettings) graphql.Marshaler {
	return ec._IceCreamSettings(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNIceCreamSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIIceCreamSettings(ctx context.Context, v interface{}) (model.APIIceCreamSettings, error) {
	res, err := ec.unmarshalInputIceCreamSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInstanceTag2githubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋhostᚐTag(ctx context.Context, sel ast.SelectionSet, v host.Tag) graphql.Marshaler {
	return ec._InstanceTag(ctx, sel, &v)
}

func (ec *executionContext) marshalNInstanceTag2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋhostᚐTagᚄ(ctx context.Context, sel ast.SelectionSet, v []host.Tag) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNInstanceTag2githubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋhostᚐTag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNInstanceTagInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋhostᚐTag(ctx context.Context, v interface{}) (*host.Tag, error) {
	res, err := ec.unmarshalInputInstanceTagInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2int64(ctx context.Context, v interface{}) (int64, error) {
	res, err := graphql.UnmarshalInt64(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2int64(ctx context.Context, sel ast.SelectionSet, v int64) graphql.Marshaler {
	res := graphql.MarshalInt64(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNIssueLinkInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIIssueLink(ctx context.Context, v interface{}) (model.APIIssueLink, error) {
	res, err := ec.unmarshalInputIssueLinkInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNJiraField2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIJiraField(ctx context.Context, sel ast.SelectionSet, v model.APIJiraField) graphql.Marshaler {
	return ec._JiraField(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNJiraFieldInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIJiraField(ctx context.Context, v interface{}) (model.APIJiraField, error) {
	res, err := ec.unmarshalInputJiraFieldInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNJiraStatus2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐJiraStatus(ctx context.Context, sel ast.SelectionSet, v *thirdparty.JiraStatus) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._JiraStatus(ctx, sel, v)
}

func (ec *executionContext) marshalNJiraTicket2githubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐJiraTicket(ctx context.Context, sel ast.SelectionSet, v thirdparty.JiraTicket) graphql.Marshaler {
	return ec._JiraTicket(ctx, sel, &v)
}

func (ec *executionContext) marshalNJiraTicket2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐJiraTicketᚄ(ctx context.Context, sel ast.SelectionSet, v []thirdparty.JiraTicket) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNJiraTicket2githubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐJiraTicket(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNJiraTicket2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐJiraTicketᚄ(ctx context.Context, sel ast.SelectionSet, v []*thirdparty.JiraTicket) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNJiraTicket2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐJiraTicket(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNJiraTicket2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐJiraTicket(ctx context.Context, sel ast.SelectionSet, v *thirdparty.JiraTicket) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._JiraTicket(ctx, sel, v)
}

func (ec *executionContext) marshalNLogMessage2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋapimodelsᚐLogMessageᚄ(ctx context.Context, sel ast.SelectionSet, v []*apimodels.LogMessage) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLogMessage2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋapimodelsᚐLogMessage(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNLogMessage2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋapimodelsᚐLogMessage(ctx context.Context, sel ast.SelectionSet, v *apimodels.LogMessage) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LogMessage(ctx, sel, v)
}

func (ec *executionContext) marshalNLogkeeperBuild2githubᚗcomᚋevergreenᚑciᚋplankᚐBuild(ctx context.Context, sel ast.SelectionSet, v plank.Build) graphql.Marshaler {
	return ec._LogkeeperBuild(ctx, sel, &v)
}

func (ec *executionContext) marshalNLogkeeperBuild2ᚖgithubᚗcomᚋevergreenᚑciᚋplankᚐBuild(ctx context.Context, sel ast.SelectionSet, v *plank.Build) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._LogkeeperBuild(ctx, sel, v)
}

func (ec *executionContext) marshalNLogkeeperTest2githubᚗcomᚋevergreenᚑciᚋplankᚐTest(ctx context.Context, sel ast.SelectionSet, v plank.Test) graphql.Marshaler {
	return ec._LogkeeperTest(ctx, sel, &v)
}

func (ec *executionContext) marshalNLogkeeperTest2ᚕgithubᚗcomᚋevergreenᚑciᚋplankᚐTestᚄ(ctx context.Context, sel ast.SelectionSet, v []plank.Test) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNLogkeeperTest2githubᚗcomᚋevergreenᚑciᚋplankᚐTest(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMainlineCommitVersion2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐMainlineCommitVersionᚄ(ctx context.Context, sel ast.SelectionSet, v []*MainlineCommitVersion) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNMainlineCommitVersion2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐMainlineCommitVersion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNMainlineCommitVersion2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐMainlineCommitVersion(ctx context.Context, sel ast.SelectionSet, v *MainlineCommitVersion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._MainlineCommitVersion(ctx, sel, v)
}

func (ec *executionContext) unmarshalNMainlineCommitsOptions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐMainlineCommitsOptions(ctx context.Context, v interface{}) (MainlineCommitsOptions, error) {
	res, err := ec.unmarshalInputMainlineCommitsOptions(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNMap2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	res, err := graphql.UnmarshalMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]interface{}) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	res := graphql.MarshalMap(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNMap2ᚕmapᚄ(ctx context.Context, v interface{}) ([]map[string]interface{}, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]map[string]interface{}, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMap2map(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNMap2ᚕmapᚄ(ctx context.Context, sel ast.SelectionSet, v []map[string]interface{}) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNMap2map(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNMergeQueue2githubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐMergeQueue(ctx context.Context, v interface{}) (model1.MergeQueue, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := model1.MergeQueue(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMergeQueue2githubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐMergeQueue(ctx context.Context, sel ast.SelectionSet, v model1.MergeQueue) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNMetStatus2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐMetStatus(ctx context.Context, v interface{}) (MetStatus, error) {
	var res MetStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNMetStatus2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐMetStatus(ctx context.Context, sel ast.SelectionSet, v MetStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNMetadataLinkInput2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIMetadataLinkᚄ(ctx context.Context, v interface{}) ([]*model.APIMetadataLink, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.APIMetadataLink, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNMetadataLinkInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIMetadataLink(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNMetadataLinkInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIMetadataLink(ctx context.Context, v interface{}) (*model.APIMetadataLink, error) {
	res, err := ec.unmarshalInputMetadataLinkInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNModule2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIModule(ctx context.Context, sel ast.SelectionSet, v model.APIModule) graphql.Marshaler {
	return ec._Module(ctx, sel, &v)
}

func (ec *executionContext) marshalNModuleCodeChange2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIModulePatch(ctx context.Context, sel ast.SelectionSet, v model.APIModulePatch) graphql.Marshaler {
	return ec._ModuleCodeChange(ctx, sel, &v)
}

func (ec *executionContext) marshalNModuleCodeChange2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIModulePatchᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIModulePatch) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNModuleCodeChange2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIModulePatch(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNMoveProjectInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐMoveProjectInput(ctx context.Context, v interface{}) (MoveProjectInput, error) {
	res, err := ec.unmarshalInputMoveProjectInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNNewDistroPayload2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐNewDistroPayload(ctx context.Context, sel ast.SelectionSet, v NewDistroPayload) graphql.Marshaler {
	return ec._NewDistroPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNNewDistroPayload2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐNewDistroPayload(ctx context.Context, sel ast.SelectionSet, v *NewDistroPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._NewDistroPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNOomTrackerInfo2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIOomTrackerInfo(ctx context.Context, sel ast.SelectionSet, v model.APIOomTrackerInfo) graphql.Marshaler {
	return ec._OomTrackerInfo(ctx, sel, &v)
}

func (ec *executionContext) marshalNParameter2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParameter(ctx context.Context, sel ast.SelectionSet, v model.APIParameter) graphql.Marshaler {
	return ec._Parameter(ctx, sel, &v)
}

func (ec *executionContext) marshalNParameter2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParameterᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIParameter) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNParameter2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParameter(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNParameter2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParameterᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.APIParameter) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNParameter2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParameter(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNParameter2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParameter(ctx context.Context, sel ast.SelectionSet, v *model.APIParameter) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Parameter(ctx, sel, v)
}

func (ec *executionContext) unmarshalNParameterInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParameter(ctx context.Context, v interface{}) (*model.APIParameter, error) {
	res, err := ec.unmarshalInputParameterInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNParsleyFilter2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParsleyFilter(ctx context.Context, sel ast.SelectionSet, v model.APIParsleyFilter) graphql.Marshaler {
	return ec._ParsleyFilter(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNParsleyFilterInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParsleyFilter(ctx context.Context, v interface{}) (model.APIParsleyFilter, error) {
	res, err := ec.unmarshalInputParsleyFilterInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPatch2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatch(ctx context.Context, sel ast.SelectionSet, v model.APIPatch) graphql.Marshaler {
	return ec._Patch(ctx, sel, &v)
}

func (ec *executionContext) marshalNPatch2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatchᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.APIPatch) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPatch2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatch(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPatch2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatch(ctx context.Context, sel ast.SelectionSet, v *model.APIPatch) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Patch(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPatchConfigure2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPatchConfigure(ctx context.Context, v interface{}) (PatchConfigure, error) {
	res, err := ec.unmarshalInputPatchConfigure(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPatchTriggerAlias2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatchTriggerDefinition(ctx context.Context, sel ast.SelectionSet, v model.APIPatchTriggerDefinition) graphql.Marshaler {
	return ec._PatchTriggerAlias(ctx, sel, &v)
}

func (ec *executionContext) marshalNPatchTriggerAlias2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatchTriggerDefinitionᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.APIPatchTriggerDefinition) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPatchTriggerAlias2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatchTriggerDefinition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPatchTriggerAlias2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatchTriggerDefinition(ctx context.Context, sel ast.SelectionSet, v *model.APIPatchTriggerDefinition) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PatchTriggerAlias(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPatchTriggerAliasInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatchTriggerDefinition(ctx context.Context, v interface{}) (model.APIPatchTriggerDefinition, error) {
	res, err := ec.unmarshalInputPatchTriggerAliasInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPatches2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPatches(ctx context.Context, sel ast.SelectionSet, v Patches) graphql.Marshaler {
	return ec._Patches(ctx, sel, &v)
}

func (ec *executionContext) marshalNPatches2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPatches(ctx context.Context, sel ast.SelectionSet, v *Patches) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Patches(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPatchesInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPatchesInput(ctx context.Context, v interface{}) (PatchesInput, error) {
	res, err := ec.unmarshalInputPatchesInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPeriodicBuild2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPeriodicBuildDefinition(ctx context.Context, sel ast.SelectionSet, v model.APIPeriodicBuildDefinition) graphql.Marshaler {
	return ec._PeriodicBuild(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNPeriodicBuildInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPeriodicBuildDefinition(ctx context.Context, v interface{}) (model.APIPeriodicBuildDefinition, error) {
	res, err := ec.unmarshalInputPeriodicBuildInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPermissions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPermissions(ctx context.Context, sel ast.SelectionSet, v Permissions) graphql.Marshaler {
	return ec._Permissions(ctx, sel, &v)
}

func (ec *executionContext) marshalNPermissions2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPermissions(ctx context.Context, sel ast.SelectionSet, v *Permissions) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Permissions(ctx, sel, v)
}

func (ec *executionContext) marshalNPlannerSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPlannerSettings(ctx context.Context, sel ast.SelectionSet, v model.APIPlannerSettings) graphql.Marshaler {
	return ec._PlannerSettings(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNPlannerSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPlannerSettings(ctx context.Context, v interface{}) (model.APIPlannerSettings, error) {
	res, err := ec.unmarshalInputPlannerSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNPlannerVersion2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPlannerVersion(ctx context.Context, v interface{}) (PlannerVersion, error) {
	var res PlannerVersion
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNPlannerVersion2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPlannerVersion(ctx context.Context, sel ast.SelectionSet, v PlannerVersion) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNPod2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPod(ctx context.Context, sel ast.SelectionSet, v model.APIPod) graphql.Marshaler {
	return ec._Pod(ctx, sel, &v)
}

func (ec *executionContext) marshalNPod2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPod(ctx context.Context, sel ast.SelectionSet, v *model.APIPod) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Pod(ctx, sel, v)
}

func (ec *executionContext) marshalNPodEventLogData2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐPodAPIEventData(ctx context.Context, sel ast.SelectionSet, v *model.PodAPIEventData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PodEventLogData(ctx, sel, v)
}

func (ec *executionContext) marshalNPodEventLogEntry2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐPodAPIEventLogEntryᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.PodAPIEventLogEntry) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPodEventLogEntry2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐPodAPIEventLogEntry(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPodEventLogEntry2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐPodAPIEventLogEntry(ctx context.Context, sel ast.SelectionSet, v *model.PodAPIEventLogEntry) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PodEventLogEntry(ctx, sel, v)
}

func (ec *executionContext) marshalNPodEvents2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPodEvents(ctx context.Context, sel ast.SelectionSet, v PodEvents) graphql.Marshaler {
	return ec._PodEvents(ctx, sel, &v)
}

func (ec *executionContext) marshalNPodEvents2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPodEvents(ctx context.Context, sel ast.SelectionSet, v *PodEvents) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PodEvents(ctx, sel, v)
}

func (ec *executionContext) marshalNPreconditionScript2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPreconditionScript(ctx context.Context, sel ast.SelectionSet, v model.APIPreconditionScript) graphql.Marshaler {
	return ec._PreconditionScript(ctx, sel, &v)
}

func (ec *executionContext) marshalNPreconditionScript2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPreconditionScriptᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIPreconditionScript) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPreconditionScript2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPreconditionScript(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNPreconditionScriptInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPreconditionScript(ctx context.Context, v interface{}) (model.APIPreconditionScript, error) {
	res, err := ec.unmarshalInputPreconditionScriptInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNPreconditionScriptInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPreconditionScriptᚄ(ctx context.Context, v interface{}) ([]model.APIPreconditionScript, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.APIPreconditionScript, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPreconditionScriptInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPreconditionScript(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNProject2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx context.Context, sel ast.SelectionSet, v model.APIProjectRef) graphql.Marshaler {
	return ec._Project(ctx, sel, &v)
}

func (ec *executionContext) marshalNProject2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRefᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.APIProjectRef) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProject2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNProject2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx context.Context, sel ast.SelectionSet, v *model.APIProjectRef) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Project(ctx, sel, v)
}

func (ec *executionContext) marshalNProjectAlias2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectAlias(ctx context.Context, sel ast.SelectionSet, v model.APIProjectAlias) graphql.Marshaler {
	return ec._ProjectAlias(ctx, sel, &v)
}

func (ec *executionContext) marshalNProjectAlias2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectAlias(ctx context.Context, sel ast.SelectionSet, v *model.APIProjectAlias) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProjectAlias(ctx, sel, v)
}

func (ec *executionContext) unmarshalNProjectAliasInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectAlias(ctx context.Context, v interface{}) (model.APIProjectAlias, error) {
	res, err := ec.unmarshalInputProjectAliasInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProjectBuildVariant2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectBuildVariantᚄ(ctx context.Context, sel ast.SelectionSet, v []*ProjectBuildVariant) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProjectBuildVariant2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectBuildVariant(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNProjectBuildVariant2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectBuildVariant(ctx context.Context, sel ast.SelectionSet, v *ProjectBuildVariant) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProjectBuildVariant(ctx, sel, v)
}

func (ec *executionContext) marshalNProjectEventLogEntry2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectEventᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.APIProjectEvent) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProjectEventLogEntry2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectEvent(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNProjectEventLogEntry2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectEvent(ctx context.Context, sel ast.SelectionSet, v *model.APIProjectEvent) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProjectEventLogEntry(ctx, sel, v)
}

func (ec *executionContext) marshalNProjectEvents2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectEvents(ctx context.Context, sel ast.SelectionSet, v ProjectEvents) graphql.Marshaler {
	return ec._ProjectEvents(ctx, sel, &v)
}

func (ec *executionContext) marshalNProjectEvents2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectEvents(ctx context.Context, sel ast.SelectionSet, v *ProjectEvents) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProjectEvents(ctx, sel, v)
}

func (ec *executionContext) unmarshalNProjectHealthView2githubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐProjectHealthView(ctx context.Context, v interface{}) (model1.ProjectHealthView, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := model1.ProjectHealthView(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProjectHealthView2githubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐProjectHealthView(ctx context.Context, sel ast.SelectionSet, v model1.ProjectHealthView) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNProjectSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectSettings(ctx context.Context, sel ast.SelectionSet, v model.APIProjectSettings) graphql.Marshaler {
	return ec._ProjectSettings(ctx, sel, &v)
}

func (ec *executionContext) marshalNProjectSettings2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectSettings(ctx context.Context, sel ast.SelectionSet, v *model.APIProjectSettings) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._ProjectSettings(ctx, sel, v)
}

func (ec *executionContext) unmarshalNProjectSettingsAccess2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectSettingsAccess(ctx context.Context, v interface{}) (ProjectSettingsAccess, error) {
	var res ProjectSettingsAccess
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProjectSettingsAccess2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectSettingsAccess(ctx context.Context, sel ast.SelectionSet, v ProjectSettingsAccess) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNProjectSettingsSection2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectSettingsSection(ctx context.Context, v interface{}) (ProjectSettingsSection, error) {
	var res ProjectSettingsSection
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProjectSettingsSection2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProjectSettingsSection(ctx context.Context, sel ast.SelectionSet, v ProjectSettingsSection) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNProvider2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProvider(ctx context.Context, v interface{}) (Provider, error) {
	var res Provider
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNProvider2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐProvider(ctx context.Context, sel ast.SelectionSet, v Provider) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNPublicKey2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPubKeyᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.APIPubKey) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPublicKey2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPubKey(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNPublicKey2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPubKey(ctx context.Context, sel ast.SelectionSet, v *model.APIPubKey) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._PublicKey(ctx, sel, v)
}

func (ec *executionContext) unmarshalNPublicKeyInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPublicKeyInput(ctx context.Context, v interface{}) (PublicKeyInput, error) {
	res, err := ec.unmarshalInputPublicKeyInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNPublicKeyInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPublicKeyInput(ctx context.Context, v interface{}) (*PublicKeyInput, error) {
	res, err := ec.unmarshalInputPublicKeyInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRepoCommitQueueParams2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPICommitQueueParams(ctx context.Context, sel ast.SelectionSet, v model.APICommitQueueParams) graphql.Marshaler {
	return ec._RepoCommitQueueParams(ctx, sel, &v)
}

func (ec *executionContext) marshalNRepoSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectSettings(ctx context.Context, sel ast.SelectionSet, v model.APIProjectSettings) graphql.Marshaler {
	return ec._RepoSettings(ctx, sel, &v)
}

func (ec *executionContext) marshalNRepoSettings2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectSettings(ctx context.Context, sel ast.SelectionSet, v *model.APIProjectSettings) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._RepoSettings(ctx, sel, v)
}

func (ec *executionContext) marshalNRepoTaskSyncOptions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskSyncOptions(ctx context.Context, sel ast.SelectionSet, v model.APITaskSyncOptions) graphql.Marshaler {
	return ec._RepoTaskSyncOptions(ctx, sel, &v)
}

func (ec *executionContext) marshalNRepoWorkstationConfig2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWorkstationConfig(ctx context.Context, sel ast.SelectionSet, v model.APIWorkstationConfig) graphql.Marshaler {
	return ec._RepoWorkstationConfig(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNRequiredStatus2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐRequiredStatus(ctx context.Context, v interface{}) (RequiredStatus, error) {
	var res RequiredStatus
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNRequiredStatus2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐRequiredStatus(ctx context.Context, sel ast.SelectionSet, v RequiredStatus) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNResourceLimits2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIResourceLimits(ctx context.Context, sel ast.SelectionSet, v model.APIResourceLimits) graphql.Marshaler {
	return ec._ResourceLimits(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNResourceLimitsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIResourceLimits(ctx context.Context, v interface{}) (model.APIResourceLimits, error) {
	res, err := ec.unmarshalInputResourceLimitsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSaveDistroInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSaveDistroInput(ctx context.Context, v interface{}) (SaveDistroInput, error) {
	res, err := ec.unmarshalInputSaveDistroInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSaveDistroPayload2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSaveDistroPayload(ctx context.Context, sel ast.SelectionSet, v SaveDistroPayload) graphql.Marshaler {
	return ec._SaveDistroPayload(ctx, sel, &v)
}

func (ec *executionContext) marshalNSaveDistroPayload2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSaveDistroPayload(ctx context.Context, sel ast.SelectionSet, v *SaveDistroPayload) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SaveDistroPayload(ctx, sel, v)
}

func (ec *executionContext) marshalNSelector2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISelector(ctx context.Context, sel ast.SelectionSet, v model.APISelector) graphql.Marshaler {
	return ec._Selector(ctx, sel, &v)
}

func (ec *executionContext) marshalNSelector2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISelectorᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APISelector) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNSelector2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISelector(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNSelectorInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISelector(ctx context.Context, v interface{}) (model.APISelector, error) {
	res, err := ec.unmarshalInputSelectorInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSelectorInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISelectorᚄ(ctx context.Context, v interface{}) ([]model.APISelector, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.APISelector, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSelectorInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISelector(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNSortDirection2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSortDirection(ctx context.Context, v interface{}) (SortDirection, error) {
	var res SortDirection
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSortDirection2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSortDirection(ctx context.Context, sel ast.SelectionSet, v SortDirection) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNSortOrder2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSortOrder(ctx context.Context, v interface{}) (*SortOrder, error) {
	res, err := ec.unmarshalInputSortOrder(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSource2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISource(ctx context.Context, sel ast.SelectionSet, v *model.APISource) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Source(ctx, sel, v)
}

func (ec *executionContext) marshalNSpawnHostConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISpawnHostConfig(ctx context.Context, sel ast.SelectionSet, v *model.APISpawnHostConfig) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._SpawnHostConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSpawnHostStatusActions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSpawnHostStatusActions(ctx context.Context, v interface{}) (SpawnHostStatusActions, error) {
	var res SpawnHostStatusActions
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNSpawnHostStatusActions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSpawnHostStatusActions(ctx context.Context, sel ast.SelectionSet, v SpawnHostStatusActions) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNSpawnVolumeInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSpawnVolumeInput(ctx context.Context, v interface{}) (SpawnVolumeInput, error) {
	res, err := ec.unmarshalInputSpawnVolumeInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNStatusCount2githubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋtaskᚐStatusCount(ctx context.Context, sel ast.SelectionSet, v task.StatusCount) graphql.Marshaler {
	return ec._StatusCount(ctx, sel, &v)
}

func (ec *executionContext) marshalNStatusCount2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋtaskᚐStatusCountᚄ(ctx context.Context, sel ast.SelectionSet, v []*task.StatusCount) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStatusCount2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋtaskᚐStatusCount(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNStatusCount2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋtaskᚐStatusCount(ctx context.Context, sel ast.SelectionSet, v *task.StatusCount) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._StatusCount(ctx, sel, v)
}

func (ec *executionContext) unmarshalNString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNString2ᚕᚖstring(ctx context.Context, v interface{}) ([]*string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOString2ᚖstring(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2ᚕᚖstring(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOString2ᚖstring(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalNString2ᚕᚖstringᚄ(ctx context.Context, v interface{}) ([]*string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2ᚖstring(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNString2ᚕᚖstringᚄ(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2ᚖstring(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNStringMap2map(ctx context.Context, v interface{}) (map[string]string, error) {
	res, err := UnmarshalStringMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNStringMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]string) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	res := MarshalStringMap(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNSubscriber2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSubscriber(ctx context.Context, sel ast.SelectionSet, v Subscriber) graphql.Marshaler {
	return ec._Subscriber(ctx, sel, &v)
}

func (ec *executionContext) marshalNSubscriber2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSubscriber(ctx context.Context, sel ast.SelectionSet, v *Subscriber) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Subscriber(ctx, sel, v)
}

func (ec *executionContext) unmarshalNSubscriberInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISubscriber(ctx context.Context, v interface{}) (model.APISubscriber, error) {
	res, err := ec.unmarshalInputSubscriberInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNSubscriptionInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISubscription(ctx context.Context, v interface{}) (model.APISubscription, error) {
	res, err := ec.unmarshalInputSubscriptionInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTask2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITask(ctx context.Context, sel ast.SelectionSet, v model.APITask) graphql.Marshaler {
	return ec._Task(ctx, sel, &v)
}

func (ec *executionContext) marshalNTask2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.APITask) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTask2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITask(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTask2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITask(ctx context.Context, sel ast.SelectionSet, v *model.APITask) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Task(ctx, sel, v)
}

func (ec *executionContext) marshalNTaskAnnotationSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskAnnotationSettings(ctx context.Context, sel ast.SelectionSet, v model.APITaskAnnotationSettings) graphql.Marshaler {
	return ec._TaskAnnotationSettings(ctx, sel, &v)
}

func (ec *executionContext) marshalNTaskContainerCreationOpts2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPodTaskContainerCreationOptions(ctx context.Context, sel ast.SelectionSet, v model.APIPodTaskContainerCreationOptions) graphql.Marshaler {
	return ec._TaskContainerCreationOpts(ctx, sel, &v)
}

func (ec *executionContext) marshalNTaskEventLogData2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐTaskEventData(ctx context.Context, sel ast.SelectionSet, v *model.TaskEventData) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskEventLogData(ctx, sel, v)
}

func (ec *executionContext) marshalNTaskEventLogEntry2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐTaskAPIEventLogEntryᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.TaskAPIEventLogEntry) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTaskEventLogEntry2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐTaskAPIEventLogEntry(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTaskEventLogEntry2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐTaskAPIEventLogEntry(ctx context.Context, sel ast.SelectionSet, v *model.TaskAPIEventLogEntry) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskEventLogEntry(ctx, sel, v)
}

func (ec *executionContext) marshalNTaskFiles2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskFiles(ctx context.Context, sel ast.SelectionSet, v TaskFiles) graphql.Marshaler {
	return ec._TaskFiles(ctx, sel, &v)
}

func (ec *executionContext) marshalNTaskFiles2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskFiles(ctx context.Context, sel ast.SelectionSet, v *TaskFiles) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskFiles(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTaskFilterOptions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskFilterOptions(ctx context.Context, v interface{}) (TaskFilterOptions, error) {
	res, err := ec.unmarshalInputTaskFilterOptions(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTaskLogLinks2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐLogLinks(ctx context.Context, sel ast.SelectionSet, v model.LogLinks) graphql.Marshaler {
	return ec._TaskLogLinks(ctx, sel, &v)
}

func (ec *executionContext) marshalNTaskLogs2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskLogs(ctx context.Context, sel ast.SelectionSet, v TaskLogs) graphql.Marshaler {
	return ec._TaskLogs(ctx, sel, &v)
}

func (ec *executionContext) marshalNTaskLogs2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskLogs(ctx context.Context, sel ast.SelectionSet, v *TaskLogs) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskLogs(ctx, sel, v)
}

func (ec *executionContext) marshalNTaskQueueDistro2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskQueueDistroᚄ(ctx context.Context, sel ast.SelectionSet, v []*TaskQueueDistro) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTaskQueueDistro2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskQueueDistro(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTaskQueueDistro2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskQueueDistro(ctx context.Context, sel ast.SelectionSet, v *TaskQueueDistro) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskQueueDistro(ctx, sel, v)
}

func (ec *executionContext) marshalNTaskQueueItem2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskQueueItemᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.APITaskQueueItem) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTaskQueueItem2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskQueueItem(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTaskQueueItem2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskQueueItem(ctx context.Context, sel ast.SelectionSet, v *model.APITaskQueueItem) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskQueueItem(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTaskQueueItemType2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskQueueItemType(ctx context.Context, v interface{}) (TaskQueueItemType, error) {
	var res TaskQueueItemType
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTaskQueueItemType2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskQueueItemType(ctx context.Context, sel ast.SelectionSet, v TaskQueueItemType) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNTaskSortCategory2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskSortCategory(ctx context.Context, v interface{}) (TaskSortCategory, error) {
	var res TaskSortCategory
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTaskSortCategory2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskSortCategory(ctx context.Context, sel ast.SelectionSet, v TaskSortCategory) graphql.Marshaler {
	return v
}

func (ec *executionContext) marshalNTaskSpecifier2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskSpecifier(ctx context.Context, sel ast.SelectionSet, v model.APITaskSpecifier) graphql.Marshaler {
	return ec._TaskSpecifier(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNTaskSpecifierInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskSpecifier(ctx context.Context, v interface{}) (model.APITaskSpecifier, error) {
	res, err := ec.unmarshalInputTaskSpecifierInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNTaskSpecifierInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskSpecifierᚄ(ctx context.Context, v interface{}) ([]model.APITaskSpecifier, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.APITaskSpecifier, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTaskSpecifierInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskSpecifier(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNTaskSyncOptions2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskSyncOptions(ctx context.Context, sel ast.SelectionSet, v model.APITaskSyncOptions) graphql.Marshaler {
	return ec._TaskSyncOptions(ctx, sel, &v)
}

func (ec *executionContext) marshalNTaskTestResult2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskTestResult(ctx context.Context, sel ast.SelectionSet, v TaskTestResult) graphql.Marshaler {
	return ec._TaskTestResult(ctx, sel, &v)
}

func (ec *executionContext) marshalNTaskTestResult2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskTestResult(ctx context.Context, sel ast.SelectionSet, v *TaskTestResult) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskTestResult(ctx, sel, v)
}

func (ec *executionContext) marshalNTaskTestResultSample2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskTestResultSample(ctx context.Context, sel ast.SelectionSet, v *TaskTestResultSample) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TaskTestResultSample(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTestFilter2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTestFilterᚄ(ctx context.Context, v interface{}) ([]*TestFilter, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*TestFilter, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTestFilter2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTestFilter(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNTestFilter2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTestFilter(ctx context.Context, v interface{}) (*TestFilter, error) {
	res, err := ec.unmarshalInputTestFilter(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTestLog2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐTestLogs(ctx context.Context, sel ast.SelectionSet, v model.TestLogs) graphql.Marshaler {
	return ec._TestLog(ctx, sel, &v)
}

func (ec *executionContext) marshalNTestResult2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITestᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.APITest) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTestResult2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITest(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNTestResult2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITest(ctx context.Context, sel ast.SelectionSet, v *model.APITest) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TestResult(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTestSortCategory2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTestSortCategory(ctx context.Context, v interface{}) (TestSortCategory, error) {
	var res TestSortCategory
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTestSortCategory2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTestSortCategory(ctx context.Context, sel ast.SelectionSet, v TestSortCategory) graphql.Marshaler {
	return v
}

func (ec *executionContext) unmarshalNTestSortOptions2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTestSortOptions(ctx context.Context, v interface{}) (*TestSortOptions, error) {
	res, err := ec.unmarshalInputTestSortOptions(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTicketFields2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐTicketFields(ctx context.Context, sel ast.SelectionSet, v *thirdparty.TicketFields) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._TicketFields(ctx, sel, v)
}

func (ec *executionContext) unmarshalNTime2timeᚐTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2timeᚐTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalNTime2ᚖtimeᚐTime(ctx context.Context, v interface{}) (*time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNTime2ᚖtimeᚐTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalNTriggerAlias2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITriggerDefinition(ctx context.Context, sel ast.SelectionSet, v model.APITriggerDefinition) graphql.Marshaler {
	return ec._TriggerAlias(ctx, sel, &v)
}

func (ec *executionContext) marshalNTriggerAlias2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITriggerDefinitionᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APITriggerDefinition) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTriggerAlias2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITriggerDefinition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNTriggerAliasInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITriggerDefinition(ctx context.Context, v interface{}) (model.APITriggerDefinition, error) {
	res, err := ec.unmarshalInputTriggerAliasInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalNUpdateVolumeInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐUpdateVolumeInput(ctx context.Context, v interface{}) (UpdateVolumeInput, error) {
	res, err := ec.unmarshalInputUpdateVolumeInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNUser2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDBUser(ctx context.Context, sel ast.SelectionSet, v model.APIDBUser) graphql.Marshaler {
	return ec._User(ctx, sel, &v)
}

func (ec *executionContext) marshalNUser2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDBUser(ctx context.Context, sel ast.SelectionSet, v *model.APIDBUser) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._User(ctx, sel, v)
}

func (ec *executionContext) marshalNVariantTask2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐVariantTask(ctx context.Context, sel ast.SelectionSet, v model.VariantTask) graphql.Marshaler {
	return ec._VariantTask(ctx, sel, &v)
}

func (ec *executionContext) marshalNVariantTask2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐVariantTask(ctx context.Context, sel ast.SelectionSet, v []model.VariantTask) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOVariantTask2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐVariantTask(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalNVariantTask2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐVariantTaskᚄ(ctx context.Context, sel ast.SelectionSet, v []model.VariantTask) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNVariantTask2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐVariantTask(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalNVariantTasks2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐVariantTasksᚄ(ctx context.Context, v interface{}) ([]*VariantTasks, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*VariantTasks, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNVariantTasks2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐVariantTasks(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNVariantTasks2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐVariantTasks(ctx context.Context, v interface{}) (*VariantTasks, error) {
	res, err := ec.unmarshalInputVariantTasks(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNVersion2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVersion(ctx context.Context, sel ast.SelectionSet, v model.APIVersion) graphql.Marshaler {
	return ec._Version(ctx, sel, &v)
}

func (ec *executionContext) marshalNVersion2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVersion(ctx context.Context, sel ast.SelectionSet, v *model.APIVersion) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Version(ctx, sel, v)
}

func (ec *executionContext) marshalNVersionTasks2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐVersionTasks(ctx context.Context, sel ast.SelectionSet, v VersionTasks) graphql.Marshaler {
	return ec._VersionTasks(ctx, sel, &v)
}

func (ec *executionContext) marshalNVersionTasks2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐVersionTasks(ctx context.Context, sel ast.SelectionSet, v *VersionTasks) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._VersionTasks(ctx, sel, v)
}

func (ec *executionContext) unmarshalNVersionToRestart2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐVersionToRestartᚄ(ctx context.Context, v interface{}) ([]*model1.VersionToRestart, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model1.VersionToRestart, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNVersionToRestart2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐVersionToRestart(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalNVersionToRestart2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐVersionToRestart(ctx context.Context, v interface{}) (*model1.VersionToRestart, error) {
	res, err := ec.unmarshalInputVersionToRestart(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNVolume2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVolumeᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.APIVolume) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNVolume2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVolume(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalNVolume2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVolume(ctx context.Context, sel ast.SelectionSet, v *model.APIVolume) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec._Volume(ctx, sel, v)
}

func (ec *executionContext) unmarshalNVolumeHost2githubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐVolumeHost(ctx context.Context, v interface{}) (VolumeHost, error) {
	res, err := ec.unmarshalInputVolumeHost(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalNWebhook2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWebHook(ctx context.Context, sel ast.SelectionSet, v model.APIWebHook) graphql.Marshaler {
	return ec._Webhook(ctx, sel, &v)
}

func (ec *executionContext) marshalNWebhookHeader2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWebhookHeader(ctx context.Context, sel ast.SelectionSet, v []model.APIWebhookHeader) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOWebhookHeader2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWebhookHeader(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) unmarshalNWebhookHeaderInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWebhookHeader(ctx context.Context, v interface{}) ([]model.APIWebhookHeader, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.APIWebhookHeader, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOWebhookHeaderInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWebhookHeader(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalNWorkstationConfig2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWorkstationConfig(ctx context.Context, sel ast.SelectionSet, v model.APIWorkstationConfig) graphql.Marshaler {
	return ec._WorkstationConfig(ctx, sel, &v)
}

func (ec *executionContext) marshalNWorkstationSetupCommand2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWorkstationSetupCommand(ctx context.Context, sel ast.SelectionSet, v model.APIWorkstationSetupCommand) graphql.Marshaler {
	return ec._WorkstationSetupCommand(ctx, sel, &v)
}

func (ec *executionContext) unmarshalNWorkstationSetupCommandInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWorkstationSetupCommand(ctx context.Context, v interface{}) (model.APIWorkstationSetupCommand, error) {
	res, err := ec.unmarshalInputWorkstationSetupCommandInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx context.Context, sel ast.SelectionSet, v introspection.Directive) graphql.Marshaler {
	return ec.___Directive(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Directive2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirectiveᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Directive) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Directive2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐDirective(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalN__DirectiveLocation2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__DirectiveLocation2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) unmarshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalN__DirectiveLocation2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalN__DirectiveLocation2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__DirectiveLocation2string(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx context.Context, sel ast.SelectionSet, v introspection.EnumValue) graphql.Marshaler {
	return ec.___EnumValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx context.Context, sel ast.SelectionSet, v introspection.Field) graphql.Marshaler {
	return ec.___Field(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx context.Context, sel ast.SelectionSet, v introspection.InputValue) graphql.Marshaler {
	return ec.___InputValue(ctx, sel, &v)
}

func (ec *executionContext) marshalN__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v introspection.Type) graphql.Marshaler {
	return ec.___Type(ctx, sel, &v)
}

func (ec *executionContext) marshalN__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalN__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

func (ec *executionContext) unmarshalN__TypeKind2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalN__TypeKind2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	if res == graphql.Null {
		if !graphql.HasFieldError(ctx, graphql.GetFieldContext(ctx)) {
			ec.Errorf(ctx, "the requested element is null which the schema does not allow")
		}
	}
	return res
}

func (ec *executionContext) marshalOAWSConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAWSConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIAWSConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AWSConfig(ctx, sel, v)
}

func (ec *executionContext) marshalOAWSPodConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAWSPodConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIAWSPodConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AWSPodConfig(ctx, sel, v)
}

func (ec *executionContext) marshalOAbortInfo2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐAbortInfo(ctx context.Context, sel ast.SelectionSet, v *AbortInfo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._AbortInfo(ctx, sel, v)
}

func (ec *executionContext) marshalOAnnotation2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskAnnotation(ctx context.Context, sel ast.SelectionSet, v *model.APITaskAnnotation) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Annotation(ctx, sel, v)
}

func (ec *executionContext) unmarshalOBoolean2bool(ctx context.Context, v interface{}) (bool, error) {
	res, err := graphql.UnmarshalBoolean(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2bool(ctx context.Context, sel ast.SelectionSet, v bool) graphql.Marshaler {
	res := graphql.MarshalBoolean(v)
	return res
}

func (ec *executionContext) unmarshalOBoolean2ᚖbool(ctx context.Context, v interface{}) (*bool, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalBoolean(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBoolean2ᚖbool(ctx context.Context, sel ast.SelectionSet, v *bool) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalBoolean(*v)
	return res
}

func (ec *executionContext) unmarshalOBuildBaronSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIBuildBaronSettings(ctx context.Context, v interface{}) (model.APIBuildBaronSettings, error) {
	res, err := ec.unmarshalInputBuildBaronSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOBuildVariantOptions2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐBuildVariantOptions(ctx context.Context, v interface{}) (*BuildVariantOptions, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputBuildVariantOptions(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOBuildVariantTuple2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋtaskᚐBuildVariantTuple(ctx context.Context, sel ast.SelectionSet, v []*task.BuildVariantTuple) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOBuildVariantTuple2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋtaskᚐBuildVariantTuple(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOBuildVariantTuple2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋtaskᚐBuildVariantTuple(ctx context.Context, sel ast.SelectionSet, v *task.BuildVariantTuple) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._BuildVariantTuple(ctx, sel, v)
}

func (ec *executionContext) marshalOChildPatchAlias2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIChildPatchAliasᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIChildPatchAlias) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNChildPatchAlias2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIChildPatchAlias(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOClientBinary2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIClientBinaryᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIClientBinary) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNClientBinary2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIClientBinary(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOClientConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIClientConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIClientConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ClientConfig(ctx, sel, v)
}

func (ec *executionContext) marshalOCloudProviderConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPICloudProviders(ctx context.Context, sel ast.SelectionSet, v *model.APICloudProviders) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._CloudProviderConfig(ctx, sel, v)
}

func (ec *executionContext) marshalOCommitQueueItem2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPICommitQueueItemᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APICommitQueueItem) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNCommitQueueItem2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPICommitQueueItem(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOCommitQueueParamsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPICommitQueueParams(ctx context.Context, v interface{}) (model.APICommitQueueParams, error) {
	res, err := ec.unmarshalInputCommitQueueParamsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOContainerResources2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIContainerResourcesᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIContainerResources) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNContainerResources2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIContainerResources(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOContainerResourcesInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIContainerResourcesᚄ(ctx context.Context, v interface{}) ([]model.APIContainerResources, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.APIContainerResources, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNContainerResourcesInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIContainerResources(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalODependency2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDependencyᚄ(ctx context.Context, sel ast.SelectionSet, v []*Dependency) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNDependency2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐDependency(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalODistro2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDistro(ctx context.Context, sel ast.SelectionSet, v *model.APIDistro) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Distro(ctx, sel, v)
}

func (ec *executionContext) marshalODistroInfo2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐDistroInfo(ctx context.Context, sel ast.SelectionSet, v model.DistroInfo) graphql.Marshaler {
	return ec._DistroInfo(ctx, sel, &v)
}

func (ec *executionContext) unmarshalODuration2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDuration(ctx context.Context, v interface{}) (model.APIDuration, error) {
	res, err := model.UnmarshalAPIDuration(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODuration2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDuration(ctx context.Context, sel ast.SelectionSet, v model.APIDuration) graphql.Marshaler {
	res := model.MarshalAPIDuration(v)
	return res
}

func (ec *executionContext) unmarshalODuration2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDuration(ctx context.Context, v interface{}) (*model.APIDuration, error) {
	if v == nil {
		return nil, nil
	}
	res, err := model.UnmarshalAPIDuration(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalODuration2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIDuration(ctx context.Context, sel ast.SelectionSet, v *model.APIDuration) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := model.MarshalAPIDuration(*v)
	return res
}

func (ec *executionContext) marshalOECSConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIECSConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIECSConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ECSConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOEditSpawnHostInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐEditSpawnHostInput(ctx context.Context, v interface{}) (*EditSpawnHostInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputEditSpawnHostInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOExternalLink2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIExternalLinkᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIExternalLink) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNExternalLink2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIExternalLink(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOExternalLinkInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIExternalLinkᚄ(ctx context.Context, v interface{}) ([]model.APIExternalLink, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.APIExternalLink, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNExternalLinkInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIExternalLink(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOFile2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIFileᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.APIFile) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNFile2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIFile(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOFloat2float64(ctx context.Context, v interface{}) (float64, error) {
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2float64(ctx context.Context, sel ast.SelectionSet, v float64) graphql.Marshaler {
	res := graphql.MarshalFloatContext(v)
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) unmarshalOFloat2ᚖfloat64(ctx context.Context, v interface{}) (*float64, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalFloatContext(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOFloat2ᚖfloat64(ctx context.Context, sel ast.SelectionSet, v *float64) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalFloatContext(*v)
	return graphql.WrapContextMarshaler(ctx, res)
}

func (ec *executionContext) marshalOGeneralSubscription2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISubscriptionᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APISubscription) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGeneralSubscription2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISubscription(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGeneralSubscription2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISubscriptionᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.APISubscription) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGeneralSubscription2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISubscription(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGitTag2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGitTagᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIGitTag) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGitTag2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGitTag(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOGithubCheckSubscriber2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGithubCheckSubscriber(ctx context.Context, sel ast.SelectionSet, v *model.APIGithubCheckSubscriber) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GithubCheckSubscriber(ctx, sel, v)
}

func (ec *executionContext) marshalOGithubPRSubscriber2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGithubPRSubscriber(ctx context.Context, sel ast.SelectionSet, v *model.APIGithubPRSubscriber) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GithubPRSubscriber(ctx, sel, v)
}

func (ec *executionContext) marshalOGithubUser2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGithubUser(ctx context.Context, sel ast.SelectionSet, v *model.APIGithubUser) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GithubUser(ctx, sel, v)
}

func (ec *executionContext) unmarshalOGithubUserInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIGithubUser(ctx context.Context, v interface{}) (*model.APIGithubUser, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputGithubUserInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOGroupedBuildVariant2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐGroupedBuildVariant(ctx context.Context, sel ast.SelectionSet, v []*GroupedBuildVariant) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOGroupedBuildVariant2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐGroupedBuildVariant(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOGroupedBuildVariant2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐGroupedBuildVariant(ctx context.Context, sel ast.SelectionSet, v *GroupedBuildVariant) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GroupedBuildVariant(ctx, sel, v)
}

func (ec *executionContext) marshalOGroupedProjects2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐGroupedProjects(ctx context.Context, sel ast.SelectionSet, v *GroupedProjects) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._GroupedProjects(ctx, sel, v)
}

func (ec *executionContext) marshalOGroupedTaskStatusCount2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋtaskᚐGroupedTaskStatusCountᚄ(ctx context.Context, sel ast.SelectionSet, v []*task.GroupedTaskStatusCount) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNGroupedTaskStatusCount2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋtaskᚐGroupedTaskStatusCount(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOHost2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIHost(ctx context.Context, sel ast.SelectionSet, v *model.APIHost) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Host(ctx, sel, v)
}

func (ec *executionContext) unmarshalOHostSortBy2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐHostSortBy(ctx context.Context, v interface{}) (*HostSortBy, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(HostSortBy)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOHostSortBy2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐHostSortBy(ctx context.Context, sel ast.SelectionSet, v *HostSortBy) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOID2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalID(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOID2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalID(*v)
	return res
}

func (ec *executionContext) unmarshalOInstanceTagInput2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋhostᚐTagᚄ(ctx context.Context, v interface{}) ([]*host.Tag, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*host.Tag, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNInstanceTagInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋhostᚐTag(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOInt2int(ctx context.Context, v interface{}) (int, error) {
	res, err := graphql.UnmarshalInt(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int(ctx context.Context, sel ast.SelectionSet, v int) graphql.Marshaler {
	res := graphql.MarshalInt(v)
	return res
}

func (ec *executionContext) unmarshalOInt2int64(ctx context.Context, v interface{}) (int64, error) {
	res, err := graphql.UnmarshalInt64(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2int64(ctx context.Context, sel ast.SelectionSet, v int64) graphql.Marshaler {
	res := graphql.MarshalInt64(v)
	return res
}

func (ec *executionContext) unmarshalOInt2ᚕint(ctx context.Context, v interface{}) ([]int, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]int, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOInt2int(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOInt2ᚕint(ctx context.Context, sel ast.SelectionSet, v []int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOInt2int(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOInt2ᚖint(ctx context.Context, v interface{}) (*int, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalInt(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOInt2ᚖint(ctx context.Context, sel ast.SelectionSet, v *int) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalInt(*v)
	return res
}

func (ec *executionContext) marshalOIssueLink2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIIssueLink(ctx context.Context, sel ast.SelectionSet, v model.APIIssueLink) graphql.Marshaler {
	return ec._IssueLink(ctx, sel, &v)
}

func (ec *executionContext) marshalOIssueLink2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIIssueLink(ctx context.Context, sel ast.SelectionSet, v []model.APIIssueLink) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOIssueLink2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIIssueLink(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOJiraConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIJiraConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIJiraConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._JiraConfig(ctx, sel, v)
}

func (ec *executionContext) marshalOJiraField2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIJiraFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIJiraField) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNJiraField2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIJiraField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOJiraFieldInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIJiraFieldᚄ(ctx context.Context, v interface{}) ([]model.APIJiraField, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.APIJiraField, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNJiraFieldInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIJiraField(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOJiraIssueSubscriber2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIJIRAIssueSubscriber(ctx context.Context, sel ast.SelectionSet, v *model.APIJIRAIssueSubscriber) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._JiraIssueSubscriber(ctx, sel, v)
}

func (ec *executionContext) unmarshalOJiraIssueSubscriberInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIJIRAIssueSubscriber(ctx context.Context, v interface{}) (*model.APIJIRAIssueSubscriber, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputJiraIssueSubscriberInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOJiraTicket2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐJiraTicket(ctx context.Context, sel ast.SelectionSet, v *thirdparty.JiraTicket) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._JiraTicket(ctx, sel, v)
}

func (ec *executionContext) marshalOMainlineCommits2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐMainlineCommits(ctx context.Context, sel ast.SelectionSet, v *MainlineCommits) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._MainlineCommits(ctx, sel, v)
}

func (ec *executionContext) marshalOManifest2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐManifest(ctx context.Context, sel ast.SelectionSet, v *Manifest) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Manifest(ctx, sel, v)
}

func (ec *executionContext) unmarshalOMap2map(ctx context.Context, v interface{}) (map[string]interface{}, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]interface{}) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalMap(v)
	return res
}

func (ec *executionContext) unmarshalOMergeQueue2githubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐMergeQueue(ctx context.Context, v interface{}) (model1.MergeQueue, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := model1.MergeQueue(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOMergeQueue2githubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐMergeQueue(ctx context.Context, sel ast.SelectionSet, v model1.MergeQueue) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	return res
}

func (ec *executionContext) marshalOMetadataLink2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIMetadataLink(ctx context.Context, sel ast.SelectionSet, v model.APIMetadataLink) graphql.Marshaler {
	return ec._MetadataLink(ctx, sel, &v)
}

func (ec *executionContext) marshalOMetadataLink2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIMetadataLink(ctx context.Context, sel ast.SelectionSet, v []model.APIMetadataLink) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOMetadataLink2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIMetadataLink(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOModule2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIModuleᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIModule) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNModule2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIModule(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalONote2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPINote(ctx context.Context, sel ast.SelectionSet, v *model.APINote) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Note(ctx, sel, v)
}

func (ec *executionContext) marshalONotifications2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPINotificationPreferences(ctx context.Context, sel ast.SelectionSet, v *model.APINotificationPreferences) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Notifications(ctx, sel, v)
}

func (ec *executionContext) unmarshalONotificationsInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPINotificationPreferences(ctx context.Context, v interface{}) (*model.APINotificationPreferences, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputNotificationsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOParameterInput2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParameter(ctx context.Context, v interface{}) ([]*model.APIParameter, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.APIParameter, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOParameterInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParameter(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOParameterInput2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParameterᚄ(ctx context.Context, v interface{}) ([]*model.APIParameter, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*model.APIParameter, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNParameterInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParameter(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOParameterInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParameter(ctx context.Context, v interface{}) (*model.APIParameter, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputParameterInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOParsleyFilter2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParsleyFilterᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIParsleyFilter) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNParsleyFilter2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParsleyFilter(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOParsleyFilterInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParsleyFilterᚄ(ctx context.Context, v interface{}) ([]model.APIParsleyFilter, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.APIParsleyFilter, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNParsleyFilterInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIParsleyFilter(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOPatch2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatchᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIPatch) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPatch2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatch(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOPatch2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatch(ctx context.Context, sel ast.SelectionSet, v *model.APIPatch) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Patch(ctx, sel, v)
}

func (ec *executionContext) marshalOPatchDuration2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPatchDuration(ctx context.Context, sel ast.SelectionSet, v *PatchDuration) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PatchDuration(ctx, sel, v)
}

func (ec *executionContext) marshalOPatchProject2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPatchProject(ctx context.Context, sel ast.SelectionSet, v *PatchProject) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PatchProject(ctx, sel, v)
}

func (ec *executionContext) marshalOPatchTime2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPatchTime(ctx context.Context, sel ast.SelectionSet, v *PatchTime) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._PatchTime(ctx, sel, v)
}

func (ec *executionContext) marshalOPatchTriggerAlias2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatchTriggerDefinitionᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIPatchTriggerDefinition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPatchTriggerAlias2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatchTriggerDefinition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOPatchTriggerAliasInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatchTriggerDefinitionᚄ(ctx context.Context, v interface{}) ([]model.APIPatchTriggerDefinition, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.APIPatchTriggerDefinition, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPatchTriggerAliasInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPatchTriggerDefinition(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOPeriodicBuild2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPeriodicBuildDefinitionᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIPeriodicBuildDefinition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNPeriodicBuild2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPeriodicBuildDefinition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOPeriodicBuildInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPeriodicBuildDefinitionᚄ(ctx context.Context, v interface{}) ([]model.APIPeriodicBuildDefinition, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.APIPeriodicBuildDefinition, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNPeriodicBuildInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPeriodicBuildDefinition(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOPod2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIPod(ctx context.Context, sel ast.SelectionSet, v *model.APIPod) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Pod(ctx, sel, v)
}

func (ec *executionContext) marshalOProject2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx context.Context, sel ast.SelectionSet, v model.APIProjectRef) graphql.Marshaler {
	return ec._Project(ctx, sel, &v)
}

func (ec *executionContext) marshalOProject2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx context.Context, sel ast.SelectionSet, v *model.APIProjectRef) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Project(ctx, sel, v)
}

func (ec *executionContext) marshalOProjectAlias2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectAliasᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIProjectAlias) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProjectAlias2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectAlias(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOProjectAlias2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectAliasᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.APIProjectAlias) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNProjectAlias2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectAlias(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOProjectAliasInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectAliasᚄ(ctx context.Context, v interface{}) ([]model.APIProjectAlias, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.APIProjectAlias, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNProjectAliasInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectAlias(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOProjectBanner2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectBanner(ctx context.Context, sel ast.SelectionSet, v model.APIProjectBanner) graphql.Marshaler {
	return ec._ProjectBanner(ctx, sel, &v)
}

func (ec *executionContext) unmarshalOProjectBannerInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectBanner(ctx context.Context, v interface{}) (model.APIProjectBanner, error) {
	res, err := ec.unmarshalInputProjectBannerInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOProjectEventSettings2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectEventSettings(ctx context.Context, sel ast.SelectionSet, v model.APIProjectEventSettings) graphql.Marshaler {
	return ec._ProjectEventSettings(ctx, sel, &v)
}

func (ec *executionContext) unmarshalOProjectHealthView2githubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐProjectHealthView(ctx context.Context, v interface{}) (model1.ProjectHealthView, error) {
	tmp, err := graphql.UnmarshalString(v)
	res := model1.ProjectHealthView(tmp)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOProjectHealthView2githubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚐProjectHealthView(ctx context.Context, sel ast.SelectionSet, v model1.ProjectHealthView) graphql.Marshaler {
	res := graphql.MarshalString(string(v))
	return res
}

func (ec *executionContext) unmarshalOProjectInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx context.Context, v interface{}) (model.APIProjectRef, error) {
	res, err := ec.unmarshalInputProjectInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOProjectSettingsInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectSettings(ctx context.Context, v interface{}) (*model.APIProjectSettings, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputProjectSettingsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOProjectVars2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectVars(ctx context.Context, sel ast.SelectionSet, v model.APIProjectVars) graphql.Marshaler {
	return ec._ProjectVars(ctx, sel, &v)
}

func (ec *executionContext) marshalOProjectVars2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectVars(ctx context.Context, sel ast.SelectionSet, v *model.APIProjectVars) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._ProjectVars(ctx, sel, v)
}

func (ec *executionContext) unmarshalOProjectVarsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectVars(ctx context.Context, v interface{}) (model.APIProjectVars, error) {
	res, err := ec.unmarshalInputProjectVarsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOPublicKeyInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐPublicKeyInput(ctx context.Context, v interface{}) (*PublicKeyInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputPublicKeyInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalORepoRef2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx context.Context, sel ast.SelectionSet, v model.APIProjectRef) graphql.Marshaler {
	return ec._RepoRef(ctx, sel, &v)
}

func (ec *executionContext) marshalORepoRef2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx context.Context, sel ast.SelectionSet, v *model.APIProjectRef) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._RepoRef(ctx, sel, v)
}

func (ec *executionContext) unmarshalORepoRefInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectRef(ctx context.Context, v interface{}) (model.APIProjectRef, error) {
	res, err := ec.unmarshalInputRepoRefInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalORepoSettingsInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIProjectSettings(ctx context.Context, v interface{}) (*model.APIProjectSettings, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputRepoSettingsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSearchReturnInfo2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋthirdpartyᚐSearchReturnInfo(ctx context.Context, sel ast.SelectionSet, v *thirdparty.SearchReturnInfo) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SearchReturnInfo(ctx, sel, v)
}

func (ec *executionContext) marshalOSlackConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISlackConfig(ctx context.Context, sel ast.SelectionSet, v *model.APISlackConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SlackConfig(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSortDirection2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSortDirection(ctx context.Context, v interface{}) (*SortDirection, error) {
	if v == nil {
		return nil, nil
	}
	var res = new(SortDirection)
	err := res.UnmarshalGQL(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSortDirection2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSortDirection(ctx context.Context, sel ast.SelectionSet, v *SortDirection) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return v
}

func (ec *executionContext) unmarshalOSortOrder2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSortOrderᚄ(ctx context.Context, v interface{}) ([]*SortOrder, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*SortOrder, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSortOrder2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSortOrder(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOSource2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISource(ctx context.Context, sel ast.SelectionSet, v *model.APISource) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Source(ctx, sel, v)
}

func (ec *executionContext) unmarshalOSpawnHostInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐSpawnHostInput(ctx context.Context, v interface{}) (*SpawnHostInput, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputSpawnHostInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOSpruceConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIAdminSettings(ctx context.Context, sel ast.SelectionSet, v *model.APIAdminSettings) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._SpruceConfig(ctx, sel, v)
}

func (ec *executionContext) marshalOStatusCount2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋtaskᚐStatusCountᚄ(ctx context.Context, sel ast.SelectionSet, v []task.StatusCount) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNStatusCount2githubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋtaskᚐStatusCount(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2string(ctx context.Context, v interface{}) (string, error) {
	res, err := graphql.UnmarshalString(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2string(ctx context.Context, sel ast.SelectionSet, v string) graphql.Marshaler {
	res := graphql.MarshalString(v)
	return res
}

func (ec *executionContext) unmarshalOString2ᚕstring(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstring(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOString2string(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚕstringᚄ(ctx context.Context, v interface{}) ([]string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2string(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕstringᚄ(ctx context.Context, sel ast.SelectionSet, v []string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2string(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚕᚖstring(ctx context.Context, v interface{}) ([]*string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalOString2ᚖstring(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕᚖstring(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalOString2ᚖstring(ctx, sel, v[i])
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚕᚖstringᚄ(ctx context.Context, v interface{}) ([]*string, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*string, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNString2ᚖstring(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOString2ᚕᚖstringᚄ(ctx context.Context, sel ast.SelectionSet, v []*string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	for i := range v {
		ret[i] = ec.marshalNString2ᚖstring(ctx, sel, v[i])
	}

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOString2ᚖstring(ctx context.Context, v interface{}) (*string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalString(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOString2ᚖstring(ctx context.Context, sel ast.SelectionSet, v *string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalString(*v)
	return res
}

func (ec *executionContext) unmarshalOStringMap2map(ctx context.Context, v interface{}) (map[string]string, error) {
	if v == nil {
		return nil, nil
	}
	res, err := UnmarshalStringMap(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOStringMap2map(ctx context.Context, sel ast.SelectionSet, v map[string]string) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := MarshalStringMap(v)
	return res
}

func (ec *executionContext) marshalOSubscriberWrapper2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISubscriber(ctx context.Context, sel ast.SelectionSet, v model.APISubscriber) graphql.Marshaler {
	return ec._SubscriberWrapper(ctx, sel, &v)
}

func (ec *executionContext) unmarshalOSubscriptionInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISubscriptionᚄ(ctx context.Context, v interface{}) ([]model.APISubscription, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.APISubscription, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNSubscriptionInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPISubscription(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOTask2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITask(ctx context.Context, sel ast.SelectionSet, v []*model.APITask) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOTask2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITask(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOTask2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.APITask) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTask2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITask(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOTask2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITask(ctx context.Context, sel ast.SelectionSet, v *model.APITask) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Task(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTaskAnnotationSettingsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskAnnotationSettings(ctx context.Context, v interface{}) (model.APITaskAnnotationSettings, error) {
	res, err := ec.unmarshalInputTaskAnnotationSettingsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTaskEndDetail2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐApiTaskEndDetail(ctx context.Context, sel ast.SelectionSet, v model.ApiTaskEndDetail) graphql.Marshaler {
	return ec._TaskEndDetail(ctx, sel, &v)
}

func (ec *executionContext) marshalOTaskInfo2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐTaskInfo(ctx context.Context, sel ast.SelectionSet, v model.TaskInfo) graphql.Marshaler {
	return ec._TaskInfo(ctx, sel, &v)
}

func (ec *executionContext) marshalOTaskSpecifier2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskSpecifierᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APITaskSpecifier) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTaskSpecifier2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskSpecifier(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOTaskStats2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋmodelᚋtaskᚐTaskStats(ctx context.Context, sel ast.SelectionSet, v *task.TaskStats) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._TaskStats(ctx, sel, v)
}

func (ec *executionContext) unmarshalOTaskSyncOptionsInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITaskSyncOptions(ctx context.Context, v interface{}) (model.APITaskSyncOptions, error) {
	res, err := ec.unmarshalInputTaskSyncOptionsInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTaskTestResultSample2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskTestResultSampleᚄ(ctx context.Context, sel ast.SelectionSet, v []*TaskTestResultSample) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTaskTestResultSample2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTaskTestResultSample(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOTestFilterOptions2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTestFilterOptions(ctx context.Context, v interface{}) (*TestFilterOptions, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputTestFilterOptions(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOTestSortOptions2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTestSortOptionsᚄ(ctx context.Context, v interface{}) ([]*TestSortOptions, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]*TestSortOptions, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTestSortOptions2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐTestSortOptions(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) unmarshalOTime2timeᚐTime(ctx context.Context, v interface{}) (time.Time, error) {
	res, err := graphql.UnmarshalTime(v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2timeᚐTime(ctx context.Context, sel ast.SelectionSet, v time.Time) graphql.Marshaler {
	res := graphql.MarshalTime(v)
	return res
}

func (ec *executionContext) unmarshalOTime2ᚖtimeᚐTime(ctx context.Context, v interface{}) (*time.Time, error) {
	if v == nil {
		return nil, nil
	}
	res, err := graphql.UnmarshalTime(v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOTime2ᚖtimeᚐTime(ctx context.Context, sel ast.SelectionSet, v *time.Time) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	res := graphql.MarshalTime(*v)
	return res
}

func (ec *executionContext) marshalOTriggerAlias2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITriggerDefinitionᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APITriggerDefinition) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNTriggerAlias2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITriggerDefinition(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOTriggerAliasInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITriggerDefinitionᚄ(ctx context.Context, v interface{}) ([]model.APITriggerDefinition, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.APITriggerDefinition, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNTriggerAliasInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPITriggerDefinition(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalOUIConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIUIConfig(ctx context.Context, sel ast.SelectionSet, v *model.APIUIConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UIConfig(ctx, sel, v)
}

func (ec *executionContext) marshalOUpstreamProject2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐUpstreamProject(ctx context.Context, sel ast.SelectionSet, v *UpstreamProject) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UpstreamProject(ctx, sel, v)
}

func (ec *executionContext) marshalOUseSpruceOptions2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIUseSpruceOptions(ctx context.Context, sel ast.SelectionSet, v *model.APIUseSpruceOptions) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UseSpruceOptions(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUseSpruceOptionsInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIUseSpruceOptions(ctx context.Context, v interface{}) (*model.APIUseSpruceOptions, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUseSpruceOptionsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOUserConfig2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐUserConfig(ctx context.Context, sel ast.SelectionSet, v *UserConfig) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UserConfig(ctx, sel, v)
}

func (ec *executionContext) marshalOUserSettings2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIUserSettings(ctx context.Context, sel ast.SelectionSet, v *model.APIUserSettings) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._UserSettings(ctx, sel, v)
}

func (ec *executionContext) unmarshalOUserSettingsInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIUserSettings(ctx context.Context, v interface{}) (*model.APIUserSettings, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputUserSettingsInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOVariantTask2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐVariantTask(ctx context.Context, sel ast.SelectionSet, v model.VariantTask) graphql.Marshaler {
	return ec._VariantTask(ctx, sel, &v)
}

func (ec *executionContext) marshalOVersion2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVersion(ctx context.Context, sel ast.SelectionSet, v []*model.APIVersion) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalOVersion2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVersion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	return ret
}

func (ec *executionContext) marshalOVersion2ᚕᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVersionᚄ(ctx context.Context, sel ast.SelectionSet, v []*model.APIVersion) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNVersion2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVersion(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalOVersion2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVersion(ctx context.Context, sel ast.SelectionSet, v *model.APIVersion) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Version(ctx, sel, v)
}

func (ec *executionContext) marshalOVersionTiming2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋgraphqlᚐVersionTiming(ctx context.Context, sel ast.SelectionSet, v *VersionTiming) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._VersionTiming(ctx, sel, v)
}

func (ec *executionContext) marshalOVolume2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIVolume(ctx context.Context, sel ast.SelectionSet, v *model.APIVolume) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._Volume(ctx, sel, v)
}

func (ec *executionContext) marshalOWebhookHeader2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWebhookHeader(ctx context.Context, sel ast.SelectionSet, v model.APIWebhookHeader) graphql.Marshaler {
	return ec._WebhookHeader(ctx, sel, &v)
}

func (ec *executionContext) unmarshalOWebhookHeaderInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWebhookHeader(ctx context.Context, v interface{}) (model.APIWebhookHeader, error) {
	res, err := ec.unmarshalInputWebhookHeaderInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOWebhookInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWebHook(ctx context.Context, v interface{}) (model.APIWebHook, error) {
	res, err := ec.unmarshalInputWebhookInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOWebhookSubscriber2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWebhookSubscriber(ctx context.Context, sel ast.SelectionSet, v *model.APIWebhookSubscriber) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec._WebhookSubscriber(ctx, sel, v)
}

func (ec *executionContext) unmarshalOWebhookSubscriberInput2ᚖgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWebhookSubscriber(ctx context.Context, v interface{}) (*model.APIWebhookSubscriber, error) {
	if v == nil {
		return nil, nil
	}
	res, err := ec.unmarshalInputWebhookSubscriberInput(ctx, v)
	return &res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) unmarshalOWorkstationConfigInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWorkstationConfig(ctx context.Context, v interface{}) (model.APIWorkstationConfig, error) {
	res, err := ec.unmarshalInputWorkstationConfigInput(ctx, v)
	return res, graphql.ErrorOnPath(ctx, err)
}

func (ec *executionContext) marshalOWorkstationSetupCommand2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWorkstationSetupCommandᚄ(ctx context.Context, sel ast.SelectionSet, v []model.APIWorkstationSetupCommand) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalNWorkstationSetupCommand2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWorkstationSetupCommand(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) unmarshalOWorkstationSetupCommandInput2ᚕgithubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWorkstationSetupCommandᚄ(ctx context.Context, v interface{}) ([]model.APIWorkstationSetupCommand, error) {
	if v == nil {
		return nil, nil
	}
	var vSlice []interface{}
	if v != nil {
		vSlice = graphql.CoerceList(v)
	}
	var err error
	res := make([]model.APIWorkstationSetupCommand, len(vSlice))
	for i := range vSlice {
		ctx := graphql.WithPathContext(ctx, graphql.NewPathWithIndex(i))
		res[i], err = ec.unmarshalNWorkstationSetupCommandInput2githubᚗcomᚋevergreenᚑciᚋevergreenᚋrestᚋmodelᚐAPIWorkstationSetupCommand(ctx, vSlice[i])
		if err != nil {
			return nil, err
		}
	}
	return res, nil
}

func (ec *executionContext) marshalO__EnumValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.EnumValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__EnumValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐEnumValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Field2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐFieldᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Field) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Field2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐField(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__InputValue2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValueᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.InputValue) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__InputValue2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐInputValue(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Schema2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐSchema(ctx context.Context, sel ast.SelectionSet, v *introspection.Schema) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, sel, v)
}

func (ec *executionContext) marshalO__Type2ᚕgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐTypeᚄ(ctx context.Context, sel ast.SelectionSet, v []introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	ret := make(graphql.Array, len(v))
	var wg sync.WaitGroup
	isLen1 := len(v) == 1
	if !isLen1 {
		wg.Add(len(v))
	}
	for i := range v {
		i := i
		fc := &graphql.FieldContext{
			Index:  &i,
			Result: &v[i],
		}
		ctx := graphql.WithFieldContext(ctx, fc)
		f := func(i int) {
			defer func() {
				if r := recover(); r != nil {
					ec.Error(ctx, ec.Recover(ctx, r))
					ret = nil
				}
			}()
			if !isLen1 {
				defer wg.Done()
			}
			ret[i] = ec.marshalN__Type2githubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx, sel, v[i])
		}
		if isLen1 {
			f(i)
		} else {
			go f(i)
		}

	}
	wg.Wait()

	for _, e := range ret {
		if e == graphql.Null {
			return graphql.Null
		}
	}

	return ret
}

func (ec *executionContext) marshalO__Type2ᚖgithubᚗcomᚋ99designsᚋgqlgenᚋgraphqlᚋintrospectionᚐType(ctx context.Context, sel ast.SelectionSet, v *introspection.Type) graphql.Marshaler {
	if v == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, sel, v)
}

// endregion ***************************** type.gotpl *****************************
